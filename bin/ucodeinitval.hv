/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------
 * Automaticaly generated by ../bin/midgetv_genucode (based on ../code/ucode.h).
 * Do not edit.
 *
 * uPC
 * ||            next uPC
 * ||            || ucodeInstruction
 * ||            || 333322222222221111111111
 * || label      || 3210987654321098765432109876543210 Purpose
 * -- ---------- -- ---------------------------------- ------------------------------------------------------
 * 00 LB_0       01 0110000000000000110110101000100000 LB     Load byte. q = rdadr=RS1+0fs
 * 01 LB_1       d2 0010001010000000101111101000001xx1        Read until q=mem[rs1+ofs) & ~3u]
 * 02 IJ_0       be 0010010000100000110111101000100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0
 * 03 FENCE      e6 0010000000000000001011x01100xxxxx0 f      Prepare read PC (FENCE)
 * 04 ADDI_0     e6 0000000000000100001011101100100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)
 * 05 _L05       04 0010000000000000001011x00x00xxxxx0 AUIPC  q = imm20 (copy x/8)
 * 06 LB_3       07 0010000000000000011011101000011xx0        q = ~mem[rs1+ofs]
 * 07 LB_4       09 0010000000000000010111101000010xx0        q = (uint8_t) mem[rs1+Iimm]
 * 08 _L08       5a 0000000000001000111010101000100000 SB     Store byte. wjj=wradr=RS1+Simm
 * 09 LB_5       0b 0010000000000000010111101000000xx0        q = D^0xffffffff^q = D^0x80
 * 0a _L0a       5a 0000000000001000111010101000100000 SB     Store byte. wjj=wradr=RS1+Simm
 * 0b LB_6       e6 0000000000000100001011101100100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80
 * 0c ADD_0      04 0010000000000000111011101000001xx0 ADD    add     Addition Q = RS1
 * 0d LUI        e6 0000000000000100001011101100111000 LUI    q = imm20
 * 0e SUB_0      10 0010000000000000111011x01100xxxxx0 SUB    Subtraction
 * 0f _L0f       e6 0000000000000100001011101100111000 LUI    q = imm20
 * 10 SUB_1      0b 0010000000000000111111101000000xx0        Q = ~RS2
 * 11 _L11       de 000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx q:11
 * 12 eFetch3       000000000xx11001111111101000100110  Fr11  Write minstret. Update I. Q=immediate, use dinx
 * 13 condb_2    14 0010000000000000111111101000000xx0        ~RS2 in Q
 * 14 condb_3    15 0010000000000000001011101000100110        Calculate RS1+~RS2+1
 * 15 condb_4    16 0010000000000000110011101001001xx0        Branch on condition
 * 16 condb_5    de 0100000010001010110111000000111110        Branch not taken.
 * 17 condb_5t   74 0100000001101010110111101000100000        Branch taken.
 * 18 BEQ        13 0000000000001100111011101100111000 BEQ    Conditional Branch. Offset to Ryy
 * 19 JALR_0     41 0000000000001000101011101100100000 JALR   jj=RS1+imm
 * 1a ANDI_1     e6 0000000000000100001011101100010xx0        rd = Iimm & RS1
 * 1b _L1b       32 0010000001100000001011100x00111000 JAL    J-imm is in q. Branch on alignfault
 * 1c ECAL_BRK   a6 0000000000101000001011100x00111000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK
 * 1d ORI_2      e6 0000000000000100001011101100110000        rd = Iimm | RS1
 * 1e aFault_1   d4 0010000000000000101011001000100110        Q = 4
 * 1f IJ_2       b7 0000000000001100101011101100111000        Read word is to be masked with 2 lsb = 00
 * 20 LH_0       52 0100000000101100110110101000100000 LH     Load hword. Q = rdadr=RS1+Iimm.
 * 21 XORI_1     e6 0000000000000100001011101100000xx0        rd = Iimm ^ RS1
 * 22 AND_1      1a 0010000000000000111011101000000xx0        RS1^0xffffffff to Q
 * 23 FENCEI     e6 0010000000000000001011x01100xxxxx0 f      Prepare read PC (FENCE)
 * 24 SLLI_0     35 0010000000000000111100100x00111000 SLLI   Shift left immediate.
 * 25 _L25       04 0010000000000000001011x00x00xxxxx0 AUIPC  q = imm20 (copy x/8)
 * 26 OR_1       27 0000000000001000111011101100000xx0        RS1^0xffffffff to jj
 * 27 OR_2       1d 0010000000000000000011101000100000        Q = rs2
 * 28 _L28       96 0000000000101000111010101000100000 SH     Store halfword. jjw=wradr=RS1+Simm
 * 29 XOR_1      21 0010000000000000111011101000000xx0        Q = RS1^0xFFFFFFFF
 * 2a _L2a       96 0000000000101000111010101000100000 SH     Store halfword. jjw=wradr=RS1+Simm
 * 2b SLTIX_1    30 0010000000000000xxxx11101100100110        RS1 - imm / RS1 - RS2
 * 2c SLL_0      3e 0010000000000000111011x00x00xxxxx0 SLL    Shift left
 * 2d _L2d       e6 0000000000000100001011101100111000 LUI    q = imm20
 * 2e _L2e       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 2f _L2f       e6 0000000000000100001011101100111000 LUI    q = imm20
 * 30 SLTIX_2    e6 0000000000000100001011101100111010        Registered ALU flag to rd
 * 31 SLTX_1     2b 0010000000000000111111101000000xx0        ~rs2 to Q
 * 32 JAL_1      86 0000000000001100001011101100100000        Target adr to jj
 * 33 JAERR_1    81 0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval
 * 34 JAL_3      de 0100000010001010110111100000001xx0        PC+imm/trap entrypt to PC. OpFetch
 * 35 SLLI_1     36 0000000000000100101101101000001xx0        Register to shift to Q (and TRG for shift 0)
 * 36 SLLI_2     03 0000000100000100101101101000101000        Repeat Q = Q+Q until shregcnt == 0
 * 37 ECALL_2    a1 0000000000001111101011101100111000        mtval = 0, now start the chore of 11 to mcause
 * 38 BNE        13 0000000000001100111011101100111000 BNE    Conditional Branch. Offset to Ryy
 * 39 _L39       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 3a SRxI_1     3d 0000000000000100101001101000001xx1        Register to shift to Q
 * 3b _L3b       32 0010000001100000001011100x00111000 JAL    J-imm is in q. Branch on alignfault
 * 3c CSRRW_0    49 0000000000001000011011101100111000 CSRRW  Decoded CSR adr in jj
 * 3d SRxI_2     03 0000000100000100101001101000001xx1        Repeat Q >>= 1 until shregcnt == 0
 * 3e SLL_1      35 0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2
 * 3f SRx_1      3a 0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2
 * 40 LW_0       50 0110000001100000110111101000100000 LW     Load word. Q=yy=rdadr=RS1+Iimm
 * 41 JALR_1     42 0010000000000000000011101000100110        Q=1
 * 42 JALR_2     86 0000000001101100001011101100010xx0        Q = (RS1+imn) & 0xfffffffe
 * 43 _L43       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 44 SLTI_0     2b 0010000000000000111111101000011xx0 SLTI   Set less than immediate (signed)
 * 45 _L45       04 0010000000000000001011x00x00xxxxx0 AUIPC  q = imm20 (copy x/8)
 * 46 ILL_1      47 0100000000001101110111101000001xx0        Store PC to mepc and Q for read of instr
 * 47 ILL_2      82 0010000010000000101111101000001xx0        Read until Q is offending instruction
 * 48 _L48       66 1110000001100000111011101000100000 SW     Store word. Q=wradr=RS1+Simm
 * 49 CSRRW_1    4b 0000000000001100001011101000100110        CSRRW sentinel 0x00000100
 * 4a _L4a       66 1110000001100000111011101000100000 SW     Store word. Q=wradr=RS1+Simm
 * 4b CSRRW_2    b0 0000100000000011101011100x00001xx0        Write PC to 0x100 start Prep emulation entrypt
 * 4c SLT_0      31 0010000000000000111011x01100xxxxx0 SLT    Set less than (signed)
 * 4d _L4d       e6 0000000000000100001011101100111000 LUI    q = imm20
 * 4e _L4e       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 4f _L4f       e6 0000000000000100001011101100111000 LUI    q = imm20
 * 50 LW_1       e6 0001000010000100101111101100001xx0        Read until d=mem[(rs1+ofs) & ~3u]
 * 51 LDAF_LW    da 0000000000001111101011100x00111000  err   LD AlignFault. Faulting adr to mtval
 * 52 LH_1       54 0010001010000000101111101000001xx1        Read until q=mem[(rs1+ofs) & ~3u]
 * 53 LDAF_LH    da 0000000000001111101011100x00111000  err   LD AlignFault. Faulting adr to mtval
 * 54 LH_2       d7 0010000100000000101001101000001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)
 * 55 aFaultb    1e 0000000000001111101011101100111000  err   LH Load access fault. Faulting adr to mtval
 * 56 LH_4       57 0010000000000000100011101000010xx0        q = (uint16_t) mem[rs1+Iimm]
 * 57 LH_5       0b 0010000000000000100011101000000xx0        q = D^0xffffffff^q = D ^ 0x00008000
 * 58 _L58       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 59 _L59       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 5a SB_1       5d 0000000000001100101101101000001xx0        Write d to Q and yy (for sh 0). Prep shift
 * 5b _L5b       32 0010000001100000001011100x00111000 JAL    J-imm is in q. Branch on alignfault
 * 5c CSRRS_0    b1 0000000000001000011011101100111000 CSRRS  Decoded CSR adr in jj
 * 5d SB_2       69 0000000100001100101101101000101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)
 * 5e LHU_1      70 0010001010000000101111101000001xx1        Read until q=mem[(rs1+ofs) & ~3u]
 * 5f LDAF_LHU   da 0000000000001111101011100x00111000  err   LD AlignFault. Faulting adr to mtval
 * 60 _L60       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 61 LBU_1      f0 0010001010000000101111101000001xx1        Read until q=mem[(rs1+ofs) & ~3u]
 * 62 LHU_3      1a 0010000000000000011111101000011xx0        Invert q. Prepare read mask
 * 63 _L63       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 64 SLTIU_0    2b 0010000000000000111111101000011xx0 SLTIU  Set less than immediate (unsigned)
 * 65 _L65       04 0010000000000000001011x00x00xxxxx0 AUIPC  q = imm20 (copy x/8)
 * 66 SW_1       f2 0000000000000011111011100x00001xx0        Write d to a+k until accepted
 * 67 SWE        93 0000000000001111001011100x00111000        Store faulting address alignment to mtval
 * 68 _L68       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 69 SB_3       6b 0010000000000000000011101100111000        Prepare get back address to use 
 * 6a _L6a       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 6b SB_4       7a 1110000000000010110011101000001xx0        Address back to Q. Prepare get item to write
 * 6c SLTU_0     31 0010000000000000111011x01100xxxxx0 SLTU   Set less than (unsigned)
 * 6d _L6d       e6 0000000000000100001011101100111000 LUI    q = imm20
 * 6e _L6e       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 6f _L6f       e6 0000000000000100001011101100111000 LUI    q = imm20
 * 70 LHU_2      62 0010000100000000101001101000001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)
 * 71 aFaultc    1e 0000000000001111101011101100111000  err   LHU Load access fault. Faulting adr to mtval
 * 72 LBU_3      1a 0010000000000000011011101000011xx0        Invert q. Prepare read mask
 * 73 BAERR_1    76 0000000000001111110011101100001xx0        Faultadr to mtval. Prepare get offset
 * 74 BrOpFet    f4 0010001010000000101111101110001xx0 NewOp2 Read until instruction latched
 * 75 BAlignEr   73 0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned
 * 76 BAERR_2    77 0010000000000000001011101000000xx0        ~offset to Q. Prep read (origPC+offset)
 * 77 BAERR_3    7d 0000000000001101101011100x00100110        origPC to mepc. Prep read 0
 * 78 _L78       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 79 _L79       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 7a SB_5       f2 0000000000000010110011100x00001xx0        Write d to a+k until accepted
 * 7b _L7b       32 0010000001100000001011100x00111000 JAL    J-imm is in q. Branch on alignfault
 * 7c CSRRC_0    b2 0000000000001000011011101100111000 CSRRC  Decoded CSR adr in jj
 * 7d BAERR_4    34 0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont
 * 7e NMI_1      90 0000000000001101xxxx11101100001xx0        Store pc to mepc.
 * 7f JALRE2     7d 0000000000001111101011100x00001xx0        mtval is target
 * 80 LBU_0      61 0110000000000000110110101000100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.
 * 81 JAERR_2    7d 0000000000001101101011100x00001xx0        Store PC to mepc
 * 82 ILL_3      89 0000000000001111101011101100111000        Store illegal instruction to mtval
 * 83 _L83       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 84 XORI_0     21 0010000000000000111111101000011xx0 XORI   Xor immediate. Q=~Iimm
 * 85 _L85       04 0010000000000000001011x00x00xxxxx0 AUIPC  q = imm20 (copy x/8)
 * 86 JAL_2      34 0000000000000100110011000x00100110        Return address to TRG
 * 87 JALRE1     7f 0000000000001101110011100x00001xx0  err   Store pc to mepc
 * 88 _L88       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 89 ILL_4      8b 0010000000000000101011101000100110        Q = 1
 * 8a _L8a       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 8b ILL_5      34 0000110000001110100111100x00100110        Store 2 to mcause
 * 8c XOR_0      29 0010000000000000111111x01100xxxxx0 XOR    xor
 * 8d _L8d       e6 0000000000000100001011101100111000 LUI    q = imm20
 * 8e _L8e       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 8f _L8f       e6 0000000000000100001011101100111000 LUI    q = imm20
 * 90 NMI_2      34 0000110000001111010011101100111000        mtval = 0.
 * 91 LDAF_2     92 0000110000001110001011000x00100110        Store 4 to mcause
 * 92 LDAF_3     34 0000000000001101100111100x00001xx0        PC to mepc
 * 93 SW_E2      94 0000000000001101101111101100001xx0        Store address that faulted
 * 94 SW_E3      95 0010000000000000101111001000100110        Q = 3
 * 95 SW_E4      34 0000110000001110100111100x00101000        Store 6 to mcause
 * 96 SH_1       9a 0000000000001100101101101000001xx0        Write d to Q and yy (for sh 0). Prep shift
 * 97 SWH        93 0000000000001111001011100x00111000        Store faulting address alignment to mtval
 * 98 BLT        13 0000000000001100111011101100111000 BLT    Conditional Branch. Offset to Ryy
 * 99 _L99       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 9a SH_2       9d 0000000100001100101101101000101000        Repeat shl until shreg = 0 (0,8 or 24 times)
 * 9b _L9b       32 0010000001100000001011100x00111000 JAL    J-imm is in q. Branch on alignfault
 * 9c _L9c       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 9d SH_3       9e 0010000000000000000011101100111000        Prepare get back address to use 
 * 9e SH_4       9f 1110000000000001110011101000001xx0        Address back to Q. Prepare get item to write
 * 9f SH_5       f2 0000000000000001110011100x00001xx0        Write d to a+k until accepted
 * a0 LHU_0      5e 0100000000101100110110101000100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm.
 * a1 ECALL_3    a2 0010000000000000101011001000100110        Q = 4
 * a2 ECALL_4    a9 0010000000000000101011001000100110        Q = 8
 * a3 _La3       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * a4 SRxI_0     3a 0010000000000000111100100x00111000 SRxI   Shift Right immediate (both logic/arith here)
 * a5 _La5       04 0010000000000000001011x00x00xxxxx0 AUIPC  q = imm20 (copy x/8)
 * a6 ECAL_RET   d0 0000000001101000001011100x00111000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET
 * a7 EBREAK_1   ab 0000000000001101xxxx11101100001xx0 EBREAK mepc = pc, prep store 0 to mtval
 * a8 _La8       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * a9 ECALL_5    34 0000110000001110100111000x00100000        mcause = 11
 * aa _Laa       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * ab EBREAK_2   ba 0000000000001111101011101100111000        mtval = 0, 
 * ac _Lac       3f 0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)
 * ad _Lad       e6 0000000000000100001011101100111000 LUI    q = imm20
 * ae _Lae       3f 0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)
 * af _Laf       e6 0000000000000100001011101100111000 LUI    q = imm20
 * b0 CSRRW_3    e6 0010000000000000101011001000100110        Prep emulation entrypt 0x108, here Q to 0x104
 * b1 CSRRS_1    b4 0000000000001100011011001100100000        CSRRS sentinel 0x00000102
 * b2 CSRRC_1    b4 0000000000001100011011001100100110        CSRRC sentinel 0x0000103
 * b3 CSRRWI_1   b4 0000000000001100011011101100100110        CSRRWI sentinel 0xffffff80
 * b4 CSRRWI_2   4b 0010000000000000001011101000100110        Prepare write current PC to 0x100
 * b5 CSRRSI_1   b4 0000000000001100011011001100100000        CSRRSI sentinel 0xffffff82
 * b6 CSRRCI_1   b4 0000000000001100011011001100100110        CSRRCI sentinel 0xffffff83
 * b7 IJ_3       bd 0010000000000000110011001000100000        Construct Q = 3
 * b8 BGE        13 0000000000001100111011101100111000 BGE    Conditional Branch. Offset to Ryy
 * b9 _Lb9       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * ba EBREAK_3   34 0000110000001110100111000x00100000        mcause = 3
 * bb _Lbb       32 0010000001100000001011100x00111000 JAL    J-imm is in q. Branch on alignfault
 * bc CSRRWI_0   b3 0000000000001000010111101100111000 CSRRWI Decoded CSR adr in jj
 * bd IJ_4       de 0100000010001010110111100000010xx0        Mask and use as PC
 * be IJ_1       1f 0010000010000000101111101000001xx0        Read until q=mem[(rs1+ofs)&~3u]
 * bf IJT_1      c1 0010000010000000101111101000001xx0        Exit CSR, enter trap
 * c0 _Lc0       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * c1 IJT_2      c2 0000000000001100101011101100111000        Read word is to be masked with ~3u
 * c2 IJT_3      c6 0010000000000000110011001000100000        Construct Q = 3
 * c3 _Lc3       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * c4 ORI_0      e1 0000000000001000111111101100011xx0 ORI    Or immediate. jj=~Iimm
 * c5 _Lc5       04 0010000000000000001011x00x00xxxxx0 AUIPC  q = imm20 (copy x/8)
 * c6 IJT_4      47 0100000000001101110111101000010xx0        Mask and store to mepc and Q for read of instr
 * c7 QINT_1     cb 0000000000001101xxxx11101100001xx0        Store pc to mepc.
 * c8 _Lc8       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * c9 xRET_2     e6 0010000000000000101011101000100110        Prep +4
 * ca _Lca       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * cb QINT_2     e6 0000110000001111010011101100111000        mtval = 0.
 * cc OR_0       26 0010000000000000111111x01100xxxxx0 OR     or
 * cd _Lcd       e6 0000000000000100001011101100111000 LUI    q = imm20
 * ce _Lce       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * cf _Lcf       e6 0000000000000100001011101100111000 LUI    q = imm20
 * d0 ECALL_1    37 0000000000001101xxxx11101100001xx0 ECALL  mepc = pc, prep store 0 to mtval
 * d1 xRET_1     c9 0010000000000000011011x01100xxxxx0 (U/S/M)RET Prepare emulation entry point 0x104
 * d2 LB_2       06 0010000100000000101001101000001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)
 * d3 aFaultd    1e 0000000000001111101011101100111000  err   LB Load access fault. Faulting adr to mtval
 * d4 aFault_2   92 0000110000001110001011100x00100110        Store 5 to mcause
 * d5 eFetch2    de 000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  Fr11  Not in use
 * d6 jFault_1   92 0000000000001110001011100x00100110        Store 1 to mcause
 * d7 LH_3       56 0010000000000000011111101000011xx0        q = ~mem[rs1+ofs]
 * d8 BLTU       13 0000000000001100111011101100111000 BLTU   Conditional Branch. Offset to Ryy
 * d9 _Ld9       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * da LDAF_a     91 0010000000000000101011x01100xxxxx0        Extra cycle after error detected write mtval
 * db _Ldb       32 0010000001100000001011100x00111000 JAL    J-imm is in q. Branch on alignfault
 * dc CSRRSI_0   b5 0000000000001000010111101100111000 CSRRSI Decoded CSR adr in jj
 * dd aF_SW_1    e2 0000000000001111101011101100111000  err   SW Store access fault. Faulting adr to mtval
 * de Fetch      f4 0011001010000000101111101110001xx0  Fr11  Read and latch instruction
 * df eFetch     f4 0011001010000000101111101110001xx0  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]
 * e0 _Le0       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * e1 ORI_1      1d 0010000000000000000011101000001xx0        Q = RS1
 * e2 aF_SW_2    e9 0010000000000000101011001000100110        Q = 4
 * e3 _Le3       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * e4 ANDI_0     1a 0010000000000000111111101000011xx0 ANDI   And immediate. Q=~Iimm
 * e5 _Le5       04 0010000000000000001011x00x00xxxxx0 AUIPC  q = imm20 (copy x/8)
 * e6 StdIncPc   de 0100000010001010110111000000100110  Fr11  IncPC, OpFetch
 * e7 aFault     1e 0000000000001111101011101100111000  err   Load access fault. Faulting adr to mtval
 * e8 _Le8       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * e9 aF_SW_3    92 0000110000001110001011000x00100000        Store 7 to mcause
 * ea _Lea       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * eb _Leb       de 000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx q:eb
 * ec AND_0      22 0010000000000000111111x01100xxxxx0 AND    And 
 * ed _Led       e6 0000000000000100001011101100111000 LUI    q = imm20
 * ee _Lee       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * ef _Lef       e6 0000000000000100001011101100111000 LUI    q = imm20
 * f0 LBU_2      72 0010000100000000101001101000001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)
 * f1 aFaulte    1e 0000000000001111101011101100111000  err   LBU Load access fault. Faulting adr to mtval
 * f2 SW_2       e6 0010000000000000001011x01100xxxxx0        Prepare read PC
 * f3 aF_SW      dd 0010000000000000xxxx11x00x00xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf
 * f4 Fetch2     12 0000000000001011000111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx
 * f5 jFault     d6 0000000000001111101011101100111000  err   Fetch access fault. Faulting adr to mtval
 * f6 _Lf6       de 000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx q:f6
 * f7 _Lf7       de 000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx q:f7
 * f8 BGEU       13 0000000000001100111011101100111000 BGEU   Conditional Branch. Offset to Ryy
 * f9 _Lf9       fe 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * fa _Lfa       de 000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx q:fa
 * fb _Lfb       32 0010000001100000001011100x00111000 JAL    J-imm is in q. Branch on alignfault
 * fc CSRRCI_0   b6 0000000000001000010111101100111000 CSRRCI Decoded CSR adr in jj
 * fd NMI_0      7e 0010000000000000001011x01100xxxxx0 NMI    Get current PC
 * fe ILLe       46 0010000000000000001011x01100xxxxx0 Illegal
 * ff QINT_0     c7 0010000000000000001011x01100xxxxx0 INT    Get current PC
 */
localparam u0_0 = 256'hbb38b300bb38ba08bb26aa207a00aa207a10ba18b000bb20b3007a20fa096a20;
localparam u0_1 = 256'hbb38b226bb30b838b838bb10bb20bb387a20703e3a48ba26fa00fa260000fa00;
localparam u0_2 = 256'hbb383000bb38b0003b26aa20ba00aa203a20bb00b000c838b300ba00bb006a20;
localparam u0_3 = 256'hc808c8089a09bb38b8389a093000bb38bb38da28da087808b820bb20fa00bb3a;
localparam u0_4 = 256'hbb383000bb38b300b808ba20ba26ba20fa087a08b000fa183000bb103a267a20;
localparam u0_5 = 256'hb838fa09da28bb38b838da08300030003a003a10bb389a09b838fa09b838fb08;
localparam u0_6 = 256'hbb383000bb38b3003a0830003b383000b838b808b000fa183000fa18fa093000;
localparam u0_7 = 256'hb8083b087808bb38b838380830003000b826ba00b000fb883b08ba18bb389a09;
localparam u0_8 = 256'hbb383000bb38f30078263000ba26300038083026b000fa183000bb38b8086a20;
localparam u0_9 = 256'h38083a083b383000b838da283000bb38b838da087828f226fb087808b0263b38;
localparam u0_A = 256'hbb38b000bb38b000bb383000702030003b08b838b000c8383000b226b2266a20;
localparam u0_B = 256'hfa08fa0878107b38b83870203000bb383220b326b320ba26bb26b326b320b226;
localparam u0_C = 256'hbb383000bb38f3003b383000ba2630003b087a10b000fb1830003220bb383000;
localparam u0_D = 256'hfb88fb88bb387b38b838b3003000bb38fa18b8260000b826bb389a09b3003b08;
localparam u0_E = 256'hbb383000bb38f30000003000b0203000bb387026b000fa183000b2263a083000;
localparam u0_F = 256'hb300b300b3007b38b83800003000bb3800000000bb387f203000b300bb389a09;
localparam u1_0 = 256'h001080030010800300100023800100238001800180000010800090838a028003;
localparam u1_1 = 256'h00328002001000a0818000100022003301ab022b800380008003006700008003;
localparam u1_2 = 256'h0010800000108003800000a3800300a3800000238000800380008003001000b3;
localparam u1_3 = 256'h80038003041200218180001280000033003e04120012022b003c003080030010;
localparam u1_4 = 256'h0010800000108003200e8183003081838202003780008003800001b080008183;
localparam u1_5 = 256'h003e8a0204320021818000328000800080028002003e8402003e8a02003e4212;
localparam u1_6 = 256'h0010800000108003800b800080008000003c000f80008003800080018a028000;
localparam u1_7 = 256'h003e0034303a00218180000b800080000036800080008a02003f8001003e8402;
localparam u1_8 = 256'h0010800000108003303a80008002800000370013800080038000003e00368003;
localparam u1_9 = 256'h00078007800080008180043280000033003c0032303a8002003600363038303d;
localparam u1_A = 256'h0010800300108003003e8000303a8000003401a08000800380008002800200b3;
localparam u1_B = 256'h82028202022b00218180303a8000003380030031003180000031003100318002;
localparam u1_C = 256'h0010800000108003303d80008002800000340037800000238000800300328000;
localparam u1_D = 256'hca02ca02003e002181808002800000338001003800003038003e840280010034;
localparam u1_E = 256'h00108000001080030000800030388000003e022b800080038000800280008000;
localparam u1_F = 256'h8000800080000021818000008000003300000000003e002c80008000003e8402;
localparam u2_0 = 256'h039800400398001003980168002c01680024001c00100398039802f803480005;
localparam u2_1 = 256'h02dc03500398029800c803980104004c01d1037900580054005000000378002c;
localparam u2_2 = 256'h039803f8039800f800c00258008402580074009c001000d40398006803980149;
localparam u2_3 = 256'h00e800d4000c012400c800f403f8004c0284000c00d803790204021800ac0398;
localparam u2_4 = 256'h039803f8039800c402c0019b012c019b0208011d001000ac03f8021801080141;
localparam u2_5 = 256'h036801c001a402c400c8017403f803f8002c015c0078035c0368015003680398;
localparam u2_6 = 256'h039803f8039800c401eb03f801ac03f8024c03c8001000ac03f8006803c003f8;
localparam u2_7 = 256'h01f4024000d002c800c803c803f803f801f401dc01cc03d001d8006800780188;
localparam u2_8 = 256'h039803f8039800a400d003f8022c03f801fc00d00010008403f8022401f40185;
localparam u2_9 = 256'h03c8027f027803f800c8027403f8004c024c026800d00254025000d0024800d0;
localparam u2_A = 256'h039800fc039800fc02e803f800d003f802ac0340001000e803f802a402880179;
localparam u2_B = 256'h0304007c037902cc00c800d003f8004c02f402d002d0012c02d002d002d00398;
localparam u2_C = 256'h039803f803980098039803f8039803f8032c011d0010038403f80318030803f8;
localparam u2_D = 256'h03d003d0038802d400c8024403f8004c015802480378024800780018032400dc;
localparam u2_E = 256'h039803f803980088037803f8024803f8007803790010006803f803a4007403f8;
localparam u2_F = 256'h031c011801f802d800c8037803f8004c037803780358004803740398007801c8;
