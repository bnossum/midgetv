/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
/* -----------------------------------------------------------------------------
 * Automaticaly generated by ../bin/midgetv_genucode_permutated
 * (based on ../code/ucode_permutated.h).
 * Do not edit.
 * Optimized control in two EBRs, and some LUTs/FFs.
 */
module m_2ebr
  (
   input         clk,
   input [7:0]   minx,
   input         progress_ucode,
   output [47:0] d
   );

   wire [31:0]   dd;
   
/* uPC
 * ||            next uPC
 * ||            || ucodeInstruction
 * ||            || 222222221111111111
 * || label      || 7654321098765432109876543210 Purpose
 * -- ---------- -- ---------------------------- ------------------------------------------------------
 * 00 LB_0       94 0000000000110110101000100000 LB     Load byte. q = rdadr=RS1+0fs
 * 01 LB_2       09 0100000000101001101000001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)
 * 02 OR_1       46 00x0001000111011100100000xx0        RS1^0xffffffff to jj
 * 03 FENCE      3a 0000000000001011x01100xxxxx0 f      Prepare read PC (FENCE)
 * 04 ADDI_0     3a 0000000100001011101100100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)
 * 05 _L05       04 0000000000001011x00x00xxxxx0 AUIPC  q = imm20 (copy x/8)
 * 06 condb_5    a6 0000001010110111001000111110        Branch not taken.
 * 07 condb_5t   86 0001101010110111101000100000        Branch taken.
 * 08 _L08       7e 0000001000111010101000100000 SB     Store byte. wjj=wradr=RS1+Simm
 * 09 LB_3       1a 0000000000011011101000011xx0        q = ~mem[rs1+ofs]
 * 0a _L0a       7e 0000001000111010101000100000 SB     Store byte. wjj=wradr=RS1+Simm
 * 0b SLTIX_2    3a 00x0000100001011100100111010        Registered ALU flag to rd
 * 0c ADD_0      04 0000000000111011101000001xx0 ADD    add     Addition Q = RS1
 * 0d LUI        3a 0000000100001011101100111000 LUI    q = imm20
 * 0e SUB_0      1f 0000000000111011x01100xxxxx0 SUB    Subtraction
 * 0f _L0f       3a 0000000100001011101100111000 LUI    q = imm20
 * 10 JAL_1      14 0000001000001011101100100000        Target adr to jj
 * 11 JAERR_1    55 00x0001111001011101x00100000  Err   JAL target adr misaligned, store to mtval
 * 12 SW_1       ba 0000000011111011100x00001xx0        Write d to a+k until accepted
 * 13 SWE        71 00x0001111001011101x00111000  err   Store faulting address to mtval
 * 14 JAL_2      54 00x0000100000011001x00100110        Return address to TRG
 * 15 JALRE1     53 00x0001101000011100x00001xx0  err   Store pc to mepc
 * 16 ECALL_1    36 0000001101xxxx11101100001xx0 ECALL  mepc = pc, prep store 0 to mtval
 * 17 EBREAK_1   73 0000001101xxxx11101100001xx0 EBREAK mepc = pc, prep store 0 to mtval
 * 18 BEQ        21 0000001100111011101100111000 BEQ    Conditional Branch. Offset to Ryy
 * 19 JALR_0     61 0000001000101011101100100000 JALR   jj=RS1+imm. Branch on alignment fault
 * 1a LB_4       1d 0000000000010111101000010xx0        q = (uint8_t) mem[rs1+Iimm]
 * 1b _L1b       10 0001100000001011100x00111000 JAL    J-imm is in q. Branch on alignfault (copy 1/8)
 * 1c ECAL_BRK   16 00x1100000001011101x00111000 ECALL/EBREAK  Select ECALL or EBREAK
 * 1d LB_5       1e 0000000000010111101000000xx0        q = D^0xffffffff^q = D^0x80
 * 1e LB_6       3a 0000000100001011101100100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80 (join)
 * 1f SUB_1      1e 0000000000111111101000000xx0        Q = ~RS2
 * 20 LH_0       90 0000101100110110101000100000 LH     Load hword. Q = rdadr=RS1+Iimm.
 * 21 condb_2    26 0000000000111111101000000xx0        ~RS2 in Q
 * 22 SLL_1      5a 00x0000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2
 * 23 FENCEI     3a 0000000000001011x01100xxxxx0 f      Prepare read PC (FENCE)
 * 24 SLLI_0     5a 00x0000000111100101x00111000 SLLI   Shift left immediate.
 * 25 _L25       04 0000000000001011x00x00xxxxx0 AUIPC  q = imm20 (copy x/8)
 * 26 condb_3    27 0000000000001011101000100110        Calculate RS1+~RS2+1
 * 27 condb_4    06 0000000000110011101001001xx0        Branch on condition
 * 28 _L28       34 0000101000111010101000100000 SH     Store halfword. jjw=wradr=RS1+Simm
 * 29 ANDI_1     3a 0000000100001011101100010xx0        rd = Iimm & RS1
 * 2a _L2a       34 0000101000111010101000100000 SH     Store halfword. jjw=wradr=RS1+Simm
 * 2b SRx_1      5e 00x0000000111100100x00001xx0        Shiftamount in low 5 bits of RS2
 * 2c SLL_0      22 00x0000000111011x01x00xxxxx0 SLL    Shift left
 * 2d _L2d       3a 0000000100001011101100111000 LUI    q = imm20
 * 2e _L2e       37 0000000000001011x01100xxxxx0 Illegal
 * 2f _L2f       3a 0000000100001011101100111000 LUI    q = imm20
 * 30 LW_1       0d 0010000000101111101000001xx0        Read until q=mem[(rs1+ofs) & ~3u]
 * 31 LDAF_LW    6b 0000001111101011101100111000  err   LD AlignFault. Faulting adr to mtval
 * 32 CSRRSI_2   69 0000000011101011100x00001xx0        Prep emulation entrypt 0x110
 * 33 OpFetch2      000xx11011111111101000100110        Update I. Q=immediate. Use dinx
 * 34 SH_1       be 0000000000101101101000001xx0        Write d to Q. Prep shift
 * 35 SWH        71 00x0001111001011100x00111000  err   Store faulting address to mtval
 * 36 ECALL_2    c7 0000001111101011101100111000        mtval = 0, now start the chore of 11 to mcause
 * 37 ILL_1      67 0000001101110111101000001xx0        Store PC to mepc and Q for read of instr
 * 38 BNE        21 0000001100111011101100111000 BNE    Conditional Branch. Offset to Ryy
 * 39 _L39       37 0000000000001011x01100xxxxx0 Illegal
 * 3a StdIncPc   a6 0000001010110111001000100110        IncPC, OpFetch
 * 3b _L3b       10 0001100000001011100x00111000 JAL    J-imm is in q. Branch on alignfault (copy 1/8)
 * 3c CSRRW_0    da 0000001000011011101100111000 CSRRW  Decoded CSR adr in jj
 * 3d ORI_1      3e 0000000000000011101000001xx0        Q = RS1
 * 3e ORI_2      3a 0000000100001011101100110000        rd = Iimm | RS1
 * 3f XORI_1     3a 0000000100001011101100000xx0        rd = Iimm ^ RS1
 * 40 LW_0       30 0001101100110111101000100000 LW     Load word. Q=yy=rdadr=RS1+Iimm
 * 41 AND_1      29 0000000000111011101000000xx0        RS1^0xffffffff to Q
 * 42 SB_5       03 0000000010110011100x00001xx0        Write d to a+k until accepted
 * 43 _L43       37 0000000000001011x01100xxxxx0 Illegal
 * 44 SLTI_0     49 0000000000111111101000011xx0 SLTI   Set less than immediate (signed)
 * 45 _L45       04 0000000000001011x00x00xxxxx0 AUIPC  q = imm20 (copy x/8)
 * 46 OR_2       3e 0000000000000011101000100000        Q = rs2
 * 47 XOR_1      3f 0000000000111011101000000xx0        Q = RS1^0xFFFFFFFF
 * 48 _L48       12 0001101100111011101000100000 SW     Store word. Q=wradr=RS1+Simm
 * 49 SLTIX_1    0b 0000000000xxxx11101100100110        RS1 - imm / RS1 - RS2
 * 4a _L4a       12 0001101100111011101000100000 SW     Store word. Q=wradr=RS1+Simm
 * 4b BAERR_4    a7 00x0001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont
 * 4c SLT_0      50 0000000000111011x01100xxxxx0 SLT    Set less than (signed)
 * 4d _L4d       3a 0000000100001011101100111000 LUI    q = imm20
 * 4e _L4e       37 0000000000001011x01100xxxxx0 Illegal
 * 4f _L4f       3a 0000000100001011101100111000 LUI    q = imm20
 * 50 SLTX_1     49 0000000000111111101000000xx0        ~rs2 to Q
 * 51 BAERR_1    a1 0000001111110011101100001xx0        Faultadr to mtval. Prepare get offset
 * 52 BAERR_3    4b 00x0001101101011100x00100110        origPC to mepc. Prep read 0
 * 53 JALRE2     4b 00x0001111101011101x00001xx0        mtval is target
 * 54 JAL_3      a6 0000001010110111101000001xx0        PC+imm to PC. OpFetch
 * 55 JAERR_2    4b 00x0001101101011100x00001xx0        Store PC to mepc
 * 56 ILL_3      a9 0000001111101011101100111000        Store illegal instruction to mtval
 * 57 LDAF_3     a7 00x0001101100111101x00001xx0        PC to mepc
 * 58 _L58       37 0000000000001011x01100xxxxx0 Illegal
 * 59 _L59       37 0000000000001011x01100xxxxx0 Illegal
 * 5a SLLI_1     5d 0000000100101101101000001xx0        Register to shift to Q (and TRG for shift 0)
 * 5b _L5b       10 0001100000001011100x00111000 JAL    J-imm is in q. Branch on alignfault (copy 1/8)
 * 5c CSRRS_0    df 0000001000011011101100111000 CSRRS  Decoded CSR adr in jj
 * 5d SLLI_2     03 0100000100101101101000101000        Repeat Q = Q+Q until shregcnt == 0
 * 5e SRxI_1     5f 0000000100101001101000001xx0        Register to shift to Q
 * 5f SRxI_2     03 0100000100101001101000001xx1        Repeat Q >>= 1 until shregcnt == 0
 * 60 _L60       37 0000000000001011x01100xxxxx0 Illegal
 * 61 JALR_1     66 0000000000000011101000100110        Q=1
 * 62 ILL_5      a7 00x0001110100111100x00100110        Store 2 to mcause
 * 63 _L63       37 0000000000001011x01100xxxxx0 Illegal
 * 64 SLTIU_0    49 0000000000111111101000011xx0 SLTIU  Set less than immediate (unsigned)
 * 65 _L65       04 0000000000001011x00x00xxxxx0 AUIPC  q = imm20 (copy x/8)
 * 66 JALR_2     14 0001101000001011101100010xx0        Q = (RS1+imn) & 0xfffffffe
 * 67 ILL_2      56 0010000000101111101000001xx0        Read until Q is offending instruction
 * 68 _L68       37 0000000000001011x01100xxxxx0 Illegal
 * 69 CSRRSI_3   fd 0000000000101011001000100110        Prep emulation entrypt
 * 6a _L6a       37 0000000000001011x01100xxxxx0 Illegal
 * 6b LDAF_2     57 00x0001110001011000x00100110        Store 4 to mcause
 * 6c SLTU_0     50 0000000000111011x01100xxxxx0 SLTU   Set less than (unsigned)
 * 6d _L6d       3a 0000000100001011101100111000 LUI    q = imm20
 * 6e _L6e       37 0000000000001011x01100xxxxx0 Illegal
 * 6f _L6f       3a 0000000100001011101100111000 LUI    q = imm20
 * 70 LH_2       74 0100000000101001101000001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)
 * 71 SW_E2      bd 0000001101101111101100001xx0        Store address that faulted
 * 72 SH_5       03 0000000001110011100x00001xx0        Write d to a+k until accepted
 * 73 EBREAK_2   cb 0000001111101011101100111000        mtval = 0, 
 * 74 LH_3       7a 0000000000011111101000011xx0        q = ~mem[rs1+ofs]
 * 75 CSRRW_2    3a 0000000011101011100x00001xx0        Prep emulation entrypt 0x104
 * 76 _L76       a6 0xxxxxxxx1xxxxxxxx1x0xxxxxxx q:76
 * 77 _L77       a6 0xxxxxxxx1xxxxxxxx1x0xxxxxxx q:77
 * 78 _L78       37 0000000000001011x01100xxxxx0 Illegal
 * 79 _L79       37 0000000000001011x01100xxxxx0 Illegal
 * 7a LH_4       7d 0000000000100011101000010xx0        q = (uint16_t) mem[rs1+Iimm]
 * 7b _L7b       10 0001100000001011100x00111000 JAL    J-imm is in q. Branch on alignfault (copy 1/8)
 * 7c CSRRC_0    dd 0000001000011011101100111000 CSRRC  Decoded CSR adr in jj
 * 7d LH_5       1e 0000000000100011101000000xx0        q = D^0xffffffff^q = D ^ 0x00008000
 * 7e SB_1       7f 0000000000101101101000001xx0        Write d to Q. Prep shift
 * 7f SB_2       9a 0100000000101101101000101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)
 * 80 LBU_0      b4 0000000000110110101000100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.
 * 81 LHU_2      89 0100000000101001101000001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)
 * 82 _L82       a6 0xxxxxxxx0xxxxxxxx0x1xxxxxxx q:82
 * 83 _L83       37 0000000000001011x01100xxxxx0 Illegal
 * 84 XORI_0     3f 0000000000111111101000011xx0 XORI   Xor immediate. Q=~Iimm
 * 85 _L85       04 0000000000001011x00x00xxxxx0 AUIPC  q = imm20 (copy x/8)
 * 86 BrOpFet    33 0010000000001111x01110xxxxx0 NewOp2 Read until instruction latched
 * 87 BAlignEr   51 00x0000000001011x01x00xxxxx0  Err   Branch target instruction address misaligned
 * 88 _L88       37 0000000000001011x01100xxxxx0 Illegal
 * 89 LHU_3      29 0000000000011111101000011xx0        Invert q. Prepare read mask
 * 8a _L8a       37 0000000000001011x01100xxxxx0 Illegal
 * 8b SW_E4      a7 00x0001110100111100x00101000        Store 6 to mcause
 * 8c XOR_0      47 0000000000111111x01100xxxxx0 XOR    xor
 * 8d _L8d       3a 0000000100001011101100111000 LUI    q = imm20
 * 8e _L8e       37 0000000000001011x01100xxxxx0 Illegal
 * 8f _L8f       3a 0000000100001011101100111000 LUI    q = imm20
 * 90 LH_1       70 1010000000101101101000001xx0        Read until q=mem[(rs1+ofs) & ~3u]
 * 91 LDAF_LH    6b 0000001111101011101100111000  err   LD AlignFault. Faulting adr to mtval
 * 92 _L92       a6 1xxxxxxxx1xxxxxxxx0x1xxxxxxx q:92
 * 93 _L93       a6 0xxxxxxxx1xxxxxxxx1x0xxxxxxx q:93
 * 94 LB_1       01 1010000000101101101000001xx0        Read until q=mem[rs1+ofs) & ~3u]
 * 95 CSRRC_2    de 0000000011101011100x00001xx0        Prep emulation entrypt 0x108
 * 96 _L96       a6 1xxxxxxxx1xxxxxxxx1x1xxxxxxx q:96
 * 97 _L97       a6 0xxxxxxxx1xxxxxxxx1x0xxxxxxx q:97
 * 98 BLT        21 0000001100111011101100111000 BLT    Conditional Branch. Offset to Ryy
 * 99 _L99       37 0000000000001011x01100xxxxx0 Illegal
 * 9a SB_3       9d 0000001100000001101100111000        Prepare get back address to use 
 * 9b _L9b       10 0001100000001011100x00111000 JAL    J-imm is in q. Branch on alignfault (copy 1/8)
 * 9c _L9c       37 0000000000001011x01100xxxxx0 Illegal
 * 9d SB_4       42 0000000000110011101000001xx0        Address back to Q. Prepare get item to write
 * 9e LBU_2      9f 0100000000101001101000001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)
 * 9f LBU_3      29 0000000000011011101000011xx0        Invert q. Prepare read mask
 * a0 LHU_0      b0 0000101100110110101000100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm.
 * a1 BAERR_2    52 0000000000001011101000000xx0        ~offset to Q. Prep read (origPC+offset)
 * a2 _La2       a6 0xxxxxxxx0xxxxxxxx0x1xxxxxxx q:a2
 * a3 _La3       37 0000000000001011x01100xxxxx0 Illegal
 * a4 SRxI_0     5e 00x0000000111100101x00111000 SRxI   Shift Right immediate (both logic/arith here)
 * a5 _La5       04 0000000000001011x00x00xxxxx0 AUIPC  q = imm20 (copy x/8)
 * a6 OpFetch    33 0010000000001111x01110xxxxx0  NewOp Read until instruction latched
 * a7 BAERR_5    a6 0000001010110111101000001xx0        PC = trap entry point. OpFetch
 * a8 _La8       37 0000000000001011x01100xxxxx0 Illegal
 * a9 ILL_4      62 0000000000101011101000100110        Q = 1
 * aa _Laa       37 0000000000001011x01100xxxxx0 Illegal
 * ab ECALL_5    a7 00x0001110100111000x00100000        mcause = 11
 * ac _Lac       2b 00x0000000111011x01x00xxxxx0 SRx    Shift Right (both SRL and SRA)
 * ad _Lad       3a 0000000100001011101100111000 LUI    q = imm20
 * ae _Lae       2b 00x0000000111011x01x00xxxxx0 SRx    Shift Right (both SRL and SRA)
 * af _Laf       3a 0000000100001011101100111000 LUI    q = imm20
 * b0 LHU_1      81 1010000000101101101000001xx0        Read until q=mem[(rs1+ofs) & ~3u]
 * b1 LDAF_LHU   6b 0000001111101011101100111000  err   LD AlignFault. Faulting adr to mtval
 * b2 _Lb2       a6 1xxxxxxxx1xxxxxxxx0x1xxxxxxx q:b2
 * b3 _Lb3       a6 0xxxxxxxx1xxxxxxxx1x0xxxxxxx q:b3
 * b4 LBU_1      9e 1010000000101101101000001xx0        Read until q=mem[(rs1+ofs) & ~3u]
 * b5 CSRRS_2    e1 0000000011101011100x00001xx0        Prep emulation entrypt 0x10c
 * b6 _Lb6       a6 1xxxxxxxx1xxxxxxxx1x1xxxxxxx q:b6
 * b7 _Lb7       a6 0xxxxxxxx1xxxxxxxx1x0xxxxxxx q:b7
 * b8 BGE        21 0000001100111011101100111000 BGE    Conditional Branch. Offset to Ryy
 * b9 _Lb9       37 0000000000001011x01100xxxxx0 Illegal
 * ba SW_2       3a 0000000000001011101100111000        Prep read PC
 * bb _Lbb       10 0001100000001011100x00111000 JAL    J-imm is in q. Branch on alignfault (copy 1/8)
 * bc CSRRWI_0   e7 0000001000011011101100111000 CSRRWI Decoded CSR adr in jj
 * bd SW_E3      8b 0000000000101111001000100110        Q = 3
 * be SH_2       bf 0100000000101101101000101000        Repeat shl until shreg = 0 (0,8 or 24 times)
 * bf SH_3       c1 0000001100000011101100111000        Prepare get back address to use 
 * c0 _Lc0       37 0000000000001011x01100xxxxx0 Illegal
 * c1 SH_4       72 0000000000110011101000001xx0        Address back to Q. Prepare get item to write
 * c2 _Lc2       a6 0xxxxxxxx0xxxxxxxx0x1xxxxxxx q:c2
 * c3 _Lc3       37 0000000000001011x01100xxxxx0 Illegal
 * c4 ORI_0      3d 00x0001000111111101100011xx0 ORI    Or immediate. jj=~Iimm
 * c5 _Lc5       04 0000000000001011x00x00xxxxx0 AUIPC  q = imm20 (copy x/8)
 * c6 _Lc6       a6 0xxxxxxxx0xxxxxxxx1x1xxxxxxx q:c6
 * c7 ECALL_3    c9 0000000000101011001000100110        Q = 4
 * c8 _Lc8       37 0000000000001011x01100xxxxx0 Illegal
 * c9 ECALL_4    ab 0000000000101011001000100110        Q = 8
 * ca _Lca       37 0000000000001011x01100xxxxx0 Illegal
 * cb EBREAK_3   a7 00x0001110100111000x00100000        mcause = 3
 * cc OR_0       02 0000000000111111x01100xxxxx0 OR     or
 * cd _Lcd       3a 0000000100001011101100111000 LUI    q = imm20
 * ce _Lce       37 0000000000001011x01100xxxxx0 Illegal
 * cf _Lcf       3a 0000000100001011101100111000 LUI    q = imm20
 * d0 _Ld0       a6 1xxxxxxxx0xxxxxxxx1x0xxxxxxx q:d0
 * d1 _Ld1       a6 0xxxxxxxx1xxxxxxxx1x0xxxxxxx q:d1
 * d2 _Ld2       a6 1xxxxxxxx1xxxxxxxx0x1xxxxxxx q:d2
 * d3 _Ld3       a6 0xxxxxxxx1xxxxxxxx1x0xxxxxxx q:d3
 * d4 _Ld4       a6 1xxxxxxxx0xxxxxxxx1x0xxxxxxx q:d4
 * d5 CSRRWI_2   e9 0000000011101011100x00001xx0        Prep emulation entrypt 0x110
 * d6 _Ld6       a6 1xxxxxxxx1xxxxxxxx1x1xxxxxxx q:d6
 * d7 _Ld7       a6 0xxxxxxxx1xxxxxxxx1x0xxxxxxx q:d7
 * d8 BLTU       21 0000001100111011101100111000 BLTU   Conditional Branch. Offset to Ryy
 * d9 _Ld9       37 0000000000001011x01100xxxxx0 Illegal
 * da CSRRW_1    75 0000000000001011101000100110        Prepare write current PC to 0x100
 * db _Ldb       10 0001100000001011100x00111000 JAL    J-imm is in q. Branch on alignfault (copy 1/8)
 * dc CSRRSI_0   ff 0000001000011011101100111000 CSRRSI Decoded CSR adr in jj
 * dd CSRRC_1    95 0000000000001011101000100110        Prepare write current PC to 0x100.
 * de CSRRC_3    3a 0000000000101011001000100110        Prep emulation entrypt
 * df CSRRS_1    b5 0000000000001011101000100110        Prepare write current PC to 0x100.
 * e0 _Le0       37 0000000000001011x01100xxxxx0 Illegal
 * e1 CSRRS_3    de 0000000000101011001000100110        Prep emulation entrypt
 * e2 _Le2       a6 0xxxxxxxx0xxxxxxxx0x1xxxxxxx q:e2
 * e3 _Le3       37 0000000000001011x01100xxxxx0 Illegal
 * e4 ANDI_0     29 0000000000111111101000011xx0 ANDI   And immediate. Q=~Iimm
 * e5 _Le5       04 0000000000001011x00x00xxxxx0 AUIPC  q = imm20 (copy x/8)
 * e6 _Le6       a6 0xxxxxxxx0xxxxxxxx1x1xxxxxxx q:e6
 * e7 CSRRWI_1   d5 0000000000001011101000100110        Prepare write current PC to 0x100.
 * e8 _Le8       37 0000000000001011x01100xxxxx0 Illegal
 * e9 CSRRWI_3   e1 0000000000101011001000100110        Prep emulation entrypt
 * ea _Lea       37 0000000000001011x01100xxxxx0 Illegal
 * eb _Leb       a6 0xxxxxxxx0xxxxxxxx0x0xxxxxxx q:eb
 * ec AND_0      41 0000000000111111x01100xxxxx0 AND    And 
 * ed _Led       3a 0000000100001011101100111000 LUI    q = imm20
 * ee _Lee       37 0000000000001011x01100xxxxx0 Illegal
 * ef _Lef       3a 0000000100001011101100111000 LUI    q = imm20
 * f0 _Lf0       a6 1xxxxxxxx0xxxxxxxx1x0xxxxxxx q:f0
 * f1 _Lf1       a6 0xxxxxxxx1xxxxxxxx1x0xxxxxxx q:f1
 * f2 _Lf2       a6 1xxxxxxxx1xxxxxxxx0x1xxxxxxx q:f2
 * f3 _Lf3       a6 0xxxxxxxx1xxxxxxxx1x0xxxxxxx q:f3
 * f4 _Lf4       a6 1xxxxxxxx0xxxxxxxx1x0xxxxxxx q:f4
 * f5 CSRRCI_2   fd 0000000011101011100x00001xx0        Prep emulation entrypt 0x110
 * f6 _Lf6       a6 1xxxxxxxx1xxxxxxxx1x1xxxxxxx q:f6
 * f7 _Lf7       a6 0xxxxxxxx1xxxxxxxx1x0xxxxxxx q:f7
 * f8 BGEU       21 0000001100111011101100111000 BGEU   Conditional Branch. Offset to Ryy
 * f9 _Lf9       37 0000000000001011x01100xxxxx0 Illegal
 * fa CSRRCI_1   f5 0000000000001011101000100110        Prepare write current PC to 0x100.
 * fb _Lfb       10 0001100000001011100x00111000 JAL    J-imm is in q. Branch on alignfault (copy 1/8)
 * fc CSRRCI_0   fa 0000001000011011101100111000 CSRRCI DEcoded CSR adr in jj
 * fd CSRRCI_3   e9 0000000000101011001000100110        Prep emulation entrypt
 * fe _Lfe       37 0000000000001011x01100xxxxx0 Illegal
 * ff CSRRSI_1   32 0000000000001011101000100110        Prepare write current PC to 0x100.
 */
localparam u0_0 = 256'hbb38b300bb38ba08b93aaa20ba18aa207a20723eb000bb20b300b9009a096a20;
localparam u0_1 = 256'hfa00bb267a00ba38b8387a10bb20bb383b083b0838083226ba38b808ba20bb20;
localparam u0_2 = 256'hbb38b300bb38b200c808aa20bb10aa203a48ba26b000ca38b300c808fa006a20;
localparam u0_3 = 256'hbb00bb303a08bb38b8387226b300bb387a08bb38b838da08fa26b808bb38fa08;
localparam u0_4 = 256'hbb38b300bb38b3007808ba203b26ba20ba003a20b000fa18b3003808ba007a20;
localparam u0_5 = 256'h9a099a08da28bb38b838da08b300b3007a08bb38b8087a08ba08b8263b08fa00;
localparam u0_6 = 256'hbb38b300bb38b300b026b300b226b300fa08bb10b000fa18b30078263a26b300;
localparam u0_7 = 256'hda28da083a00bb38b8383a10b300b30002000200b808fa18bb383808fb089a09;
localparam u0_8 = 256'hbb38b300bb38f3007828b300fa18b300b200f380b000fa18b30000809a096a20;
localparam u0_9 = 256'hba189a093a08b300b8381b38b300bb3802000280b808da0802000080bb38da08;
localparam u0_A = 256'hbb38b200bb38b2007020b300ba26b3007a08f380b000ca38b3000080ba006a20;
localparam u0_B = 256'h3b38da28f226bb38b838bb38b300bb3802000280b808da0802000080bb38da08;
localparam u0_C = 256'hbb38b300bb38f3007020b300b226b300b2260280b000fb18b30000803a08b300;
localparam u0_D = 256'hba26b226ba26bb38b838ba26b300bb3802000280b80802000200008002000200;
localparam u0_E = 256'hbb38b300bb38f3000000b300b226b300ba260280b000fa18b3000080b226b300;
localparam u0_F = 256'hba26b300b226bb38b838ba26b300bb3802000280b80802000200008002000200;
localparam u1_0 = 256'ha010f003a0104003a010e023a001e02361ab602b4000a010a000602394024003;
localparam u1_1 = 256'he003a010e00161800180d001102210333034603430344010103ca00f503c4020;
localparam u1_2 = 256'ha0107000a0102003e00340a3a01040a3600370004000a003a000a003600300b3;
localparam u1_3 = 256'ha010a010e000a0210180602b700010337037703e103ce002006f900eb03ed202;
localparam u1_4 = 256'ha0107000a0100003703a21b3b00021b3f003e000400090037000300b900301b3;
localparam u1_5 = 256'h3412f0123412f0210180d012700070007036903eb036602bb03eb036103f9003;
localparam u1_6 = 256'ha0107000a010000370387000d0027000620241a0400090037000703a60007000;
localparam u1_7 = 256'ha402f002e002d0210180d0027000700060046004a00ea001b03e3007d0364402;
localparam u1_8 = 256'ha0107000a0107003703a700090017000100032004000f0037000600094024003;
localparam u1_9 = 256'h9001f402200370000180d0307000103360046804e00e1a0260046804b03e0a02;
localparam u1_A = 256'ha010b003a010b003703a700020027000602b32004000e00370006000200000b3;
localparam u1_B = 256'h1030f402b00270210180a0007000103360046804100eea0260046804b03e1a02;
localparam u1_C = 256'ha0107000a0102003703a7000b0027000900260004000d0237000600020037000;
localparam u1_D = 256'h5000a0025000f021018050007000103360046804900e68006004680460046800;
localparam u1_E = 256'ha0107000a01010036000700010027000500060004000900370006000e0027000;
localparam u1_F = 256'h200070009002a021018050007000103360046804d00e68006004680460046800;

   /* verilator lint_off UNUSED */
   wire [15:0]   sim_a;
   wire [15:0]   sim_b;
   /* verilator lint_on UNUSED */

   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u0_0), .INIT_1(u0_1), .INIT_2(u0_2), .INIT_3(u0_3),
                   .INIT_4(u0_4), .INIT_5(u0_5), .INIT_6(u0_6), .INIT_7(u0_7),
                   .INIT_8(u0_8), .INIT_9(u0_9), .INIT_A(u0_A), .INIT_B(u0_B),
                   .INIT_C(u0_C), .INIT_D(u0_D), .INIT_E(u0_E), .INIT_F(u0_F)
                   ) ucode0
     (
      .RDATA( dd[15:0]            ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               ),
      .sim_pre_RDATA( sim_a )
      );
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u1_0), .INIT_1(u1_1), .INIT_2(u1_2), .INIT_3(u1_3),
                   .INIT_4(u1_4), .INIT_5(u1_5), .INIT_6(u1_6), .INIT_7(u1_7),
                   .INIT_8(u1_8), .INIT_9(u1_9), .INIT_A(u1_A), .INIT_B(u1_B),
                   .INIT_C(u1_C), .INIT_D(u1_D), .INIT_E(u1_E), .INIT_F(u1_F)
                   ) ucode1
     (
      .RDATA( dd[31:16]           ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               ),
      .sim_pre_RDATA( sim_b )
      );
   
   assign d[0] = dd[0];
   assign d[1] = dd[1];
   assign d[2] = dd[2];
   assign d[3] = dd[3];
   assign d[4] = dd[4];
   assign d[5] = dd[5];
   assign d[6] = dd[6];
   assign d[8] = dd[7];
   assign d[10] = dd[8];
   assign d[11] = dd[9];
   assign d[12] = dd[10];
   assign d[13] = dd[11];
   assign d[14] = dd[12];
   assign d[15] = dd[13];
   assign d[16] = dd[14];
   assign d[17] = dd[15];
   assign d[19] = dd[16];
   assign d[20] = dd[17];
   assign d[21] = dd[18];
   assign d[22] = dd[19];
   assign d[23] = dd[20];
   assign d[24] = dd[21];
   assign d[25] = dd[22];
   assign d[26] = dd[23];
   assign d[28] = dd[24];
   assign d[29] = dd[25];
   assign d[30] = dd[26];
   assign d[31] = dd[27];
   assign d[32] = dd[28];
   assign d[33] = dd[29];
   assign d[34] = dd[30];
   assign d[35] = dd[31];

   wire        oa0;
   SB_LUT4 #(.LUT_INIT(16'h1000)) cmb0( .O(oa0), .I3(minx[7]), .I2(minx[4]), .I1(minx[3]), .I0(minx[0]));
   SB_DFFE  reg0( .Q(d[27]), .C(clk), .E(progress_ucode), .D(oa0));
   wire        oa1;
   SB_LUT4 #(.LUT_INIT(16'h0e00)) cmb1( .O(oa1), .I3(minx[4]), .I2(minx[3]), .I1(minx[1]), .I0(minx[0]));
   SB_DFFE  reg1( .Q(d[18]), .C(clk), .E(progress_ucode), .D(oa1));
   wire        oa2;
   SB_LUT4 #(.LUT_INIT(16'hf7db)) cmb2( .O(oa2), .I3(minx[3]), .I2(minx[2]), .I1(minx[1]), .I0(minx[0]));
   SB_DFFE  reg2( .Q(d[9]), .C(clk), .E(progress_ucode), .D(oa2));
   wire        oa3;
   SB_LUT4 #(.LUT_INIT(16'h0400)) cmb3( .O(oa3), .I3(minx[7]), .I2(minx[3]), .I1(minx[1]), .I0(minx[0]));
   SB_DFFE  reg3( .Q(d[7]), .C(clk), .E(progress_ucode), .D(oa3));
   assign d[36] = 1'b0;
   assign d[37] = 1'b0;
   assign d[38] = 1'b0;
   assign d[39] = 1'b0;
   assign d[40] = 1'b0;
   assign d[41] = 1'b0;
   assign d[42] = 1'b0;
   assign d[43] = 1'b0;
   assign d[44] = 1'b0;
   assign d[45] = 1'b0;
   assign d[46] = 1'b0;
   assign d[47] = 1'b0;
   
endmodule
// Local Variables:
// verilog-library-directories:("."  )
// verilog-library-extensions:(".v" )
// End:
