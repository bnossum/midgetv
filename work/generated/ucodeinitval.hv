/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------
 * Automaticaly generated by ../bin/midgetv_genucode (based on ../code/ucode.h).
 * Do not edit.
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       d2 LB_2       0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       be IJ_1       0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     e6 StdIncPc   0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     e6 StdIncPc   0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 LB_3       07 LB_4       0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 07 LB_4       09 LB_5       0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 08 _L0x08     5a SB_1       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_5       8b LB_6       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 0a _L0x0a     5a SB_1       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b JALR_2     86 JAL_2      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      10 SUB_1      0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 SUB_1      8b LB_6       0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 11 AND_1      1a ANDI_1     0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 12 unx12         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 12: Not in use                                           00000000 
 * 13 condb_2    14 condb_3    0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 14 condb_3    15 condb_4    0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 15 condb_4    16 condb_5    0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 16 condb_5    de Fetch      0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 17 condb_5t   74 BrOpFet    0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 18 BEQ        13 condb_2    0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     41 JALR_1     0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a ANDI_1     e6 StdIncPc   0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 1b _L0x1b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   a6 ECAL_RET   0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d ORI_2      e6 StdIncPc   0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 1e aFault_1   d4 aFault_2   0010000000000000101011001100100110        Q = 4                                             00000000 
 * 1f IJ_2       b7 IJ_3       0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 20 LH_0       52 LH_1       0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 XORI_1     e6 StdIncPc   0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 22 MULHU_6    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000100b close to ij
 * 23 _L0x23     e6 StdIncPc   0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     35 SLLI_1     0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 OR_1       27 OR_2       0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 27 OR_2       1d ORI_2      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 28 _L0x28     96 SH_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 XOR_1      21 XORI_1     0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 2a _L0x2a     96 SH_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b SLTIX_1    30 SLTIX_2    0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 2c SLL_0      3e SLL_1      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e _LMULHU_1  fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40001033 sloppy sll     
 * 2f _L0x2f     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SLTIX_2    e6 StdIncPc   0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 31 SLTX_1     2b SLTIX_1    0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 32 JAL_1      86 JAL_2      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 33 JAERR_1    81 JAERR_2    0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 34 JAL_3      de Fetch      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 35 SLLI_1     36 SLLI_2     0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 36 SLLI_2     03 _L0x03     0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 37 ECALL_2    d7 ECALL_3    0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 38 BNE        13 condb_2    0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 MULHU_7    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00001067 close to jalr
 * 3a SRxI_1     3d SRxI_2     0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 3b _L0x3b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    49 CSRRW_1    0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d SRxI_2     03 _L0x03     0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 3e SLL_1      35 SLLI_1     0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 3f SRx_1      3a SRxI_1     0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 40 LW_0       50 LW_1       0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 JALR_1     0b JALR_2     0010000000000000000011101100100110        Q=1                                               00000000 
 * 42 MULHU_2    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000200b close to ij
 * 43 MULHU_4    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000200f close to fence
 * 44 SLTI_0     2b SLTIX_1    0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 WFI_3      65 WFI_4      0010000000000000101011101100100110        More check offset                                 00000000 
 * 46 ILL_1      47 ILL_2      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 47 ILL_2      8f ILL_3      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 48 _L0x48     66 SW_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 CSRRW_1    4b CSRRW_2    0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 4a _L0x4a     66 SW_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b CSRRW_2    b0 CSRRW_3    0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 4c SLT_0      31 SLTX_1     0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * 4e eILL0b     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40002033 sloppy slt     
 * 4f MRET_8     e6 StdIncPc   0010000000000000101011101100100110        Prep +4                                           00000000 
 * 50 LW_1       e6 StdIncPc   0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 51 LDAF_LW    da LDAF_a     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 52 LH_1       54 LH_2       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 53 LDAF_LH    da LDAF_a     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 54 LH_2       eb LH_3       0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 55 aFaultb    1e aFault_1   0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 56 LH_4       57 LH_5       0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 57 LH_5       8b LB_6       0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 58 DIV_A      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00002063 close to branch
 * 59 DIV_B      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00002067 close to jalr
 * 5a SB_1       5d SB_2       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5b _L0x5b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    49 CSRRW_1    0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SB_2       fb SB_3       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 5e LHU_1      70 LHU_2      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 5f LDAF_LHU   da LDAF_a     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 60 MULHU_3    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003003 close to load
 * 61 EBRKWFI2   f7 EBREAK_1   0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 62 DIV_8      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000300b close to ij
 * 63 DIV_9      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000300f close to fence
 * 64 SLTIU_0    2b SLTIX_1    0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 WFI_4      ef WFI_5      0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 66 SW_1       f2 SW_2       0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 67 SW_E1SWE   93 SW_E2      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 68 DIV_12     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003023 close to store
 * 69 _LDIV_13   fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 6a MULH_1     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          40003023 close to store
 * 6b SB_4       7a SB_5       1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 6c SLTU_0     31 SLTX_1     0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * 6e _LDIV_C    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003033 sloppy sltu    
 * 6f MRET_6     cf MRET_7     0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 70 LHU_2      ba LHU_3      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 71 aFaultc    1e aFault_1   0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 72 LBU_3      1a ANDI_1     0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 73 BAERR_1    76 BAERR_2    0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 74 BrOpFet    f4 Fetch2     0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 75 BAlignEr   73 BAERR_1    0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 76 BAERR_2    77 BAERR_3    0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 77 BAERR_3    7d BAERR_4    0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * 78 DIV_4      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003063 close to branch
 * 79 DIV_5      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003067 close to jalr
 * 7a SB_5       f2 SW_2       0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 7b _L0x7b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    49 CSRRW_1    0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d BAERR_4    34 JAL_3      0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 7e NMI_1      90 NMI_2      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 7f JALRE2     7d BAERR_4    0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * 80 LBU_0      85 LBU_1      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 JAERR_2    7d BAERR_4    0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 82 DIV_1      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000400b close to ij
 * 83 DIV_2      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000400f close to fence
 * 84 XORI_0     21 XORI_1     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 LBU_1      f0 LBU_2      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 86 JAL_2      34 JAL_3      0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 87 JALRE1     7f JALRE2     0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 88 DIV_E      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00004023 close to store
 * 89 _LDIV_F    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 8a DIVU_5     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math). Paired                  40004023 close to store
 * 8b LB_6       e6 StdIncPc   0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 8c XOR_0      29 XOR_1      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * 8e _LCSRRS_1  fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40004033 sloppy xor     
 * 8f ILL_3      a9 ILL_4      0010000000000000101011101100100110        Q = 1                                             00000000 
 * 90 NMI_2      34 JAL_3      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 91 LDAF_2     92 LDAF_3     0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 92 LDAF_3     34 JAL_3      0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 93 SW_E2      95 SW_E3      0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 94 SW_E4      34 JAL_3      0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 95 SW_E3      94 SW_E4      0010000000000000101111001100100110        Q = 3                                             00000000 
 * 96 SH_1       bb SH_2       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 97 SW_E1SWH   93 SW_E2      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 98 BLT        13 condb_2    0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a ECALL_6    34 JAL_3      0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 9b unx9b         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 9b: Not in use                                           00000000 
 * 9c DIV_10     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00004073 close to csr/system 
 * 9d _LDIV_11   fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 9e SH_4       9f SH_5       1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 9f SH_5       f2 SW_2       0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * a0 LHU_0      5e LHU_1      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_4    b6 ECALL_5    0010000000000000101011001100100110        Q = 4                                             00000000 
 * a2 DIV_14     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000500b close to ij
 * a3 _LDIV_15   fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000500f close to fence
 * a4 SRxI_0     3a SRxI_1     0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_3     af MRET_4     0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * a6 ECAL_RET   d0 ECALL_1    0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * a7 EBRKWFI1   61 EBRKWFI2   0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * a8 DIV_3      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00005023 close to store
 * a9 ILL_4      34 JAL_3      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * aa DIV_6      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          40005023 close to store
 * ab EBREAK_2   9a ECALL_6    0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * ac _L0xac     3f SRx_1      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * ae _L0xae     3f SRx_1      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_4     c5 MRET_5     0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b0 CSRRW_3    b2 CSRRW_4    0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b1 aF_SW_3    92 LDAF_3     0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * b2 CSRRW_4    de Fetch      0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b3 unxb3         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx b3: Not in use                                           00000000 
 * b4 eFetch3       (use dinx) 000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * b5 SH_3       9e SH_4       0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b6 ECALL_5    9a ECALL_6    0010000000000000101011001100100110        Q = 8                                             00000000 
 * b7 IJ_3       bd IJ_4       0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b8 BGE        13 condb_2    0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 DIV_e      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00005067 close to jalr
 * ba LHU_3      1a ANDI_1     0010000000000000011111101100010xx0        Invert q. Prepare read mask                       00000000 
 * bb SH_2       b5 SH_3       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * bc CSRRWI_0   49 CSRRW_1    0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd IJ_4       de Fetch      0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * be IJ_1       1f IJ_2       0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * bf IJT_1      c1 IJT_2      0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * c0 DIV_D      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00006003 close to load
 * c1 IJT_2      e9 IJT_3      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c2 DIVU_3     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000600b close to ij
 * c3 DIVU_4     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000600f close to fence
 * c4 ORI_0      e1 ORI_1      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_5     6f MRET_6     0010000000000000000011101100010xx0        ~302                                              00000000 
 * c6 IJT_4      47 ILL_2      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * c7 QINT_1     cb QINT_2     0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * c8 DIV_7      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00006023 close to store
 * c9 MRET_2     a5 MRET_3     0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * ca DIVU_2     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          40006023 close to store
 * cb QINT_2     e6 StdIncPc   0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * cc OR_0       26 OR_1       0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * ce _LCSRRCI_1 fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006033 sloppy or      
 * cf MRET_7     4f MRET_8     0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * d0 ECALL_1    37 ECALL_2    0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * d1 MRET_1     c9 MRET_2     0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * d2 LB_2       06 LB_3       0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * d3 aFaultd    1e aFault_1   0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * d4 aFault_2   92 LDAF_3     0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * d5 unxd5         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx d5: Not in use                                           00000000 
 * d6 eILL0c     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d7 ECALL_3    a1 ECALL_4    0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * d8 BLTU       13 condb_2    0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MULH_3     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00006067 close to jalr
 * da LDAF_a     91 LDAF_2     0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * db jFault_1   92 LDAF_3     0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * dc CSRRSI_0   49 CSRRW_1    0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd aF_SW_1    e5 aF_SW_2    0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * de Fetch      f4 Fetch2     0001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * df eFetch     f4 Fetch2     0001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * e0 DIVU_1     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00007003 close to load
 * e1 ORI_1      1d ORI_2      0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * e2 MUL_1      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000700b close to ij
 * e3 MUL_3      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000700f close to fence
 * e4 ANDI_0     1a ANDI_1     0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 aF_SW_2    b1 aF_SW_3    0010000000000000101011001100100110        Q = 4                                             00000000 
 * e6 StdIncPc   de Fetch      0100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * e7 aFault     1e aFault_1   0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * e8 MUL_2      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00007023 close to store
 * e9 IJT_3      c6 IJT_4      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ea _LMULHU_5  fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40007023 close to store
 * eb LH_3       56 LH_4       0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * ec AND_0      11 AND_1      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * ee eILL0a     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40007033 sloppy and     
 * ef WFI_5      de Fetch      0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * f0 LBU_2      72 LBU_3      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * f1 aFaulte    1e aFault_1   0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * f2 SW_2       e6 StdIncPc   0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * f3 aF_SW      dd aF_SW_1    0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * f4 Fetch2     b4 eFetch3    0000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f5 jFault     db jFault_1   0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * f6 WFI_1      fa WFI_2      0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * f7 EBREAK_1   ab EBREAK_2   0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * f8 BGEU       13 condb_2    0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 MULH_2     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00007067 close to jalr
 * fa WFI_2      45 WFI_3      0010000000000000101011101100100110        Check offset                                      00000000 
 * fb SB_3       6b SB_4       0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fc CSRRCI_0   49 CSRRW_1    0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      7e NMI_1      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       46 ILL_1      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     c7 QINT_1     0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 
 */
/* Col   x   1   0
 *  41   4   4 248 Can not simplify, can't possibly represent between 4 and 8 high values with only 4 bits index
 *  40   4  17 235 Can not simplify, can't possibly represent between 17 and 21 high values with only 4 bits index
 *  39   4 151 101 Can not simplify, can't possibly represent between 151 and 155 high values with only 4 bits index
 *  38   4   4 248 Can not simplify, can't possibly represent between 4 and 8 high values with only 4 bits index
 *  37   4  10 242 Can not simplify, can't possibly represent between 10 and 14 high values with only 4 bits index
 *  36   4  10 242 Can not simplify, can't possibly represent between 10 and 14 high values with only 4 bits index
 *  35   4   7 245 Can not simplify, can't possibly represent between 7 and 11 high values with only 4 bits index
 *  34   4   8 244 Can not simplify, can't possibly represent between 8 and 12 high values with only 4 bits index
 *  33   4  16 236 Can not simplify, no legal mapping
 *  32   5  10 241 Can not simplify, can't possibly represent between 10 and 15 high values with only 4 bits index
 *  31   5  16 235 Can not simplify, can't represent fixed locations with any less than 7 bits of the index
 *  30   4   1 251 Can not simplify, can't possibly represent between 1 and 5 high values with only 4 bits index
 *  29   4  81 171 Can not simplify, can't possibly represent between 81 and 85 high values with only 4 bits index
 *  28   4  77 175 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  27   4  40 212 Can not simplify, can't possibly represent between 40 and 44 high values with only 4 bits index
 *  26   4  37 215 Can not simplify, can't possibly represent between 37 and 41 high values with only 4 bits index
 *  25  64 127  65 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  24  64  82 110 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  23  64 148  44 Can not simplify, can't represent fixed locations with any less than 6 bits of the index
 *  22  64  60 132 Can not simplify, can't represent fixed locations with any less than 7 bits of the index
 *  21   4 236  16 Can not simplify, can't represent fixed locations with any less than 5 bits of the index
 *  20   4 240  12 Can not simplify, can't represent fixed locations with any less than 7 bits of the index
 *  19  78 160  18 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  18   4   1 251 Can not simplify, can't possibly represent between 1 and 5 high values with only 4 bits index
 *  17   4 151 101 Can not simplify, can't possibly represent between 151 and 155 high values with only 4 bits index
 *  16  83 102  71 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  15   4   3 249 Can not simplify, can't possibly represent between 3 and 7 high values with only 4 bits index
 *  14   4   5 247 Can not simplify, can't possibly represent between 5 and 9 high values with only 4 bits index
 *  13  78 109  69 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  12  78  67 111 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  11  78  53 125 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  10 147  31  78 
 * Candidate function 4200, used ffff, inputs 1b
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       57 LH_5       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 MRET_5     a6 ECAL_RET   0010000000000000000011101100010xx0        ~302                                              00000000 
 * 02 IJ_0       ffffffff (null)     0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     7e NMI_1      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     7e NMI_1      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 JAL_1      69 _LDIV_13   0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 07 JAERR_1    6b SB_4       0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 08 _L0x08     b4 eFetch3    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 ORI_2      ffffffff (null)     0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 0a _L0x0a     b4 eFetch3    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b IJ_2       3e SLL_1      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     7e NMI_1      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      72 LBU_3      0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     7e NMI_1      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 eILL0b     ffffffff (null)     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 11 MRET_8     77 BAERR_3    0010000000000000101011101100100110        Prep +4                                           00000000 
 * 12 IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 13 IJT_1      1a ANDI_1     0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 14 eILL0a     76 BAERR_2    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 15 WFI_5      1e aFault_1   0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 16 SW_2       ce _LCSRRCI_1 0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 17 aF_SW      ee eILL0a     0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 18 BEQ        74 BrOpFet    0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     51 LDAF_LW    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a condb_3    7e NMI_1      0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 1b _L0x1b     06 LB_3       0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   8e _LCSRRS_1  0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d OR_2       7e NMI_1      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 1e condb_5    de Fetch      0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 1f condb_5t   3d SRxI_2     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 20 LH_0       46 ILL_1      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 IJT_4      7e NMI_1      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 22 MULHU_6    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000100b close to ij
 * 23 _L0x23     7e NMI_1      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     96 SH_1       0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LW_1       1d ORI_2      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LW    09 LB_5       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     8a DIVU_5     0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 SLTIX_2    7d BAERR_4    0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 2a _L0x2a     8a DIVU_5     0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b SLLI_2     29 XOR_1      0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 2c SLL_0      a3 _LDIV_15   0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     7e NMI_1      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e SB_2       fe ILLe       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   40001033 sloppy sll     
 * 2f _L0x2f     7e NMI_1      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 eILL0b     7e NMI_1      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 31 MRET_8     3a SRxI_1     0010000000000000101011101100100110        Prep +4                                           00000000 
 * 32 NMI_2      3e SLL_1      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 33 SW_E4      d7 ECALL_3    0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 34 ECALL_6    ce _LCSRRCI_1 0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 35 aFault_1   2b SLTIX_1    0010000000000000101011001100100110        Q = 4                                             00000000 
 * 36 aF_SW_3    03 _L0x03     0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 37 SH_3       c7 QINT_1     0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * 38 BNE        74 BrOpFet    0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 MULHU_7    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00001067 close to jalr
 * 3a SLTIX_1    9f SH_5       0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 3b _L0x3b     06 LB_3       0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    5a SB_1       0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d IJ_3       03 _L0x03     0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 3e JAL_2      96 SH_1       0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 3f JALRE1     9d _LDIV_11   0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 40 LW_0       26 OR_1       0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 QINT_1     70 LHU_2      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 42 MULHU_2    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000200b close to ij
 * 43 DIVU_1     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000200f close to fence
 * 44 SLTI_0     3a SRxI_1     0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 _LCSRRCI_1 b7 IJ_3       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 46 LH_1       af MRET_4     0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 47 LDAF_LH    7a SB_5       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 48 _L0x48     6e _LDIV_C    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 SH_2       b0 CSRRW_3    0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 4a _L0x4a     6e _LDIV_C    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b IJT_2      be IJ_1       0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * 4c SLT_0      93 SW_E2      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * 4e LH_2       fe ILLe       0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40002033 sloppy slt     
 * 4f aFaultb    7e NMI_1      0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 50 MRET_2     7e NMI_1      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * 51 JALR_1     65 WFI_4      0010000000000000000011101100100110        Q=1                                               00000000 
 * 52 QINT_2     4e eILL0b     0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 53 aF_SW_1    65 WFI_4      0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 54 IJT_3      a1 ECALL_4    0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 55 WFI_3      35 SLLI_1     0010000000000000101011101100100110        More check offset                                 00000000 
 * 56 SB_3       b3 unxb3      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * 57 LB_1       ffffffff (null)     0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 58 MULHU_4    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00002063 close to branch
 * 59 DIV_A      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00002067 close to jalr
 * 5a CSRRW_1    2e _LMULHU_1  0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 5b _L0x5b     06 LB_3       0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    5a SB_1       0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d LB_3       56 LH_4       0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 5e ECALL_1    86 JAL_2      0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 5f MRET_1     65 WFI_4      0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 60 DIV_B      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003003 close to load
 * 61 MRET_7     9b unx9b      0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * 62 MULHU_3    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000300b close to ij
 * 63 MUL_1      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000300f close to fence
 * 64 SLTIU_0    3a SRxI_1     0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 LDAF_a     15 condb_4    0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * 66 LHU_1      16 condb_5    0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 67 LDAF_LHU   f0 LBU_2      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 68 DIV_8      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003023 close to store
 * 69 LB_4       fe ILLe       0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 6a DIV_9      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          40003023 close to store
 * 6b LB_5       d2 LB_2       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 6c SLTU_0     93 SW_E2      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * 6e SW_1       fe ILLe       0000000000000011111011100100001xx0        Write d to a+k until accepted                     40003033 sloppy sltu    
 * 6f SW_E1SWE   61 EBRKWFI2   0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 70 JALR_2     ffffffff (null)     0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 71 MRET_6     35 SLLI_1     0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 72 SUB_1      77 BAERR_3    0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 73 AND_1      d0 ECALL_1    0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 74 condb_2    ea _LMULHU_5  0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 75 BAERR_3    cb QINT_2     0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * 76 condb_4    75 BAlignEr   0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 77 ANDI_1     d3 aFaultd    0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 78 DIV_12     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003063 close to branch
 * 79 MULH_1     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003067 close to jalr
 * 7a ILL_3      16 condb_5    0010000000000000101011101100100110        Q = 1                                             00000000 
 * 7b _L0x7b     06 LB_3       0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    5a SB_1       0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d XORI_1     94 SW_E4      0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 7e StdIncPc   32 JAL_1      0100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 7f aFault     d3 aFaultd    0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 80 LBU_0      db jFault_1   0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 ORI_1      d3 aFaultd    0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 82 DIV_4      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000400b close to ij
 * 83 MUL_3      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000400f close to fence
 * 84 XORI_0     7d BAERR_4    0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 _LMULHU_5  e6 StdIncPc   0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 86 LHU_2      94 SW_E4      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 87 aFaultc    d6 eILL0c     0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 88 DIV_5      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00004023 close to store
 * 89 OR_1       fe ILLe       0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 8a SH_1       fe ILLe       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        40004023 close to store
 * 8b SW_E1SWH   7e NMI_1      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 8c XOR_0      90 NMI_2      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * 8e ECAL_RET   fe ILLe       0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40004033 sloppy xor     
 * 8f EBRKWFI1   b5 SH_3       0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 90 XOR_1      94 SW_E4      0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 91 LDAF_2     e9 IJT_3      0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 92 _LMULHU_1  94 SW_E4      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 93 SLTX_1     95 SW_E3      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 94 JAL_3      94 SW_E4      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 95 SW_E3      33 JAERR_1    0010000000000000101111001100100110        Q = 3                                             00000000 
 * 96 SLLI_1     49 CSRRW_1    0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 97 ECALL_2    f0 LBU_2      0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 98 BLT        74 BrOpFet    0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 DIV_1      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00004067 close to jalr
 * 9a WFI_1      94 SW_E4      0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 9b EBREAK_1      (use dinx) 0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 9c DIV_2      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00004073 close to csr/system 
 * 9d SRxI_1     fe ILLe       0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 9e ECALL_4    f4 Fetch2     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 9f SRxI_2     16 condb_5    0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * a0 LHU_0      66 SW_1       0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 LH_3       da LDAF_a     0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * a2 DIV_E      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000500b close to ij
 * a3 SLL_1      fe ILLe       0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              0000500f close to fence
 * a4 SRxI_0     9d _LDIV_11   0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 (null)     ba LHU_3      00x000000000000000xxxx00x00xx00000 QINT_0                                                   00000000 
 * a6 LB_2       5e LHU_1      0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * a7 aFaultd    b6 ECALL_5    0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * a8 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00005023 close to store
 * a9 SRx_1      94 SW_E4      0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * aa DIV_10     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          40005023 close to store
 * ab ILL_1      34 JAL_3      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * ac _L0xac     a9 ILL_4      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * ae _L0xae     a9 ILL_4      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af ILL_2      01 LB_1       0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * b0 CSRRW_2    d1 MRET_1     0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * b1 MRET_3     e9 IJT_3      0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * b2 LH_4       ce _LCSRRCI_1 0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * b3 LH_5          (use dinx) 0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * b4 SB_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * b5 ILL_4      f3 aF_SW      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * b6 EBRKWFI2   34 JAL_3      0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * b7 WFI_4      fb SB_3       0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * b8 BGE        74 BrOpFet    0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 DIV_14     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00005067 close to jalr
 * ba MRET_4     77 BAERR_3    0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * bb _LDIV_13   37 ECALL_2    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bc CSRRWI_0   5a SB_1       0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SB_4       ce _LCSRRCI_1 1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * be CSRRW_3    0b JALR_2     0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * bf _LDIV_C    4b CSRRW_2    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * c0 DIV_3      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00006003 close to load
 * c1 (null)     54 LH_2       00x000000000000000xxxx00x00xx00000 QINT_0                                                   00000000 
 * c2 DIV_6      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000600b close to ij
 * c3 MUL_2      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000600f close to fence
 * c4 ORI_0      81 JAERR_2    0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     71 aFaultc    00x000000000000000xxxx00x00xx00000 QINT_0                                                   00000000 
 * c6 eILL0c     af MRET_4     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * c7 ECALL_3    52 LH_1       0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * c8 DIV_e      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00006023 close to store
 * c9 LBU_3      b1 aF_SW_3    0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * ca DIV_D      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          40006023 close to store
 * cb BAERR_1    7e NMI_1      0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * cc OR_0       89 _LDIV_F    0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * ce Fetch      fe ILLe       0001001010001000101111101010110000  Fr11  Read and latch instruction                        40006033 sloppy or      
 * cf eFetch     31 SLTX_1     0001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * d0 BAERR_2    97 SW_E1SWH   0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * d1 CSRRW_4    50 LW_1       0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d2 SB_5       5d SB_2       0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * d3 BAERR_4    35 SLLI_1     0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * d4 NMI_1      e9 IJT_3      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * d5 eFetch3       (use dinx) 000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * d6 JALRE2     fe ILLe       0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * d7 JAERR_2    9e SH_4       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * d8 BLTU       74 BrOpFet    0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 DIVU_3     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00006067 close to jalr
 * da ECALL_5    91 LDAF_2     0010000000000000101011001100100110        Q = 8                                             00000000 
 * db LBU_1      e9 IJT_3      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * dc CSRRSI_0   5a SB_1       0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd _LDIV_F    f5 jFault     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * de aFault_2   ea _LMULHU_5  0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * df _LCSRRS_1  ea _LMULHU_5  0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * e0 DIVU_4     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00007003 close to load
 * e1 (null)     09 LB_5       00x000000000000000xxxx00x00xx00000 QINT_0                                                   00000000 
 * e2 DIV_7      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000700b close to ij
 * e3 MULH_2     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000700f close to fence
 * e4 ANDI_0     77 BAERR_3    0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     36 SLLI_2     00x000000000000000xxxx00x00xx00000 QINT_0                                                   00000000 
 * e6 LBU_2      ce _LCSRRCI_1 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * e7 aFaulte    35 SLLI_1     0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * e8 DIVU_2     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00007023 close to store
 * e9 LDAF_3     21 XORI_1     0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * ea Fetch2     fe ILLe       0000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     40007023 close to store
 * eb jFault     b2 CSRRW_4    0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * ec AND_0      73 BAERR_1    0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * ee BrOpFet    fe ILLe       0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    40007033 sloppy and     
 * ef BAlignEr   ce _LCSRRCI_1 0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * f0 SW_E2      c9 MRET_2     0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * f1 jFault_1   35 SLLI_1     0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * f2 _LDIV_11   7e NMI_1      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f3 SH_4       53 LDAF_LH    1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * f4 SH_5       d5 unxd5      0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * f5 aF_SW_2    f1 aFaulte    0010000000000000101011001100100110        Q = 4                                             00000000 
 * f6 _LDIV_15   fa WFI_2      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f7 EBREAK_2   f7 EBREAK_1   0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * f8 BGEU       74 BrOpFet    0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 MULH_3     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00007067 close to jalr
 * fa WFI_2      55 aFaultb    0010000000000000101011101100100110        Check offset                                      00000000 
 * fb IJ_4       bd IJ_4       0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * fc CSRRCI_0   5a SB_1       0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      d4 aFault_2   0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       ab EBREAK_2   0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     41 JALR_1     0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 2010, used ffff, inputs 39
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       5d SB_2       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 ORI_2      7e NMI_1      0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 02 IJ_0       a6 ECAL_RET   0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     16 condb_5    0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     16 condb_5    0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 JAL_1      65 WFI_4      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 07 JAERR_1    69 _LDIV_13   0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 08 _L0x08     b4 eFetch3    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 IJ_2       ffffffff (null)     0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 0a _L0x0a     b4 eFetch3    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b OR_2       12 unx12      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     16 condb_5    0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      70 LHU_2      0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     16 condb_5    0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 condb_5    ffffffff (null)     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 11 condb_5t   7a SB_5       0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 12 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 13 JALRE1     37 ECALL_2    0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 14 ECALL_1    76 BAERR_2    0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 15 MRET_1     52 LH_1       0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 16 StdIncPc   8a DIVU_5     0100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 17 aFault     9e SH_4       0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 18 BEQ        74 BrOpFet    0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     71 aFaultc    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a SLTIX_2    16 condb_5    0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 1b _L0x1b     06 LB_3       0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   6e _LDIV_C    0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d SLLI_2     16 condb_5    0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 1e LW_1       f1 aFaulte    0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 1f LDAF_LW    3d SRxI_2     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 20 LH_0       26 OR_1       0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SB_2       16 condb_5    0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 22 MULHU_6    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000100b close to ij
 * 23 _L0x23     16 condb_5    0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     95 SW_E3      0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LH_1       0b JALR_2     0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LH    01 LB_1       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 NMI_2      7d BAERR_4    0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 2a _L0x2a     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b SW_E4      1a ANDI_1     0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 2c SLL_0      a3 _LDIV_15   0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     16 condb_5    0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e ECALL_6    fe ILLe       0000110000001110100111000x00100000        mcause = 11                                       40001033 sloppy sll     
 * 2f _L0x2f     16 condb_5    0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 eILL0b     16 condb_5    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 31 MRET_8     56 LH_4       0010000000000000101011101100100110        Prep +4                                           00000000 
 * 32 eILL0a     12 unx12      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 33 WFI_5      d1 MRET_1     0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 34 eILL0b     8a DIVU_5     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 35 MRET_8     1d ORI_2      0010000000000000101011101100100110        Prep +4                                           00000000 
 * 36 aF_SW_3    03 _L0x03     0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 37 condb_3    87 JALRE1     0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 38 BNE        74 BrOpFet    0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 MULHU_7    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00001067 close to jalr
 * 3a SH_3       a1 ECALL_4    0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * 3b _L0x3b     06 LB_3       0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    75 BAlignEr   0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d IJ_3       03 _L0x03     0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 3e LH_2       95 SW_E3      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultb    9d _LDIV_11   0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 40 LW_0       1e aFault_1   0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 SH_2       6b SB_4       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 42 MULHU_2    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000200b close to ij
 * 43 DIVU_1     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000200f close to fence
 * 44 SLTI_0     56 LH_4       0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJT_2      bd IJ_4       0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * 46 LHU_1      ab EBREAK_2   0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 47 LDAF_LHU   92 LDAF_3     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 48 _L0x48     4e eILL0b     1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 MRET_2     af MRET_4     0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * 4a _L0x4a     4e eILL0b     1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b QINT_2     d0 ECALL_1    0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 4c SLT_0      91 LDAF_2     0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * 4e SW_1       fe ILLe       0000000000000011111011100100001xx0        Write d to a+k until accepted                     40002033 sloppy slt     
 * 4f SW_E1SWE   16 condb_5    0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 50 WFI_1      16 condb_5    0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 51 EBREAK_1   ef WFI_5      0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 52 condb_5    3e SLL_1      0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 53 condb_5t   ef WFI_5      0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 54 aFault_1   f4 Fetch2     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 55 aF_SW_1    54 LH_2       0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 56 SLTIX_1    b2 CSRRW_4    0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 57 IJT_3      ffffffff (null)     0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 58 MULHU_4    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00002063 close to branch
 * 59 DIV_A      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00002067 close to jalr
 * 5a SB_3       21 XORI_1     0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * 5b _L0x5b     06 LB_3       0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    75 BAlignEr   0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d LB_1       5a SB_1       0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 5e LHU_2      5e LHU_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaultc    ef WFI_5      0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 60 DIV_B      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003003 close to load
 * 61 LB_3       51 LDAF_LW    0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 62 MULHU_3    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000300b close to ij
 * 63 MUL_2      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000300f close to fence
 * 64 SLTIU_0    56 LH_4       0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 LB_4       33 JAERR_1    0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 66 SH_1       ba LHU_3      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 67 SW_E1SWH   db jFault_1   0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 68 DIV_8      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003023 close to store
 * 69 LB_5       fe ILLe       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 6a DIV_9      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          40003023 close to store
 * 6b JALR_2     c9 MRET_2     0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 6c SLTU_0     91 LDAF_2     0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * 6e ECAL_RET   fe ILLe       0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40003033 sloppy sltu    
 * 6f EBRKWFI1   ee eILL0a     0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 70 SUB_1      ffffffff (null)     0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 71 JALR_1     54 LH_2       0010000000000000000011101100100110        Q=1                                               00000000 
 * 72 AND_1      7a SB_5       0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 73 WFI_3      c7 QINT_1     0010000000000000101011101100100110        More check offset                                 00000000 
 * 74 condb_2    9a ECALL_6    0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 75 CSRRW_1    c6 IJT_4      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 76 condb_4    90 NMI_2      0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 77 MRET_6     cb QINT_2     0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 78 DIV_12     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003063 close to branch
 * 79 MULH_1     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003067 close to jalr
 * 7a ANDI_1     ba LHU_3      0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 7b _L0x7b     06 LB_3       0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    75 BAlignEr   0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d XORI_1     93 SW_E2      0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 7e LB_2       29 XOR_1      0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 7f aFaultd    cb QINT_2     0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 80 LBU_0      d3 aFaultd    0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 OR_1       cb QINT_2     0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 82 DIV_4      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000400b close to ij
 * 83 MUL_1      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000400f close to fence
 * 84 XORI_0     7d BAERR_4    0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 XOR_1      8e _LCSRRS_1  0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 86 eILL0c     93 SW_E2      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 87 ECALL_3    cf MRET_7     0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 88 DIV_5      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00004023 close to store
 * 89 _LMULHU_1  fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 8a Fetch      fe ILLe       0001001010001000101111101010110000  Fr11  Read and latch instruction                        40004023 close to store
 * 8b eFetch     16 condb_5    0001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 8c XOR_0      85 LBU_1      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * 8e LBU_2      fe ILLe       0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40004033 sloppy xor     
 * 8f aFaulte    b5 SH_3       0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 90 BAERR_3    93 SW_E2      0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * 91 SLTX_1     da LDAF_a     0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 92 ILL_3      93 SW_E2      0010000000000000101011101100100110        Q = 1                                             00000000 
 * 93 JAL_3      96 SH_1       0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 94 LDAF_2     93 SW_E2      0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 95 SLLI_1     2b SLTIX_1    0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 96 SW_E3      41 JALR_1     0010000000000000101111001100100110        Q = 3                                             00000000 
 * 97 ECALL_2    db jFault_1   0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 98 BLT        74 BrOpFet    0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 DIV_1      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00004067 close to jalr
 * 9a Fetch2     93 SW_E2      0000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 9b jFault        (use dinx) 0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 9c DIV_2      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00004073 close to csr/system 
 * 9d SRxI_1     fe ILLe       0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 9e BrOpFet    df eFetch     0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 9f BAlignEr   ba LHU_3      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * a0 LHU_0      46 ILL_1      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SRxI_2     d6 eILL0c     0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * a2 DIV_E      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000500b close to ij
 * a3 SLL_1      fe ILLe       0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              0000500f close to fence
 * a4 SRxI_0     9d _LDIV_11   0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SRx_1      b7 IJ_3       0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * a6 IJ_1       14 condb_3    0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * a7 IJT_1      b6 ECALL_5    0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * a8 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00005023 close to store
 * a9 ILL_1      93 SW_E2      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * aa DIV_10     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          40005023 close to store
 * ab ILL_2      2e _LMULHU_1  0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * ac _L0xac     a5 MRET_3     0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * ae _L0xae     a5 MRET_3     0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af CSRRW_2    e7 aFault     0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * b0 LH_4       d2 LB_2       0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * b1 ECALL_4    da LDAF_a     0010000000000000101011001100100110        Q = 4                                             00000000 
 * b2 LH_5       8a DIVU_5     0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * b3 MRET_3        (use dinx) 0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * b4 SB_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * b5 ILL_4      de Fetch      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * b6 EBRKWFI2   2e _LMULHU_1  0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * b7 MRET_4     e6 StdIncPc   0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b8 BGE        74 BrOpFet    0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 DIV_14     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00005067 close to jalr
 * ba SW_2       7a SB_5       0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * bb aF_SW      3a SRxI_1     0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * bc CSRRWI_0   75 BAlignEr   0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd WFI_4      8a DIVU_5     0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * be _LDIV_13   09 LB_5       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bf SB_4       45 WFI_3      1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * c0 DIV_3      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00006003 close to load
 * c1 _LDIV_C    57 LH_5       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * c2 DIV_6      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000600b close to ij
 * c3 MUL_3      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000600f close to fence
 * c4 ORI_0      f0 LBU_2      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 LBU_3      77 BAERR_3    0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * c6 BAERR_1    ab EBREAK_2   0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * c7 BAERR_2    4b CSRRW_2    0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * c8 DIV_e      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00006023 close to store
 * c9 SB_5       b3 unxb3      0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * ca DIV_D      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          40006023 close to store
 * cb BAERR_4    16 condb_5    0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * cc OR_0       81 JAERR_2    0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * ce NMI_1      fe ILLe       0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40006033 sloppy or      
 * cf JALRE2     35 SLLI_1     0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * d0 CSRRW_3    97 SW_E1SWH   0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * d1 JAERR_2    49 CSRRW_1    0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * d2 CSRRW_4    61 EBRKWFI2   0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d3 LBU_1      54 LH_2       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * d4 eFetch3    da LDAF_a     000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * d5 _LDIV_F       (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d6 ECALL_5    fe ILLe       0010000000000000101011001100100110        Q = 8                                             00000000 
 * d7 _LCSRRS_1  b1 aF_SW_3    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d8 BLTU       74 BrOpFet    0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 DIVU_3     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00006067 close to jalr
 * da LDAF_3     94 SW_E4      0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * db SW_E2      da LDAF_a     0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * dc CSRRSI_0   75 BAlignEr   0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd _LDIV_11   f5 jFault     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * de SH_4       9a ECALL_6    1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * df SH_5       9a ECALL_6    0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * e0 DIVU_4     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00007003 close to load
 * e1 _LDIV_15   01 LB_1       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * e2 DIV_7      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000700b close to ij
 * e3 MULH_2     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000700f close to fence
 * e4 ANDI_0     7a SB_5       0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 EBREAK_2   36 SLLI_2     0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * e6 IJ_4       8a DIVU_5     0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * e7 MRET_5     54 LH_2       0010000000000000000011101100010xx0        ~302                                              00000000 
 * e8 DIVU_2     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00007023 close to store
 * e9 IJT_4      e9 IJT_3      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * ea QINT_1     fe ILLe       0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40007023 close to store
 * eb _LCSRRCI_1 b0 CSRRW_3    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * ec AND_0      72 LBU_3      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * ee MRET_7     fe ILLe       0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               40007033 sloppy and     
 * ef LDAF_a     8a DIVU_5     0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * f0 ORI_1      c5 MRET_5     0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * f1 aFault_2   54 LH_2       0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * f2 _LMULHU_5  16 condb_5    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f3 jFault_1   55 aFaultb    0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * f4 LH_3       d4 aFault_2   0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f5 aF_SW_2    f3 aF_SW      0010000000000000101011001100100110        Q = 4                                             00000000 
 * f6 (null)     f7 EBREAK_1   00x000000000000000xxxx00x00xx00000 QINT_0                                                   00000000 
 * f7 WFI_2      e5 aF_SW_2    0010000000000000101011101100100110        Check offset                                      00000000 
 * f8 BGEU       74 BrOpFet    0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 MULH_3     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00007067 close to jalr
 * fa (null)     73 BAERR_1    00x000000000000000xxxx00x00xx00000 QINT_0                                                   00000000 
 * fb (null)     bf IJT_1      00x000000000000000xxxx00x00xx00000 QINT_0                                                   00000000 
 * fc CSRRCI_0   75 BAlignEr   0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      ce _LCSRRCI_1 0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       a9 ILL_4      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     ea _LMULHU_5  0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 8408, used ffff, inputs 4d
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       4e eILL0b     0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 ORI_2      72 LBU_3      0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 02 IJ_0       9e SH_4       0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     66 SW_1       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     66 SW_1       0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 eILL0b     5e LHU_1      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 07 MRET_8     61 EBRKWFI2   0010000000000000101011101100100110        Prep +4                                           00000000 
 * 08 _L0x08     bb SH_2       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 IJ_2       ffffffff (null)     0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 0a _L0x0a     bb SH_2       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b OR_2       54 LH_2       0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     66 SW_1       0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      69 _LDIV_13   0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     66 SW_1       0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      ffffffff (null)     0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    7e NMI_1      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 LW_1          (use dinx) 0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 13 LDAF_LW    17 condb_5t   0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 14 eILL0a     7a SB_5       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 15 WFI_5      76 BAERR_2    0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 16 SLTIX_2    8e _LCSRRS_1  0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 17 condb_3    9a ECALL_6    0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 18 BEQ        6e _LDIV_C    0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     37 ECALL_2    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a SLLI_2     66 SW_1       0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   70 LHU_2      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d SB_2       66 SW_1       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 1e LH_1       5d SB_2       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 1f LDAF_LH    34 JAL_3      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 20 LH_0       1e aFault_1   0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 NMI_2      66 SW_1       0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 22 MULHU_6    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000100b close to ij
 * 23 _L0x23     66 SW_1       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     a1 ECALL_4    0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 SW_E4      0b JALR_2     0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 27 aFault_1   01 LB_1       0010000000000000101011001100100110        Q = 4                                             00000000 
 * 28 _L0x28     52 LH_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 ECALL_6    81 JAERR_2    0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 2a _L0x2a     52 LH_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b aF_SW_3    16 condb_5    0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 2c SLL_0      ab EBREAK_2   0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     66 SW_1       0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e SH_3       fe ILLe       0010000000000000000011101000110000        Prepare get back address to use                   40001033 sloppy sll     
 * 2f _L0x2f     66 SW_1       0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_2       66 SW_1       0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 31 aFaultb    35 SLLI_1     0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 32 LHU_1      54 LH_2       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 33 LDAF_LHU   d3 aFaultd    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 34 IJ_3       8e _LCSRRS_1  0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 35 SLTIX_1    1a ANDI_1     0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 36 SH_2       03 _L0x03     0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 37 JALR_1     8b LB_6       0010000000000000000011101100100110        Q=1                                               00000000 
 * 38 BNE        6e _LDIV_C    0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 MULHU_7    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00001067 close to jalr
 * 3a IJT_2      a9 ILL_4      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    87 JALRE1     0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d MRET_2     03 _L0x03     0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * 3e SW_1       a1 ECALL_4    0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 3f SW_E1SWE   a6 ECAL_RET   0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 40 LW_0       12 unx12      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 QINT_2     65 WFI_4      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 42 MULHU_2    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000200b close to ij
 * 43 DIVU_1     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000200f close to fence
 * 44 SLTI_0     35 SLLI_1     0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 aF_SW_1    be IJ_1       0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 46 condb_5    b3 unxb3      0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 47 condb_5t   a5 MRET_3     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 48 _L0x48     3e SLL_1      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 IJT_3      b4 eFetch3    0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 4a _L0x4a     3e SLL_1      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b SB_3       e6 StdIncPc   0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * 4c SLT_0      96 SH_1       0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * 4e LB_1       fe ILLe       0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  40002033 sloppy slt     
 * 4f ECALL_5    66 SW_1       0010000000000000101011001100100110        Q = 8                                             00000000 
 * 50 LHU_2      66 SW_1       0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 51 aFaultc    f5 jFault     0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 52 SH_1       30 SLTIX_2    0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 53 SW_E1SWH   f5 jFault     0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 54 JAL_2      fb SB_3       0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 55 JALRE1     27 OR_2       0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 56 ECALL_1    ba LHU_3      0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 57 MRET_1     ffffffff (null)     0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 58 MULHU_4    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00002063 close to branch
 * 59 DIV_A      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00002067 close to jalr
 * 5a LB_3       1d ORI_2      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    87 JALRE1     0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d aFault_2   4b CSRRW_2    0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 5e LB_4       50 LW_1       0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 5f jFault_1   f5 jFault     0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 60 DIV_B      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003003 close to load
 * 61 LB_5       75 BAlignEr   0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 62 MULHU_3    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000300b close to ij
 * 63 MUL_1      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000300f close to fence
 * 64 SLTIU_0    35 SLLI_1     0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 JALR_2     15 condb_4    0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 66 StdIncPc   b0 CSRRW_3    0100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 67 aFault     de Fetch      0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 68 DIV_8      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003023 close to store
 * 69 SUB_1      fe ILLe       0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 6a DIV_9      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          40003023 close to store
 * 6b AND_1      ce _LCSRRCI_1 0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 6c SLTU_0     96 SH_1       0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * 6e condb_2    fe ILLe       0010000000000000111111101100000xx0        ~RS2 in Q                                         40003033 sloppy sltu    
 * 6f aF_SW_2    f3 aF_SW      0010000000000000101011001100100110        Q = 4                                             00000000 
 * 70 ECAL_RET   ffffffff (null)     0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 71 EBRKWFI1   27 OR_2       0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 72 LB_2       7e NMI_1      0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 73 aFaultd    cb QINT_2     0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 74 WFI_1      92 LDAF_3     0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 75 EBREAK_1   c9 MRET_2     0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 76 condb_5    97 SW_E1SWH   0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 77 condb_5t   d0 ECALL_1    0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 78 DIV_12     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003063 close to branch
 * 79 MULH_1     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003067 close to jalr
 * 7a condb_4    b0 CSRRW_3    0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    87 JALRE1     0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d WFI_2      9d _LDIV_11   0010000000000000101011101100100110        Check offset                                      00000000 
 * 7e ANDI_1     21 XORI_1     0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 7f (null)     d0 ECALL_1    00x000000000000000xxxx00x00xx00000 QINT_0                                                   00000000 
 * 80 LBU_0      d5 unxd5      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 XORI_1     d0 ECALL_1    0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 82 DIV_4      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000400b close to ij
 * 83 MULH_2     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000400f close to fence
 * 84 XORI_0     81 JAERR_2    0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 WFI_3      90 NMI_2      0010000000000000101011101100100110        More check offset                                 00000000 
 * 86 OR_1       9d _LDIV_11   0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 87 CSRRW_1    d2 LB_2       0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 88 DIV_5      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00004023 close to store
 * 89 XOR_1      fe ILLe       0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 8a eILL0c     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40004023 close to store
 * 8b ECALL_3    66 SW_1       0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 8c XOR_0      89 _LDIV_F    0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * 8e Fetch      fe ILLe       0001001010001000101111101010110000  Fr11  Read and latch instruction                        40004033 sloppy xor     
 * 8f eFetch     d4 aFault_2   0001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 90 LBU_2      9d _LDIV_11   0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 91 aFaulte    db jFault_1   0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 92 Fetch2     9d _LDIV_11   0000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 93 jFault     b5 SH_3       0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 94 _LMULHU_1  9d _LDIV_11   0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 95 MRET_6     26 OR_1       0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 96 SLTX_1     36 SLLI_2     0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 97 BAERR_3    de Fetch      0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * 98 BLT        6e _LDIV_C    0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 DIV_1      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00004067 close to jalr
 * 9a BrOpFet    9d _LDIV_11   0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 9b BAlignEr      (use dinx) 0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 9c DIV_2      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00004073 close to csr/system 
 * 9d JAL_3      fe ILLe       0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 9e IJ_1       e7 aFault     0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 9f IJT_1      b0 CSRRW_3    0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * a0 LHU_0      32 JAL_1      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SLLI_1     4f MRET_8     0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * a2 DIV_E      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000500b close to ij
 * a3 ECALL_2    fe ILLe       0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  0000500f close to fence
 * a4 SRxI_0     a6 ECAL_RET   0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 ILL_3      d6 eILL0c     0010000000000000101011101100100110        Q = 1                                             00000000 
 * a6 SRxI_1     56 LH_4       0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * a7 LDAF_2     bd IJ_4       0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * a8 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00005023 close to store
 * a9 SRxI_2     9d _LDIV_11   0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * aa DIV_10     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          40005023 close to store
 * ab SLL_1      29 XOR_1      0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * ac _L0xac     af MRET_4     0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * ae _L0xae     af MRET_4     0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SRx_1      ee eILL0a     0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * b0 SW_2       f4 Fetch2     0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * b1 aF_SW      db jFault_1   0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * b2 ILL_1      8e _LCSRRS_1  0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * b3 ILL_2         (use dinx) 0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * b4 CSRRW_2       (use dinx) 0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * b5 SW_E3      e5 aF_SW_2    0010000000000000101111001100100110        Q = 3                                             00000000 
 * b6 LH_4       29 XOR_1      0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * b7 ECALL_4    eb LH_3       0010000000000000101011001100100110        Q = 4                                             00000000 
 * b8 BGE        6e _LDIV_C    0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 DIV_14     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00005067 close to jalr
 * ba LH_5       7e NMI_1      0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * bb SB_1       2e _LMULHU_1  0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * bc CSRRWI_0   87 JALRE1     0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd EBRKWFI2   8e _LCSRRS_1  0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * be WFI_4      09 LB_5       0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * bf _LDIV_13   3a SRxI_1     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * c0 DIV_3      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00006003 close to load
 * c1 SB_4       49 CSRRW_1    1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * c2 DIV_6      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000600b close to ij
 * c3 MUL_3      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000600f close to fence
 * c4 ORI_0      f7 EBREAK_1   0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 _LDIV_C    95 SW_E3      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * c6 MRET_3     b3 unxb3      0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * c7 LBU_3      41 JALR_1     0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * c8 DIV_e      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00006023 close to store
 * c9 BAERR_1    c6 IJT_4      0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * ca DIV_D      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          40006023 close to store
 * cb BAERR_2    66 SW_1       0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * cc OR_0       86 JAL_2      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * ce SB_5       fe ILLe       0000000000000010110011100100001xx0        Write d to a+k until accepted                     40006033 sloppy or      
 * cf (null)     07 LB_4       00x000000000000000xxxx00x00xx00000 QINT_0                                                   00000000 
 * d0 BAERR_4    a3 _LDIV_15   0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * d1 NMI_1      3d SRxI_2     0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * d2 JALRE2     5a SB_1       0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * d3 JAERR_2    27 OR_2       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * d4 ILL_4      db jFault_1   0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * d5 LBU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * d6 MRET_4     fe ILLe       0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * d7 _LDIV_F    b7 IJ_3       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d8 BLTU       6e _LDIV_C    0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 DIVU_3     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00006067 close to jalr
 * da _LCSRRS_1  a7 EBRKWFI1   0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * db LDAF_3     db jFault_1   0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * dc CSRRSI_0   87 JALRE1     0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd (null)     6f MRET_6     00x000000000000000xxxx00x00xx00000 QINT_0                                                   00000000 
 * de SW_E2      92 LDAF_3     0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * df (null)     92 LDAF_3     00x000000000000000xxxx00x00xx00000 QINT_0                                                   00000000 
 * e0 DIVU_4     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00007003 close to load
 * e1 _LDIV_11   01 LB_1       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * e2 DIV_7      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000700b close to ij
 * e3 MUL_2      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000700f close to fence
 * e4 ANDI_0     7e NMI_1      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SH_4       2b SLTIX_1    1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * e6 CSRRW_3    8e _LCSRRS_1  0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * e7 SH_5       27 OR_2       0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * e8 DIVU_2     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00007023 close to store
 * e9 _LDIV_15   f0 LBU_2      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * ea EBREAK_2   fe ILLe       0000000000001101101011101000001xx0        pc to mepc                                        40007023 close to store
 * eb IJ_4       b6 ECALL_5    0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * ec AND_0      6b SB_4       0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * ee MRET_5     fe ILLe       0010000000000000000011101100010xx0        ~302                                              40007033 sloppy and     
 * ef (null)     8e _LCSRRS_1  00x000000000000000xxxx00x00xx00000 QINT_0                                                   00000000 
 * f0 IJT_4      c7 QINT_1     0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * f1 QINT_1     27 OR_2       0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * f2 _LCSRRCI_1 66 SW_1       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f3 MRET_7     45 WFI_3      0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f4 CSRRW_4    f6 WFI_1      0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * f5 LDAF_a     5f LDAF_LHU   0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * f6 eFetch3    7d BAERR_4    000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * f7 ORI_1      ea _LMULHU_5  0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * f8 BGEU       6e _LDIV_C    0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 MULH_3     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00007067 close to jalr
 * fa _LMULHU_5  85 LBU_1      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * fb LH_3       c1 IJT_2      0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * fc CSRRCI_0   87 JALRE1     0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      d1 MRET_1     0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       b2 CSRRW_4    0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     f1 aFaulte    0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 8040, used ffff, inputs 93
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       65 WFI_4      0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 ORI_2      54 LH_2       0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 02 IJ_0       8a DIVU_5     0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     32 JAL_1      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     32 JAL_1      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 JAL_1      6b SB_4       0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 07 JAERR_1    73 BAERR_1    0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 08 _L0x08     c6 IJT_4      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 IJ_2       ffffffff (null)     0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 0a _L0x0a     c6 IJT_4      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b OR_2       16 condb_5    0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     32 JAL_1      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      7d BAERR_4    0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     32 JAL_1      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 LW_1       ffffffff (null)     0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 11 LDAF_LW    94 SW_E4      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 12 condb_5       (use dinx) 0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 13 condb_5t   1a ANDI_1     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 14 LH_1       91 LDAF_2     0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LH    12 unx12      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 JAL_2      6e _LDIV_C    0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 17 JALRE1     86 JAL_2      0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 18 BEQ        90 NMI_2      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     52 LH_1       0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a condb_3    32 JAL_1      0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 1b _L0x1b     06 LB_3       0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   50 LW_1       0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d SLTIX_2    32 JAL_1      0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 1e ECALL_1    df eFetch     0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 1f MRET_1     45 WFI_3      0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 20 LH_0       14 condb_3    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SLLI_2     32 JAL_1      0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 22 MULHU_6    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000100b close to ij
 * 23 _L0x23     32 JAL_1      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     ab EBREAK_2   0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LH_2       0b JALR_2     0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 27 aFaultb    01 LB_1       0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 28 _L0x28     4e eILL0b     0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 SB_2       95 SW_E3      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 2a _L0x2a     4e eILL0b     0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b NMI_2      1d ORI_2      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 2c SLL_0      b2 CSRRW_4    0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     32 JAL_1      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e SW_E4      fe ILLe       0000110000001110100111100x00101000        Store 6 to mcause                                 40001033 sloppy sll     
 * 2f _L0x2f     32 JAL_1      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      32 JAL_1      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   3e SLL_1      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 StdIncPc   16 condb_5    0100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 33 aFault     de Fetch      0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 34 SW_1       6e _LDIV_C    0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   21 XORI_1     0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 WFI_1      03 _L0x03     0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 37 EBREAK_1   67 SW_E1SWE   0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 38 BNE        90 NMI_2      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 MULHU_7    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00001067 close to jalr
 * 3a aFault_1   b1 aF_SW_3    0010000000000000101011001100100110        Q = 4                                             00000000 
 * 3b _L0x3b     06 LB_3       0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    5a SB_1       0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ECALL_6    03 _L0x03     0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 3e SLTIX_1    ab EBREAK_2   0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 3f aF_SW_3    b0 CSRRW_3    0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 40 LW_0       10 SUB_1      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 SH_3       77 BAERR_3    0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * 42 MULHU_2    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000200b close to ij
 * 43 MULHU_4    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000200f close to fence
 * 44 SLTI_0     3e SLL_1      0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_3       cb QINT_2     0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 46 LHU_2      b6 ECALL_5    0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultc    76 BAERR_2    0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 48 _L0x48     34 JAL_3      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 SH_2       ba LHU_3      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 4a _L0x4a     34 JAL_3      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b IJT_2      bf IJT_1      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * 4c SLT_0      a6 ECAL_RET   0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * 4e SH_1       fe ILLe       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        40002033 sloppy slt     
 * 4f SW_E1SWH   32 JAL_1      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 50 ECAL_RET   32 JAL_1      0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 51 EBRKWFI1   a1 ECALL_4    0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 52 JALR_1     26 OR_1       0010000000000000000011101100100110        Q=1                                               00000000 
 * 53 MRET_2     a1 ECALL_4    0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * 54 LB_2       c1 IJT_2      0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 55 aFaultd    3a SRxI_1     0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 56 WFI_3      be IJ_1       0010000000000000101011101100100110        More check offset                                 00000000 
 * 57 QINT_2     ffffffff (null)     0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 58 DIV_A      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00002063 close to branch
 * 59 DIV_B      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00002067 close to jalr
 * 5a CSRRW_1    29 XOR_1      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 5b _L0x5b     06 LB_3       0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    5a SB_1       0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d aF_SW_1    61 EBRKWFI2   0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 5e MRET_6     46 ILL_1      0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 5f IJT_3      a1 ECALL_4    0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 60 MULHU_3    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003003 close to load
 * 61 SB_3       37 ECALL_2    0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * 62 DIV_8      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000300b close to ij
 * 63 DIV_9      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000300f close to fence
 * 64 SLTIU_0    3e SLL_1      0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 LB_1       97 SW_E1SWH   0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 66 eILL0c     8e _LCSRRS_1  0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 67 ECALL_3    ee eILL0a     0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 68 DIV_12     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003023 close to store
 * 69 LB_3       fe ILLe       0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 6a MULH_1     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          40003023 close to store
 * 6b LB_4       d5 unxd5      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 6c SLTU_0     a6 ECAL_RET   0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * 6e Fetch      fe ILLe       0001001010001000101111101010110000  Fr11  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     89 _LDIV_F    0001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 LBU_2      ffffffff (null)     0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 71 aFaulte    3a SRxI_1     0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 72 BAERR_3    94 SW_E4      0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * 73 LB_5       d4 aFault_2   0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 74 Fetch2     74 BrOpFet    0000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 75 jFault     d2 LB_2       0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 76 ILL_3      72 LBU_3      0010000000000000101011101100100110        Q = 1                                             00000000 
 * 77 JALR_2     d6 eILL0c     0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 78 DIV_4      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003063 close to branch
 * 79 DIV_5      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00003067 close to jalr
 * 7a LDAF_2     8e _LCSRRS_1  0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 7b _L0x7b     06 LB_3       0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    5a SB_1       0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SUB_1      a7 EBRKWFI1   0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 7e SW_E3      2b SLTIX_1    0010000000000000101111001100100110        Q = 3                                             00000000 
 * 7f AND_1      d6 eILL0c     0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 80 LBU_0      e6 StdIncPc   0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 QINT_1     d6 eILL0c     0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 82 DIV_6      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000400b close to ij
 * 83 DIVU_2     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000400f close to fence
 * 84 XORI_0     95 SW_E3      0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 _LCSRRCI_1 70 LHU_2      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 86 BrOpFet    a7 EBRKWFI1   0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 87 BAlignEr   dd aF_SW_1    0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 88 DIV_1      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00004023 close to store
 * 89 MRET_7     fe ILLe       0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * 8a IJ_1       fe ILLe       0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   40004023 close to store
 * 8b IJT_1      32 JAL_1      0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 8c XOR_0      9e SH_4       0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * 8e SW_2       fe ILLe       0010000000000000001011x01000xxxxx0        Prepare read PC                                   40004033 sloppy xor     
 * 8f aF_SW      b7 IJ_3       0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 90 condb_2    a7 EBRKWFI1   0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 91 condb_4    eb LH_3       0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 92 eILL0b     a7 EBRKWFI1   0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 93 MRET_8     7e NMI_1      0010000000000000101011101100100110        Prep +4                                           00000000 
 * 94 ANDI_1     a7 EBRKWFI1   0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 95 XORI_1     2e _LMULHU_1  0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 96 eILL0a     49 CSRRW_1    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 97 WFI_5      ee eILL0a     0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 98 BLT        90 NMI_2      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 MUL_1      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00004067 close to jalr
 * 9a eILL0b     a7 EBRKWFI1   0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 9b MRET_8        (use dinx) 0010000000000000101011101100100110        Prep +4                                           00000000 
 * 9c DIV_2      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00004073 close to csr/system 
 * 9d OR_1       fe ILLe       0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 9e XOR_1      f1 aFaulte    0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 9f ECALL_4    8e _LCSRRS_1  0010000000000000101011001100100110        Q = 4                                             00000000 
 * a0 LHU_0      30 SLTIX_2    0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 LDAF_a     db jFault_1   0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * a2 DIV_e      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000500b close to ij
 * a3 _LMULHU_1  fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000500f close to fence
 * a4 SRxI_0     b0 CSRRW_3    0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 ORI_1      bb SH_2       0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * a6 SLTX_1     1e aFault_1   0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * a7 JAL_3      c7 QINT_1     0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a8 DIV_E      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00005023 close to store
 * a9 _LMULHU_5  a7 EBRKWFI1   0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * aa DIV_D      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          40005023 close to store
 * ab SLLI_1     3d SRxI_2     0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * ac _L0xac     b4 eFetch3    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * ae _L0xae     b4 eFetch3    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af ECALL_2    f6 WFI_1      0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * b0 SRxI_1     d3 aFaultd    0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * b1 SRxI_2     eb LH_3       0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * b2 SLL_1      6e _LDIV_C    0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * b3 MRET_3        (use dinx) 0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * b4 SRx_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * b5 ILL_1      f0 LBU_2      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * b6 ILL_2      3d SRxI_2     0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * b7 ILL_4      f5 jFault     0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * b8 BGE        90 NMI_2      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MUL_3      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00005067 close to jalr
 * ba CSRRW_2    94 SW_E4      0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * bb MRET_4     41 JALR_1     0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * bc CSRRWI_0   5a SB_1       0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd LH_4       6e _LDIV_C    0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * be LH_5       09 LB_5       0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * bf CSRRW_3    4b CSRRW_2    0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * c0 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00006003 close to load
 * c1 LH_3       5f LDAF_LHU   0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * c2 DIVU_3     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000600b close to ij
 * c3 MULH_3     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000600f close to fence
 * c4 ORI_0      a5 MRET_3     0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     5e LHU_1      00x000000000000000xxxx00x00xx00000 QINT_0                                                   00000000 
 * c6 SB_1       b6 ECALL_5    0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * c7 EBRKWFI2   57 LH_5       0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * c8 DIV_10     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00006023 close to store
 * c9 (null)     b3 unxb3      00x000000000000000xxxx00x00xx00000 QINT_0                                                   00000000 
 * ca DIVU_4     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          40006023 close to store
 * cb WFI_4      32 JAL_1      0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * cc OR_0       9d _LDIV_11   0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * ce _LDIV_13   fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006033 sloppy or      
 * cf SB_4       9b unx9b      1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * d0 _LDIV_C    af MRET_4     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d1 LBU_3      53 LDAF_LH    0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * d2 BAERR_1    69 _LDIV_13   0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * d3 CSRRW_4    3a SRxI_1     0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d4 BAERR_2    eb LH_3       0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * d5 SB_5          (use dinx) 0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * d6 BAERR_4    fe ILLe       0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * d7 eFetch3    9f SH_5       000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * d8 BLTU       90 NMI_2      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MUL_2      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00006067 close to jalr
 * da NMI_1      7a SB_5       0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * db ECALL_5    eb LH_3       0010000000000000101011001100100110        Q = 8                                             00000000 
 * dc CSRRSI_0   5a SB_1       0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd JALRE2     f7 EBREAK_1   0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * de JAERR_2    74 BrOpFet    0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * df aFault_2   74 BrOpFet    0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * e0 DIV_14     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00007003 close to load
 * e1 (null)     01 LB_1       00x000000000000000xxxx00x00xx00000 QINT_0                                                   00000000 
 * e2 DIV_7      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000700b close to ij
 * e3 DIVU_1     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          0000700f close to fence
 * e4 ANDI_0     94 SW_E4      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     3f SRx_1      00x000000000000000xxxx00x00xx00000 QINT_0                                                   00000000 
 * e6 LBU_1      6e _LDIV_C    0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * e7 _LDIV_F    3a SRxI_1     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * e8 DIV_3      fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00007023 close to store
 * e9 (null)     fa WFI_2      00x000000000000000xxxx00x00xx00000 QINT_0                                                   00000000 
 * ea _LCSRRS_1  fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40007023 close to store
 * eb LDAF_3     bd IJ_4       0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * ec AND_0      7f JALRE2     0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Math entry point not used                                00000000 
 * ee SW_E2      fe ILLe       0000000000001101101111101000001xx0        Store address that faulted                        40007033 sloppy and     
 * ef _LDIV_11   6e _LDIV_C    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f0 SH_4       d1 MRET_1     1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * f1 SH_5       3a SRxI_1     0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * f2 _LDIV_15   32 JAL_1      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f3 jFault_1   5d SB_2       0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * f4 EBREAK_2   d7 ECALL_3    0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * f5 IJ_4       f3 aF_SW      0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * f6 MRET_5     fb SB_3       0010000000000000000011101100010xx0        ~302                                              00000000 
 * f7 aF_SW_2    f4 Fetch2     0010000000000000101011001100100110        Q = 4                                             00000000 
 * f8 BGEU       90 NMI_2      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 MULH_2     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (math)                          00007067 close to jalr
 * fa IJT_4      56 LH_4       0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * fb WFI_2      cf MRET_7     0010000000000000101011101100100110        Check offset                                      00000000 
 * fc CSRRCI_0   5a SB_1       0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      da LDAF_a     0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       b5 SH_3       0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     81 JAERR_2    0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 
 *   9 714 161 405 Can not simplify, no legal mapping
 *   8   4  50 1226 Can not simplify, can't possibly represent between 50 and 54 high values with only 4 bits index
 *   7   4 748 528 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *   6   4 745 531 Can not simplify, can't possibly represent between 745 and 749 high values with only 4 bits index
 *   5  22 750 508 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *   4   4 859 417 Can not simplify, can't possibly represent between 859 and 863 high values with only 4 bits index
 *   3  22 647 611 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *   2  22 807 451 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *   1  22 891 367 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *   0  22 465 793 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 */
localparam u0_0 = 256'h30e6001030e608041886205a008b205a18091007000420e600e620be09d22001;
localparam u0_1 = 256'h30b726d438e630a6303218e620413013207436de4816261500140000001a008b;
localparam u0_2 = 256'h30e600fe30e6003e2630209600212096201d00270004303500e600fe00e62052;
localparam u0_3 = 256'h083a0835090330493032093d00fe301348d72803083608de20812086002b32e6;
localparam u0_4 = 256'h26e600fe00fe003108b02066264b2066088f08472665102b00fe00fe260b2050;
localparam u0_5 = 256'h30da097028fb30493032085d00fe00fe008b1857301e09eb30da095430da08e6;
localparam u0_6 = 256'h26cf00fe00fe0031087a00fe00fe00fe309308f240ef102b00fe00fe50f700fe;
localparam u0_7 = 256'h087d089008343049303208f200fe00fe267d0077007388f40876101a301e09ba;
localparam u0_8 = 256'h26a900fe00fe002926e600fe00fe00fe087f263409f0102100fe00fe087d2085;
localparam u0_9 = 256'h08f2089f00fe00fe0000203400fe3013309308bb269428340895083426923034;
localparam u0_A = 256'h26c5003f00fe003f089a00fe263400fe206130d026af303a00fe00fe26b6205e;
localparam u0_B = 256'h08c1081f18de304928b5101a00fe301320bd269a309e2600000026de209226b2;
localparam u0_C = 256'h404f00fe00fe002630e600fe20a500fe08cb1847106f10e100fe00fe30e900fe;
localparam u0_D = 256'hb0f4b0f430e530492692009100fe301330a100fe00002692301e090630c92637;
localparam u0_E = 256'h26de00fe00fe0011105600fe20c600fe301e26de26b1101a00fe00fe081d00fe;
localparam u0_F = 256'h00c70046007e3049306b264500fe301330ab26fa30db20b400dd00e6301e0972;
localparam u1_0 = 256'h10ba03b210ba03bbb0ba23ab017b23ab017b01bb00b110ba00b2837b02fb036b;
localparam u1_1 = 256'h32ba02b310ba82f980b910ba22ba33baab7b2b71033b00bb03fb000003bb03fb;
localparam u1_2 = 256'h10ba003010ba03b0003aa3ab03bba3ab003b23ba00b103c800b2003010bab36b;
localparam u1_3 = 256'h03c803c8129b31ba80b9129b003033ba343a12db12db2b793cb830ba03fb10ba;
localparam u1_4 = 256'h02bb0030003003b20eb983bb003b83bb3eba36b802bb03fb00300030003b837b;
localparam u1_5 = 256'h3eb902fb32db31ba80b932db00300030023b023b3eba029b3eb902fb3eb912fa;
localparam u1_6 = 256'h003b0030003003b20b3b0030003000303cb80fb900b203fb0030003021ba0030;
localparam u1_7 = 256'h3eb8343a3a7831ba80b90b390030003036b800bb00b002fa3f3a01bb3eba029b;
localparam u1_8 = 256'h02bb0030003003f210ba0030003000303738133002fb03fb0030003036b8036b;
localparam u1_9 = 256'h0739073b0030003000003a70003033ba3cb832db02f33a7836fa367838b03d3a;
localparam u1_A = 256'h003b03b0003003b036ba00303a780030003b82f901bb03c80030003002b3b36b;
localparam u1_B = 256'h02fb02fb2b7931ba32db01fb003033ba033302b3003a67fb00002b7138b002b3;
localparam u1_C = 256'h01b20030003003f23d3a003001b30030343a377b003b23fa0030003032ba0030;
localparam u1_D = 256'h22fa22fa3eba31ba38b802b2003033ba3eba0030000038b83eba029b21ba00bb;
localparam u1_E = 256'h2b710030003003f201fb0030033300303eba2b7102b303fb00300030003b0030;
localparam u1_F = 256'h00b200b000b231ba003a02bb003033ba3cba00333eba2c7e003100b23eba029b;
localparam u2_0 = 256'h00000080000000800001040000800400008000800080040000800490008a0580;
localparam u2_1 = 256'h00000c8000000080008100000400000005010102008004800080000000800080;
localparam u2_2 = 256'h0000008000000080048004000080040004800000008000800080008000000500;
localparam u2_3 = 256'h0080008000040000008100000080000000000004000001020400040000800000;
localparam u2_4 = 256'h0480008000800080002007810480078100000000048000800080008004800581;
localparam u2_5 = 256'h0000008a00040000008100000080008000800080000000840000008a00000042;
localparam u2_6 = 256'h0480008000800080038000800080008000000000008000800080008000000080;
localparam u2_7 = 256'h0000000000300000008100000080008004000080008000ca0000008000000084;
localparam u2_8 = 256'h00800080008000800c0000800080008000002c00008a00800080008000000580;
localparam u2_9 = 256'h00000380008000800000043000800000000000000c800030000000000c300030;
localparam u2_A = 256'h048000800080008000000080043000800480008104800080008000800c800500;
localparam u2_B = 256'h0082008201020000000400800080000004800c800080040000000d0204300c80;
localparam u2_C = 256'h0080008000800080003000800480008000000100008000000080008000000080;
localparam u2_D = 256'h004a004a00000000040000800080000000000080000004300000008400000480;
localparam u2_E = 256'h0d02008000800080008000800480008000000d020c8000800080008000800080;
localparam u2_F = 256'h0080008000800000008004800080000000000c80000004000080008000000084;
