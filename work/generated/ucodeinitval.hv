/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------
 * Automaticaly generated by ../bin/midgetv_genucode (based on ../code/ucode.h).
 * Do not edit.
 *
 * uPC
 * ||            next uPC
 * ||            || ucodeInstruction
 * ||            || 3333333322222222221111111111
 * || label      || 76543210987654321098765432109876543210 Purpose
 * -- ---------- -- -------------------------------------- ------------------------------------------------------
 * 00 LB_0       01 00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs
 * 01 LB_1       d2 00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]
 * 02 IJ_0       be 00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0
 * 03 FENCE      e6 00000010000000000000001011x01000xxxxx0 f      Prepare read PC (FENCE)
 * 04 ADDI_0     e6 00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)
 * 05 _L05       04 00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/8)
 * 06 LB_3       07 00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]
 * 07 LB_4       09 00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]
 * 08 _L08       5a 00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm
 * 09 LB_5       a3 00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80
 * 0a _L0a       5a 00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm
 * 0b JALR_2     86 00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe
 * 0c ADD_0      04 00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1
 * 0d MUL_0      e2 00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear
 * 0e SUB_0      10 00000010000000000000111011x01000xxxxx0 SUB    Subtraction
 * 0f _L0f       e6 00000000000000000100001011101000110000 LUI    q = imm20
 * 10 SUB_1      a3 00000010000000000000111111101100000xx0        Q = ~RS2
 * 11 AND_1      1a 00000010000000000000111011101100000xx0        RS1^0xffffffff to Q
 * 12 eFetch3    74 0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx
 * 13 condb_2    14 00000010000000000000111111101100000xx0        ~RS2 in Q
 * 14 condb_3    15 00010010000000000000110011101100100110        Calculate RS1+~RS2+1
 * 15 condb_4    16 00000010000000000000000011101101001xx0        Branch on condition
 * 16 condb_5    e6 00000010000000000000001011x01000xxxxx0        Branch not taken.
 * 17 condb_5t   de 00010100000010001010110111100100100000        Branch taken.
 * 18 BEQ        13 00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy
 * 19 JALR_0     41 00010000000000001000101011101000100000 JALR   jj=RS1+imm
 * 1a ANDI_1     e6 00000000000000000100001011101000011xx0        rd = Iimm & RS1
 * 1b _L1b       32 00000010000000000000000011100100110000 JAL    J-imm is in q.
 * 1c ECAL_BRK   a6 00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI
 * 1d ORI_2      e6 00000000000000000100001011101000111000        rd = Iimm | RS1
 * 1e aFault_1   d4 00110010000000000000101011001100100110        Q = 4
 * 1f IJ_2       b7 00000000000000001100101011101000110000        Read word is to be masked with lsb = 0
 * 20 LH_0       52 00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.
 * 21 XORI_1     e6 00000000000000000100001011101000000xx0        rd = Iimm ^ RS1
 * 22 MULHU_6    39 00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar
 * 23 FENCEI     e6 00000010000000000000001011x01000xxxxx0 f      Prepare read PC (FENCE)
 * 24 SLLI_0     35 00000010000000000000111100100x00110000 SLLI   Shift left immediate.
 * 25 _L25       04 00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/8)
 * 26 OR_1       27 00000000000000001000111011101000000xx0        RS1^0xffffffff to jj
 * 27 OR_2       1d 00010010000000000000000011101100100000        Q = rs2
 * 28 _L28       96 00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm
 * 29 XOR_1      21 00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF
 * 2a _L2a       96 00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm
 * 2b SLTIX_1    30 00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2
 * 2c SLL_0      3e 00000010000000000000111011x00x00xxxxx0 SLL    Shift left
 * 2d MULH_0     fb 00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--
 * 2e EBRKWFI2   f7 00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI
 * 2f _L2f       e6 00000000000000000100001011101000110000 LUI    q = imm20
 * 30 SLTIX_2    e6 00000000000000000100001011101000110010        Registered ALU flag to rd
 * 31 SLTX_1     2b 00000010000000000000111111101100000xx0        ~rs2 to Q
 * 32 JAL_1      86 00010000000000001100001011101000100000        Target adr to yy
 * 33 JAERR_1    de 0000000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx        Not in use
 * 34 JAL_3      de 00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch
 * 35 SLLI_1     36 00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)
 * 36 SLLI_2     03 00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0
 * 37 ECALL_2    d7 00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval
 * 38 BNE        13 00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy
 * 39 MULHU_7    e6 00100000000000000100001011101000001xx0        Last shift.
 * 3a SRxI_1     3d 00000000000000000100101001101100001xx1        Register to shift to Q
 * 3b _L3b       32 00000010000000000000000011100100110000 JAL    J-imm is in q.
 * 3c CSRRW_0    49 00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy
 * 3d SRxI_2     03 00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0
 * 3e SLL_1      35 00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2
 * 3f SRx_1      3a 00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2
 * 40 LW_0       50 00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm
 * 41 JALR_1     0b 00010010000000000000000011101100100110        Q=1
 * 42 MULHU_2    bb 00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar
 * 43 MULHU_4    ea 00000010000000000000000011100100000xx0        Prepare read Rjj.
 * 44 SLTI_0     2b 00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)
 * 45 WFI_3      65 00010010000000000000101011101100100110        More check offset
 * 46 ILL_1      47 00000100000000001101110111101100001xx0        Store PC to mepc and Q for read of instr
 * 47 ILL_2      8f 00000010000010000000101111101100001xx0        Read until Q is offending instruction
 * 48 _L48       66 00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm
 * 49 CSRRW_1    4b 00010010000000000000000011101100100110        Construct PC storage adr
 * 4a _L4a       66 00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm
 * 4b CSRRW_2    b0 00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt
 * 4c SLT_0      31 00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)
 * 4d MULHSU_0   9b 00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--
 * 4e eILL0b     fe 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 4f MRET_8     e6 00010010000000000000101011101100100110        Prep +4
 * 50 LW_1       e6 00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]
 * 51 LDAF_LW    da 00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval
 * 52 LH_1       54 00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]
 * 53 LDAF_LH    da 00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval
 * 54 LH_2       eb 00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)
 * 55 aFaultb    1e 00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval
 * 56 LH_4       57 00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]
 * 57 LH_5       a3 00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000
 * 58 DIV_A      ba 00110010000000000000101111101100001xx1        Transfer rM to rDee
 * 59 DIV_B      9c 00000000000000001100111111101000110000        REM = Q to yy
 * 5a SB_1       5d 00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift
 * 5b _L5b       32 00000010000000000000000011100100110000 JAL    J-imm is in q.
 * 5c CSRRS_0    49 00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy
 * 5d SB_2       6a 00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)
 * 5e LHU_1      70 00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]
 * 5f LDAF_LHU   da 00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval
 * 60 DIV_14     a3 00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy
 * 61 DIV_15     e6 00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result
 * 62 DIV_8      c8 00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]
 * 63 DIV_9      58 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]
 * 64 SLTIU_0    2b 00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)
 * 65 WFI_4      ef 00000010000000000000001011x01001xxxxx0        Prepare read PC
 * 66 SW_1       f2 00000000000000000011111011100100001xx0        Write d to a+k until accepted
 * 67 SWE        93 00000000000000001111001011100x00110000        Store faulting address alignment to mtval
 * 68 DIV_12     e6 00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result
 * 69 DIV_13     a3 00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy
 * 6a SB_3       6b 00000010000000000000000011101000110000        Prepare get back address to use 
 * 6b SB_4       7a 00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write
 * 6c SLTU_0     31 00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)
 * 6d MULHU_0    9b 00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--
 * 6e LHU_3      1a 00000010000000000000011111101100010xx0        Invert q. Prepare read mask
 * 6f MRET_6     cf 00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision
 * 70 LHU_2      6e 00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)
 * 71 aFaultc    1e 00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval
 * 72 LBU_3      1a 00000010000000000000011011101100010xx0        Invert q. Prepare read mask
 * 73 BAERR_1    de 0000000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx       not used
 * 74 unalignd   75 00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword
 * 75 straddle   76 10110100000010001010110111000100100110  Fr10u IncPC, OpFetch
 * 76 Fetchu     d5 00000010000000000000001111101010110000  Fr10u Read and latch instruction
 * 77 eFetchu    d5 00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]
 * 78 DIV_4      a9 00000000000000001100000011101000110000        ~abs(divisor) to yy
 * 79 DIV_5      a8 00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr
 * 7a SB_5       f2 00000000000000000010110011100100001xx0        Write d to a+k until accepted
 * 7b _L7b       32 00000010000000000000000011100100110000 JAL    J-imm is in q.
 * 7c CSRRC_0    49 00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy
 * 7d BAERR_4    de 0000000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx       not used
 * 7e NMI_1      90 00000000000000001101xxxx11101000001xx0        Store pc to mepc.
 * 7f JALRE2     de 0000000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx        Not in use
 * 80 LBU_0      85 00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.
 * 81 JAERR_2    de 0000000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx        Not in use
 * 82 DIV_1      a8 00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor
 * 83 DIV_2      82 00010010000000000000101011101100100000        Dividend negative, make RS1-1
 * 84 XORI_0     21 00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm
 * 85 LBU_1      f0 00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]
 * 86 JAL_2      34 10110000000000000100110011000x00100110        Return address to TRG
 * 87 JALRE1     de 0000000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx        Not in use
 * 88 DIV_E      9c 01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs
 * 89 DIV_F      e6 00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff
 * 8a ILL_4      8b 00010010000000000000101011101100100110        Q = 1
 * 8b ILL_5      34 00010000110000001110100111100x00100110        Store 2 to mcause
 * 8c XOR_0      29 00000010000000000000111111x01000xxxxx0 XOR    xor
 * 8d DIV_0      82 01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1
 * 8e aF_SW_3    92 00010000110000001110001011000x00100000        Store 7 to mcause
 * 8f ILL_3      8a 00000000000000001111101011101000110000        Store illegal instruction to mtval
 * 90 NMI_2      34 00000000110000001111010011101000110000        mtval = 0.
 * 91 LDAF_2     92 00110000110000001110001011000x00100110        Store 4 to mcause
 * 92 LDAF_3     34 00000000000000001101100111100x00001xx0        PC to mepc
 * 93 SW_E2      95 00000000000000001101101111101000001xx0        Store address that faulted
 * 94 SW_E4      34 00000000110000001110100111100x00101000        Store 6 to mcause
 * 95 SW_E3      94 00110010000000000000101111001100100110        Q = 3
 * 96 SH_1       9a 00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift
 * 97 SWH        93 00000000000000001111001011100x00110000        Store faulting address alignment to mtval
 * 98 BLT        13 00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy
 * 99 _L99       fe 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * 9a SH_2       b5 00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)
 * 9b MULHU_1    42 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1. 
 * 9c DIV_10     68 01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1
 * 9d DIV_11     60 01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1
 * 9e SH_4       9f 00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write
 * 9f SH_5       f2 00000000000000000001110011100100001xx0        Write d to a+k until accepted
 * a0 LHU_0      5e 00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm.
 * a1 ECALL_4    ce 00110010000000000000101011001100100110        Q = 4
 * a2 DIVU_5     1a 00110010000000000000101111x01000xxxxx1        Transfer rM to rDee
 * a3 LB_6       e6 00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80
 * a4 SRxI_0     3a 00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)
 * a5 MRET_3     af 00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202
 * a6 ECAL_RET   d0 00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET
 * a7 EBRKWFI1   2e 00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI
 * a8 DIV_3      78 01100010000000000000101011101100000xx0        Branch on sign divisor RS2
 * a9 DIV_6      c8 00100010000000000000101111x01000xxxxx0        Write M. Prepare shift
 * aa ECALL_6    34 00010000110000001110100111000x00100000        mcause = 11
 * ab EBREAK_2   aa 00000000000000001101101011101000001xx0        pc to mepc
 * ac _Lac       3f 00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)
 * ad DIVU_0     e0 00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2
 * ae _Lae       3f 00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)
 * af MRET_4     c5 00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302
 * b0 CSRRW_3    b2 00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104
 * b1 CSRRS_1    de 0000000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx        Not in use
 * b2 CSRRW_4    de 00110100000010001010110111000100100110        IncPC, OpFetch, but force +4
 * b3 CSRRWI_1   de 0000000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx        Not in use
 * b4 CSRRWI_2   de 0000000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx        Not in use
 * b5 SH_3       9e 00000010000000000000000011101000110000        Prepare get back address to use 
 * b6 CSRRCI_1   de 0000000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx        Not in use
 * b7 IJ_3       bd 00010010000000000000110011101100100110        Construct Q = 1
 * b8 BGE        13 00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy
 * b9 DIV_e      c0 00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF
 * ba DIV_C      b9 00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff
 * bb MULHU_3    42 00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1
 * bc CSRRWI_0   49 00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy
 * bd IJ_4       de 00000100000010001010110111100100011xx0        Mask and use as PC
 * be IJ_1       1f 00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]
 * bf IJT_1      c1 00000010000010000000101111101100001xx0        Exit CSR, enter trap
 * c0 DIV_D      88 00000010000000000000111011101101001xx0        Is RS2 == 0?
 * c1 IJT_2      e9 00000000000000001100101011101000110000        Read word is to be masked with ~1u
 * c2 DIVU_3     ca 00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]
 * c3 DIVU_4     a2 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]
 * c4 ORI_0      e1 00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm
 * c5 MRET_5     6f 00000010000000000000000011101100010xx0        ~302
 * c6 IJT_4      47 00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr
 * c7 QINT_1     cb 00000000000000001101xxxx11101000001xx0        Store pc to mepc.
 * c8 DIV_7      62 00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub
 * c9 MRET_2     a5 00010010000000000000011011001100100000        0xff+3 = 0x102
 * ca DIVU_2     c2 00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub
 * cb QINT_2     e6 00000000110000001111010011101000110000        mtval = 0.
 * cc OR_0       26 00000010000000000000111111x01000xxxxx0 OR     or
 * cd REM_0      82 01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1
 * ce ECALL_5    aa 00110010000000000000101011001100100110        Q = 8
 * cf MRET_7     4f 00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104
 * d0 ECALL_1    37 00010010000000000000001011101100100110 ECALL  Verify Imm==0x000
 * d1 MRET_1     c9 00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check
 * d2 LB_2       06 00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)
 * d3 aFaultd    1e 00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval
 * d4 aFault_2   92 00010000110000001110001011100x00100110        Store 5 to mcause
 * d5 Fetch2u       0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx
 * d6 eILL0c     fe 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * d7 ECALL_3    a1 00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause
 * d8 BLTU       13 00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy
 * d9 MULH_3     42 00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.
 * da LDAF_a     91 00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval
 * db jFault_1   92 00010000000000001110001011100x00100110        Store 1 to mcause
 * dc CSRRSI_0   49 00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy
 * dd aF_SW_1    e5 00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval
 * de Fetch      f4 00000001001010001000101111101010110000  Fr11  Read and latch instruction
 * df eFetch     f4 00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]
 * e0 DIVU_1     ca 00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift
 * e1 ORI_1      1d 00000010000000000000000011101100001xx0        Q = RS1
 * e2 MUL_1      e8 00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar
 * e3 MUL_3      1a 00110010000000000000101111x01000xxxxx1        Transfer rM to rDee
 * e4 ANDI_0     1a 00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm
 * e5 aF_SW_2    8e 00110010000000000000101011001100100110        Q = 4
 * e6 StdIncPc   de 10110100000010001010110111000100100110  Fr11  IncPC, OpFetch
 * e7 aFault     1e 00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval
 * e8 MUL_2      e2 00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2
 * e9 IJT_3      c6 00010010000000000000110011101100100110        Construct Q = 1
 * ea MULHU_5    22 00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy
 * eb LH_3       56 00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]
 * ec AND_0      11 00000010000000000000111111x01000xxxxx0 AND    And 
 * ed REMU_0     e0 00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0
 * ee eILL0a     fe 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen
 * ef WFI_5      de 00110100000010001010110111000100100110        IncPC, OpFetch
 * f0 LBU_2      72 00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)
 * f1 aFaulte    1e 00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval
 * f2 SW_2       e6 00000010000000000000001011x01000xxxxx0        Prepare read PC
 * f3 aF_SW      dd 00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf
 * f4 Fetch2     12 00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx
 * f5 jFault     db 00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval
 * f6 WFI_1      fa 00110010000000000000000011001100100110 WFI    To check offset
 * f7 EBREAK_1   ab 00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval
 * f8 BGEU       13 00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy
 * f9 MULH_2     d9 00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0
 * fa WFI_2      45 00010010000000000000101011101100100110        Check offset
 * fb MULH_1     f9 00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.
 * fc CSRRCI_0   49 00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy
 * fd NMI_0      7e 00000010000000000000001011x01000xxxxx0 NMI    Get current PC
 * fe ILLe       46 00000010000000000000001011x01000xxxxx0 Illegal
 * ff QINT_0     c7 00000010000000000000001011x01000xxxxx0 INT    Get current PC
 */
localparam u0_0 = 256'hba30b200b200bb08ba18ab207b00ab207b18bb103100ba20b2007b20fb096b20;
localparam u0_1 = 256'hba30b326ba38f9303930ba18ba20ba307920b2003b483b26fb00fb26bb00fb00;
localparam u0_2 = 256'hba30ba509b08b0003a26ab20bb00ab203b20ba003100c830b200bb21ba006b20;
localparam u0_3 = 256'hc808c8089b09ba3039309b09ba08ba303a48db28db0879080000ba20fb00ba32;
localparam u0_4 = 256'hbb2630009a08b200b908bb203b26bb20fb087b08bb26fb1039009b213b267b20;
localparam u0_5 = 256'hb930fb09db28ba303930db08fa30fb093b003b18ba309b09b930fb09b930fa08;
localparam u0_6 = 256'h3b26fb109a08b2003b083a30bb00ba08b830b908b240fb10fb26db26ba08bb00;
localparam u0_7 = 256'h00003a080000ba3039303908bb263a30fab0fab07126ba300000bb10ba309b09;
localparam u0_8 = 256'hba30b020db08f2007826bb26ba30f00000003026fb09fb10bb20ba0000006b20;
localparam u0_9 = 256'h39083b083a083a08fa30db283000ba30b830db08f3267828fa087808b0263a30;
localparam u0_A = 256'h3b26b0009200b000ba087020f200bb003b20f930bb26c830ba26f201b3266b20;
localparam u0_B = 256'hfb08fb087918ba30fb08b9083b06ba303b2600003a300000000071260000b326;
localparam u0_C = 256'hb240b326db08f2003a303b2cb3203b2c3a087b183b10fa10fb26db26ba30bb48;
localparam u0_D = 256'hfab0fab0ba30ba30b826b200f200ba30ba303000ff20b826ba309b09ba30bb26;
localparam u0_E = 256'h712630009200f200fb103b203b26bb08ba307126b326fb10f2019b213b08fa00;
localparam u0_F = 256'hb200b200b200ba30ba00bb26ba26ba30ba303326ba307e203100b200ba309b09;
localparam u1_0 = 256'h001080038003800300300023800100238001800180000010800090838a028003;
localparam u1_1 = 256'h00328002001080828000001000220033022b8000800080038003006780038003;
localparam u1_2 = 256'h0010002180028003800000a3800300a3800000238000800380008002001000b3;
localparam u1_3 = 256'h80038003041200318000001200100033003404120012022b0000003080030010;
localparam u1_4 = 256'h8002800000338003200e81838000818382020037800280038000800280008183;
localparam u1_5 = 256'h003e8a0204320031800000320033800280028002003e8402003e8a02003e4212;
localparam u1_6 = 256'h8000800100338003800b800080020010003c000f800080038002800200108002;
localparam u1_7 = 256'h00000034000000318000000b80020030ca028000022b800000008001003e8402;
localparam u1_8 = 256'h003e303880028003303a800200108003000000138a0280038002002300008003;
localparam u1_9 = 256'h00078007800380030023043280000033003c00328002303a003600363038303d;
localparam u1_A = 256'h80008003800380030036303a80028002800081828001800300108002800200b3;
localparam u1_B = 256'h82028202022b0031800300338003003380030000800000000000022b00008002;
localparam u1_C = 256'h8001800280028003303d80038001800300340037800000238002800200328003;
localparam u1_D = 256'h4a224a22003e00310038800280030033003e8000006f3038003e840200218000;
localparam u1_E = 256'h022b8000800380038001800380038003003e022b800280038002800280000032;
localparam u1_F = 256'h80008000800000310032800200230033003c8000003e002c80008000003e8402;
localparam u2_0 = 256'h39800400388801002180168428c01684024001c00100398439802f8434800045;
localparam u2_1 = 256'h2dc0350c398029800c803980104404c0378539800580054405001d04068028c0;
localparam u2_2 = 256'h39803dc03ec00f800c04258408402584074409c001000d4039800e4039801485;
localparam u2_3 = 256'h0e800d4000c012400c800f40398804c035c000c00d803781378021840ac03980;
localparam u2_4 = 256'h39843f8026c00c402c00198712c4198723c011c119440ac03a802ec002c41405;
localparam u2_5 = 256'h36801c001a8012400c80174027002e8c28c015c007803ac03680150036803980;
localparam u2_6 = 256'h33c4068026c00c401e831ac028c0398024c03c803bc00ac016143204398028c0;
localparam u2_7 = 256'h37802400378012400c803c802a0c2a40354035401dad1d403780068007801b80;
localparam u2_8 = 256'h2280248420980a400d0422c43980271837800d2c3c00084020842a0037802145;
localparam u2_9 = 256'h3c8027c318181a1810882d403f8004c024c02680250c0d0025400d00248c0d00;
localparam u2_A = 256'h31440fc038080fc02a800d0432081e180b8434002bc40e80398c068c338c1785;
localparam u2_B = 256'h304007c03781124010882e40300004c02f443780278037803780378d37802c8c;
localparam u2_C = 256'h13c02a8c20980980398030882944188832c011c11bc03840289432843a402200;
localparam u2_D = 256'h3d003d003940124024842440108804c028403f80000424840780018032400dc4;
localparam u2_E = 256'h378d3f80380804401580088031843888078037ad238c0680068c3a0007403280;
localparam u2_F = 256'h31c011801f8012403e401144364404c02ac03e8c36c004843740398007801c80;
