/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------
 * Automaticaly generated by ../bin/midgetv_genucode (based on ../code/ucode.h).
 * Do not edit.
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       d2 LB_2       00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       be IJ_1       00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     e6 StdIncPc   00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     e6 StdIncPc   00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 LB_3       07 LB_4       00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 07 LB_4       09 LB_5       00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 08 _L0x08     5a SB_1       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_5       8b LB_6       00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 0a _L0x0a     5a SB_1       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b JALR_2     86 JAL_2      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      e2 MUL_1      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      10 SUB_1      00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     e6 StdIncPc   00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 SUB_1      8b LB_6       00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 11 AND_1      1a ANDI_1     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 12 straddle   76 Fetchu     10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 13 condb_2    14 condb_3    00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 14 condb_3    15 condb_4    00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 15 condb_4    16 condb_5    00000010000000000000000011101101001xx0        Branch on condition                               00000000 
 * 16 condb_5    e6 StdIncPc   00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 17 condb_5t   de Fetch      00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 18 BEQ        13 condb_2    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     41 JALR_1     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a ANDI_1     e6 StdIncPc   00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 1b _L0x1b     32 JAL_1      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   a6 ECAL_RET   00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d ORI_2      e6 StdIncPc   00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 1e aFault_1   d4 aFault_2   00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 1f IJ_2       b7 IJ_3       00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 20 LH_0       52 LH_1       00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 XORI_1     e6 StdIncPc   00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 22 MULHU_6    39 MULHU_7    00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      0000100b close to ij
 * 23 _L0x23     e6 StdIncPc   00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     35 SLLI_1     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 OR_1       27 OR_2       00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 27 OR_2       1d ORI_2      00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 28 _L0x28     96 SH_1       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 XOR_1      21 XORI_1     00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 2a _L0x2a     96 SH_1       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b SLTIX_1    30 SLTIX_2    00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 2c SLL_0      3e SLL_1      00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     6a MULH_1     00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e MULHU_1    42 MULHU_2    00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                40001033 sloppy sll     
 * 2f _L0x2f     e6 StdIncPc   00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SLTIX_2    e6 StdIncPc   00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 31 SLTX_1     2b SLTIX_1    00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 32 JAL_1      86 JAL_2      00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 33 unx33         (use dinx) 0000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 33: Not in use                                           00000000 
 * 34 JAL_3      de Fetch      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 35 SLLI_1     36 SLLI_2     00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 36 SLLI_2     03 _L0x03     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 37 ECALL_2    d7 ECALL_3    00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 38 BNE        13 condb_2    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 MULHU_7    e6 StdIncPc   00100000000000000100001011101000001xx0        Last shift.                                       00001067 close to jalr
 * 3a SRxI_1     3d SRxI_2     00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 3b _L0x3b     32 JAL_1      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    49 CSRRW_1    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d SRxI_2     03 _L0x03     00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 3e SLL_1      35 SLLI_1     00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 3f SRx_1      3a SRxI_1     00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 40 LW_0       50 LW_1       00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 JALR_1     0b JALR_2     00010010000000000000000011101100100110        Q=1                                               00000000 
 * 42 MULHU_2    60 MULHU_3    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           0000200b close to ij
 * 43 MULHU_4    ea MULHU_5    00000010000000000000000011100100000xx0        Prepare read Rjj.                                 0000200f close to fence
 * 44 SLTI_0     2b SLTIX_1    00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 WFI_3      65 WFI_4      00010010000000000000101011101100100110        More check offset                                 00000000 
 * 46 ILL_1      47 ILL_2      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 47 ILL_2      8f ILL_3      00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 48 _L0x48     66 SW_1       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 CSRRW_1    4b CSRRW_2    00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 4a _L0x4a     66 SW_1       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b CSRRW_2    b0 CSRRW_3    00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 4c SLT_0      31 SLTX_1     00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   2e MULHU_1    00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e eILL0b     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40002033 sloppy slt     
 * 4f MRET_8     e6 StdIncPc   00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 50 LW_1       e6 StdIncPc   00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 51 LDAF_LW    da LDAF_a     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 52 LH_1       54 LH_2       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 53 LDAF_LH    da LDAF_a     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 54 LH_2       eb LH_3       00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 55 aFaultb    1e aFault_1   00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 56 LH_4       57 LH_5       00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 57 LH_5       8b LB_6       00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 58 DIV_A      6e DIV_C      00110010000000000000101111101100001xx1        Transfer rM to rDee                               00002063 close to branch
 * 59 DIV_B      9c DIV_10     00000000000000001100111111101000110000        REM = Q to yy                                     00002067 close to jalr
 * 5a SB_1       5d SB_2       00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5b _L0x5b     32 JAL_1      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    49 CSRRW_1    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SB_2       fb SB_3       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 5e LHU_1      70 LHU_2      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 5f LDAF_LHU   da LDAF_a     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 60 MULHU_3    42 MULHU_2    00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00003003 close to load
 * 61 EBRKWFI2   f7 EBREAK_1   00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 62 DIV_8      c8 DIV_7      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIV_9      58 DIV_A      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    2b SLTIX_1    00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 WFI_4      ef WFI_5      00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 66 SW_1       f2 SW_2       00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 67 SW_E1SWE   93 SW_E2      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 68 DIV_12     e6 StdIncPc   00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00003023 close to store
 * 69 DIV_13     8b LB_6       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 6a MULH_1     f9 MULH_2     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              40003023 close to store
 * 6b SB_4       7a SB_5       00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 6c SLTU_0     31 SLTX_1     00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    2e MULHU_1    00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_C      b9 DIV_e      00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              40003033 sloppy sltu    
 * 6f MRET_6     cf MRET_7     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 70 LHU_2      ba LHU_3      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 71 aFaultc    1e aFault_1   00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 72 LBU_3      1a ANDI_1     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 73 unalignd   12 straddle   00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * 74 unx74         (use dinx) 0000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 74: Not in use                                           00000000 
 * 75 unx75         (use dinx) 0000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 75: Not in use                                           00000000 
 * 76 Fetchu     d5 Fetch2u    00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00000000 
 * 77 eFetchu    d5 Fetch2u    00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 78 DIV_4      aa DIV_6      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00003063 close to branch
 * 79 DIV_5      a8 DIV_3      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00003067 close to jalr
 * 7a SB_5       f2 SW_2       00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 7b _L0x7b     32 JAL_1      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    49 CSRRW_1    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d unx7d         (use dinx) 0000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 7d: Not in use                                           00000000 
 * 7e NMI_1      90 NMI_2      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 7f unx7f         (use dinx) 0000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 7f: Not in use                                           00000000 
 * 80 LBU_0      85 LBU_1      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 unx81         (use dinx) 0000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 81: Not in use                                           00000000 
 * 82 DIV_1      a8 DIV_3      00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  0000400b close to ij
 * 83 DIV_2      82 DIV_1      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     0000400f close to fence
 * 84 XORI_0     21 XORI_1     00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 LBU_1      f0 LBU_2      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 86 JAL_2      34 JAL_3      10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 87 unx87         (use dinx) 0000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 87: Not in use                                           00000000 
 * 88 DIV_E      9c DIV_10     01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00004023 close to store
 * 89 DIV_F      e6 StdIncPc   00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 8a DIVU_5     1a ANDI_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               40004023 close to store
 * 8b LB_6       e6 StdIncPc   00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 8c XOR_0      29 XOR_1      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      82 DIV_1      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e _LCSRRS_1  fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40004033 sloppy xor     
 * 8f ILL_3      a9 ILL_4      00000010000000000000101011101100100110        Q = 1                                             00000000 
 * 90 NMI_2      34 JAL_3      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 91 LDAF_2     92 LDAF_3     00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 92 LDAF_3     34 JAL_3      00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 93 SW_E2      95 SW_E3      00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 94 SW_E4      34 JAL_3      00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 95 SW_E3      94 SW_E4      00110010000000000000101111001100100110        Q = 3                                             00000000 
 * 96 SH_1       bb SH_2       00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 97 SW_E1SWH   93 SW_E2      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 98 BLT        13 condb_2    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a ECALL_6    34 JAL_3      00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 9b unx9b         (use dinx) 0000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 9b: Not in use                                           00000000 
 * 9c DIV_10     68 DIV_12     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00004073 close to csr/system 
 * 9d DIV_11     a2 DIV_14     01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 9e SH_4       9f SH_5       00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 9f SH_5       f2 SW_2       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * a0 LHU_0      5e LHU_1      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_4    b6 ECALL_5    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * a2 DIV_14     8b LB_6       00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 0000500b close to ij
 * a3 DIV_15     e6 StdIncPc   00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               0000500f close to fence
 * a4 SRxI_0     3a SRxI_1     00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_3     af MRET_4     00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * a6 ECAL_RET   d0 ECALL_1    00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * a7 EBRKWFI1   61 EBRKWFI2   00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * a8 DIV_3      78 DIV_4      01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00005023 close to store
 * a9 ILL_4      34 JAL_3      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * aa DIV_6      c8 DIV_7      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            40005023 close to store
 * ab EBREAK_2   9a ECALL_6    00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * ac _L0xac     3f SRx_1      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     e0 DIVU_1     00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     3f SRx_1      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_4     c5 MRET_5     00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b0 CSRRW_3    b2 CSRRW_4    00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b1 aF_SW_3    92 LDAF_3     00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * b2 CSRRW_4    de Fetch      00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b3 unxb3         (use dinx) 0000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx b3: Not in use                                           00000000 
 * b4 eFetch3    73 unalignd   0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * b5 SH_3       9e SH_4       00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b6 ECALL_5    9a ECALL_6    00110010000000000000101011001100100110        Q = 8                                             00000000 
 * b7 IJ_3       bd IJ_4       00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * b8 BGE        13 condb_2    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 DIV_e      c0 DIV_D      00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00005067 close to jalr
 * ba LHU_3      1a ANDI_1     00000010000000000000011111101100010xx0        Invert q. Prepare read mask                       00000000 
 * bb SH_2       b5 SH_3       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * bc CSRRWI_0   49 CSRRW_1    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd IJ_4       de Fetch      00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * be IJ_1       1f IJ_2       00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * bf IJT_1      c1 IJT_2      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * c0 DIV_D      88 DIV_E      00000010000000000000111011101101001xx0        Is RS2 == 0?                                      00006003 close to load
 * c1 IJT_2      e9 IJT_3      00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * c2 DIVU_3     ca DIVU_2     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000600b close to ij
 * c3 DIVU_4     8a DIVU_5     01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000600f close to fence
 * c4 ORI_0      e1 ORI_1      00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_5     6f MRET_6     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * c6 IJT_4      47 ILL_2      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * c7 QINT_1     cb QINT_2     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * c8 DIV_7      62 DIV_8      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00006023 close to store
 * c9 MRET_2     a5 MRET_3     00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * ca DIVU_2     c2 DIVU_3     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            40006023 close to store
 * cb QINT_2     e6 StdIncPc   00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * cc OR_0       26 OR_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      82 DIV_1      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce _LCSRRCI_1 fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006033 sloppy or      
 * cf MRET_7     4f MRET_8     00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * d0 ECALL_1    37 ECALL_2    00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * d1 MRET_1     c9 MRET_2     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * d2 LB_2       06 LB_3       00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * d3 aFaultd    1e aFault_1   00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * d4 aFault_2   92 LDAF_3     00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * d5 Fetch2u       (use dinx) 0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * d6 eILL0c     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d7 ECALL_3    a1 ECALL_4    00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * d8 BLTU       13 condb_2    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MULH_3     42 MULHU_2    00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00006067 close to jalr
 * da LDAF_a     91 LDAF_2     00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * db jFault_1   92 LDAF_3     00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * dc CSRRSI_0   49 CSRRW_1    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd aF_SW_1    e5 aF_SW_2    00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * de Fetch      f4 Fetch2     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * df eFetch     f4 Fetch2     00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * e0 DIVU_1     ca DIVU_2     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00007003 close to load
 * e1 ORI_1      1d ORI_2      00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * e2 MUL_1      e8 MUL_2      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           0000700b close to ij
 * e3 MUL_3      1a ANDI_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               0000700f close to fence
 * e4 ANDI_0     1a ANDI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 aF_SW_2    b1 aF_SW_3    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * e6 StdIncPc   de Fetch      10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * e7 aFault     1e aFault_1   00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * e8 MUL_2      e2 MUL_1      00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00007023 close to store
 * e9 IJT_3      c6 IJT_4      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * ea MULHU_5    22 MULHU_6    00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          40007023 close to store
 * eb LH_3       56 LH_4       00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * ec AND_0      11 AND_1      00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     e0 DIVU_1     00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee eILL0a     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40007033 sloppy and     
 * ef WFI_5      de Fetch      00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * f0 LBU_2      72 LBU_3      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * f1 aFaulte    1e aFault_1   00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * f2 SW_2       e6 StdIncPc   00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * f3 aF_SW      dd aF_SW_1    00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * f4 Fetch2     b4 eFetch3    00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f5 jFault     db jFault_1   00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * f6 WFI_1      fa WFI_2      00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * f7 EBREAK_1   ab EBREAK_2   00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * f8 BGEU       13 condb_2    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 MULH_2     d9 MULH_3     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00007067 close to jalr
 * fa WFI_2      45 WFI_3      00010010000000000000101011101100100110        Check offset                                      00000000 
 * fb SB_3       6b SB_4       00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fc CSRRCI_0   49 CSRRW_1    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      7e NMI_1      00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       46 ILL_1      00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     c7 QINT_1     00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 
 */
/* Col   x   1   0
 *  45   0   3 253 Can not simplify, can't possibly represent between 3 and 3 high values with only 4 bits index
 *  44   0   8 248 Can not simplify, can't possibly represent between 8 and 8 high values with only 4 bits index
 *  43   0  35 221 Can not simplify, can't possibly represent between 35 and 35 high values with only 4 bits index
 *  42   0  64 192 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  41   9   4 243 Can not simplify, can't possibly represent between 4 and 13 high values with only 4 bits index
 *  40   9  17 230 Can not simplify, can't possibly represent between 17 and 26 high values with only 4 bits index
 *  39   9 140 107 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  38   9   4 243 Can not simplify, can't possibly represent between 4 and 13 high values with only 4 bits index
 *  37   9   9 238 
 * Candidate function 0002, used ffff, inputs 0f
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       09 LB_5       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 CSRRW_2    92 LDAF_3     00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 02 IJ_0       88 DIV_E      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     9e SH_4       00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     9e SH_4       00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 IJ_3       10 SUB_1      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 07 jFault_1   1a ANDI_1     00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 08 _L0x08     ca DIVU_2     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_1       73 unalignd   00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 0a _L0x0a     ca DIVU_2     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_3       df eFetch     00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      9c DIV_10     00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      22 MULHU_6    00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     9e SH_4       00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 LB_4       73 unalignd   00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 11 NMI_2      3a SRxI_1     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 12 condb_5    62 DIV_8      00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 13 condb_5t   30 SLTIX_2    00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 14 MULHU_2    39 MULHU_7    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 15 MULHU_4    12 straddle   00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 16 DIV_e      9e SH_4       00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 17 aF_SW_1    9a ECALL_6    00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 18 BEQ        2e MULHU_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     bf IJT_1      00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       9e SH_4       00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     85 LBU_1      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   82 DIV_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     9e SH_4       00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e eILL0b     81 unx81      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 1f MRET_8     06 LB_3       00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 20 LH_0       34 JAL_3      00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 LDAF_2     9e SH_4       00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 22 SUB_1      b9 DIV_e      00000010000000000000111111101100000xx0        Q = ~RS2                                          0000100b close to ij
 * 23 _L0x23     9e SH_4       00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     a5 MRET_3     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 SH_2       5d SB_2       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 27 DIVU_1     3d SRxI_2     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 28 _L0x28     74 unx74      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 AND_1      4b CSRRW_2    00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 2a _L0x2a     74 unx74      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b straddle   7a SB_5       10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2c SLL_0      bd IJ_4       00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     d2 LB_2       00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_2    14 condb_3    00000010000000000000111111101100000xx0        ~RS2 in Q                                         40001033 sloppy sll     
 * 2f _L0x2f     9e SH_4       00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 condb_3    9e SH_4       00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 31 SW_E4      65 WFI_4      00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 32 LW_1       df eFetch     00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 33 LDAF_LW       (use dinx) 00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 34 LH_1       9a ECALL_6    00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 35 LDAF_LH    af MRET_4     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 36 IJ_4       03 _L0x03     00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 37 ORI_1      95 SW_E3      00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 38 BNE        2e MULHU_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    9e SH_4       00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     bb SH_2       00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     85 LBU_1      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    c5 MRET_5     00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LH_2       a5 MRET_3     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultb    ba LHU_3      00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 40 LW_0       32 JAL_1      00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 ECALL_6    1d ORI_2      00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 42 DIV_A      ce _LCSRRCI_1 00110010000000000000101111101100001xx1        Transfer rM to rDee                               0000200b close to ij
 * 43 DIV_B      77 eFetchu    00000000000000001100111111101000110000        REM = Q to yy                                     0000200f close to fence
 * 44 SLTI_0     65 WFI_4      00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 aFault_1   d0 ECALL_1    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 46 IJT_2      c3 DIVU_4     00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * 47 aF_SW_2    e2 MUL_1      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 48 _L0x48     54 LH_2       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 IJ_2       01 LB_1       00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 4a _L0x4a     54 LH_2       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b XORI_1     f4 Fetch2     00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4c SLT_0      7d unx7d      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   70 LHU_2      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e LHU_1      fe ILLe       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40002033 sloppy slt     
 * 4f LDAF_LHU   9e SH_4       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 50 MULHU_6    9e SH_4       00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 51 ILL_4      f6 WFI_1      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 52 DIV_8      3e SLL_1      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 53 DIV_9      f6 WFI_1      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 54 SW_1       87 unx87      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 55 SW_E1SWE   45 WFI_3      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 MRET_5     c9 MRET_2     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * 57 MUL_2      73 unalignd   00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 58 DIV_12     d4 aFault_2   00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00002063 close to branch
 * 59 DIV_13     78 DIV_4      00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00002067 close to jalr
 * 5a OR_1       cb QINT_2     00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     85 LBU_1      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    c5 MRET_5     00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       b7 IJ_3       00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e LHU_2      5e LHU_1      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaultc    f6 WFI_1      00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 60 XOR_1      14 condb_3    00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00003003 close to load
 * 61 aF_SW_3    b5 SH_3       00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 62 Fetchu     86 JAL_2      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000300b close to ij
 * 63 eFetchu    42 MULHU_2    00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000300f close to fence
 * 64 SLTIU_0    65 WFI_4      00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLTIX_1    a3 DIV_15     00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 66 IJT_4      aa DIV_6      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 67 IJT_3      e5 aF_SW_2    00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 68 DIV_4      9e SH_4       00000000000000001100000011101000110000        ~abs(divisor) to yy                               00003023 close to store
 * 69 DIV_5      73 unalignd   00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 6a DIV_1      97 SW_E1SWH   00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40003023 close to store
 * 6b DIV_2      db jFault_1   00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 6c SLTU_0     7d unx7d      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    70 LHU_2      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_E      16 condb_5    01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             40003033 sloppy sltu    
 * 6f DIV_F      c6 IJT_4      00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 70 MULHU_1    ffffffff (null)     00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 71 QINT_2     45 WFI_3      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 72 DIVU_5     3a SRxI_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 73 LB_6       2b SLTIX_1    00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 74 SH_1          (use dinx) 00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 75 SW_E1SWH      (use dinx) 00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 76 QINT_1     d6 eILL0c     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 77 MULHU_5    d6 eILL0c     00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 78 DIV_10     f0 LBU_2      01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00003063 close to branch
 * 79 DIV_11     ef WFI_5      01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00003067 close to jalr
 * 7a SLTIX_2    aa DIV_6      00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 7b _L0x7b     85 LBU_1      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    c5 MRET_5     00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SLTX_1        (use dinx) 00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 7e DIV_14     11 AND_1      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00000000 
 * 7f DIV_15        (use dinx) 00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 80 LBU_0      de Fetch      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 aFault_2      (use dinx) 00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 82 ECAL_RET   ef WFI_5      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000400b close to ij
 * 83 EBRKWFI1   6a MULH_1     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000400f close to fence
 * 84 XORI_0     4b CSRRW_2    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 JAL_1      a8 DIV_3      00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 86 DIV_7      90 NMI_2      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * 87 LH_3          (use dinx) 00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 88 IJ_1       78 DIV_4      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00004023 close to store
 * 89 IJT_1      9e SH_4       00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 8a DIVU_3     3a SRxI_1     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           40004023 close to store
 * 8b DIVU_4     9e SH_4       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 8c XOR_0      60 MULHU_3    00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      6a MULH_1     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e ECALL_1    fe ILLe       00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40004033 sloppy xor     
 * 8f MRET_1     51 LDAF_LW    00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 90 JAL_3      90 NMI_2      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 91 (null)     e3 MUL_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 92 LB_2       90 NMI_2      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 93 aFaultd    e8 MUL_2      00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 94 eILL0c     90 NMI_2      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 95 ECALL_3    31 SLTX_1     00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 96 MRET_2     26 OR_1       00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * 97 MULH_2     e5 aF_SW_2    00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * 98 BLT        2e MULHU_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a Fetch      90 NMI_2      00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 9b eFetch        (use dinx) 00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 9c MUL_1      58 DIV_A      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00004073 close to csr/system 
 * 9d MUL_3      7e NMI_1      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 9e StdIncPc   ea MULHU_5    10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 9f aFault     aa DIV_6      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * a0 LHU_0      4e eILL0b     00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 (null)     fb SB_3       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * a2 eILL0a     73 unalignd   00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000500b close to ij
 * a3 WFI_5      9e SH_4       00110100000010001010110111000100100110        IncPC, OpFetch                                    0000500f close to fence
 * a4 SRxI_0     ba LHU_3      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SLLI_1     f3 aF_SW      00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * a6 DIVU_2     8e _LCSRRS_1  00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * a7 WFI_2      cf MRET_7     00010010000000000000101011101100100110        Check offset                                      00000000 
 * a8 LBU_2      68 DIV_12     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00005023 close to store
 * a9 aFaulte    90 NMI_2      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * aa SW_2       86 JAL_2      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   40005023 close to store
 * ab aF_SW      41 JALR_1     00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * ac _L0xac     be IJ_1       00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     27 OR_2       00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     be IJ_1       00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SLLI_2     56 LH_4       00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * b0 ECALL_2    f5 jFault     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * b1 (null)     e3 MUL_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b2 Fetch2     9a ECALL_6    00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * b3 jFault        (use dinx) 00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * b4 WFI_1      da LDAF_a     00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * b5 EBREAK_1   e9 IJT_3      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * b6 _LCSRRCI_1 41 JALR_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b7 SB_3       36 SLLI_2     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b8 BGE        2e MULHU_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MULHU_7    ffffffff (null)     00100000000000000100001011101000001xx0        Last shift.                                       00005067 close to jalr
 * ba SRxI_1     3a SRxI_1     00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * bb SRxI_2     fa WFI_2      00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * bc CSRRWI_0   c5 MRET_5     00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SLL_1      9a ECALL_6    00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * be SRx_1      49 CSRRW_1    00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * bf JALR_1     46 ILL_1      00010010000000000000000011101100100110        Q=1                                               00000000 
 * c0 WFI_3      6e DIV_C      00010010000000000000101011101100100110        More check offset                                 00006003 close to load
 * c1 (null)     67 SW_E1SWE   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c2 ILL_1      a6 ECAL_RET   00000000000000001101101011100x00001xx0        Store PC to mepc                                  0000600b close to ij
 * c3 ILL_2      72 LBU_3      00000000000000001111101011101000001xx0        Store 0 to mtval                                  0000600f close to fence
 * c4 ORI_0      37 ECALL_2    00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 CSRRW_1    d5 Fetch2u    00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * c6 MRET_7     c3 DIVU_4     00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * c7 (null)     71 aFaultc    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c8 LH_4       52 LH_1       00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00006023 close to store
 * c9 LH_5       ee eILL0a     00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * ca SB_1       8a DIVU_5     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        40006023 close to store
 * cb SB_2       9e SH_4       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      6a MULH_1     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce MULHU_3    fe ILLe       00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  40006033 sloppy or      
 * cf EBRKWFI2   1f IJ_2       00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * d0 WFI_4      b0 CSRRW_3    00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * d1 (null)     96 SH_1       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d2 MULH_1     0b JALR_2     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * d3 SB_4       45 WFI_3      00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * d4 DIV_C      e3 MUL_3      00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * d5 MRET_6        (use dinx) 00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * d6 Fetch2u    fe ILLe       0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * d7 (null)     eb LH_3       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d8 BLTU       2e MULHU_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 LBU_3      14 condb_3    00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00006067 close to jalr
 * da unalignd   21 XORI_1     00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * db SB_5       e3 MUL_3      00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * dc CSRRSI_0   c5 MRET_5     00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd NMI_1      47 ILL_2      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * de LBU_1      b2 CSRRW_4    00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * df JAL_2      b2 CSRRW_4    10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * e0 _LCSRRS_1  a6 ECAL_RET   00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00007003 close to load
 * e1 (null)     3d SRxI_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e2 ILL_3      57 LH_5       00000010000000000000101011101100100110        Q = 1                                             0000700b close to ij
 * e3 LDAF_3     3a SRxI_1     00000000000000001101100111100x00001xx0        PC to mepc                                        0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SW_E2      61 EBRKWFI2   00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * e6 MULH_3     9a ECALL_6    00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * e7 (null)     45 WFI_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e8 SW_E3      9c DIV_10     00110010000000000000101111001100100110        Q = 3                                             00007023 close to store
 * e9 SH_4       66 SW_1       00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * ea SH_5       50 LW_1       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     40007023 close to store
 * eb ECALL_4    c8 DIV_7      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * ec AND_0      29 XOR_1      00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     27 OR_2       00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee MRET_3     fe ILLe       00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          40007033 sloppy and     
 * ef DIV_3      9a ECALL_6    01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * f0 DIV_6      d9 MULH_3     00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * f1 (null)     45 WFI_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f2 EBREAK_2   9e SH_4       00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * f3 MRET_4     17 condb_5t   00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * f4 CSRRW_3    f9 MULH_2     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * f5 CSRRW_4    07 LB_4       00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * f6 LDAF_a     a7 EBRKWFI1   00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * f7 (null)     f2 SW_2       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2e MULHU_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 eFetch3    e6 StdIncPc   0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00007067 close to jalr
 * fa SH_3       c0 DIV_D      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fb ECALL_5    d3 aFaultd    00110010000000000000101011001100100110        Q = 8                                             00000000 
 * fc CSRRCI_0   c5 MRET_5     00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      dd aF_SW_1    00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       c2 DIVU_3     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     76 Fetchu     00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0002, used ffff, inputs 17
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       0b JALR_2     00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 CSRRW_2    76 Fetchu     00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 02 IJ_0       6e DIV_C      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     86 JAL_2      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     86 JAL_2      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    1d ORI_2      00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   22 MULHU_6    00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     b7 IJ_3       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 NMI_2      59 DIV_B      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 0a _L0x0a     b7 IJ_3       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_1       cb QINT_2     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      82 DIV_1      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      2e MULHU_1    00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     86 JAL_2      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    59 DIV_B      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    53 LDAF_LH    00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 jFault_1   4e eILL0b     00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 13 LB_3       45 WFI_3      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 14 eILL0b     4b CSRRW_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 15 MRET_8     06 LB_3       00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 16 LW_1       86 JAL_2      00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LW    7e NMI_1      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        3d SRxI_2     00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     af MRET_4     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a aF_SW_1    86 JAL_2      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 1b _L0x1b     9e SH_4       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   6a MULH_1     00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d LB_4       86 JAL_2      00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 1e LH_1       81 unx81      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 1f LDAF_LH    e6 StdIncPc   00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 20 LH_0       1e aFault_1   00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 LDAF_2     86 JAL_2      00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 22 LB_5       a6 ECAL_RET   00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       0000100b close to ij
 * 23 _L0x23     86 JAL_2      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     a2 DIV_14     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 LH_2       85 LBU_1      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 27 aFaultb    5d SB_2       00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 28 _L0x28     5e LHU_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 SW_E4      68 DIV_12     00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 2a _L0x2a     5e LHU_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b JALR_2     9c DIV_10     00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 2c SLL_0      aa DIV_6      00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     bf IJT_1      00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e SUB_1      10 SUB_1      00000010000000000000111111101100000xx0        Q = ~RS2                                          40001033 sloppy sll     
 * 2f _L0x2f     86 JAL_2      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 DIV_A      86 JAL_2      00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 31 DIV_B      93 SW_E2      00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 32 DIVU_1     cb QINT_2     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 33 AND_1         (use dinx) 00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 34 LHU_1      7e NMI_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 35 LDAF_LHU   a3 DIV_15     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 36 DIV_8      03 _L0x03     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 37 DIV_9      79 DIV_5      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 38 BNE        3d SRxI_2     00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 straddle   86 JAL_2      10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00001067 close to jalr
 * 3a ORI_1      a8 DIV_3      00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 3b _L0x3b     9e SH_4       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    b4 eFetch3    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d condb_2    03 _L0x03     00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 3e SW_1       a2 DIV_14     00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 3f SW_E1SWE   a7 EBRKWFI1   00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 40 LW_0       16 condb_5    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 ECALL_6    2b SLTIX_1    00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 42 DIV_12     bb SH_2       00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              0000200b close to ij
 * 43 DIV_13     7a SB_5       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  0000200f close to fence
 * 44 SLTI_0     93 SW_E2      00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 condb_3    be IJ_1       00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 46 LHU_2      b3 unxb3      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultc    cf MRET_7     00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 48 _L0x48     3e SLL_1      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 ILL_4      01 LB_1       00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 4a _L0x4a     3e SLL_1      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b condb_4    df eFetch     00000010000000000000000011101101001xx0        Branch on condition                               00000000 
 * 4c SLT_0      9d DIV_11     00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   9b unx9b      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e Fetchu     fe ILLe       00000010000000000000001111101010110000  Fr10u Read and latch instruction                        40002033 sloppy slt     
 * 4f eFetchu    86 JAL_2      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 50 DIV_4      86 JAL_2      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 51 DIV_5      fb SB_3       00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 52 aF_SW_2    26 OR_1       00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 53 ANDI_1     fb SB_3       00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 54 DIV_1      92 LDAF_3     00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 55 DIV_2      60 MULHU_3    00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 56 DIV_E      b6 ECALL_5    01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 57 DIV_F      59 DIV_B      00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 58 DIVU_5     c2 DIVU_3     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00002063 close to branch
 * 59 LB_6       62 DIV_8      00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00002067 close to jalr
 * 5a MUL_2      b9 DIV_e      00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 5b _L0x5b     9e SH_4       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    b4 eFetch3    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d ORI_2      ba LHU_3      00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 5e SH_1       46 ILL_1      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5f SW_E1SWH   fb SB_3       00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 60 aFault_1   10 SUB_1      00110010000000000000101011001100100110        Q = 4                                             00003003 close to load
 * 61 aF_SW_3    97 SW_E1SWH   00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 62 DIV_10     f1 aFaulte    01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    0000300b close to ij
 * 63 DIV_11     30 SLTIX_2    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    0000300f close to fence
 * 64 SLTIU_0    93 SW_E2      00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 IJ_2       8b LB_6       00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 66 DIV_14     90 NMI_2      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00000000 
 * 67 DIV_15     d1 MRET_1     00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 68 XORI_1     86 JAL_2      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00003023 close to store
 * 69 QINT_2     59 DIV_B      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 6a ECAL_RET   9a ECALL_6    00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40003023 close to store
 * 6b EBRKWFI1   c7 QINT_1     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 6c SLTU_0     9d DIV_11     00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    9b unx9b      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e IJ_1       e7 aFault     00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   40003033 sloppy sltu    
 * 6f IJT_1      f6 WFI_1      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 70 DIVU_3     ffffffff (null)     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 71 DIVU_4     60 MULHU_3    01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 72 IJT_3      53 LDAF_LH    00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 73 MULHU_6    39 MULHU_7    00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 74 ECALL_1       (use dinx) 00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 75 MRET_1        (use dinx) 00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 76 LB_2       f7 EBREAK_1   00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 77 aFaultd    f7 EBREAK_1   00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 78 eILL0c     db jFault_1   00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00003063 close to branch
 * 79 ECALL_3    d9 MULH_3     00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00003067 close to jalr
 * 7a MULHU_5    90 NMI_2      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 7b _L0x7b     9e SH_4       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    b4 eFetch3    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d OR_1          (use dinx) 00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 7e Fetch      09 LB_5       00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 7f eFetch        (use dinx) 00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 80 LBU_0      ca DIVU_2     00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 aFault_2      (use dinx) 00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 82 MUL_1      d9 MULH_3     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           0000400b close to ij
 * 83 MUL_3      54 LH_2       00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               0000400f close to fence
 * 84 XORI_0     68 DIV_12     00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 OR_2       8e _LCSRRS_1  00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 86 StdIncPc   9f SH_5       10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 87 aFault        (use dinx) 00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 88 XOR_1      62 DIV_8      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00004023 close to store
 * 89 (null)     86 JAL_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 8a eILL0a     53 LDAF_LH    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40004023 close to store
 * 8b WFI_5      86 JAL_2      00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 8c XOR_0      88 DIV_E      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      54 LH_2       01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e LBU_2      fe ILLe       00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40004033 sloppy xor     
 * 8f aFaulte    49 CSRRW_1    00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 90 SW_2       9f SH_5       00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 91 aF_SW      d0 ECALL_1    00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 92 LH_3       9f SH_5       00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 93 SLTIX_1    d3 aFaultd    00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 94 Fetch2     9f SH_5       00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 95 jFault     29 XOR_1      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 96 WFI_1      e8 MUL_2      00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 97 EBREAK_1   d1 MRET_1     00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 98 BLT        3d SRxI_2     00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a MULH_2     9f SH_5       00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * 9b MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 9c SLTIX_2    42 MULHU_2    00000000000000000100001011101000110010        Registered ALU flag to rd                         00004073 close to csr/system 
 * 9d SLTX_1     66 SW_1       00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 9e JAL_1      d5 Fetch2u    00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 9f JAL_3      90 NMI_2      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a0 LHU_0      34 JAL_3      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 (null)     e5 aF_SW_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * a2 SLLI_1     59 DIV_B      00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      0000500b close to ij
 * a3 SLLI_2     86 JAL_2      00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                0000500f close to fence
 * a4 SRxI_0     a7 EBRKWFI1   00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 ECALL_2    de Fetch      00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * a6 MULHU_7    74 unx74      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * a7 SRxI_1     bd IJ_4       00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * a8 SRxI_2     50 LW_1       00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00005023 close to store
 * a9 (null)     9f SH_5       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * aa SLL_1      f1 aFaulte    00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              40005023 close to store
 * ab SRx_1      41 JALR_1     00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * ac _L0xac     ab EBREAK_2   00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     32 JAL_1      00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     ab EBREAK_2   00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af JALR_1     ee eILL0a     00010010000000000000000011101100100110        Q=1                                               00000000 
 * b0 WFI_3      e0 DIVU_1     00010010000000000000101011101100100110        More check offset                                 00000000 
 * b1 ILL_1      d0 ECALL_1    00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * b2 WFI_2      7e NMI_1      00010010000000000000101011101100100110        Check offset                                      00000000 
 * b3 ILL_2         (use dinx) 00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * b4 CSRRW_1    c6 IJT_4      00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * b5 LH_4       d4 aFault_2   00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * b6 LH_5       41 JALR_1     00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * b7 SB_1       ea MULHU_5    00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * b8 BGE        3d SRxI_2     00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SB_2       ffffffff (null)     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00005067 close to jalr
 * ba SB_3       53 LDAF_LH    00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * bb MULHU_3    e3 MUL_3      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * bc CSRRWI_0   b4 eFetch3    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd EBRKWFI2   7e NMI_1      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * be WFI_4      65 WFI_4      00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * bf MULH_1     eb LH_3       00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * c0 SB_4       56 LH_4       00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00006003 close to load
 * c1 (null)     72 LBU_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c2 DIV_C      f4 Fetch2     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              0000600b close to ij
 * c3 MRET_6     58 DIV_A      00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            0000600f close to fence
 * c4 ORI_0      3a SRxI_1     00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 LBU_3      c3 DIVU_4     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * c6 unalignd   b3 unxb3      00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * c7 SB_5       69 DIV_13     00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * c8 NMI_1      36 SLLI_2     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00006023 close to store
 * c9 (null)     d7 ECALL_3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ca LBU_1      70 LHU_2      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40006023 close to store
 * cb JAL_2      86 JAL_2      10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * cc OR_0       7d unx7d      00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      54 LH_2       01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce _LCSRRS_1  fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006033 sloppy or      
 * cf ILL_3      15 condb_4    00000010000000000000101011101100100110        Q = 1                                             00000000 
 * d0 LDAF_3     a5 MRET_3     00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * d1 SW_E2      f3 aF_SW      00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * d2 (null)     13 condb_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d3 SW_E3      60 MULHU_3    00110010000000000000101111001100100110        Q = 3                                             00000000 
 * d4 SH_4       d0 ECALL_1    00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * d5 SH_5          (use dinx) 00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * d6 ECALL_4    fe ILLe       00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d7 MRET_3     d6 eILL0c     00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * d8 BLTU       3d SRxI_2     00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 DIV_3      10 SUB_1      01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00006067 close to jalr
 * da (null)     21 XORI_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * db DIV_6      d0 ECALL_1    00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * dc CSRRSI_0   b4 eFetch3    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd EBREAK_2   52 LH_1       00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * de MRET_4     94 SW_E4      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * df CSRRW_3    94 SW_E4      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * e0 CSRRW_4    f4 Fetch2     00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00007003 close to load
 * e1 (null)     5d SB_2       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e2 eFetch3    5a SB_1       0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   0000700b close to ij
 * e3 SH_3       53 LDAF_LH    00000010000000000000000011101000110000        Prepare get back address to use                   0000700f close to fence
 * e4 ANDI_0     53 LDAF_LH    00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 ECALL_5    61 EBRKWFI2   00110010000000000000101011001100100110        Q = 8                                             00000000 
 * e6 IJ_3       7e NMI_1      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * e7 DIV_e      60 MULHU_3    00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * e8 SH_2       82 DIV_1      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00007023 close to store
 * e9 (null)     ef WFI_5      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ea IJ_4       73 unalignd   00000100000010001010110111100100011xx0        Mask and use as PC                                40007023 close to store
 * eb IJT_2      b5 SH_3       00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * ec AND_0      33 unx33      00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     32 JAL_1      00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee MRET_5     fe ILLe       00000010000000000000000011101100010xx0        ~302                                              40007033 sloppy and     
 * ef IJT_4      7e NMI_1      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * f0 QINT_1     c5 MRET_5     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * f1 DIV_7      60 MULHU_3    00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f2 (null)     86 JAL_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f3 MRET_2     1a ANDI_1     00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * f4 DIVU_2     e2 MUL_1      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f5 _LCSRRCI_1 12 straddle   00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f6 MRET_7     b2 CSRRW_4    00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f7 Fetch2u    dd aF_SW_1    0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f8 BGEU       3d SRxI_2     00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 MULH_3     f9 MULH_2     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00007067 close to jalr
 * fa (null)     b0 CSRRW_3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb LDAF_a     c0 DIV_D      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * fc CSRRCI_0   b4 eFetch3    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      c8 DIV_7      00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       b1 aF_SW_3    00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     f0 LBU_2      00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0100, used ffff, inputs 1b
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       9e SH_4       00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       8e _LCSRRS_1  00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     aa DIV_6      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     aa DIV_6      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     df eFetch     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       7f unx7f      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     df eFetch     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       f9 MULH_2     00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      a8 DIV_3      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     aa DIV_6      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 CSRRW_2    7f unx7f      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 11 LDAF_3     3a SRxI_1     00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 12 IJ_3       68 DIV_12     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 13 jFault_1   2e MULHU_1    00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 14 NMI_2      39 MULHU_7    00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 15 SW_E2      06 LB_3       00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 16 DIV_e      aa DIV_6      00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 17 aF_SW_1    a6 ECAL_RET   00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     ce _LCSRRCI_1 00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       aa DIV_6      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   8a DIVU_5     00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     aa DIV_6      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e MULHU_2    90 NMI_2      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 1f MULHU_4    12 straddle   00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 20 LH_0       42 MULHU_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      aa DIV_6      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      c5 MRET_5     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     aa DIV_6      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     af MRET_4     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 eILL0b     5d SB_2       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     3d SRxI_2     00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     82 DIV_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     82 DIV_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      ca DIVU_2     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     e5 aF_SW_2    00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    1e aFault_1   00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     aa DIV_6      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LDAF_2     aa DIV_6      00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 31 SW_E3      7a SB_5       00110010000000000000101111001100100110        Q = 3                                             00000000 
 * 32 SH_2       f9 MULH_2     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 33 DIVU_1        (use dinx) 00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 34 SW_E4      a6 ECAL_RET   00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 35 SH_4       b9 DIV_e      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 36 IJ_4       03 _L0x03     00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 37 ORI_1      a3 DIV_15     00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    aa DIV_6      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     c9 MRET_2     00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    db jFault_1   00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LW_1       af MRET_4     00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    c8 DIV_7      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 LH_1       e1 ORI_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH    77 eFetchu    00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       e3 MUL_3      00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 LH_2       da LDAF_a     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    fb SB_3       00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     10 SUB_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    b5 SH_3       00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_A      fe ILLe       00110010000000000000101111101100001xx1        Transfer rM to rDee                               40002033 sloppy slt     
 * 4f DIV_B      aa DIV_6      00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 50 ECALL_6    aa DIV_6      00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 51 SH_5       f6 WFI_1      00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 52 IJT_2      46 ILL_1      00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * 53 aF_SW_2    f6 WFI_1      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 54 ILL_4      93 SW_E2      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 55 ECALL_4    41 JALR_1     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 56 MRET_5     de Fetch      00000010000000000000000011101100010xx0        ~302                                              00000000 
 * 57 MUL_2      7f unx7f      00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 58 LHU_1      e7 aFault     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00002063 close to branch
 * 59 LDAF_LHU   86 JAL_2      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00002067 close to jalr
 * 5a OR_1       e0 DIVU_1     00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    db jFault_1   00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       b7 IJ_3       00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIV_8      66 SW_1       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 5f DIV_9      f6 WFI_1      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 60 SW_1       1e aFault_1   00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00003003 close to load
 * 61 SW_E1SWE   c7 QINT_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 DIV_12     92 LDAF_3     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              0000300b close to ij
 * 63 DIV_13     4e eILL0b     00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      bb SH_2       00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 LHU_2      c0 DIV_D      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 67 aFaultc    15 condb_4    00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 68 Fetchu     aa DIV_6      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00003023 close to store
 * 69 eFetchu    7f unx7f      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 6a DIV_4      97 SW_E1SWH   00000000000000001100000011101000110000        ~abs(divisor) to yy                               40003023 close to store
 * 6b DIV_5      eb LH_3       00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_1      16 condb_5    00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40003033 sloppy sltu    
 * 6f DIV_2      d2 LB_2       00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 70 aF_SW_3    ffffffff (null)     00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 71 MRET_3     41 JALR_1     00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * 72 IJT_4      3a SRxI_1     00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 73 IJT_3      29 XOR_1      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 74 QINT_2        (use dinx) 00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 75 DIV_3         (use dinx) 01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * 76 QINT_1     d6 eILL0c     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 77 MULHU_5    d6 eILL0c     00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 78 DIV_E      91 LDAF_2     01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003063 close to branch
 * 79 DIV_F      75 unx75      00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00003067 close to jalr
 * 7a SLTIX_1    c0 DIV_D      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    db jFault_1   00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e DIVU_5     14 condb_3    00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 7f LB_6          (use dinx) 00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 80 LBU_0      ef WFI_5      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 SH_1       75 unx75      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        0000400b close to ij
 * 83 SW_E1SWH   6e DIV_C      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     be IJ_1       00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 DIV_10     a5 MRET_3     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 87 DIV_11        (use dinx) 01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 88 DIV_14     86 JAL_2      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00004023 close to store
 * 89 DIV_15     aa DIV_6      00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 8a ECAL_RET   3a SRxI_1     00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40004023 close to store
 * 8b EBRKWFI1   aa DIV_6      00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      6e DIV_C      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e IJ_1       fe ILLe       00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   40004033 sloppy xor     
 * 8f IJT_1      54 LH_2       00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 90 aFault_2   a5 MRET_3     00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 91 DIV_6      11 AND_1      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * 92 DIV_7      a5 MRET_3     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * 93 LH_3       31 SLTX_1     00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 94 (null)     a5 MRET_3     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 95 EBREAK_2   34 JAL_3      00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * 96 MRET_2     32 JAL_1      00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * 97 MULH_2     15 condb_4    00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a DIVU_3     a5 MRET_3     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 9b DIVU_4        (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 9c ECALL_1    62 DIV_8      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00004073 close to csr/system 
 * 9d MRET_1     88 DIV_E      00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 9e LB_2       51 LDAF_LW    00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 9f aFaultd    c0 DIV_D      00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * a0 LHU_0      58 DIV_A      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JAL_1      f5 jFault     00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * a2 eILL0c     7f unx7f      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000500b close to ij
 * a3 ECALL_3    aa DIV_6      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    0000500f close to fence
 * a4 SRxI_0     c8 DIV_7      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 JAL_3      b1 aF_SW_3    00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a6 Fetch      9c DIV_10     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * a7 eFetch     e2 MUL_1      00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * a8 MUL_1      6a MULH_1     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00005023 close to store
 * a9 MUL_3      a5 MRET_3     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * aa StdIncPc   92 LDAF_3     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    40005023 close to store
 * ab aFault     50 LW_1       00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * ac _L0xac     cb QINT_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     33 unx33      00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     cb QINT_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SLLI_1     56 LH_4       00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * b0 (null)     d1 MRET_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b1 MRET_4     11 AND_1      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b2 DIVU_2     a6 ECAL_RET   00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * b3 WFI_2         (use dinx) 00010010000000000000101011101100100110        Check offset                                      00000000 
 * b4 (null)     ea MULHU_5    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b5 CSRRW_3    35 SLLI_1     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b6 _LCSRRCI_1 50 LW_1       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b7 SB_3       36 SLLI_2     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SLLI_2     ffffffff (null)     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00005067 close to jalr
 * ba eILL0a     3a SRxI_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bb WFI_5      f1 aFaulte    00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * bc CSRRWI_0   db jFault_1   00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ECALL_2    a6 ECAL_RET   00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * be LBU_2      45 WFI_3      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * bf aFaulte    52 LH_1       00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * c0 SW_2       78 DIV_4      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00006003 close to load
 * c1 aF_SW      73 unalignd   00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * c2 Fetch2     b2 CSRRW_4    00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     0000600b close to ij
 * c3 jFault     7e NMI_1      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000600f close to fence
 * c4 ORI_0      37 ECALL_2    00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MULHU_7    e8 MUL_2      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * c6 WFI_1      da LDAF_a     00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * c7 EBREAK_1   74 unx74      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * c8 SRxI_1     5e LHU_1      00000000000000000100101001101100001xx1        Register to shift to Q                            00006023 close to store
 * c9 SRxI_2     71 aFaultc    00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * ca SLL_1      9a ECALL_6    00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              40006023 close to store
 * cb SRx_1      aa DIV_6      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      6e DIV_C      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce JALR_1     fe ILLe       00010010000000000000000011101100100110        Q=1                                               40006033 sloppy or      
 * cf WFI_3      27 OR_2       00010010000000000000101011101100100110        More check offset                                 00000000 
 * d0 (null)     bd IJ_4       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d1 CSRRW_4    96 SH_1       00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d2 MRET_7     09 LB_5       00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * d3 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d4 (null)     11 AND_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d5 eFetch3       (use dinx) 0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * d6 Fetch2u    fe ILLe       0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * d7 (null)     55 aFaultb    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 ILL_1      1e aFault_1   00000000000000001101101011100x00001xx0        Store PC to mepc                                  00006067 close to jalr
 * da ILL_2      30 SLTIX_2    00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * db CSRRW_1    11 AND_1      00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * dc CSRRSI_0   db jFault_1   00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd LH_4       53 LDAF_LH    00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * de LH_5       c2 DIVU_3     00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * df SB_1       c2 DIVU_3     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * e0 SB_2       b2 CSRRW_4    00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00007003 close to load
 * e1 MULHU_3    3d SRxI_2     00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * e2 EBRKWFI2   57 LH_5       00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         0000700b close to ij
 * e3 WFI_4      3a SRxI_1     00000010000000000000001011x01001xxxxx0        Prepare read PC                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 MULH_1     70 LHU_2      00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * e6 SB_4       a6 ECAL_RET   00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * e7 DIV_C      41 JALR_1     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * e8 MRET_6     a8 DIV_3      00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00007023 close to store
 * e9 LBU_3      72 LBU_3      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * ea unalignd   4b CSRRW_2    00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                40007023 close to store
 * eb SB_5       dd aF_SW_1    00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     33 unx33      00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee NMI_1      fe ILLe       00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40007033 sloppy and     
 * ef LBU_1      a6 ECAL_RET   00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * f0 (null)     e9 IJT_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f1 SH_3       41 JALR_1     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f2 MULH_3     aa DIV_6      00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * f3 (null)     17 condb_5t   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 (null)     d5 Fetch2u    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f5 ECALL_5    13 condb_2    00110010000000000000101011001100100110        Q = 8                                             00000000 
 * f6 LDAF_a     b3 unxb3      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * f7 (null)     95 SW_E3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 JAL_2      f2 SW_2       10110000000000000100110011000x00100110        Return address to TRG                             00007067 close to jalr
 * fa _LCSRRS_1  cf MRET_7     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * fb ILL_3      e6 StdIncPc   00000010000000000000101011101100100110        Q = 1                                             00000000 
 * fc CSRRCI_0   db jFault_1   00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      ee eILL0a     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       d9 MULH_3     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     76 Fetchu     00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0020, used ffff, inputs 1d
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       be IJ_1       00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       a2 DIV_14     00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     ce _LCSRRCI_1 00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     ce _LCSRRCI_1 00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    1d ORI_2      00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   21 XORI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     fb SB_3       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 CSRRW_2    87 unx87      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 0a _L0x0a     fb SB_3       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b NMI_2      d2 LB_2       00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      c6 IJT_4      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      2e MULHU_1    00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     ce _LCSRRCI_1 00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 SB_2       87 unx87      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 11 LDAF_3     5a SB_1       00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 12 MULHU_3    6e DIV_C      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * 13 SW_E2      41 JALR_1     00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 14 IJ_3       45 WFI_3      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 15 jFault_1   06 LB_3       00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 16 DIV_e      ce _LCSRRCI_1 00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 17 aF_SW_1    c2 DIVU_3     00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 18 BEQ        3d SRxI_2     00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     e5 aF_SW_2    00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_3       ce _LCSRRCI_1 00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 1b _L0x1b     a8 DIV_3      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   9e SH_4       00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d LB_4       ce _LCSRRCI_1 00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 1e MULHU_2    89 DIV_F      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 1f MULHU_4    14 condb_3    00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 20 LH_0       42 MULHU_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 LB_5       ce _LCSRRCI_1 00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 22 JALR_2     c5 MRET_5     00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        0000100b close to ij
 * 23 _L0x23     ce _LCSRRCI_1 00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     af MRET_4     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 eILL0b     81 unx81      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     5d SB_2       00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     8e _LCSRRS_1  00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 LDAF_2     6a MULH_1     00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 2a _L0x2a     8e _LCSRRS_1  00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b SW_E4      a1 ECALL_4    00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 2c SLL_0      d9 MULH_3     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     50 LW_1       00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e SUB_1      1e aFault_1   00000010000000000000111111101100000xx0        Q = ~RS2                                          40001033 sloppy sll     
 * 2f _L0x2f     ce _LCSRRCI_1 00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 EBRKWFI2   ce _LCSRRCI_1 00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 31 SW_E3      88 DIV_E      00110010000000000000101111001100100110        Q = 3                                             00000000 
 * 32 WFI_4      d2 LB_2       00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 33 SH_4          (use dinx) 00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 34 SH_2       c2 DIVU_3     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 35 DIVU_1     b9 DIV_e      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 36 IJ_4       03 _L0x03     00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 37 ORI_1      c1 IJT_2      00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 38 BNE        3d SRxI_2     00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 AND_1      ce _LCSRRCI_1 00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00001067 close to jalr
 * 3a straddle   ca DIVU_2     10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 3b _L0x3b     a8 DIV_3      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    ef WFI_5      00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d condb_2    03 _L0x03     00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 3e LW_1       af MRET_4     00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    c8 DIV_7      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 condb_3    22 MULHU_6    00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 42 LH_1       12 straddle   00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH    77 eFetchu    00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     88 DIV_E      00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 condb_4    32 JAL_1      00000010000000000000000011101101001xx0        Branch on condition                               00000000 
 * 46 LH_2       ee eILL0a     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    f2 SW_2       00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 ECALL_6    09 LB_5       00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 4a _L0x4a     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b ILL_4      b3 unxb3      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 4c SLT_0      a5 MRET_3     00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   8a DIVU_5     00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_A      fe ILLe       00110010000000000000101111101100001xx1        Transfer rM to rDee                               40002033 sloppy slt     
 * 4f DIV_B      ce _LCSRRCI_1 00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 50 MULH_1     ce _LCSRRCI_1 00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * 51 SH_5       f6 WFI_1      00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 52 SB_4       46 ILL_1      00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 53 ECALL_4    f6 WFI_1      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 54 IJT_2      95 SW_E3      00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * 55 aF_SW_2    65 WFI_4      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 56 MRET_5     fa WFI_2      00000010000000000000000011101100010xx0        ~302                                              00000000 
 * 57 MUL_2      87 unx87      00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 58 LHU_1      70 LHU_2      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00002063 close to branch
 * 59 LDAF_LHU   9a ECALL_6    00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00002067 close to jalr
 * 5a ANDI_1     10 SUB_1      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 5b _L0x5b     a8 DIV_3      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    ef WFI_5      00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d ORI_2      b7 IJ_3       00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 5e DIV_8      66 SW_1       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 5f DIV_9      f6 WFI_1      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 60 SW_1       1e aFault_1   00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00003003 close to load
 * 61 SW_E1SWE   e7 aFault     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 DIV_12     94 SW_E4      00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              0000300b close to ij
 * 63 DIV_13     4e eILL0b     00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  0000300f close to fence
 * 64 SLTIU_0    88 DIV_E      00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 aFault_1   db jFault_1   00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 66 LHU_2      e0 DIVU_1     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 67 aFaultc    13 condb_2    00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 68 IJ_2       ce _LCSRRCI_1 00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00003023 close to store
 * 69 aF_SW_3    87 unx87      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 6a XORI_1     97 SW_E1SWH   00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   40003023 close to store
 * 6b QINT_2     b0 CSRRW_3    00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 6c SLTU_0     a5 MRET_3     00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    8a DIVU_5     00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e Fetchu     16 condb_5    00000010000000000000001111101010110000  Fr10u Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetchu    d4 aFault_2   00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 DIV_C      ffffffff (null)     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * 71 MRET_3     65 WFI_4      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * 72 MRET_6     5a SB_1       00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 73 DIV_3      3a SRxI_1     01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * 74 IJT_4         (use dinx) 00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 75 IJT_3         (use dinx) 00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 76 QINT_1     d6 eILL0c     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 77 MULHU_5    d6 eILL0c     00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 78 DIV_4      91 LDAF_2     00000000000000001100000011101000110000        ~abs(divisor) to yy                               00003063 close to branch
 * 79 DIV_5      73 unalignd   00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00003067 close to jalr
 * 7a MULHU_6    e0 DIVU_1     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 7b _L0x7b     a8 DIV_3      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    ef WFI_5      00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d OR_1          (use dinx) 00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 7e DIV_1      0b JALR_2     00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 7f DIV_2         (use dinx) 00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 80 LBU_0      d0 ECALL_1    00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 OR_2          (use dinx) 00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 82 DIV_E      73 unalignd   01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             0000400b close to ij
 * 83 DIV_F      7e NMI_1      00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       0000400f close to fence
 * 84 XORI_0     6a MULH_1     00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 XOR_1      de Fetch      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 86 DIVU_5     aa DIV_6      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 87 LB_6          (use dinx) 00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 88 SLTIX_1    9a ECALL_6    00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00004023 close to store
 * 89 aFault_2   ce _LCSRRCI_1 00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 8a MULHU_1    5a SB_1       00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                40004023 close to store
 * 8b (null)     ce _LCSRRCI_1 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 8c XOR_0      85 LBU_1      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      7e NMI_1      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e SH_1       fe ILLe       00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        40004033 sloppy xor     
 * 8f SW_E1SWH   4b CSRRW_2    00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 90 LBU_3      aa DIV_6      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 91 DIV_6      11 AND_1      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * 92 unalignd   aa DIV_6      00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * 93 EBREAK_2   31 SLTX_1     00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * 94 DIV_7      aa DIV_6      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * 95 LH_3       2b SLTIX_1    00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 96 MRET_2     34 JAL_3      00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * 97 MULH_2     13 condb_2    00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * 98 BLT        3d SRxI_2     00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a DIV_10     aa DIV_6      01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 9b DIV_11        (use dinx) 01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 9c DIV_14     62 DIV_8      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00004073 close to csr/system 
 * 9d DIV_15     9c DIV_10     00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 9e ECAL_RET   51 LDAF_LW    00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 9f EBRKWFI1   e0 DIVU_1     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * a0 LHU_0      58 DIV_A      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SLTIX_2    f3 aF_SW      00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * a2 IJ_1       87 unx87      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   0000500b close to ij
 * a3 IJT_1      ce _LCSRRCI_1 00000010000010000000101111101100001xx0        Exit CSR, enter trap                              0000500f close to fence
 * a4 SRxI_0     c8 DIV_7      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SLTX_1     b1 aF_SW_3    00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * a6 DIVU_3     ba LHU_3      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * a7 DIVU_4     30 SLTIX_2    01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * a8 JAL_1      78 DIV_4      00010000000000001100001011101000100000        Target adr to yy                                  00005023 close to store
 * a9 (null)     aa DIV_6      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * aa JAL_3      94 SW_E4      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                40005023 close to store
 * ab (null)     49 CSRRW_1    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ac _L0xac     dd aF_SW_1    00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     35 SLLI_1     00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     dd aF_SW_1    00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SLLI_1     56 LH_4       00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * b0 SB_5       d1 MRET_1     00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b1 MRET_4     11 AND_1      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b2 NMI_1      c2 DIVU_3     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * b3 CSRRW_3       (use dinx) 00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b4 DIVU_2     92 LDAF_3     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * b5 WFI_2      33 unx33      00010010000000000000101011101100100110        Check offset                                      00000000 
 * b6 _LCSRRCI_1 49 CSRRW_1    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b7 SB_3       36 SLLI_2     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b8 BGE        3d SRxI_2     00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SLLI_2     ffffffff (null)     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00005067 close to jalr
 * ba ECALL_1    5a SB_1       00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * bb MRET_1     f1 aFaulte    00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * bc CSRRWI_0   ef WFI_5      00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ECALL_2    c2 DIVU_3     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * be LB_2       68 DIV_12     00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * bf aFaultd    54 LH_2       00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * c0 eILL0c     82 DIV_1      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00006003 close to load
 * c1 ECALL_3    75 unx75      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * c2 Fetch      b4 eFetch3    00000001001010001000101111101010110000  Fr11  Read and latch instruction                        0000600b close to ij
 * c3 eFetch     86 JAL_2      00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             0000600f close to fence
 * c4 ORI_0      37 ECALL_2    00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MULHU_7    72 LBU_3      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * c6 MUL_1      ee eILL0a     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * c7 MUL_3      6b SB_4       00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * c8 SRxI_1     5e LHU_1      00000000000000000100101001101100001xx1        Register to shift to Q                            00006023 close to store
 * c9 (null)     71 aFaultc    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ca SRxI_2     a6 ECAL_RET   00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                40006023 close to store
 * cb (null)     ce _LCSRRCI_1 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * cc OR_0       7d unx7d      00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      7e NMI_1      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce StdIncPc   fe ILLe       10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    40006033 sloppy or      
 * cf aFault     27 OR_2       00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * d0 LBU_1      bd IJ_4       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * d1 CSRRW_4    96 SH_1       00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d2 JAL_2      1a ANDI_1     10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * d3 eFetch3    65 WFI_4      0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * d4 MRET_7     11 AND_1      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * d5 (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d6 Fetch2u    fe ILLe       0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * d7 (null)     53 LDAF_LH    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d8 BLTU       3d SRxI_2     00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 SLL_1      1e aFault_1   00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00006067 close to jalr
 * da eILL0a     29 XOR_1      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * db WFI_5      11 AND_1      00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * dc CSRRSI_0   ef WFI_5      00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd SRx_1      55 aFaultb    00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * de LBU_2      e2 MUL_1      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * df aFaulte    e2 MUL_1      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * e0 SW_2       b4 eFetch3    00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00007003 close to load
 * e1 aF_SW      5d SB_2       00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * e2 Fetch2     57 LH_5       00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     0000700b close to ij
 * e3 jFault     5a SB_1       00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000700f close to fence
 * e4 ANDI_0     5a SB_1       00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 JALR_1     69 DIV_13     00010010000000000000000011101100100110        Q=1                                               00000000 
 * e6 WFI_1      c2 DIVU_3     00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * e7 EBREAK_1   65 WFI_4      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * e8 WFI_3      c6 IJT_4      00010010000000000000101011101100100110        More check offset                                 00007023 close to store
 * e9 (null)     74 unx74      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ea ILL_1      7a SB_5       00000000000000001101101011100x00001xx0        Store PC to mepc                                  40007023 close to store
 * eb (null)     f9 MULH_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ec AND_0      39 MULHU_7    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     35 SLLI_1     00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee ILL_2      fe ILLe       00000000000000001111101011101000001xx0        Store 0 to mtval                                  40007033 sloppy and     
 * ef CSRRW_1    c2 DIVU_3     00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * f0 _LCSRRS_1  90 NMI_2      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f1 SH_3       65 WFI_4      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f2 ILL_3      ce _LCSRRCI_1 00000010000000000000101011101100100110        Q = 1                                             00000000 
 * f3 ECALL_5    17 condb_5t   00110010000000000000101011001100100110        Q = 8                                             00000000 
 * f4 MULH_3     d3 aFaultd    00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * f5 (null)     15 condb_4    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f6 LDAF_a     b5 SH_3       00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * f7 (null)     93 SW_E2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       3d SRxI_2     00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 LH_4       f4 Fetch2     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00007067 close to jalr
 * fa LH_5       e8 MUL_2      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * fb SB_1       52 LH_1       00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * fc CSRRCI_0   ef WFI_5      00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      b2 CSRRW_4    00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       ea MULHU_5    00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     76 Fetchu     00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0008, used ffff, inputs 1e
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       be IJ_1       00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       a8 DIV_3      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     ca DIVU_2     00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     ca DIVU_2     00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 CSRRW_2    0b JALR_2     00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 07 NMI_2      1a ANDI_1     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 08 _L0x08     fb SB_3       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       8f ILL_3      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     fb SB_3       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       d1 MRET_1     00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      c8 DIV_7      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     ca DIVU_2     00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 SB_2       8f ILL_3      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 11 MULHU_3    3a SRxI_1     00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * 12 LDAF_3     7e NMI_1      00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 13 SW_E2      2e MULHU_1    00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 14 IJ_3       39 MULHU_7    00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 15 DIV_e      1e aFault_1   00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 16 jFault_1   ca DIVU_2     00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 17 aF_SW_1    c2 DIVU_3     00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     e9 IJT_3      00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       ca DIVU_2     00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   a2 DIV_14     00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     ca DIVU_2     00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e condb_5    86 JAL_2      00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 1f condb_5t   14 condb_3    00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 20 LH_0       58 DIV_A      00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      ca DIVU_2     00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      c5 MRET_5     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     ca DIVU_2     00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     af MRET_4     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 LDAF_2     5d SB_2       00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 27 SW_E4      3d SRxI_2     00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 28 _L0x28     9a ECALL_6    00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     9a ECALL_6    00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      e5 aF_SW_2    00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     50 LW_1       00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    3e SLL_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     ca DIVU_2     00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 EBRKWFI2   ca DIVU_2     00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 31 WFI_4      7a SB_5       00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 32 SW_E3      d1 MRET_1     00110010000000000000101111001100100110        Q = 3                                             00000000 
 * 33 SH_4          (use dinx) 00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 34 SH_2       c2 DIVU_3     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 35 IJ_4       b9 DIV_e      00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 36 DIVU_1     03 _L0x03     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 37 ORI_1      c1 IJT_2      00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    ca DIVU_2     00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     dd aF_SW_1    00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    ef WFI_5      00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e MULHU_2    af MRET_4     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 3f MULHU_4    d9 MULH_3     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 40 LW_0       4e eILL0b     00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 eILL0b     11 AND_1      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000200b close to ij
 * 43 MRET_8     77 eFetchu    00010010000000000000101011101100100110        Prep +4                                           0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       31 SLTX_1     00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 ECALL_6    ee eILL0a     00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 47 ILL_4      f1 aFaulte    00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 48 _L0x48     6a MULH_1     00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     06 LB_3       00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     6a MULH_1     00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    b3 unxb3      00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e LW_1       fe ILLe       00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 40002033 sloppy slt     
 * 4f LDAF_LW    ca DIVU_2     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 50 MULH_1     ca DIVU_2     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * 51 SB_4       f5 jFault     00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 52 SH_5       5e LHU_1      00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 53 ECALL_4    f5 jFault     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 54 IJT_2      96 SH_1       00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * 55 MRET_5     41 JALR_1     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * 56 aF_SW_2    fa WFI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 57 MUL_2      8f ILL_3      00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 58 LH_1       70 LHU_2      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00002063 close to branch
 * 59 LDAF_LH    9c DIV_10     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00002067 close to jalr
 * 5a OR_1       10 SUB_1      00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    ef WFI_5      00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       b7 IJ_3       00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e LH_2       78 DIV_4      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaultb    f5 jFault     00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 60 DIV_A      3e SLL_1      00110010000000000000101111101100001xx1        Transfer rM to rDee                               00003003 close to load
 * 61 DIV_B      e3 MUL_3      00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 62 LHU_1      94 SW_E4      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000300b close to ij
 * 63 LDAF_LHU   60 MULHU_3    00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      cf MRET_7     00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 aF_SW_3    de Fetch      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 67 QINT_2     13 condb_2    00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 68 DIV_8      ca DIVU_2     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00003023 close to store
 * 69 DIV_9      8f ILL_3      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 6a SW_1       97 SW_E1SWH   00000000000000000011111011100100001xx0        Write d to a+k until accepted                     40003023 close to store
 * 6b SW_E1SWE   b0 CSRRW_3    00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_12     15 condb_4    00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              40003033 sloppy sltu    
 * 6f DIV_13     d4 aFault_2   00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 70 DIV_C      ffffffff (null)     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * 71 MRET_6     41 JALR_1     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 72 MRET_3     3a SRxI_1     00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * 73 DIV_3      29 XOR_1      01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * 74 IJT_4         (use dinx) 00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 75 QINT_1        (use dinx) 00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 76 IJT_3      d5 Fetch2u    00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 77 MULHU_5    d5 Fetch2u    00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 78 LHU_2      92 LDAF_3     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00003063 close to branch
 * 79 aFaultc    73 unalignd   00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00003067 close to jalr
 * 7a SLTIX_1    de Fetch      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    ef WFI_5      00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e Fetchu     07 LB_4       00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00000000 
 * 7f eFetchu       (use dinx) 00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 80 LBU_0      d0 ECALL_1    00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 DIV_4      73 unalignd   00000000000000001100000011101000110000        ~abs(divisor) to yy                               0000400b close to ij
 * 83 DIV_5      88 DIV_E      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     da LDAF_a     00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 aFault_2   a5 MRET_3     00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 87 (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 88 DIV_1      9c DIV_10     00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00004023 close to store
 * 89 DIV_2      ca DIVU_2     00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 8a DIV_E      3a SRxI_1     01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             40004023 close to store
 * 8b DIV_F      ca DIVU_2     00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      88 DIV_E      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e DIVU_5     fe ILLe       00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               40004033 sloppy xor     
 * 8f LB_6       47 ILL_2      00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 90 LBU_3      a5 MRET_3     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 91 unalignd   12 straddle   00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * 92 DIV_6      a5 MRET_3     00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * 93 EBREAK_2   32 JAL_1      00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * 94 DIV_7      a5 MRET_3     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * 95 MRET_2     27 OR_2       00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * 96 LH_3       34 JAL_3      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 97 MULH_2     13 condb_2    00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a SH_1       a5 MRET_3     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 9b SW_E1SWH      (use dinx) 00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 9c DIV_10     6e DIV_C      01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00004073 close to csr/system 
 * 9d DIV_11     9e SH_4       01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 9e DIV_14     52 LH_1       00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00000000 
 * 9f DIV_15     de Fetch      00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * a0 LHU_0      62 DIV_8      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JAL_1      f3 aF_SW      00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * a2 ECAL_RET   8f ILL_3      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000500b close to ij
 * a3 EBRKWFI1   ca DIVU_2     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000500f close to fence
 * a4 SRxI_0     d9 MULH_3     00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 JAL_3      b2 CSRRW_4    00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a6 (null)     ba LHU_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * a7 (null)     30 SLTIX_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * a8 IJ_1       82 DIV_1      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00005023 close to store
 * a9 IJT_1      a5 MRET_3     00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * aa DIVU_3     94 SW_E4      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           40005023 close to store
 * ab DIVU_4     46 ILL_1      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * ac _L0xac     e8 MUL_2      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     36 SLLI_2     00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     e8 MUL_2      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SLLI_1     55 aFaultb    00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * b0 SB_5       d2 LB_2       00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b1 NMI_1      12 straddle   00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * b2 MRET_4     c2 DIVU_3     00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b3 CSRRW_3       (use dinx) 00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b4 DIVU_2     91 LDAF_2     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * b5 _LCSRRCI_1 33 unx33      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b6 WFI_2      46 ILL_1      00010010000000000000101011101100100110        Check offset                                      00000000 
 * b7 SB_3       35 SLLI_1     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SLLI_2     ffffffff (null)     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00005067 close to jalr
 * ba ECALL_1    3a SRxI_1     00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * bb MRET_1     f2 SW_2       00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * bc CSRRWI_0   ef WFI_5      00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ECALL_2    c2 DIVU_3     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * be LB_2       45 WFI_3      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * bf aFaultd    54 LH_2       00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * c0 eILL0c     8a DIVU_5     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00006003 close to load
 * c1 ECALL_3    76 Fetchu     00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * c2 Fetch      b4 eFetch3    00000001001010001000101111101010110000  Fr11  Read and latch instruction                        0000600b close to ij
 * c3 eFetch     8e _LCSRRS_1  00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             0000600f close to fence
 * c4 ORI_0      37 ECALL_2    00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MULHU_7    71 aFaultc    00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * c6 (null)     ee eILL0a     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c7 (null)     67 SW_E1SWE   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c8 MUL_1      68 DIV_12     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00006023 close to store
 * c9 MUL_3      72 LBU_3      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * ca StdIncPc   aa DIV_6      10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    40006023 close to store
 * cb aFault     ca DIVU_2     00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      88 DIV_E      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce eILL0a     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006033 sloppy or      
 * cf WFI_5      43 MULHU_4    00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * d0 LBU_1      bd IJ_4       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * d1 JAL_2      95 SW_E3      10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * d2 CSRRW_4    09 LB_5       00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d3 eFetch3    41 JALR_1     0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * d4 MRET_7     12 straddle   00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * d5 Fetch2u       (use dinx) 0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * d6 (null)     fe ILLe       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d7 (null)     53 LDAF_LH    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 SRxI_1     3e SLL_1      00000000000000000100101001101100001xx1        Register to shift to Q                            00006067 close to jalr
 * da LBU_2      26 OR_1       00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * db aFaulte    12 straddle   00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * dc CSRRSI_0   ef WFI_5      00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd SRxI_2     56 LH_4       00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * de SW_2       e0 DIVU_1     00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * df aF_SW      e0 DIVU_1     00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * e0 Fetch2     b4 eFetch3    00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00007003 close to load
 * e1 jFault     3d SRxI_2     00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * e2 WFI_1      57 LH_5       00110010000000000000000011001100100110 WFI    To check offset                                   0000700b close to ij
 * e3 EBREAK_1   3a SRxI_1     00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SLL_1      66 SW_1       00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * e6 (null)     c2 DIVU_3     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e7 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e8 SRx_1      c8 DIV_7      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00007023 close to store
 * e9 JALR_1     74 unx74      00010010000000000000000011101100100110        Q=1                                               00000000 
 * ea WFI_3      4b CSRRW_2    00010010000000000000101011101100100110        More check offset                                 40007023 close to store
 * eb ILL_1      f9 MULH_2     00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     36 SLLI_2     00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee ILL_2      fe ILLe       00000000000000001111101011101000001xx0        Store 0 to mtval                                  40007033 sloppy and     
 * ef CSRRW_1    c2 DIVU_3     00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * f0 _LCSRRS_1  90 NMI_2      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f1 ILL_3      41 JALR_1     00000010000000000000101011101100100110        Q = 1                                             00000000 
 * f2 SH_3       ca DIVU_2     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f3 ECALL_5    17 condb_5t   00110010000000000000101011001100100110        Q = 8                                             00000000 
 * f4 MULH_3     d3 aFaultd    00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * f5 LDAF_a     16 condb_5    00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * f6 (null)     b6 ECALL_5    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     93 SW_E2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 LH_4       f4 Fetch2     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00007067 close to jalr
 * fa LH_5       ea MULHU_5    00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * fb SB_1       51 LDAF_LW    00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * fc CSRRCI_0   ef WFI_5      00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      b1 aF_SW_3    00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       eb LH_3       00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     75 unx75      00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0200, used ffff, inputs 27
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       66 SW_1       00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     82 DIV_1      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     82 DIV_1      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     a6 ECAL_RET   00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       55 aFaultb    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     a6 ECAL_RET   00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       bb SH_2       00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      7e NMI_1      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      22 MULHU_6    00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     82 DIV_1      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    55 aFaultb    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    41 JALR_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     46 ILL_1      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     3a SRxI_1     00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       3d SRxI_2     00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       82 DIV_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    76 Fetchu     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        30 SLTIX_2    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     9c DIV_10     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       82 DIV_1      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     81 unx81      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   62 DIV_8      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     82 DIV_1      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       a1 ECALL_4    00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    d2 LB_2       00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 CSRRW_2    82 DIV_1      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 22 SUB_1      95 SW_E3      00000010000000000000111111101100000xx0        Q = ~RS2                                          0000100b close to ij
 * 23 _L0x23     82 DIV_1      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     92 LDAF_3     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      65 WFI_4      00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      45 WFI_3      00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     56 LH_4       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 NMI_2      5a SB_1       00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 2a _L0x2a     56 LH_4       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b AND_1      7a SB_5       00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 2c SLL_0      9a ECALL_6    00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     af MRET_4     00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e straddle   10 SUB_1      10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    40001033 sloppy sll     
 * 2f _L0x2f     82 DIV_1      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 condb_2    82 DIV_1      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 31 LDAF_2     70 LHU_2      00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 32 LHU_1      bb SH_2       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 33 LDAF_LHU      (use dinx) 00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 34 DIV_8      76 Fetchu     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 35 DIV_9      93 SW_E2      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 36 SW_1       03 _L0x03     00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 37 SW_E1SWE   75 unx75      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 38 BNE        30 SLTIX_2    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 SW_E4      82 DIV_1      00000000110000001110100111100x00101000        Store 6 to mcause                                 00001067 close to jalr
 * 3a condb_3    97 SW_E1SWH   00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 3b _L0x3b     81 unx81      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    a2 DIV_14     00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d condb_4    03 _L0x03     00000010000000000000000011101101001xx0        Branch on condition                               00000000 
 * 3e DIV_12     92 LDAF_3     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 3f DIV_13     96 SH_1       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 ANDI_1     1d ORI_2      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 42 LHU_2      a8 DIV_3      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     0000200b close to ij
 * 43 aFaultc    f0 LBU_2      00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      0000200f close to fence
 * 44 SLTI_0     70 LHU_2      00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 ORI_2      ab EBREAK_2   00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 46 Fetchu     9f SH_5       00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00000000 
 * 47 eFetchu    be IJ_1       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 48 _L0x48     36 SLLI_2     00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 aFault_1   21 XORI_1     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 4a _L0x4a     36 SLLI_2     00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b IJ_2       cb QINT_2     00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 4c SLT_0      7d unx7d      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   78 DIV_4      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_4      fe ILLe       00000000000000001100000011101000110000        ~abs(divisor) to yy                               40002033 sloppy slt     
 * 4f DIV_5      82 DIV_1      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 50 DIV_1      82 DIV_1      00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 51 DIV_2      e5 aF_SW_2    00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 52 DIV_E      1e aFault_1   01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 53 DIV_F      e5 aF_SW_2    00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 54 DIVU_5     f2 SW_2       00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 55 LB_6       49 CSRRW_1    00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 56 SH_1       a5 MRET_3     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 57 SW_E1SWH   55 aFaultb    00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 58 DIV_10     b2 CSRRW_4    01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00002063 close to branch
 * 59 DIV_11     58 DIV_A      01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00002067 close to jalr
 * 5a XORI_1     a7 EBRKWFI1   00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 5b _L0x5b     81 unx81      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    a2 DIV_14     00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d MULHU_6    f5 jFault     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 5e DIV_14     42 MULHU_2    00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00000000 
 * 5f DIV_15     e5 aF_SW_2    00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 60 OR_1       10 SUB_1      00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00003003 close to load
 * 61 ECALL_6    91 LDAF_2     00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 62 ECAL_RET   db jFault_1   00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000300b close to ij
 * 63 EBRKWFI1   26 OR_1       00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000300f close to fence
 * 64 SLTIU_0    70 LHU_2      00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 OR_2       87 unx87      00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 66 IJ_1       8a DIVU_5     00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * 67 IJT_1      c0 DIV_D      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 68 XOR_1      82 DIV_1      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00003023 close to store
 * 69 ILL_4      55 aFaultb    00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 6a DIVU_3     f3 aF_SW      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           40003023 close to store
 * 6b DIVU_4     b6 ECALL_5    01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 6c SLTU_0     7d unx7d      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    78 DIV_4      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e ECALL_1    d3 aFaultd    00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40003033 sloppy sltu    
 * 6f MRET_1     e0 DIVU_1     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 70 SLTIX_1    ffffffff (null)     00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 71 aF_SW_3    49 CSRRW_1    00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 72 LB_2       41 JALR_1     00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 73 aFaultd    2e MULHU_1    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 74 eILL0c        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 ECALL_3       (use dinx) 00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 76 Fetch      e2 MUL_1      00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 77 eFetch     e2 MUL_1      00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 78 MULHU_1    c8 DIV_7      00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00003063 close to branch
 * 79 QINT_2     c7 QINT_1     00000000110000001111010011101000110000        mtval = 0.                                        00003067 close to jalr
 * 7a SLTIX_2    8a DIVU_5     00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 7b _L0x7b     81 unx81      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    a2 DIV_14     00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SLTX_1        (use dinx) 00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 7e MUL_1      29 XOR_1      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 7f MUL_3         (use dinx) 00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 80 LBU_0      ba LHU_3      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 JAL_1         (use dinx) 00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 82 StdIncPc   c7 QINT_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    0000400b close to ij
 * 83 aFault     50 LW_1       00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          0000400f close to fence
 * 84 XORI_0     5a SB_1       00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 JAL_3      88 DIV_E      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 86 eILL0a     85 LBU_1      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 87 WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 88 LBU_2      58 DIV_A      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00004023 close to store
 * 89 aFaulte    82 DIV_1      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 8a SW_2       41 JALR_1     00000010000000000000001011x01000xxxxx0        Prepare read PC                                   40004023 close to store
 * 8b aF_SW      82 DIV_1      00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 8c XOR_0      68 DIV_12     00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      50 LW_1       01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e Fetch2     fe ILLe       00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     40004033 sloppy xor     
 * 8f jFault     69 DIV_13     00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 90 WFI_1      85 LBU_1      00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 91 EBREAK_1   bf IJT_1      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 92 SLLI_1     85 LBU_1      00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 93 SLLI_2     c1 IJT_2      00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 94 ECALL_2    85 LBU_1      00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 95 MULHU_7    39 MULHU_7    00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 96 SRxI_1     d4 aFault_2   00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 97 SRxI_2     c0 DIV_D      00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 98 BLT        30 SLTIX_2    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a SLL_1      85 LBU_1      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 9b SRx_1         (use dinx) 00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 9c JALR_1     3e SLL_1      00010010000000000000000011101100100110        Q=1                                               00004073 close to csr/system 
 * 9d WFI_3      5e LHU_1      00010010000000000000101011101100100110        More check offset                                 00000000 
 * 9e ILL_1      c3 DIVU_4     00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 9f ILL_2      8a DIVU_5     00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * a0 LHU_0      32 JAL_1      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 aFault_2   d1 MRET_1     00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * a2 CSRRW_1    55 aFaultb    00010010000000000000000011101100100110        Construct PC storage adr                          0000500b close to ij
 * a3 LH_4       82 DIV_1      00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      0000500f close to fence
 * a4 SRxI_0     96 SH_1       00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 LH_5       ca DIVU_2     00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * a6 SB_1       6e DIV_C      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * a7 SB_2       aa DIV_6      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * a8 MULHU_3    4e eILL0b     00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00005023 close to store
 * a9 (null)     85 LBU_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * aa EBRKWFI2   db jFault_1   00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         40005023 close to store
 * ab WFI_4      61 EBRKWFI2   00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * ac _L0xac     9b unx9b      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     e8 MUL_2      00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     9b unx9b      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MULH_1     d7 ECALL_3    00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * b0 SB_4       ce _LCSRRCI_1 00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b1 (null)     bf IJT_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b2 DIV_C      76 Fetchu     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b3 MRET_6        (use dinx) 00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * b4 LBU_3      b5 SH_3       00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * b5 unalignd   c2 DIVU_3     00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * b6 SB_5       61 EBRKWFI2   00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b7 NMI_1      d5 Fetch2u    00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * b8 BGE        30 SLTIX_2    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 (null)     ffffffff (null)     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00005067 close to jalr
 * ba LBU_1      41 JALR_1     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * bb JAL_2      d0 ECALL_1    10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * bc CSRRWI_0   a2 DIV_14     00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd _LCSRRS_1  76 Fetchu     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * be ILL_3      4b CSRRW_2    00000010000000000000101011101100100110        Q = 1                                             00000000 
 * bf LDAF_3     d6 eILL0c     00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * c0 SW_E2      52 LH_1       00000000000000001101101111101000001xx0        Store address that faulted                        00006003 close to load
 * c1 SW_E3      ef WFI_5      00110010000000000000101111001100100110        Q = 3                                             00000000 
 * c2 SH_4       de Fetch      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      0000600b close to ij
 * c3 SH_5       54 LH_2       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     0000600f close to fence
 * c4 ORI_0      ea MULHU_5    00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 ECALL_4    b3 unxb3      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * c6 MRET_3     9f SH_5       00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * c7 DIV_3      79 DIV_5      01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * c8 DIV_6      34 JAL_3      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00006023 close to store
 * c9 EBREAK_2   c6 IJT_4      00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * ca MRET_4     6a MULH_1     00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          40006023 close to store
 * cb CSRRW_3    82 DIV_1      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * cc OR_0       60 MULHU_3    00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      50 LW_1       01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce CSRRW_4    fe ILLe       00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      40006033 sloppy or      
 * cf eFetch3    13 condb_2    0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * d0 SH_3       94 SW_E4      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d1 ECALL_5    dd aF_SW_1    00110010000000000000101011001100100110        Q = 8                                             00000000 
 * d2 IJ_3       09 LB_5       00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * d3 DIV_e      49 CSRRW_1    00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * d4 SH_2       bf IJT_1      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d5 IJ_4          (use dinx) 00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * d6 IJT_2      fe ILLe       00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * d7 MRET_5     c5 MRET_5     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * d8 BLTU       30 SLTIX_2    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 IJT_4      10 SUB_1      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00006067 close to jalr
 * da QINT_1     31 SLTX_1     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * db DIV_7      bf IJT_1      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * dc CSRRSI_0   a2 DIV_14     00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd MRET_2     eb LH_3       00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * de DIVU_2     8e _LCSRRS_1  00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * df _LCSRRCI_1 8e _LCSRRS_1  00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * e0 MRET_7     de Fetch      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00007003 close to load
 * e1 (null)     45 WFI_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e2 Fetch2u    ee eILL0a     0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     0000700b close to ij
 * e3 MULH_3     41 JALR_1     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              0000700f close to fence
 * e4 ANDI_0     41 JALR_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 LDAF_a     71 aFaultc    00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * e6 jFault_1   76 Fetchu     00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * e7 aF_SW_1    49 CSRRW_1    00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * e8 DIVU_1     7e NMI_1      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00007023 close to store
 * e9 (null)     d9 MULH_3     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ea ORI_1      5d SB_2       00000010000000000000000011101100001xx0        Q = RS1                                           40007023 close to store
 * eb aF_SW_2    a3 DIV_15     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * ec AND_0      2b SLTIX_1    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     e8 MUL_2      00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee MUL_2      fe ILLe       00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  40007033 sloppy and     
 * ef IJT_3      76 Fetchu     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * f0 MULHU_5    b4 eFetch3    00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * f1 (null)     49 CSRRW_1    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f2 LH_3       82 DIV_1      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f3 MULH_2     e7 aFault     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * f4 WFI_2      cf MRET_7     00010010000000000000101011101100100110        Check offset                                      00000000 
 * f5 SB_3       e6 StdIncPc   00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f6 (null)     f4 Fetch2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     c9 MRET_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       30 SLTIX_2    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)     e3 MUL_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00007067 close to jalr
 * fa (null)     9d DIV_11     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     b0 CSRRW_3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   a2 DIV_14     00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      b7 IJ_3       00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       9e SH_4       00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     da LDAF_a     00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0400, used ffff, inputs 2b
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       78 DIV_4      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       6e DIV_C      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     88 DIV_E      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     88 DIV_E      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     a7 EBRKWFI1   00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       59 DIV_B      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     a7 EBRKWFI1   00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       bb SH_2       00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      86 JAL_2      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     88 DIV_E      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    59 DIV_B      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    37 ECALL_2    00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     50 LW_1       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       33 unx33      00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       88 DIV_E      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    82 DIV_1      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     9c DIV_10     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       88 DIV_E      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     73 unalignd   00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   6a MULH_1     00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     88 DIV_E      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       a2 DIV_14     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    d2 LB_2       00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      88 DIV_E      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 CSRRW_2    85 LBU_1      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    0000100b close to ij
 * 23 _L0x23     88 DIV_E      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     7a SB_5       00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 NMI_2      4b CSRRW_2    00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 27 AND_1      39 MULHU_7    00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 28 _L0x28     5e LHU_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   41 JALR_1     10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     5e LHU_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    65 WFI_4      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      9a ECALL_6    00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     af MRET_4     00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     88 DIV_E      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 DIV_A      88 DIV_E      00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 31 DIV_B      5d SB_2       00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 32 LDAF_2     bb SH_2       00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 33 condb_4       (use dinx) 00000010000000000000000011101101001xx0        Branch on condition                               00000000 
 * 34 LHU_1      82 DIV_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 35 LDAF_LHU   7d unx7d      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 36 SW_E4      03 _L0x03     00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 37 ANDI_1     7f unx7f      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 ORI_2      88 DIV_E      00000000000000000100001011101000111000        rd = Iimm | RS1                                   00001067 close to jalr
 * 3a aFault_1   97 SW_E1SWH   00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 3b _L0x3b     73 unalignd   00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d IJ_2       03 _L0x03     00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 3e DIV_8      7a SB_5       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 3f DIV_9      96 SH_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 XORI_1     1d ORI_2      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 42 SW_1       a9 ILL_4      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     0000200b close to ij
 * 43 SW_E1SWE   f0 LBU_2      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         0000200f close to fence
 * 44 SLTI_0     5d SB_2       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 MULHU_6    ab EBREAK_2   00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 46 DIV_12     9f SH_5       00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 47 DIV_13     be IJ_1       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 48 _L0x48     42 MULHU_2    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 OR_1       22 MULHU_6    00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 4a _L0x4a     42 MULHU_2    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b OR_2       cb QINT_2     00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 4c SLT_0      67 SW_E1SWE   00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   63 DIV_9      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e LHU_2      fe ILLe       00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40002033 sloppy slt     
 * 4f aFaultc    88 DIV_E      00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 50 Fetchu     88 DIV_E      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00000000 
 * 51 eFetchu    e5 aF_SW_2    00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 52 DIV_4      1e aFault_1   00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 53 DIV_5      e5 aF_SW_2    00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 54 DIV_1      f1 aFaulte    00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 55 DIV_2      3a SRxI_1     00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 56 DIV_E      a5 MRET_3     01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 57 DIV_F      59 DIV_B      00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 58 DIVU_5     b1 aF_SW_3    00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00002063 close to branch
 * 59 LB_6       60 MULHU_3    00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00002067 close to jalr
 * 5a XOR_1      a8 DIV_3      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 5b _L0x5b     73 unalignd   00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLTIX_1    f5 jFault     00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 5e SH_1       4e eILL0b     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5f SW_E1SWH   e5 aF_SW_2    00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 60 DIV_10     10 SUB_1      01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00003003 close to load
 * 61 DIV_11     95 SW_E3      01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 62 ECALL_6    db jFault_1   00010000110000001110100111000x00100000        mcause = 11                                       0000300b close to ij
 * 63 MULHU_1    30 SLTIX_2    00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                0000300f close to fence
 * 64 SLTIU_0    5d SB_2       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLTIX_2    8b LB_6       00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 66 ILL_4      90 NMI_2      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 67 SLTX_1     c0 DIV_D      00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 68 DIV_14     88 DIV_E      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00003023 close to store
 * 69 DIV_15     59 DIV_B      00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 6a ECAL_RET   f3 aF_SW      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40003023 close to store
 * 6b EBRKWFI1   b7 IJ_3       00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 6c SLTU_0     67 SW_E1SWE   00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    63 DIV_9      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e IJ_1       d3 aFaultd    00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   40003033 sloppy sltu    
 * 6f IJT_1      e0 DIVU_1     00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 70 DIVU_3     ffffffff (null)     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 71 DIVU_4     3a SRxI_1     01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 72 aF_SW_3    37 ECALL_2    00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 73 JAL_1      29 XOR_1      00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 74 ECALL_1       (use dinx) 00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 75 MRET_1        (use dinx) 00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 76 QINT_2     e1 ORI_1      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 77 JAL_3      e1 ORI_1      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 78 LB_2       c8 DIV_7      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003063 close to branch
 * 79 aFaultd    c7 QINT_1     00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00003067 close to jalr
 * 7a SLLI_1     90 NMI_2      00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 7b _L0x7b     73 unalignd   00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SLLI_2        (use dinx) 00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 7e eILL0c     26 OR_1       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 7f ECALL_3       (use dinx) 00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 80 LBU_0      ba LHU_3      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 ECALL_2       (use dinx) 00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 82 Fetch      c7 QINT_1     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        0000400b close to ij
 * 83 eFetch     54 LH_2       00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             0000400f close to fence
 * 84 XORI_0     41 JALR_1     00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 MULHU_7    8e _LCSRRS_1  00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 86 MUL_1      77 eFetchu    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 87 MUL_3         (use dinx) 00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 88 StdIncPc   60 MULHU_3    10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00004023 close to store
 * 89 aFault     88 DIV_E      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 8a eILL0a     37 ECALL_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40004023 close to store
 * 8b WFI_5      88 DIV_E      00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 8c XOR_0      5a SB_1       00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      54 LH_2       01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e LBU_2      fe ILLe       00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40004033 sloppy xor     
 * 8f aFaulte    66 SW_1       00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 90 SW_2       77 eFetchu    00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 91 aF_SW      bf IJT_1      00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 92 Fetch2     77 eFetchu    00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 93 jFault     c1 IJT_2      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 94 WFI_1      77 eFetchu    00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 95 EBREAK_1   36 SLLI_2     00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 96 SRxI_1     d4 aFault_2   00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 97 SRxI_2     c0 DIV_D      00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a SLL_1      77 eFetchu    00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 9b SRx_1         (use dinx) 00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 9c JALR_1     46 ILL_1      00010010000000000000000011101100100110        Q=1                                               00004073 close to csr/system 
 * 9d WFI_3      68 DIV_12     00010010000000000000101011101100100110        More check offset                                 00000000 
 * 9e ILL_1      c3 DIVU_4     00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 9f ILL_2      90 NMI_2      00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * a0 LHU_0      34 JAL_3      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 CSRRW_1    d1 MRET_1     00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * a2 aFault_2   59 DIV_B      00010000110000001110001011100x00100110        Store 5 to mcause                                 0000500b close to ij
 * a3 LH_4       88 DIV_E      00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      0000500f close to fence
 * a4 SRxI_0     96 SH_1       00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 LH_5       ca DIVU_2     00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * a6 (null)     74 unx74      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * a7 SB_1       aa DIV_6      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * a8 SB_2       52 LH_1       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00005023 close to store
 * a9 MULHU_3    77 eFetchu    00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * aa EBRKWFI2   db jFault_1   00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         40005023 close to store
 * ab WFI_4      62 DIV_8      00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * ac _L0xac     9b unx9b      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     e9 IJT_3      00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     9b unx9b      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MULH_1     d7 ECALL_3    00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * b0 SB_4       ce _LCSRRCI_1 00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b1 DIV_C      bf IJT_1      00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b2 (null)     82 DIV_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b3 MRET_6        (use dinx) 00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * b4 LBU_3      b5 SH_3       00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * b5 unalignd   c2 DIVU_3     00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * b6 (null)     62 DIV_8      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b7 SB_5       d5 Fetch2u    00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 NMI_1      ffffffff (null)     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00005067 close to jalr
 * ba LBU_1      37 ECALL_2    00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * bb JAL_2      d0 ECALL_1    10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * bc CSRRWI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd _LCSRRS_1  82 DIV_1      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * be ILL_3      3d SRxI_2     00000010000000000000101011101100100110        Q = 1                                             00000000 
 * bf LDAF_3     d6 eILL0c     00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * c0 SW_E2      56 LH_4       00000000000000001101101111101000001xx0        Store address that faulted                        00006003 close to load
 * c1 SW_E3      ef WFI_5      00110010000000000000101111001100100110        Q = 3                                             00000000 
 * c2 SH_4       de Fetch      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      0000600b close to ij
 * c3 SH_5       58 DIV_A      00000000000000000001110011100100001xx0        Write d to a+k until accepted                     0000600f close to fence
 * c4 ORI_0      ea MULHU_5    00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 ECALL_4    b3 unxb3      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * c6 MRET_3     9f SH_5       00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * c7 DIV_3      76 Fetchu     01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * c8 DIV_6      3e SLL_1      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00006023 close to store
 * c9 EBREAK_2   c6 IJT_4      00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * ca MRET_4     70 LHU_2      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          40006023 close to store
 * cb CSRRW_3    88 DIV_E      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * cc OR_0       49 CSRRW_1    00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      54 LH_2       01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce CSRRW_4    fe ILLe       00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      40006033 sloppy or      
 * cf eFetch3    13 condb_2    0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * d0 SH_3       81 unx81      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d1 ECALL_5    dd aF_SW_1    00110010000000000000101011001100100110        Q = 8                                             00000000 
 * d2 IJ_3       09 LB_5       00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * d3 DIV_e      3a SRxI_1     00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * d4 SH_2       bf IJT_1      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d5 IJ_4          (use dinx) 00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * d6 IJT_2      fe ILLe       00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * d7 MRET_5     c5 MRET_5     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 IJT_4      10 SUB_1      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00006067 close to jalr
 * da QINT_1     32 JAL_1      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * db DIV_7      bf IJT_1      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * dc CSRRSI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd MRET_2     eb LH_3       00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * de DIVU_2     92 LDAF_3     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * df _LCSRRCI_1 92 LDAF_3     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * e0 MRET_7     de Fetch      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00007003 close to load
 * e1 Fetch2u    39 MULHU_7    0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * e2 (null)     ee eILL0a     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700b close to ij
 * e3 MULH_3     37 ECALL_2    00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              0000700f close to fence
 * e4 ANDI_0     37 ECALL_2    00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 LDAF_a     72 LBU_3      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * e6 (null)     82 DIV_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e7 jFault_1   3a SRxI_1     00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * e8 aF_SW_1    86 JAL_2      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00007023 close to store
 * e9 DIVU_1     d9 MULH_3     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * ea ORI_1      45 WFI_3      00000010000000000000000011101100001xx0        Q = RS1                                           40007023 close to store
 * eb aF_SW_2    a3 DIV_15     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * ec AND_0      27 OR_2       00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     e9 IJT_3      00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee MUL_2      fe ILLe       00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  40007033 sloppy and     
 * ef IJT_3      82 DIV_1      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * f0 MULHU_5    b4 eFetch3    00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * f1 LH_3       3a SRxI_1     00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f2 (null)     88 DIV_E      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f3 MULH_2     e8 MUL_2      00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * f4 WFI_2      cf MRET_7     00010010000000000000101011101100100110        Check offset                                      00000000 
 * f5 SB_3       e7 aFault     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f6 (null)     f4 Fetch2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     c9 MRET_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)     e3 MUL_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00007067 close to jalr
 * fa (null)     9d DIV_11     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     b0 CSRRW_3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      b9 DIV_e      00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       9e SH_4       00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     da LDAF_a     00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0008, used ffff, inputs 2e
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       7e NMI_1      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       72 LBU_3      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     8e _LCSRRS_1  00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     8e _LCSRRS_1  00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 CSRRW_2    0b JALR_2     00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 07 NMI_2      1a ANDI_1     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 08 _L0x08     b9 DIV_e      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       63 DIV_9      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     b9 DIV_e      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       cb QINT_2     00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      8a DIVU_5     00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     8e _LCSRRS_1  00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 condb_5    63 DIV_9      00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 11 condb_5t   3a SRxI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 12 MULHU_2    54 LH_2       00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 13 MULHU_4    2e MULHU_1    00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 14 eILL0b     39 MULHU_7    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 15 MRET_8     10 SUB_1      00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 16 LDAF_2     8e _LCSRRS_1  00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 17 SW_E4      88 DIV_E      00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     af MRET_4     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       8e _LCSRRS_1  00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     9e SH_4       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   70 LHU_2      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     8e _LCSRRS_1  00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LW_1       86 JAL_2      00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 1f LDAF_LW    e5 aF_SW_2    00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 20 LH_0       30 SLTIX_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      8e _LCSRRS_1  00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      a5 MRET_3     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     8e _LCSRRS_1  00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     a1 ECALL_4    00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 jFault_1   5d SB_2       00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 27 aF_SW_1    3d SRxI_2     00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 28 _L0x28     68 DIV_12     00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     68 DIV_12     00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      aa DIV_6      00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     bf IJT_1      00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    12 straddle   00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     8e _LCSRRS_1  00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_1       8e _LCSRRS_1  00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LH    7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 LH_2       cb QINT_2     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 33 aFaultb       (use dinx) 00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 34 DIV_A      88 DIV_E      00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 35 DIV_B      a2 DIV_14     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 36 DIVU_1     03 _L0x03     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 37 ORI_1      83 DIV_2      00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    8e _LCSRRS_1  00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     a9 ILL_4      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     9e SH_4       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    b3 unxb3      00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_1      a1 ECALL_4    00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LHU   a8 DIV_3      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       1e aFault_1   00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 DIV_8      bb SH_2       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000200b close to ij
 * 43 DIV_9      77 eFetchu    01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       be IJ_1       00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 ECALL_6    b2 CSRRW_4    00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 47 ILL_4      cf MRET_7     00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 48 _L0x48     4e eILL0b     00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     06 LB_3       00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     4e eILL0b     00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    df eFetch     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e SW_1       fe ILLe       00000000000000000011111011100100001xx0        Write d to a+k until accepted                     40002033 sloppy slt     
 * 4f SW_E1SWE   8e _LCSRRS_1  00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 50 DIV_12     8e _LCSRRS_1  00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 51 DIV_13     fb SB_3       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 52 LHU_2      32 JAL_1      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 53 aFaultc    fb SB_3       00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 54 Fetchu     a6 ECAL_RET   00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00000000 
 * 55 eFetchu    41 JALR_1     00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 56 aF_SW_3    b5 SH_3       00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 57 QINT_2     63 DIV_9      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 58 DIV_4      c1 IJT_2      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00002063 close to branch
 * 59 DIV_5      6a MULH_1     00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00002067 close to jalr
 * 5a OR_1       ba LHU_3      00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     9e SH_4       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    b3 unxb3      00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       b7 IJ_3       00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIV_1      52 LH_1       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 5f DIV_2      fb SB_3       00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 60 DIV_E      12 straddle   01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003003 close to load
 * 61 DIV_F      9d DIV_11     00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 62 DIVU_5     f1 aFaulte    00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               0000300b close to ij
 * 63 LB_6       34 JAL_3      00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      91 LDAF_2     00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 aF_SW_2    94 SW_E4      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 67 MUL_2      d1 MRET_1     00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 68 SH_1       8e _LCSRRS_1  00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00003023 close to store
 * 69 SW_E1SWH   63 DIV_9      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 6a DIV_10     a7 EBRKWFI1   01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    40003023 close to store
 * 6b DIV_11     c8 DIV_7      01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_14     e8 MUL_2      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 40003033 sloppy sltu    
 * 6f DIV_15     f5 jFault     00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 70 ECAL_RET   ffffffff (null)     00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 71 EBRKWFI1   41 JALR_1     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 72 IJ_1       3a SRxI_1     00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * 73 IJT_1      29 XOR_1      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 74 DIVU_3        (use dinx) 00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 75 DIVU_4        (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 76 IJT_3      f9 MULH_2     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 77 MULHU_5    f9 MULH_2     00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 78 ECALL_1    db jFault_1   00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00003063 close to branch
 * 79 MRET_1     da LDAF_a     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00003067 close to jalr
 * 7a SLTIX_1    94 SW_E4      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     9e SH_4       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    b3 unxb3      00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e LB_2       07 LB_4       00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 7f aFaultd       (use dinx) 00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 80 LBU_0      ca DIVU_2     00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 eILL0c     da LDAF_a     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000400b close to ij
 * 83 ECALL_3    5e LHU_1      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     92 LDAF_3     00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 aFault_2   9f SH_5       00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 87 (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 88 Fetch      6a MULH_1     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00004023 close to store
 * 89 eFetch     8e _LCSRRS_1  00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 8a MUL_1      3a SRxI_1     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           40004023 close to store
 * 8b MUL_3      8e _LCSRRS_1  00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      5e LHU_1      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e StdIncPc   fe ILLe       10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    40004033 sloppy xor     
 * 8f aFault     47 ILL_2      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 90 eILL0a     9f SH_5       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 91 WFI_5      d0 ECALL_1    00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 92 LBU_2      9f SH_5       00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 93 aFaulte    d2 LB_2       00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 94 SW_2       9f SH_5       00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 95 aF_SW      17 condb_5t   00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 96 (null)     e9 IJT_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 97 (null)     d1 MRET_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a Fetch2     9f SH_5       00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 9b jFault        (use dinx) 00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 9c WFI_1      50 LW_1       00110010000000000000000011001100100110 WFI    To check offset                                   00004073 close to csr/system 
 * 9d EBREAK_1   6e DIV_C      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 9e JAL_1      d4 aFault_2   00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 9f JAL_3      94 SW_E4      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a0 LHU_0      3e SLL_1      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SLLI_1     e3 MUL_3      00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * a2 SLLI_2     63 DIV_9      00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                0000500b close to ij
 * a3 ECALL_2    8e _LCSRRS_1  00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  0000500f close to fence
 * a4 SRxI_0     a8 DIV_3      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MULHU_7    de Fetch      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * a6 LH_3       78 DIV_4      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * a7 MULH_2     bd IJ_4       00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * a8 SRxI_1     58 DIV_A      00000000000000000100101001101100001xx1        Register to shift to Q                            00005023 close to store
 * a9 SRxI_2     9f SH_5       00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * aa SLL_1      f1 aFaulte    00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              40005023 close to store
 * ab SRx_1      46 ILL_1      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * ac _L0xac     ab EBREAK_2   00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     36 SLLI_2     00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     ab EBREAK_2   00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af JALR_1     ee eILL0a     00010010000000000000000011101100100110        Q=1                                               00000000 
 * b0 WFI_3      e0 DIVU_1     00010010000000000000101011101100100110        More check offset                                 00000000 
 * b1 ILL_1      d0 ECALL_1    00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * b2 ILL_2      88 DIV_E      00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * b3 CSRRW_1       (use dinx) 00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * b4 LH_4       c5 MRET_5     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * b5 LH_5       d3 aFaultd    00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * b6 WFI_2      46 ILL_1      00010010000000000000101011101100100110        Check offset                                      00000000 
 * b7 SB_3       ea MULHU_5    00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SB_1       ffffffff (null)     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00005067 close to jalr
 * ba SB_2       3a SRxI_1     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * bb MULHU_3    e2 MUL_1      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * bc CSRRWI_0   b3 unxb3      00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd EBRKWFI2   88 DIV_E      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * be WFI_4      45 WFI_3      00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * bf MULH_1     eb LH_3       00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * c0 SB_4       60 MULHU_3    00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00006003 close to load
 * c1 DIV_C      76 Fetchu     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * c2 MRET_6     f3 aF_SW      00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            0000600b close to ij
 * c3 LBU_3      62 DIV_8      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       0000600f close to fence
 * c4 ORI_0      37 ECALL_2    00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 unalignd   c2 DIVU_3     00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * c6 (null)     b2 CSRRW_4    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c7 (null)     57 LH_5       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c8 SB_5       42 MULHU_2    00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00006023 close to store
 * c9 NMI_1      d9 MULH_3     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * ca LBU_1      74 unx74      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40006023 close to store
 * cb JAL_2      8e _LCSRRS_1  10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      5e LHU_1      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce _LCSRRS_1  fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006033 sloppy or      
 * cf ILL_3      15 condb_4    00000010000000000000101011101100100110        Q = 1                                             00000000 
 * d0 LDAF_3     a3 DIV_15     00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * d1 SW_E2      f2 SW_2       00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * d2 SW_E3      09 LB_5       00110010000000000000101111001100100110        Q = 3                                             00000000 
 * d3 SH_4       41 JALR_1     00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * d4 SH_5       d0 ECALL_1    00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * d5 ECALL_4       (use dinx) 00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d6 (null)     fe ILLe       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d7 (null)     d5 Fetch2u    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MRET_3     12 straddle   00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00006067 close to jalr
 * da DIV_3      16 condb_5    01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * db DIV_6      d0 ECALL_1    00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * dc CSRRSI_0   b3 unxb3      00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd EBREAK_2   66 SW_1       00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * de MRET_4     9a ECALL_6    00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * df CSRRW_3    9a ECALL_6    00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * e0 CSRRW_4    f3 aF_SW      00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00007003 close to load
 * e1 eFetch3    3d SRxI_2     0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * e2 SH_3       67 SW_E1SWE   00000010000000000000000011101000110000        Prepare get back address to use                   0000700b close to ij
 * e3 ECALL_5    3a SRxI_1     00110010000000000000101011001100100110        Q = 8                                             0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 IJ_3       56 LH_4       00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * e6 (null)     88 DIV_E      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e7 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e8 DIV_e      8a DIVU_5     00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00007023 close to store
 * e9 SH_2       ef WFI_5      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * ea IJ_4       4b CSRRW_2    00000100000010001010110111100100011xx0        Mask and use as PC                                40007023 close to store
 * eb IJT_2      b4 eFetch3    00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     36 SLLI_2     00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee MRET_5     fe ILLe       00000010000000000000000011101100010xx0        ~302                                              40007033 sloppy and     
 * ef IJT_4      88 DIV_E      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * f0 QINT_1     c3 DIVU_4     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * f1 DIV_7      41 JALR_1     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f2 MRET_2     8e _LCSRRS_1  00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * f3 DIVU_2     27 OR_2       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f4 _LCSRRCI_1 e1 ORI_1      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f5 MRET_7     26 OR_1       00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f6 (null)     b6 ECALL_5    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     dd aF_SW_1    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 Fetch2u    fa WFI_2      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00007067 close to jalr
 * fa MULH_3     b0 CSRRW_3    00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * fb LDAF_a     c0 DIV_D      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * fc CSRRCI_0   b3 unxb3      00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      c9 MRET_2     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       b1 aF_SW_3    00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     f0 LBU_2      00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0040, used ffff, inputs 33
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       76 Fetchu     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       70 LHU_2      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     86 JAL_2      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     86 JAL_2      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   13 condb_2    00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     a9 ILL_4      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       63 DIV_9      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     a9 ILL_4      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       bb SH_2       00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      82 DIV_1      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      1d ORI_2      00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     86 JAL_2      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    63 DIV_9      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    2e MULHU_1    00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 CSRRW_2    50 LW_1       00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 13 LB_5       29 XOR_1      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 14 eILL0b     2b SLTIX_1    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 15 MRET_8     06 LB_3       00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 16 NMI_2      86 JAL_2      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 17 JALR_2     7e NMI_1      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 18 BEQ        22 MULHU_6    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     a1 ECALL_4    00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LDAF_2     86 JAL_2      00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 1b _L0x1b     7a SB_5       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   6e DIV_C      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d SUB_1      86 JAL_2      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 1e SW_E4      92 LDAF_3     00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 1f AND_1      d3 aFaultd    00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 20 LH_0       30 SLTIX_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 straddle   86 JAL_2      10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 22 condb_2    97 SW_E1SWH   00000010000000000000111111101100000xx0        ~RS2 in Q                                         0000100b close to ij
 * 23 _L0x23     86 JAL_2      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     81 unx81      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 LW_1       4b CSRRW_2    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LW    39 MULHU_7    00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     66 SW_1       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_3    41 JALR_1     00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2a _L0x2a     66 SW_1       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_4    5f LDAF_LHU   00000010000000000000000011101101001xx0        Branch on condition                               00000000 
 * 2c SLL_0      9d DIV_11     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     b1 aF_SW_3    00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e ANDI_1     10 SUB_1      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     86 JAL_2      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_1       86 JAL_2      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LH    57 LH_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 LH_2       bb SH_2       00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 33 aFaultb       (use dinx) 00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 34 DIV_A      7e NMI_1      00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 35 DIV_B      85 LBU_1      00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 36 LHU_1      03 _L0x03     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 37 LDAF_LHU   79 DIV_5      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 38 BNE        22 MULHU_6    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 ORI_2      86 JAL_2      00000000000000000100001011101000111000        rd = Iimm | RS1                                   00001067 close to jalr
 * 3a aFault_1   9c DIV_10     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 3b _L0x3b     7a SB_5       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    a6 ECAL_RET   00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d IJ_2       03 _L0x03     00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 3e DIV_8      81 unx81      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 3f DIV_9      9b unx9b      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 40 LW_0       26 OR_1       00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 XORI_1     17 condb_5t   00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 42 SW_1       ab EBREAK_2   00000000000000000011111011100100001xx0        Write d to a+k until accepted                     0000200b close to ij
 * 43 SW_E1SWE   f2 SW_2       00000000000000001111001011100x00110000        Store faulting address alignment to mtval         0000200f close to fence
 * 44 SLTI_0     57 LH_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 MULHU_6    b0 CSRRW_3    00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 46 DIV_12     a5 MRET_3     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 47 DIV_13     be IJ_1       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 48 _L0x48     42 MULHU_2    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 OR_1       12 straddle   00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 4a _L0x4a     42 MULHU_2    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b OR_2       cb QINT_2     00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 4c SLT_0      65 WFI_4      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   5d SB_2       00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e LHU_2      fe ILLe       00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40002033 sloppy slt     
 * 4f aFaultc    86 JAL_2      00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 50 Fetchu     86 JAL_2      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00000000 
 * 51 eFetchu    e8 MUL_2      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 52 ECALL_6    32 JAL_1      00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 53 XOR_1      e8 MUL_2      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 54 DIV_4      f3 aF_SW      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 55 DIV_5      3a SRxI_1     00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 56 ILL_4      a8 DIV_3      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 57 SLTIX_1    63 DIV_9      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 58 DIV_1      b3 unxb3      00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00002063 close to branch
 * 59 DIV_2      68 DIV_12     00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00002067 close to jalr
 * 5a aF_SW_3    aa DIV_6      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 5b _L0x5b     7a SB_5       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    a6 ECAL_RET   00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d MULHU_1    f6 WFI_1      00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 5e QINT_2     4e eILL0b     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 5f SLTIX_2    e8 MUL_2      00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 60 DIV_E      10 SUB_1      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003003 close to load
 * 61 DIV_F      95 SW_E3      00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 62 DIVU_5     e0 DIVU_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               0000300b close to ij
 * 63 LB_6       34 JAL_3      00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          0000300f close to fence
 * 64 SLTIU_0    57 LH_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLTX_1     89 DIV_F      00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 66 SH_1       8e _LCSRRS_1  00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 67 SW_E1SWH   c0 DIV_D      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 68 DIV_10     86 JAL_2      01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00003023 close to store
 * 69 DIV_11     63 DIV_9      01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 6a DIV_14     f4 Fetch2     00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 40003023 close to store
 * 6b DIV_15     b7 IJ_3       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 6c SLTU_0     65 WFI_4      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    5d SB_2       00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e ECAL_RET   d4 aFault_2   00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40003033 sloppy sltu    
 * 6f EBRKWFI1   e5 aF_SW_2    00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 70 IJ_1       ffffffff (null)     00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * 71 IJT_1      3a SRxI_1     00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 72 DIVU_3     2e MULHU_1    00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 73 DIVU_4     21 XORI_1     01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 74 ECALL_1       (use dinx) 00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 75 MRET_1        (use dinx) 00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 76 LB_2       e6 StdIncPc   00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 77 aFaultd    e6 StdIncPc   00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 78 eILL0c     c8 DIV_7      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00003063 close to branch
 * 79 ECALL_3    c7 QINT_1     00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00003067 close to jalr
 * 7a JAL_1      8e _LCSRRS_1  00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 7b _L0x7b     7a SB_5       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    a6 ECAL_RET   00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d JAL_3         (use dinx) 00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 7e Fetch      16 condb_5    00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 7f eFetch        (use dinx) 00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 80 LBU_0      ba LHU_3      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLLI_1        (use dinx) 00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 82 MUL_1      c7 QINT_1     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           0000400b close to ij
 * 83 MUL_3      58 DIV_A      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               0000400f close to fence
 * 84 XORI_0     41 JALR_1     00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLLI_2     8a DIVU_5     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 86 StdIncPc   7d unx7d      10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 87 aFault        (use dinx) 00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 88 eILL0a     68 DIV_12     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00004023 close to store
 * 89 WFI_5      86 JAL_2      00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 8a LBU_2      2e MULHU_1    00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40004023 close to store
 * 8b aFaulte    86 JAL_2      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 8c XOR_0      53 LDAF_LH    00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      58 DIV_A      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e SW_2       fe ILLe       00000010000000000000001011x01000xxxxx0        Prepare read PC                                   40004033 sloppy xor     
 * 8f aF_SW      56 LH_4       00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 90 Fetch2     7d unx7d      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 91 jFault     bf IJT_1      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 92 aFault_2   7d unx7d      00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 93 ECALL_2    c1 IJT_2      00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 94 WFI_1      7d unx7d      00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 95 EBREAK_1   1e aFault_1   00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 96 (null)     d5 Fetch2u    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 97 MULHU_7    c0 DIV_D      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 98 BLT        22 MULHU_6    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a (null)     7d unx7d      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 9b SRxI_1        (use dinx) 00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 9c SRxI_2     46 ILL_1      00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00004073 close to csr/system 
 * 9d SLL_1      6a MULH_1     00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 9e (null)     c3 DIVU_4     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 9f SRx_1      8e _LCSRRS_1  00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * a0 LHU_0      36 SLLI_2     00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JALR_1     d1 MRET_1     00010010000000000000000011101100100110        Q=1                                               00000000 
 * a2 WFI_3      63 DIV_9      00010010000000000000101011101100100110        More check offset                                 0000500b close to ij
 * a3 ILL_1      86 JAL_2      00000000000000001101101011100x00001xx0        Store PC to mepc                                  0000500f close to fence
 * a4 SRxI_0     9b unx9b      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 ILL_2      ca DIVU_2     00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * a6 CSRRW_1    74 unx74      00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * a7 LH_4       af MRET_4     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * a8 LH_5       54 LH_2       00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00005023 close to store
 * a9 SB_1       7d unx7d      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * aa SB_2       e0 DIVU_1     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   40005023 close to store
 * ab MULHU_3    52 LH_1       00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * ac _L0xac     9f SH_5       00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     eb LH_3       00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     9f SH_5       00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af EBRKWFI2   db jFault_1   00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * b0 WFI_4      ce _LCSRRCI_1 00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * b1 MULH_1     bf IJT_1      00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * b2 SB_4       7e NMI_1      00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b3 DIV_C         (use dinx) 00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b4 MRET_6     b6 ECALL_5    00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * b5 LBU_3      c2 DIVU_3     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * b6 unalignd   52 LH_1       00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * b7 SB_5       d7 ECALL_3    00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b8 BGE        22 MULHU_6    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 NMI_1      ffffffff (null)     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00005067 close to jalr
 * ba LBU_1      2e MULHU_1    00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * bb JAL_2      d0 ECALL_1    10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * bc CSRRWI_0   a6 ECAL_RET   00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd _LCSRRS_1  7e NMI_1      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * be ILL_3      3d SRxI_2     00000010000000000000101011101100100110        Q = 1                                             00000000 
 * bf LDAF_3     d9 MULH_3     00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * c0 SW_E2      60 MULHU_3    00000000000000001101101111101000001xx0        Store address that faulted                        00006003 close to load
 * c1 SW_E3      f1 aFaulte    00110010000000000000101111001100100110        Q = 3                                             00000000 
 * c2 SH_4       e2 MUL_1      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      0000600b close to ij
 * c3 SH_5       62 DIV_8      00000000000000000001110011100100001xx0        Write d to a+k until accepted                     0000600f close to fence
 * c4 ORI_0      ee eILL0a     00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 ECALL_4    b4 eFetch3    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * c6 MRET_3     a5 MRET_3     00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * c7 DIV_3      5e LHU_1      01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * c8 DIV_6      3e SLL_1      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00006023 close to store
 * c9 EBREAK_2   c6 IJT_4      00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * ca MRET_4     72 LBU_3      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          40006023 close to store
 * cb CSRRW_3    86 JAL_2      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * cc OR_0       49 CSRRW_1    00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      58 DIV_A      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce CSRRW_4    fe ILLe       00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      40006033 sloppy or      
 * cf eFetch3    15 condb_4    0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * d0 SH_3       93 SW_E2      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d1 ECALL_5    e1 ORI_1      00110010000000000000101011001100100110        Q = 8                                             00000000 
 * d2 (null)     09 LB_5       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d3 IJ_3       3a SRxI_1     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * d4 DIV_e      bf IJT_1      00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * d5 SH_2          (use dinx) 00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d6 (null)     fe ILLe       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d7 IJ_4       c5 MRET_5     00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * d8 BLTU       22 MULHU_6    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 IJT_2      10 SUB_1      00000000000000001100101011101000110000        Read word is to be masked with ~1u                00006067 close to jalr
 * da (null)     1a ANDI_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * db MRET_5     bf IJT_1      00000010000000000000000011101100010xx0        ~302                                              00000000 
 * dc CSRRSI_0   a6 ECAL_RET   00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd IJT_4      ef WFI_5      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * de (null)     90 NMI_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * df QINT_1     90 NMI_2      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * e0 DIV_7      e2 MUL_1      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00007003 close to load
 * e1 MRET_2     39 MULHU_7    00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * e2 DIVU_2     f0 LBU_2      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            0000700b close to ij
 * e3 _LCSRRCI_1 2e MULHU_1    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000700f close to fence
 * e4 ANDI_0     2e MULHU_1    00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 MRET_7     5a SB_1       00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * e6 Fetch2u    7e NMI_1      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * e7 MULH_3     3a SRxI_1     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * e8 LDAF_a     82 DIV_1      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00007023 close to store
 * e9 jFault_1   dd aF_SW_1    00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * ea aF_SW_1    45 WFI_3      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      40007023 close to store
 * eb DIVU_1     a7 EBRKWFI1   00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * ec AND_0      1f IJ_2       00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     eb LH_3       00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee ORI_1      fe ILLe       00000010000000000000000011101100001xx0        Q = RS1                                           40007033 sloppy and     
 * ef aF_SW_2    7e NMI_1      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * f0 MUL_2      b5 SH_3       00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * f1 IJT_3      3a SRxI_1     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * f2 MULHU_5    86 JAL_2      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * f3 LH_3       ea MULHU_5    00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f4 MULH_2     cf MRET_7     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * f5 WFI_2      e9 IJT_3      00010010000000000000101011101100100110        Check offset                                      00000000 
 * f6 SB_3       f5 jFault     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f7 (null)     c9 MRET_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       22 MULHU_6    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)     e7 aFault     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00007067 close to jalr
 * fa (null)     a2 DIV_14     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     b2 CSRRW_4    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   a6 ECAL_RET   00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      b9 DIV_e      00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       a3 DIV_15     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     df eFetch     00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0080, used ffff, inputs 35
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       76 Fetchu     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       70 LHU_2      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     86 JAL_2      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     86 JAL_2      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   14 condb_3    00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     a9 ILL_4      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       63 DIV_9      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     a9 ILL_4      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       bb SH_2       00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      82 DIV_1      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      1a ANDI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     86 JAL_2      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    63 DIV_9      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    2e MULHU_1    00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     50 LW_1       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     29 XOR_1      00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LB_5       2b SLTIX_1    00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 15 CSRRW_2    06 LB_3       00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 16 JALR_2     86 JAL_2      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 17 NMI_2      7e NMI_1      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 18 BEQ        22 MULHU_6    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     a1 ECALL_4    00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a SUB_1      86 JAL_2      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 1b _L0x1b     7a SB_5       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   6e DIV_C      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d LDAF_2     86 JAL_2      00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 1e AND_1      95 SW_E3      00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 1f SW_E4      d2 LB_2       00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 20 LH_0       30 SLTIX_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 straddle   86 JAL_2      10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 22 condb_2    96 SH_1       00000010000000000000111111101100000xx0        ~RS2 in Q                                         0000100b close to ij
 * 23 _L0x23     86 JAL_2      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     81 unx81      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 LW_1       4b CSRRW_2    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LW    39 MULHU_7    00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     66 SW_1       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_3    41 JALR_1     00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2a _L0x2a     66 SW_1       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_4    5e LHU_1      00000010000000000000000011101101001xx0        Branch on condition                               00000000 
 * 2c SLL_0      9c DIV_10     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     b1 aF_SW_3    00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e ANDI_1     10 SUB_1      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     86 JAL_2      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_1       86 JAL_2      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LH    56 LH_4       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 LH_2       bb SH_2       00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 33 aFaultb       (use dinx) 00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 34 DIV_A      7e NMI_1      00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 35 DIV_B      85 LBU_1      00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 36 LHU_1      03 _L0x03     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 37 LDAF_LHU   79 DIV_5      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 38 BNE        22 MULHU_6    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 ORI_2      86 JAL_2      00000000000000000100001011101000111000        rd = Iimm | RS1                                   00001067 close to jalr
 * 3a aFault_1   9b unx9b      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 3b _L0x3b     7a SB_5       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    a6 ECAL_RET   00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d IJ_2       03 _L0x03     00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 3e DIV_8      81 unx81      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 3f DIV_9      9a ECALL_6    01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 40 LW_0       26 OR_1       00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 XORI_1     16 condb_5    00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 42 SW_1       ab EBREAK_2   00000000000000000011111011100100001xx0        Write d to a+k until accepted                     0000200b close to ij
 * 43 SW_E1SWE   f2 SW_2       00000000000000001111001011100x00110000        Store faulting address alignment to mtval         0000200f close to fence
 * 44 SLTI_0     56 LH_4       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 MULHU_6    b0 CSRRW_3    00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 46 DIV_12     a5 MRET_3     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 47 DIV_13     be IJ_1       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 48 _L0x48     42 MULHU_2    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 OR_1       15 condb_4    00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 4a _L0x4a     42 MULHU_2    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b OR_2       cb QINT_2     00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 4c SLT_0      65 WFI_4      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   5a SB_1       00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e LHU_2      fe ILLe       00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40002033 sloppy slt     
 * 4f aFaultc    86 JAL_2      00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 50 Fetchu     86 JAL_2      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00000000 
 * 51 eFetchu    e8 MUL_2      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 52 DIV_4      32 JAL_1      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 53 DIV_5      e8 MUL_2      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 54 XOR_1      f3 aF_SW      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 55 ECALL_6    3a SRxI_1     00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 56 SLTIX_1    a8 DIV_3      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 57 ILL_4      63 DIV_9      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 58 DIV_1      b3 unxb3      00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00002063 close to branch
 * 59 DIV_2      68 DIV_12     00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00002067 close to jalr
 * 5a MULHU_1    aa DIV_6      00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 5b _L0x5b     7a SB_5       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    a6 ECAL_RET   00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d aF_SW_3    f6 WFI_1      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 5e SLTIX_2    4e eILL0b     00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 5f QINT_2     e8 MUL_2      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 60 DIV_E      10 SUB_1      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003003 close to load
 * 61 DIV_F      93 SW_E2      00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 62 DIVU_5     e0 DIVU_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               0000300b close to ij
 * 63 LB_6       34 JAL_3      00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          0000300f close to fence
 * 64 SLTIU_0    56 LH_4       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLTX_1     89 DIV_F      00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 66 SH_1       8e _LCSRRS_1  00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 67 SW_E1SWH   c0 DIV_D      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 68 DIV_10     86 JAL_2      01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00003023 close to store
 * 69 DIV_11     63 DIV_9      01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 6a DIV_14     f4 Fetch2     00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 40003023 close to store
 * 6b DIV_15     b7 IJ_3       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 6c SLTU_0     65 WFI_4      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    5a SB_1       00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e ECAL_RET   d3 aFaultd    00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40003033 sloppy sltu    
 * 6f EBRKWFI1   e5 aF_SW_2    00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 70 IJ_1       ffffffff (null)     00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * 71 IJT_1      3a SRxI_1     00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 72 DIVU_3     2e MULHU_1    00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 73 DIVU_4     21 XORI_1     01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 74 ECALL_1       (use dinx) 00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 75 MRET_1        (use dinx) 00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 76 LB_2       e6 StdIncPc   00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 77 aFaultd    e6 StdIncPc   00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 78 eILL0c     c8 DIV_7      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00003063 close to branch
 * 79 ECALL_3    c7 QINT_1     00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00003067 close to jalr
 * 7a JAL_1      8e _LCSRRS_1  00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 7b _L0x7b     7a SB_5       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    a6 ECAL_RET   00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d JAL_3         (use dinx) 00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 7e Fetch      17 condb_5t   00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 7f eFetch        (use dinx) 00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 80 LBU_0      ba LHU_3      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLLI_1        (use dinx) 00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 82 MUL_1      c7 QINT_1     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           0000400b close to ij
 * 83 MUL_3      58 DIV_A      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               0000400f close to fence
 * 84 XORI_0     41 JALR_1     00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLLI_2     8a DIVU_5     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 86 StdIncPc   7d unx7d      10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 87 aFault        (use dinx) 00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 88 eILL0a     68 DIV_12     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00004023 close to store
 * 89 WFI_5      86 JAL_2      00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 8a LBU_2      2e MULHU_1    00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40004023 close to store
 * 8b aFaulte    86 JAL_2      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 8c XOR_0      54 LH_2       00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      58 DIV_A      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e SW_2       fe ILLe       00000010000000000000001011x01000xxxxx0        Prepare read PC                                   40004033 sloppy xor     
 * 8f aF_SW      57 LH_5       00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 90 Fetch2     7d unx7d      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 91 jFault     bf IJT_1      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 92 WFI_1      7d unx7d      00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 93 EBREAK_1   c1 IJT_2      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 94 ECALL_2    7d unx7d      00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 95 aFault_2   1f IJ_2       00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 96 MULHU_7    d4 aFault_2   00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 97 (null)     c0 DIV_D      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 98 BLT        22 MULHU_6    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a SRxI_1     7d unx7d      00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 9b SRxI_2        (use dinx) 00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 9c SLL_1      46 ILL_1      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00004073 close to csr/system 
 * 9d (null)     6a MULH_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 9e SRx_1      c3 DIVU_4     00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 9f (null)     8e _LCSRRS_1  000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * a0 LHU_0      36 SLLI_2     00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JALR_1     d1 MRET_1     00010010000000000000000011101100100110        Q=1                                               00000000 
 * a2 WFI_3      63 DIV_9      00010010000000000000101011101100100110        More check offset                                 0000500b close to ij
 * a3 ILL_1      86 JAL_2      00000000000000001101101011100x00001xx0        Store PC to mepc                                  0000500f close to fence
 * a4 SRxI_0     9a ECALL_6    00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 ILL_2      ca DIVU_2     00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * a6 CSRRW_1    74 unx74      00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * a7 LH_4       af MRET_4     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * a8 LH_5       52 LH_1       00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00005023 close to store
 * a9 SB_1       7d unx7d      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * aa SB_2       e0 DIVU_1     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   40005023 close to store
 * ab MULHU_3    55 aFaultb    00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * ac _L0xac     9e SH_4       00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     eb LH_3       00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     9e SH_4       00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af EBRKWFI2   da LDAF_a     00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * b0 WFI_4      ce _LCSRRCI_1 00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * b1 MULH_1     bf IJT_1      00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * b2 SB_4       7e NMI_1      00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b3 DIV_C         (use dinx) 00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b4 MRET_6     b6 ECALL_5    00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * b5 LBU_3      c2 DIVU_3     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * b6 unalignd   55 aFaultb    00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * b7 SB_5       d6 eILL0c     00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b8 BGE        22 MULHU_6    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 NMI_1      ffffffff (null)     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00005067 close to jalr
 * ba LBU_1      2e MULHU_1    00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * bb JAL_2      d0 ECALL_1    10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * bc CSRRWI_0   a6 ECAL_RET   00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd _LCSRRS_1  7e NMI_1      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * be ILL_3      3d SRxI_2     00000010000000000000101011101100100110        Q = 1                                             00000000 
 * bf LDAF_3     d9 MULH_3     00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * c0 SW_E2      60 MULHU_3    00000000000000001101101111101000001xx0        Store address that faulted                        00006003 close to load
 * c1 SW_E3      f1 aFaulte    00110010000000000000101111001100100110        Q = 3                                             00000000 
 * c2 SH_4       e2 MUL_1      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      0000600b close to ij
 * c3 SH_5       62 DIV_8      00000000000000000001110011100100001xx0        Write d to a+k until accepted                     0000600f close to fence
 * c4 ORI_0      ee eILL0a     00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 ECALL_4    b4 eFetch3    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * c6 MRET_3     a5 MRET_3     00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * c7 DIV_3      5f LDAF_LHU   01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * c8 DIV_6      3e SLL_1      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00006023 close to store
 * c9 EBREAK_2   c6 IJT_4      00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * ca MRET_4     72 LBU_3      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          40006023 close to store
 * cb CSRRW_3    86 JAL_2      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * cc OR_0       49 CSRRW_1    00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      58 DIV_A      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce CSRRW_4    fe ILLe       00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      40006033 sloppy or      
 * cf eFetch3    13 condb_2    0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * d0 SH_3       94 SW_E4      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d1 ECALL_5    e1 ORI_1      00110010000000000000101011001100100110        Q = 8                                             00000000 
 * d2 IJ_3       09 LB_5       00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * d3 DIV_e      3a SRxI_1     00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * d4 SH_2       bf IJT_1      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d5 (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d6 IJ_4       fe ILLe       00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * d7 (null)     c5 MRET_5     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d8 BLTU       22 MULHU_6    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 IJT_2      10 SUB_1      00000000000000001100101011101000110000        Read word is to be masked with ~1u                00006067 close to jalr
 * da MRET_5     1d ORI_2      00000010000000000000000011101100010xx0        ~302                                              00000000 
 * db IJT_4      bf IJT_1      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * dc CSRRSI_0   a6 ECAL_RET   00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd (null)     ef WFI_5      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * de QINT_1     90 NMI_2      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * df (null)     90 NMI_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e0 DIV_7      e2 MUL_1      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00007003 close to load
 * e1 MRET_2     39 MULHU_7    00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * e2 DIVU_2     f0 LBU_2      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            0000700b close to ij
 * e3 _LCSRRCI_1 2e MULHU_1    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000700f close to fence
 * e4 ANDI_0     2e MULHU_1    00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 MRET_7     5d SB_2       00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * e6 Fetch2u    7e NMI_1      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * e7 MULH_3     3a SRxI_1     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * e8 LDAF_a     82 DIV_1      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00007023 close to store
 * e9 jFault_1   db jFault_1   00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * ea aF_SW_1    45 WFI_3      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      40007023 close to store
 * eb DIVU_1     a7 EBRKWFI1   00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * ec AND_0      1e aFault_1   00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     eb LH_3       00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee ORI_1      fe ILLe       00000010000000000000000011101100001xx0        Q = RS1                                           40007033 sloppy and     
 * ef aF_SW_2    7e NMI_1      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * f0 MUL_2      b5 SH_3       00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * f1 IJT_3      3a SRxI_1     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * f2 MULHU_5    86 JAL_2      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * f3 LH_3       ea MULHU_5    00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f4 MULH_2     cf MRET_7     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * f5 WFI_2      e9 IJT_3      00010010000000000000101011101100100110        Check offset                                      00000000 
 * f6 SB_3       f5 jFault     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f7 (null)     c9 MRET_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       22 MULHU_6    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)     e7 aFault     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00007067 close to jalr
 * fa (null)     a2 DIV_14     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     b2 CSRRW_4    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   a6 ECAL_RET   00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      b9 DIV_e      00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       a3 DIV_15     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     de Fetch      00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0080, used ffff, inputs 36
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       6a MULH_1     00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     7e NMI_1      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     7e NMI_1      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     a9 ILL_4      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       59 DIV_B      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     a9 ILL_4      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       bb SH_2       00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      78 DIV_4      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     7e NMI_1      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    59 DIV_B      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     4e eILL0b     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 CSRRW_2    7e NMI_1      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 17 NMI_2      76 Fetchu     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     a1 ECALL_4    00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       7e NMI_1      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   68 DIV_12     00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     7e NMI_1      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LDAF_2     96 SH_1       00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 1f SW_E4      d2 LB_2       00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 20 LH_0       26 OR_1       00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      7e NMI_1      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      95 SW_E3      00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     7e NMI_1      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     92 LDAF_3     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 LH_1       5d SB_2       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LH    3d SRxI_2     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     60 MULHU_3    00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     60 MULHU_3    00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      9c DIV_10     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     b1 aF_SW_3    00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     7e NMI_1      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_2       7e NMI_1      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 31 aFaultb    7a SB_5       00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 32 DIV_A      bb SH_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 33 DIV_B         (use dinx) 00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 34 LHU_1      76 Fetchu     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 35 LDAF_LHU   93 SW_E2      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 36 DIV_8      03 _L0x03     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 37 DIV_9      75 unx75      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    7e NMI_1      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     9b unx9b      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    a6 ECAL_RET   00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e SW_1       92 LDAF_3     00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 3f SW_E1SWE   9a ECALL_6    00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 DIV_12     ab EBREAK_2   00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              0000200b close to ij
 * 43 DIV_13     f2 SW_2       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       b0 CSRRW_3    00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 LHU_2      a5 MRET_3     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultc    be IJ_1       00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 48 _L0x48     3e SLL_1      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     16 condb_5    00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     3e SLL_1      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    cb QINT_2     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e Fetchu     fe ILLe       00000010000000000000001111101010110000  Fr10u Read and latch instruction                        40002033 sloppy slt     
 * 4f eFetchu    7e NMI_1      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 50 DIV_4      7e NMI_1      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 51 DIV_5      e8 MUL_2      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 52 DIV_1      30 SLTIX_2    00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 53 DIV_2      e8 MUL_2      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 54 DIV_E      f3 aF_SW      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 55 DIV_F      41 JALR_1     00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 56 ECALL_6    a8 DIV_3      00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 57 ILL_4      59 DIV_B      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 58 DIVU_5     b3 unxb3      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00002063 close to branch
 * 59 LB_6       62 DIV_8      00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00002067 close to jalr
 * 5a OR_1       aa DIV_6      00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    a6 ECAL_RET   00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       f6 WFI_1      00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e aF_SW_3    46 ILL_1      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 5f QINT_2     e8 MUL_2      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 60 SH_1       10 SUB_1      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00003003 close to load
 * 61 SW_E1SWH   8f ILL_3      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 DIV_10     e0 DIVU_1     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    0000300b close to ij
 * 63 DIV_11     32 JAL_1      01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      83 DIV_2      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 DIV_14     88 DIV_E      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00000000 
 * 67 DIV_15     c0 DIV_D      00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 68 ECAL_RET   7e NMI_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00003023 close to store
 * 69 EBRKWFI1   59 DIV_B      00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 6a IJ_1       f4 Fetch2     00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   40003023 close to store
 * 6b IJT_1      b7 IJ_3       00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIVU_3     d3 aFaultd    00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           40003033 sloppy sltu    
 * 6f DIVU_4     e5 aF_SW_2    01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 70 ECALL_1    ffffffff (null)     00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 71 MRET_1     41 JALR_1     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 72 LB_2       3a SRxI_1     00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 73 aFaultd    29 XOR_1      00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 74 eILL0c        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 ECALL_3       (use dinx) 00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 76 Fetch      e6 StdIncPc   00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 77 eFetch     e6 StdIncPc   00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 78 MUL_1      c8 DIV_7      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00003063 close to branch
 * 79 MUL_3      c7 QINT_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00003067 close to jalr
 * 7a SLTIX_1    88 DIV_E      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    a6 ECAL_RET   00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e StdIncPc   17 condb_5t   10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 7f aFault        (use dinx) 00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 80 LBU_0      ba LHU_3      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 eILL0a     c7 QINT_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000400b close to ij
 * 83 WFI_5      52 LH_1       00110100000010001010110111000100100110        IncPC, OpFetch                                    0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     86 JAL_2      00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 LBU_2      91 LDAF_2     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 87 aFaulte       (use dinx) 00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 88 SW_2       62 DIV_8      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00004023 close to store
 * 89 aF_SW      7e NMI_1      00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 8a Fetch2     3a SRxI_1     00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     40004023 close to store
 * 8b jFault     7e NMI_1      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      52 LH_1       01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e WFI_1      fe ILLe       00110010000000000000000011001100100110 WFI    To check offset                                   40004033 sloppy xor     
 * 8f EBREAK_1   57 LH_5       00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 90 JAL_1      91 LDAF_2     00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 91 JAL_3      bf IJT_1      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 92 SLLI_1     91 LDAF_2     00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 93 SLLI_2     c1 IJT_2      00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 94 ECALL_2    91 LDAF_2     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 95 MULHU_7    1f IJ_2       00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 96 aFault_2   d4 aFault_2   00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 97 (null)     c0 DIV_D      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a SRxI_1     91 LDAF_2     00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 9b SRxI_2        (use dinx) 00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 9c SLL_1      42 MULHU_2    00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00004073 close to csr/system 
 * 9d SRx_1      66 SW_1       00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 9e (null)     c3 DIVU_4     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 9f (null)     88 DIV_E      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * a0 LHU_0      34 JAL_3      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JALR_1     d1 MRET_1     00010010000000000000000011101100100110        Q=1                                               00000000 
 * a2 WFI_3      59 DIV_B      00010010000000000000101011101100100110        More check offset                                 0000500b close to ij
 * a3 ILL_1      7e NMI_1      00000000000000001101101011100x00001xx0        Store PC to mepc                                  0000500f close to fence
 * a4 SRxI_0     9a ECALL_6    00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 ILL_2      ca DIVU_2     00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * a6 CSRRW_1    70 LHU_2      00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * a7 LH_4       af MRET_4     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * a8 LH_5       50 LW_1       00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00005023 close to store
 * a9 SB_1       91 LDAF_2     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * aa SB_2       e0 DIVU_1     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   40005023 close to store
 * ab MULHU_3    56 LH_4       00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * ac _L0xac     9d DIV_11     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     eb LH_3       00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     9d DIV_11     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af EBRKWFI2   da LDAF_a     00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * b0 WFI_4      ce _LCSRRCI_1 00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * b1 MULH_1     bf IJT_1      00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * b2 SB_4       76 Fetchu     00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b3 DIV_C         (use dinx) 00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b4 MRET_6     b6 ECALL_5    00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * b5 LBU_3      c2 DIVU_3     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * b6 unalignd   56 LH_4       00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * b7 SB_5       d5 Fetch2u    00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 NMI_1      ffffffff (null)     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00005067 close to jalr
 * ba LBU_1      3a SRxI_1     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * bb JAL_2      d0 ECALL_1    10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * bc CSRRWI_0   a6 ECAL_RET   00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd _LCSRRS_1  76 Fetchu     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * be ILL_3      45 WFI_3      00000010000000000000101011101100100110        Q = 1                                             00000000 
 * bf LDAF_3     d9 MULH_3     00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * c0 SW_E2      54 LH_2       00000000000000001101101111101000001xx0        Store address that faulted                        00006003 close to load
 * c1 SW_E3      f1 aFaulte    00110010000000000000101111001100100110        Q = 3                                             00000000 
 * c2 SH_4       e2 MUL_1      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      0000600b close to ij
 * c3 SH_5       58 DIV_A      00000000000000000001110011100100001xx0        Write d to a+k until accepted                     0000600f close to fence
 * c4 ORI_0      ee eILL0a     00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 ECALL_4    b4 eFetch3    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * c6 MRET_3     a5 MRET_3     00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * c7 DIV_3      5f LDAF_LHU   01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * c8 DIV_6      36 SLLI_2     00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00006023 close to store
 * c9 EBREAK_2   c6 IJT_4      00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * ca MRET_4     6e DIV_C      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          40006023 close to store
 * cb CSRRW_3    7e NMI_1      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      52 LH_1       01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce CSRRW_4    fe ILLe       00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      40006033 sloppy or      
 * cf eFetch3    13 condb_2    0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * d0 SH_3       94 SW_E4      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d1 ECALL_5    e1 ORI_1      00110010000000000000101011001100100110        Q = 8                                             00000000 
 * d2 IJ_3       09 LB_5       00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * d3 DIV_e      41 JALR_1     00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * d4 SH_2       bf IJT_1      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d5 IJ_4          (use dinx) 00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * d6 (null)     fe ILLe       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d7 (null)     c5 MRET_5     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 IJT_2      10 SUB_1      00000000000000001100101011101000110000        Read word is to be masked with ~1u                00006067 close to jalr
 * da MRET_5     1e aFault_1   00000010000000000000000011101100010xx0        ~302                                              00000000 
 * db IJT_4      bf IJT_1      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * dc CSRRSI_0   a6 ECAL_RET   00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd QINT_1     ef WFI_5      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * de (null)     8a DIVU_5     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * df (null)     8a DIVU_5     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e0 DIV_7      e2 MUL_1      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00007003 close to load
 * e1 MRET_2     3d SRxI_2     00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * e2 DIVU_2     f0 LBU_2      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            0000700b close to ij
 * e3 _LCSRRCI_1 3a SRxI_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 MRET_7     5e LHU_1      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * e6 Fetch2u    76 Fetchu     0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * e7 MULH_3     41 JALR_1     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * e8 LDAF_a     78 DIV_4      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00007023 close to store
 * e9 jFault_1   db jFault_1   00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * ea aF_SW_1    4b CSRRW_2    00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      40007023 close to store
 * eb DIVU_1     a7 EBRKWFI1   00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     eb LH_3       00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee ORI_1      fe ILLe       00000010000000000000000011101100001xx0        Q = RS1                                           40007033 sloppy and     
 * ef aF_SW_2    76 Fetchu     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * f0 MUL_2      b5 SH_3       00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * f1 IJT_3      41 JALR_1     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * f2 MULHU_5    7e NMI_1      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * f3 LH_3       ea MULHU_5    00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f4 MULH_2     cf MRET_7     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * f5 WFI_2      e9 IJT_3      00010010000000000000101011101100100110        Check offset                                      00000000 
 * f6 SB_3       f5 jFault     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f7 (null)     c9 MRET_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)     e7 aFault     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00007067 close to jalr
 * fa (null)     a2 DIV_14     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     b2 CSRRW_4    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   a6 ECAL_RET   00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      b9 DIV_e      00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       a3 DIV_15     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     dd aF_SW_1    00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0010, used ffff, inputs 39
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       9e SH_4       00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       8e _LCSRRS_1  00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     aa DIV_6      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     aa DIV_6      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     df eFetch     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       7f unx7f      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     df eFetch     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       f9 MULH_2     00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      a8 DIV_3      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     aa DIV_6      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 CSRRW_2    7f unx7f      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 11 LDAF_3     3a SRxI_1     00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 12 NMI_2      68 DIV_12     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 13 SW_E2      2e MULHU_1    00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 14 LDAF_2     39 MULHU_7    00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 15 SW_E3      06 LB_3       00110010000000000000101111001100100110        Q = 3                                             00000000 
 * 16 SW_E4      aa DIV_6      00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 17 SH_4       a6 ECAL_RET   00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     ce _LCSRRCI_1 00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       aa DIV_6      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   8a DIVU_5     00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     aa DIV_6      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e MULHU_2    90 NMI_2      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 1f MULHU_4    30 SLTIX_2    00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 20 LH_0       42 MULHU_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      aa DIV_6      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      c5 MRET_5     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     aa DIV_6      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     af MRET_4     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 eILL0b     5d SB_2       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     3d SRxI_2     00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     82 DIV_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     82 DIV_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      ca DIVU_2     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     e5 aF_SW_2    00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    1e aFault_1   00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     aa DIV_6      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 IJ_3       aa DIV_6      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 31 jFault_1   7a SB_5       00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 32 DIV_e      f9 MULH_2     00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 33 aF_SW_1       (use dinx) 00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 34 SH_2       a6 ECAL_RET   00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 35 DIVU_1     b9 DIV_e      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 36 IJ_4       03 _L0x03     00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 37 ORI_1      a3 DIV_15     00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    aa DIV_6      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     c9 MRET_2     00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    db jFault_1   00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LW_1       af MRET_4     00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    c8 DIV_7      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 LH_1       e1 ORI_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH    77 eFetchu    00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       e3 MUL_3      00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 LH_2       da LDAF_a     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    fb SB_3       00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     10 SUB_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    97 SW_E1SWH   00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_A      fe ILLe       00110010000000000000101111101100001xx1        Transfer rM to rDee                               40002033 sloppy slt     
 * 4f DIV_B      aa DIV_6      00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 50 ECALL_6    aa DIV_6      00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 51 SH_5       f6 WFI_1      00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 52 ILL_4      46 ILL_1      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 53 ECALL_4    f6 WFI_1      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 54 aF_SW_3    b1 aF_SW_3    00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 55 MRET_3     41 JALR_1     00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * 56 QINT_2     de Fetch      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 57 DIV_3      7f unx7f      01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * 58 LHU_1      e7 aFault     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00002063 close to branch
 * 59 LDAF_LHU   86 JAL_2      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00002067 close to jalr
 * 5a OR_1       e0 DIVU_1     00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    db jFault_1   00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       b7 IJ_3       00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIV_8      66 SW_1       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 5f DIV_9      f6 WFI_1      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 60 SW_1       1e aFault_1   00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00003003 close to load
 * 61 SW_E1SWE   c7 QINT_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 DIV_12     b0 CSRRW_3    00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              0000300b close to ij
 * 63 DIV_13     4e eILL0b     00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      bb SH_2       00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 LHU_2      c0 DIV_D      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 67 aFaultc    13 condb_2    00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 68 Fetchu     aa DIV_6      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00003023 close to store
 * 69 eFetchu    7f unx7f      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 6a DIV_4      b3 unxb3      00000000000000001100000011101000110000        ~abs(divisor) to yy                               40003023 close to store
 * 6b DIV_5      eb LH_3       00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_1      32 JAL_1      00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40003033 sloppy sltu    
 * 6f DIV_2      f0 LBU_2      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 70 IJT_2      ffffffff (null)     00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * 71 aF_SW_2    41 JALR_1     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 72 MRET_5     3a SRxI_1     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * 73 MUL_2      29 XOR_1      00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 74 IJT_4         (use dinx) 00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 75 IJT_3         (use dinx) 00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 76 QINT_1     f2 SW_2       00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 77 MULHU_5    f2 SW_2       00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 78 DIV_E      91 LDAF_2     01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003063 close to branch
 * 79 DIV_F      57 LH_5       00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00003067 close to jalr
 * 7a SLTIX_1    c0 DIV_D      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    db jFault_1   00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e DIVU_5     12 straddle   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 7f LB_6          (use dinx) 00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 80 LBU_0      ef WFI_5      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 SH_1       57 LH_5       00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        0000400b close to ij
 * 83 SW_E1SWH   6e DIV_C      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     be IJ_1       00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 DIV_10     a5 MRET_3     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 87 DIV_11        (use dinx) 01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 88 DIV_14     86 JAL_2      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00004023 close to store
 * 89 DIV_15     aa DIV_6      00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 8a ECAL_RET   3a SRxI_1     00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40004023 close to store
 * 8b EBRKWFI1   aa DIV_6      00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      6e DIV_C      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e IJ_1       fe ILLe       00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   40004033 sloppy xor     
 * 8f IJT_1      52 LH_1       00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 90 aFault_2   a5 MRET_3     00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 91 DIV_6      11 AND_1      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * 92 (null)     a5 MRET_3     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 93 EBREAK_2   15 condb_4    00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * 94 (null)     a5 MRET_3     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 95 MRET_4     16 condb_5    00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * 96 (null)     34 JAL_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 97 CSRRW_3    13 condb_2    00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a DIVU_3     a5 MRET_3     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 9b DIVU_4        (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 9c ECALL_1    62 DIV_8      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00004073 close to csr/system 
 * 9d MRET_1     88 DIV_E      00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 9e LB_2       51 LDAF_LW    00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 9f aFaultd    c0 DIV_D      00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * a0 LHU_0      58 DIV_A      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JAL_1      d7 ECALL_3    00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * a2 eILL0c     7f unx7f      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000500b close to ij
 * a3 ECALL_3    aa DIV_6      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    0000500f close to fence
 * a4 SRxI_0     c8 DIV_7      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 JAL_3      95 SW_E3      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a6 Fetch      9c DIV_10     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * a7 eFetch     e2 MUL_1      00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * a8 MUL_1      6a MULH_1     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00005023 close to store
 * a9 MUL_3      a5 MRET_3     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * aa StdIncPc   b0 CSRRW_3    10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    40005023 close to store
 * ab aFault     50 LW_1       00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * ac _L0xac     cb QINT_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     35 SLLI_1     00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     cb QINT_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SLLI_1     72 LBU_3      00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * b0 DIV_7      d1 MRET_1     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * b1 LH_3       11 AND_1      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * b2 MRET_2     a6 ECAL_RET   00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * b3 MULH_2        (use dinx) 00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * b4 DIVU_2     ea MULHU_5    00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * b5 WFI_2      17 condb_5t   00010010000000000000101011101100100110        Check offset                                      00000000 
 * b6 _LCSRRCI_1 50 LW_1       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b7 SB_3       36 SLLI_2     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SLLI_2     ffffffff (null)     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00005067 close to jalr
 * ba eILL0a     3a SRxI_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bb WFI_5      d5 Fetch2u    00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * bc CSRRWI_0   db jFault_1   00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ECALL_2    a6 ECAL_RET   00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * be LBU_2      45 WFI_3      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * bf aFaulte    70 LHU_2      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * c0 SW_2       78 DIV_4      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00006003 close to load
 * c1 aF_SW      75 unx75      00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * c2 Fetch2     b4 eFetch3    00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     0000600b close to ij
 * c3 jFault     7e NMI_1      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000600f close to fence
 * c4 ORI_0      37 ECALL_2    00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MULHU_7    e8 MUL_2      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * c6 WFI_1      da LDAF_a     00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * c7 EBREAK_1   56 LH_4       00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * c8 SRxI_1     5e LHU_1      00000000000000000100101001101100001xx1        Register to shift to Q                            00006023 close to store
 * c9 SRxI_2     55 aFaultb    00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * ca SLL_1      9a ECALL_6    00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              40006023 close to store
 * cb SRx_1      aa DIV_6      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      6e DIV_C      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce JALR_1     fe ILLe       00010010000000000000000011101100100110        Q=1                                               40006033 sloppy or      
 * cf WFI_3      27 OR_2       00010010000000000000101011101100100110        More check offset                                 00000000 
 * d0 (null)     bd IJ_4       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d1 CSRRW_4    b2 CSRRW_4    00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d2 (null)     09 LB_5       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d3 eFetch3    41 JALR_1     0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * d4 (null)     11 AND_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d5 SH_3          (use dinx) 00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d6 (null)     fe ILLe       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d7 ECALL_5    53 LDAF_LH    00110010000000000000101011001100100110        Q = 8                                             00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 ILL_1      1e aFault_1   00000000000000001101101011100x00001xx0        Store PC to mepc                                  00006067 close to jalr
 * da ILL_2      14 condb_3    00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * db CSRRW_1    11 AND_1      00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * dc CSRRSI_0   db jFault_1   00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd LH_4       71 aFaultc    00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * de LH_5       c2 DIVU_3     00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * df SB_1       c2 DIVU_3     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * e0 SB_2       b4 eFetch3    00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00007003 close to load
 * e1 MULHU_3    3d SRxI_2     00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * e2 EBRKWFI2   73 unalignd   00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         0000700b close to ij
 * e3 WFI_4      3a SRxI_1     00000010000000000000001011x01001xxxxx0        Prepare read PC                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 MULH_1     54 LH_2       00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * e6 SB_4       a6 ECAL_RET   00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * e7 DIV_C      41 JALR_1     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * e8 MRET_6     a8 DIV_3      00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00007023 close to store
 * e9 LBU_3      74 unx74      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * ea unalignd   4b CSRRW_2    00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                40007023 close to store
 * eb SB_5       dd aF_SW_1    00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     35 SLLI_1     00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee NMI_1      fe ILLe       00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40007033 sloppy and     
 * ef LBU_1      a6 ECAL_RET   00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * f0 MRET_7     e9 IJT_3      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f1 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f2 Fetch2u    aa DIV_6      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f3 (null)     33 unx33      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 MULH_3     d3 aFaultd    00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * f5 (null)     31 SLTX_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f6 LDAF_a     b5 SH_3       00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * f7 (null)     93 SW_E2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 JAL_2      f4 Fetch2     10110000000000000100110011000x00100110        Return address to TRG                             00007067 close to jalr
 * fa _LCSRRS_1  cf MRET_7     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * fb ILL_3      e6 StdIncPc   00000010000000000000101011101100100110        Q = 1                                             00000000 
 * fc CSRRCI_0   db jFault_1   00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      ee eILL0a     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       d9 MULH_3     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     76 Fetchu     00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0010, used ffff, inputs 3a
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       9e SH_4       00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       8e _LCSRRS_1  00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     aa DIV_6      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     aa DIV_6      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     df eFetch     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       7f unx7f      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     df eFetch     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       f9 MULH_2     00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      a8 DIV_3      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     aa DIV_6      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 CSRRW_2    7f unx7f      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 11 NMI_2      3a SRxI_1     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 12 LDAF_3     68 DIV_12     00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 13 SW_E2      2e MULHU_1    00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 14 LDAF_2     39 MULHU_7    00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 15 SW_E4      06 LB_3       00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 16 SW_E3      aa DIV_6      00110010000000000000101111001100100110        Q = 3                                             00000000 
 * 17 SH_4       a6 ECAL_RET   00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     ce _LCSRRCI_1 00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       aa DIV_6      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   8a DIVU_5     00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     aa DIV_6      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e MULHU_2    90 NMI_2      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 1f MULHU_4    30 SLTIX_2    00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 20 LH_0       42 MULHU_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      aa DIV_6      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      c5 MRET_5     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     aa DIV_6      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     af MRET_4     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 eILL0b     5d SB_2       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     3d SRxI_2     00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     82 DIV_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     82 DIV_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      ca DIVU_2     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     e5 aF_SW_2    00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    1e aFault_1   00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     aa DIV_6      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 IJ_3       aa DIV_6      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 31 DIV_e      7a SB_5       00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 32 jFault_1   f9 MULH_2     00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 33 aF_SW_1       (use dinx) 00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 34 SH_2       a6 ECAL_RET   00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 35 IJ_4       b9 DIV_e      00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 36 DIVU_1     03 _L0x03     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 37 ORI_1      a3 DIV_15     00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    aa DIV_6      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     c9 MRET_2     00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    db jFault_1   00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LW_1       af MRET_4     00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    c8 DIV_7      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 LH_1       e1 ORI_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH    77 eFetchu    00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       e3 MUL_3      00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 LH_2       da LDAF_a     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    fb SB_3       00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     10 SUB_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    97 SW_E1SWH   00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_A      fe ILLe       00110010000000000000101111101100001xx1        Transfer rM to rDee                               40002033 sloppy slt     
 * 4f DIV_B      aa DIV_6      00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 50 ECALL_6    aa DIV_6      00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 51 ILL_4      f5 jFault     00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 52 SH_5       46 ILL_1      00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 53 ECALL_4    f5 jFault     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 54 aF_SW_3    b2 CSRRW_4    00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 55 QINT_2     41 JALR_1     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 56 MRET_3     de Fetch      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * 57 DIV_3      7f unx7f      01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * 58 LHU_1      e7 aFault     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00002063 close to branch
 * 59 LDAF_LHU   86 JAL_2      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00002067 close to jalr
 * 5a OR_1       e0 DIVU_1     00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    db jFault_1   00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       b7 IJ_3       00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIV_8      66 SW_1       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 5f DIV_9      f5 jFault     01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 60 SW_1       1e aFault_1   00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00003003 close to load
 * 61 SW_E1SWE   c7 QINT_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 DIV_12     b0 CSRRW_3    00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              0000300b close to ij
 * 63 DIV_13     4e eILL0b     00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      bb SH_2       00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 LHU_2      c0 DIV_D      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 67 aFaultc    13 condb_2    00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 68 Fetchu     aa DIV_6      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00003023 close to store
 * 69 eFetchu    7f unx7f      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 6a DIV_4      b3 unxb3      00000000000000001100000011101000110000        ~abs(divisor) to yy                               40003023 close to store
 * 6b DIV_5      eb LH_3       00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_1      31 SLTX_1     00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40003033 sloppy sltu    
 * 6f DIV_2      f0 LBU_2      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 70 IJT_2      ffffffff (null)     00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * 71 MRET_5     41 JALR_1     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * 72 aF_SW_2    3a SRxI_1     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 73 MUL_2      29 XOR_1      00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 74 IJT_4         (use dinx) 00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 75 QINT_1        (use dinx) 00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 76 IJT_3      f1 aFaulte    00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 77 MULHU_5    f1 aFaulte    00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 78 DIV_E      92 LDAF_3     01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003063 close to branch
 * 79 DIV_F      57 LH_5       00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00003067 close to jalr
 * 7a SLTIX_1    c0 DIV_D      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    db jFault_1   00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e DIVU_5     11 AND_1      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 7f LB_6          (use dinx) 00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 80 LBU_0      ef WFI_5      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 SH_1       57 LH_5       00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        0000400b close to ij
 * 83 SW_E1SWH   6e DIV_C      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     be IJ_1       00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 DIV_10     a5 MRET_3     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 87 DIV_11        (use dinx) 01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 88 DIV_14     86 JAL_2      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00004023 close to store
 * 89 DIV_15     aa DIV_6      00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 8a ECAL_RET   3a SRxI_1     00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40004023 close to store
 * 8b EBRKWFI1   aa DIV_6      00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      6e DIV_C      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e IJ_1       fe ILLe       00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   40004033 sloppy xor     
 * 8f IJT_1      51 LDAF_LW    00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 90 aFault_2   a5 MRET_3     00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 91 (null)     12 straddle   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 92 DIV_6      a5 MRET_3     00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * 93 EBREAK_2   16 condb_5    00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * 94 (null)     a5 MRET_3     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 95 (null)     15 condb_4    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 96 MRET_4     34 JAL_3      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * 97 CSRRW_3    13 condb_2    00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a DIVU_3     a5 MRET_3     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 9b DIVU_4        (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 9c ECALL_1    62 DIV_8      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00004073 close to csr/system 
 * 9d MRET_1     88 DIV_E      00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 9e LB_2       52 LH_1       00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 9f aFaultd    c0 DIV_D      00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * a0 LHU_0      58 DIV_A      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JAL_1      d7 ECALL_3    00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * a2 eILL0c     7f unx7f      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000500b close to ij
 * a3 ECALL_3    aa DIV_6      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    0000500f close to fence
 * a4 SRxI_0     c8 DIV_7      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 JAL_3      96 SH_1       00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a6 Fetch      9c DIV_10     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * a7 eFetch     e2 MUL_1      00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * a8 MUL_1      6a MULH_1     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00005023 close to store
 * a9 MUL_3      a5 MRET_3     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * aa StdIncPc   b0 CSRRW_3    10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    40005023 close to store
 * ab aFault     50 LW_1       00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * ac _L0xac     cb QINT_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     36 SLLI_2     00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     cb QINT_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SLLI_1     71 aFaultc    00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * b0 DIV_7      d2 LB_2       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * b1 MRET_2     12 straddle   00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * b2 LH_3       a6 ECAL_RET   00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * b3 MULH_2        (use dinx) 00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * b4 DIVU_2     ea MULHU_5    00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * b5 _LCSRRCI_1 17 condb_5t   00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b6 WFI_2      50 LW_1       00010010000000000000101011101100100110        Check offset                                      00000000 
 * b7 SB_3       35 SLLI_1     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SLLI_2     ffffffff (null)     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00005067 close to jalr
 * ba eILL0a     3a SRxI_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bb WFI_5      d6 eILL0c     00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * bc CSRRWI_0   db jFault_1   00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ECALL_2    a6 ECAL_RET   00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * be LBU_2      45 WFI_3      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * bf aFaulte    70 LHU_2      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * c0 SW_2       78 DIV_4      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00006003 close to load
 * c1 aF_SW      76 Fetchu     00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * c2 Fetch2     b4 eFetch3    00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     0000600b close to ij
 * c3 jFault     7e NMI_1      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000600f close to fence
 * c4 ORI_0      37 ECALL_2    00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MULHU_7    e8 MUL_2      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * c6 WFI_1      da LDAF_a     00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * c7 EBREAK_1   55 aFaultb    00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * c8 SRxI_1     5e LHU_1      00000000000000000100101001101100001xx1        Register to shift to Q                            00006023 close to store
 * c9 SRxI_2     56 LH_4       00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * ca SLL_1      9a ECALL_6    00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              40006023 close to store
 * cb SRx_1      aa DIV_6      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      6e DIV_C      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce JALR_1     fe ILLe       00010010000000000000000011101100100110        Q=1                                               40006033 sloppy or      
 * cf WFI_3      27 OR_2       00010010000000000000101011101100100110        More check offset                                 00000000 
 * d0 (null)     bd IJ_4       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d1 (null)     b1 aF_SW_3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d2 CSRRW_4    09 LB_5       00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d3 eFetch3    41 JALR_1     0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * d4 (null)     12 straddle   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d5 (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d6 SH_3       fe ILLe       00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d7 ECALL_5    53 LDAF_LH    00110010000000000000101011001100100110        Q = 8                                             00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 ILL_1      1e aFault_1   00000000000000001101101011100x00001xx0        Store PC to mepc                                  00006067 close to jalr
 * da ILL_2      14 condb_3    00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * db CSRRW_1    12 straddle   00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * dc CSRRSI_0   db jFault_1   00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd LH_4       72 LBU_3      00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * de LH_5       c2 DIVU_3     00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * df SB_1       c2 DIVU_3     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * e0 SB_2       b4 eFetch3    00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00007003 close to load
 * e1 MULHU_3    3d SRxI_2     00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * e2 EBRKWFI2   73 unalignd   00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         0000700b close to ij
 * e3 WFI_4      3a SRxI_1     00000010000000000000001011x01001xxxxx0        Prepare read PC                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 MULH_1     54 LH_2       00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * e6 SB_4       a6 ECAL_RET   00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * e7 DIV_C      41 JALR_1     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * e8 MRET_6     a8 DIV_3      00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00007023 close to store
 * e9 LBU_3      74 unx74      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * ea unalignd   4b CSRRW_2    00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                40007023 close to store
 * eb SB_5       dd aF_SW_1    00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     36 SLLI_2     00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee NMI_1      fe ILLe       00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40007033 sloppy and     
 * ef LBU_1      a6 ECAL_RET   00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * f0 MRET_7     e9 IJT_3      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f1 Fetch2u    41 JALR_1     0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f2 (null)     aa DIV_6      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f3 (null)     33 unx33      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 MULH_3     d3 aFaultd    00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * f5 LDAF_a     32 JAL_1      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * f6 (null)     b6 ECALL_5    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     93 SW_E2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 JAL_2      f4 Fetch2     10110000000000000100110011000x00100110        Return address to TRG                             00007067 close to jalr
 * fa _LCSRRS_1  cf MRET_7     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * fb ILL_3      e6 StdIncPc   00000010000000000000101011101100100110        Q = 1                                             00000000 
 * fc CSRRCI_0   db jFault_1   00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      ee eILL0a     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       d9 MULH_3     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     75 unx75      00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0010, used ffff, inputs 3c
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       9e SH_4       00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       8e _LCSRRS_1  00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     aa DIV_6      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     aa DIV_6      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     df eFetch     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       7f unx7f      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     df eFetch     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       f9 MULH_2     00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      a8 DIV_3      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     aa DIV_6      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 CSRRW_2    7f unx7f      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 11 NMI_2      3a SRxI_1     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 12 LDAF_2     68 DIV_12     00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 13 SW_E4      2e MULHU_1    00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 14 LDAF_3     39 MULHU_7    00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 15 SW_E2      06 LB_3       00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 16 SW_E3      aa DIV_6      00110010000000000000101111001100100110        Q = 3                                             00000000 
 * 17 SH_4       a6 ECAL_RET   00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     ce _LCSRRCI_1 00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       aa DIV_6      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   8a DIVU_5     00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     aa DIV_6      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e MULHU_2    90 NMI_2      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 1f MULHU_4    30 SLTIX_2    00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 20 LH_0       42 MULHU_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      aa DIV_6      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      c5 MRET_5     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     aa DIV_6      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     af MRET_4     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 eILL0b     5d SB_2       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     3d SRxI_2     00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     82 DIV_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     82 DIV_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      ca DIVU_2     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     e5 aF_SW_2    00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    1e aFault_1   00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     aa DIV_6      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 IJ_3       aa DIV_6      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 31 DIV_e      7a SB_5       00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 32 SH_2       f9 MULH_2     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 33 IJ_4          (use dinx) 00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 34 jFault_1   a6 ECAL_RET   00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 35 aF_SW_1    b9 DIV_e      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 36 DIVU_1     03 _L0x03     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 37 ORI_1      a3 DIV_15     00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    aa DIV_6      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     c9 MRET_2     00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    db jFault_1   00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LW_1       af MRET_4     00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    c8 DIV_7      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 LH_1       e1 ORI_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH    77 eFetchu    00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       e3 MUL_3      00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 LH_2       da LDAF_a     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    fb SB_3       00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     10 SUB_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    97 SW_E1SWH   00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_A      fe ILLe       00110010000000000000101111101100001xx1        Transfer rM to rDee                               40002033 sloppy slt     
 * 4f DIV_B      aa DIV_6      00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 50 ECALL_6    aa DIV_6      00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 51 ILL_4      f3 aF_SW      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 52 aF_SW_3    46 ILL_1      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 53 QINT_2     f3 aF_SW      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 54 SH_5       b4 eFetch3    00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 55 ECALL_4    41 JALR_1     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 56 MRET_3     de Fetch      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * 57 DIV_3      7f unx7f      01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * 58 LHU_1      e7 aFault     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00002063 close to branch
 * 59 LDAF_LHU   86 JAL_2      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00002067 close to jalr
 * 5a OR_1       e0 DIVU_1     00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    db jFault_1   00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       b7 IJ_3       00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIV_8      66 SW_1       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 5f DIV_9      f3 aF_SW      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 60 SW_1       1e aFault_1   00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00003003 close to load
 * 61 SW_E1SWE   c7 QINT_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 DIV_12     b0 CSRRW_3    00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              0000300b close to ij
 * 63 DIV_13     4e eILL0b     00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      bb SH_2       00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 LHU_2      c0 DIV_D      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 67 aFaultc    15 condb_4    00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 68 Fetchu     aa DIV_6      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00003023 close to store
 * 69 eFetchu    7f unx7f      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 6a DIV_4      b5 SH_3       00000000000000001100000011101000110000        ~abs(divisor) to yy                               40003023 close to store
 * 6b DIV_5      eb LH_3       00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_1      31 SLTX_1     00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40003033 sloppy sltu    
 * 6f DIV_2      f0 LBU_2      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 70 IJT_2      ffffffff (null)     00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * 71 MRET_5     41 JALR_1     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * 72 IJT_4      3a SRxI_1     00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 73 QINT_1     29 XOR_1      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 74 aF_SW_2       (use dinx) 00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 75 MUL_2         (use dinx) 00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 76 IJT_3      f1 aFaulte    00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 77 MULHU_5    f1 aFaulte    00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 78 DIV_E      94 SW_E4      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003063 close to branch
 * 79 DIV_F      57 LH_5       00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00003067 close to jalr
 * 7a SLTIX_1    c0 DIV_D      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    db jFault_1   00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e DIVU_5     11 AND_1      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 7f LB_6          (use dinx) 00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 80 LBU_0      ef WFI_5      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 SH_1       57 LH_5       00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        0000400b close to ij
 * 83 SW_E1SWH   6e DIV_C      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     be IJ_1       00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 DIV_10     a5 MRET_3     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 87 DIV_11        (use dinx) 01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 88 DIV_14     86 JAL_2      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00004023 close to store
 * 89 DIV_15     aa DIV_6      00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 8a ECAL_RET   3a SRxI_1     00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40004023 close to store
 * 8b EBRKWFI1   aa DIV_6      00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      6e DIV_C      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e IJ_1       fe ILLe       00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   40004033 sloppy xor     
 * 8f IJT_1      51 LDAF_LW    00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 90 aFault_2   a5 MRET_3     00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 91 (null)     14 condb_3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 92 (null)     a5 MRET_3     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 93 (null)     16 condb_5    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 94 DIV_6      a5 MRET_3     00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * 95 EBREAK_2   13 condb_2    00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * 96 MRET_4     32 JAL_1      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * 97 CSRRW_3    15 condb_4    00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a DIVU_3     a5 MRET_3     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 9b DIVU_4        (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 9c ECALL_1    62 DIV_8      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00004073 close to csr/system 
 * 9d MRET_1     88 DIV_E      00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 9e LB_2       54 LH_2       00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 9f aFaultd    c0 DIV_D      00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * a0 LHU_0      58 DIV_A      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JAL_1      d7 ECALL_3    00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * a2 eILL0c     7f unx7f      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000500b close to ij
 * a3 ECALL_3    aa DIV_6      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    0000500f close to fence
 * a4 SRxI_0     c8 DIV_7      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 JAL_3      96 SH_1       00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a6 Fetch      9c DIV_10     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * a7 eFetch     e2 MUL_1      00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * a8 MUL_1      6a MULH_1     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00005023 close to store
 * a9 MUL_3      a5 MRET_3     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * aa StdIncPc   b0 CSRRW_3    10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    40005023 close to store
 * ab aFault     50 LW_1       00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * ac _L0xac     cb QINT_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     36 SLLI_2     00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     cb QINT_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SLLI_1     71 aFaultc    00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * b0 DIV_7      d4 aFault_2   00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * b1 MRET_2     14 condb_3    00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * b2 DIVU_2     a6 ECAL_RET   00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * b3 _LCSRRCI_1    (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b4 LH_3       ea MULHU_5    00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * b5 MULH_2     17 condb_5t   00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * b6 WFI_2      50 LW_1       00010010000000000000101011101100100110        Check offset                                      00000000 
 * b7 SB_3       33 unx33      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SLLI_2     ffffffff (null)     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00005067 close to jalr
 * ba eILL0a     3a SRxI_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bb WFI_5      d6 eILL0c     00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * bc CSRRWI_0   db jFault_1   00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ECALL_2    a6 ECAL_RET   00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * be LBU_2      45 WFI_3      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * bf aFaulte    70 LHU_2      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * c0 SW_2       78 DIV_4      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00006003 close to load
 * c1 aF_SW      76 Fetchu     00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * c2 Fetch2     b2 CSRRW_4    00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     0000600b close to ij
 * c3 jFault     7e NMI_1      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000600f close to fence
 * c4 ORI_0      37 ECALL_2    00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MULHU_7    e8 MUL_2      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * c6 WFI_1      da LDAF_a     00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * c7 EBREAK_1   53 LDAF_LH    00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * c8 SRxI_1     5e LHU_1      00000000000000000100101001101100001xx1        Register to shift to Q                            00006023 close to store
 * c9 SRxI_2     56 LH_4       00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * ca SLL_1      9a ECALL_6    00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              40006023 close to store
 * cb SRx_1      aa DIV_6      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      6e DIV_C      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce JALR_1     fe ILLe       00010010000000000000000011101100100110        Q=1                                               40006033 sloppy or      
 * cf WFI_3      27 OR_2       00010010000000000000101011101100100110        More check offset                                 00000000 
 * d0 (null)     bd IJ_4       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d1 (null)     b1 aF_SW_3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d2 (null)     09 LB_5       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d3 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d4 CSRRW_4    14 condb_3    00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d5 eFetch3       (use dinx) 0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * d6 SH_3       fe ILLe       00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d7 ECALL_5    55 aFaultb    00110010000000000000101011001100100110        Q = 8                                             00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 ILL_1      1e aFault_1   00000000000000001101101011100x00001xx0        Store PC to mepc                                  00006067 close to jalr
 * da ILL_2      12 straddle   00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * db CSRRW_1    14 condb_3    00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * dc CSRRSI_0   db jFault_1   00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd LH_4       74 unx74      00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * de LH_5       c2 DIVU_3     00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * df SB_1       c2 DIVU_3     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * e0 SB_2       b2 CSRRW_4    00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00007003 close to load
 * e1 MULHU_3    3d SRxI_2     00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * e2 EBRKWFI2   75 unx75      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         0000700b close to ij
 * e3 WFI_4      3a SRxI_1     00000010000000000000001011x01001xxxxx0        Prepare read PC                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 MULH_1     52 LH_1       00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * e6 SB_4       a6 ECAL_RET   00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * e7 DIV_C      41 JALR_1     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * e8 MRET_6     a8 DIV_3      00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00007023 close to store
 * e9 LBU_3      72 LBU_3      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * ea unalignd   4b CSRRW_2    00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                40007023 close to store
 * eb SB_5       dd aF_SW_1    00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     36 SLLI_2     00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee NMI_1      fe ILLe       00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40007033 sloppy and     
 * ef LBU_1      a6 ECAL_RET   00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * f0 MRET_7     e9 IJT_3      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f1 Fetch2u    41 JALR_1     0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f2 MULH_3     aa DIV_6      00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * f3 LDAF_a     35 SLLI_1     00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * f4 (null)     d5 Fetch2u    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f5 (null)     34 JAL_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f6 (null)     b6 ECALL_5    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     95 SW_E3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 JAL_2      f2 SW_2       10110000000000000100110011000x00100110        Return address to TRG                             00007067 close to jalr
 * fa _LCSRRS_1  cf MRET_7     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * fb ILL_3      e6 StdIncPc   00000010000000000000101011101100100110        Q = 1                                             00000000 
 * fc CSRRCI_0   db jFault_1   00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      ee eILL0a     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       d9 MULH_3     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     73 unalignd   00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0200, used ffff, inputs 47
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       74 unx74      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       6a MULH_1     00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     86 JAL_2      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     86 JAL_2      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     a5 MRET_3     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       55 aFaultb    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     a5 MRET_3     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       b6 ECALL_5    00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      82 DIV_1      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     86 JAL_2      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    55 aFaultb    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       86 JAL_2      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    7e NMI_1      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     9c DIV_10     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       86 JAL_2      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     7a SB_5       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   66 SW_1       00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     86 JAL_2      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       c1 IJT_2      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    d0 ECALL_1    00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      86 JAL_2      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      95 SW_E3      00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     86 JAL_2      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     81 unx81      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     56 LH_4       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   50 LW_1       10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     56 LH_4       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    70 LHU_2      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      9a ECALL_6    00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     aa DIV_6      00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     86 JAL_2      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      86 JAL_2      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   65 WFI_4      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      b6 ECALL_5    00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       7e NMI_1      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   85 LBU_1      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     77 eFetchu    00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    86 JAL_2      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     97 SW_E1SWH   00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     7a SB_5       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      81 unx81      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    96 SH_1       00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 CSRRW_2    1d ORI_2      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 42 Fetchu     a7 EBRKWFI1   00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    f0 LBU_2      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     65 WFI_4      00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 aFault_1   a9 ILL_4      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 46 DIV_4      9f SH_5       00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 47 DIV_5      b9 DIV_e      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 NMI_2      41 JALR_1     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b IJ_2       c8 DIV_7      00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 4c SLT_0      78 DIV_4      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   68 DIV_12     00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_1      fe ILLe       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40002033 sloppy slt     
 * 4f DIV_2      86 JAL_2      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 50 XORI_1     86 JAL_2      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 51 LDAF_2     e5 aF_SW_2    00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 52 DIV_E      1e aFault_1   01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 53 DIV_F      e5 aF_SW_2    00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 54 DIVU_5     f2 SW_2       00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 55 LB_6       45 WFI_3      00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 56 SH_1       a3 DIV_15     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 57 SW_E1SWH   55 aFaultb    00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 58 MULHU_6    af MRET_4     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00002063 close to branch
 * 59 SW_E4      5e LHU_1      00000000110000001110100111100x00101000        Store 6 to mcause                                 00002067 close to jalr
 * 5a OR_1       a6 ECAL_RET   00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     7a SB_5       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       f5 jFault     00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIV_10     3e SLL_1      01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 5f DIV_11     e5 aF_SW_2    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 60 XOR_1      10 SUB_1      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00003003 close to load
 * 61 ECALL_6    93 SW_E2      00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 62 DIV_14     db jFault_1   00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 0000300b close to ij
 * 63 DIV_15     26 OR_1       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               0000300f close to fence
 * 64 SLTIU_0    65 WFI_4      00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLTIX_1    89 DIV_F      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 66 ECAL_RET   8e _LCSRRS_1  00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 67 EBRKWFI1   bb SH_2       00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 68 MULHU_1    86 JAL_2      00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00003023 close to store
 * 69 ILL_4      55 aFaultb    00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 6a IJ_1       f3 aF_SW      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   40003023 close to store
 * 6b IJT_1      b3 unxb3      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 6c SLTU_0     78 DIV_4      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    68 DIV_12     00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIVU_3     d2 LB_2       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           40003033 sloppy sltu    
 * 6f DIVU_4     e0 DIVU_1     01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 70 SLTIX_2    ffffffff (null)     00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 71 aF_SW_3    45 WFI_3      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 72 ECALL_1    3a SRxI_1     00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 73 MRET_1     29 XOR_1      00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 74 LB_2          (use dinx) 00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 75 aFaultd       (use dinx) 00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 76 eILL0c     e2 MUL_1      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 77 ECALL_3    e2 MUL_1      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 78 SLTX_1     c5 MRET_5     00000010000000000000111111101100000xx0        ~rs2 to Q                                         00003063 close to branch
 * 79 QINT_2     c3 DIVU_4     00000000110000001111010011101000110000        mtval = 0.                                        00003067 close to jalr
 * 7a JAL_1      8e _LCSRRS_1  00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 7b _L0x7b     7a SB_5       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d JAL_3         (use dinx) 00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 7e Fetch      49 CSRRW_1    00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 7f eFetch        (use dinx) 00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 80 LBU_0      b5 SH_3       00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLLI_1        (use dinx) 00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 82 MUL_1      c3 DIVU_4     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           0000400b close to ij
 * 83 MUL_3      4e eILL0b     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               0000400f close to fence
 * 84 XORI_0     50 LW_1       00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLLI_2     8a DIVU_5     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 86 StdIncPc   7d unx7d      10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 87 aFault        (use dinx) 00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 88 eILL0a     5e LHU_1      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00004023 close to store
 * 89 WFI_5      86 JAL_2      00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 8a LBU_2      3a SRxI_1     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40004023 close to store
 * 8b aFaulte    86 JAL_2      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 8c XOR_0      60 MULHU_3    00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      4e eILL0b     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e SW_2       fe ILLe       00000010000000000000001011x01000xxxxx0        Prepare read PC                                   40004033 sloppy xor     
 * 8f aF_SW      69 DIV_13     00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 90 Fetch2     7d unx7d      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 91 jFault     ba LHU_3      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 92 WFI_1      7d unx7d      00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 93 EBREAK_1   bd IJ_4       00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 94 ECALL_2    7d unx7d      00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 95 MULHU_7    59 DIV_B      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 96 SRxI_1     d3 aFaultd    00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 97 SRxI_2     bb SH_2       00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a SLL_1      7d unx7d      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 9b SRx_1         (use dinx) 00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 9c JALR_1     36 SLLI_2     00010010000000000000000011101100100110        Q=1                                               00004073 close to csr/system 
 * 9d WFI_3      62 DIV_8      00010010000000000000101011101100100110        More check offset                                 00000000 
 * 9e ILL_1      bf IJT_1      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 9f ILL_2      8e _LCSRRS_1  00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 CSRRW_1    cf MRET_7     00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * a2 LH_4       55 aFaultb    00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      0000500b close to ij
 * a3 LH_5       86 JAL_2      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               0000500f close to fence
 * a4 SRxI_0     96 SH_1       00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SB_1       c7 QINT_1     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * a6 SB_2       72 LBU_3      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * a7 MULHU_3    a8 DIV_3      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * a8 EBRKWFI2   46 ILL_1      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00005023 close to store
 * a9 WFI_4      7d unx7d      00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * aa MULH_1     db jFault_1   00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              40005023 close to store
 * ab SB_4       61 EBRKWFI2   00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * ac _L0xac     9b unx9b      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     e8 MUL_2      00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     9b unx9b      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af DIV_C      d6 eILL0c     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b0 MRET_6     ca DIVU_2     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * b1 LBU_3      ba LHU_3      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * b2 unalignd   7e NMI_1      00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * b3 SB_5          (use dinx) 00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b4 NMI_1      b2 CSRRW_4    00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * b5 LBU_1      be IJ_1       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * b6 JAL_2      61 EBRKWFI2   10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * b7 _LCSRRS_1  d4 aFault_2   00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 ILL_3      ffffffff (null)     00000010000000000000101011101100100110        Q = 1                                             00005067 close to jalr
 * ba LDAF_3     3a SRxI_1     00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * bb SW_E2      ce _LCSRRCI_1 00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * bc CSRRWI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SW_E3      7e NMI_1      00110010000000000000101111001100100110        Q = 3                                             00000000 
 * be SH_4       4b CSRRW_2    00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * bf SH_5       d5 Fetch2u    00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * c0 ECALL_4    52 LH_1       00110010000000000000101011001100100110        Q = 4                                             00006003 close to load
 * c1 aFault_2   ef WFI_5      00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * c2 MRET_3     de Fetch      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          0000600b close to ij
 * c3 DIV_3      54 LH_2       01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        0000600f close to fence
 * c4 ORI_0      ea MULHU_5    00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 DIV_6      b0 CSRRW_3    00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * c6 EBREAK_2   9f SH_5       00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * c7 MRET_4     79 DIV_5      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * c8 CSRRW_3    32 JAL_1      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00006023 close to store
 * c9 (null)     c2 DIVU_3     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ca CSRRW_4    6e DIV_C      00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      40006023 close to store
 * cb eFetch3    86 JAL_2      0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      4e eILL0b     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce SH_3       fe ILLe       00000010000000000000000011101000110000        Prepare get back address to use                   40006033 sloppy or      
 * cf ECALL_5    13 condb_2    00110010000000000000101011001100100110        Q = 8                                             00000000 
 * d0 IJ_3       94 SW_E4      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * d1 (null)     dd aF_SW_1    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d2 DIV_e      09 LB_5       00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * d3 SH_2       45 WFI_3      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d4 IJ_4       ba LHU_3      00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * d5 IJT_2         (use dinx) 00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * d6 MRET_5     fe ILLe       00000010000000000000000011101100010xx0        ~302                                              00000000 
 * d7 IJT_4      c0 DIV_D      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 (null)     10 SUB_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00006067 close to jalr
 * da QINT_1     51 LDAF_LW    00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * db DIV_7      ba LHU_3      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * dc CSRRSI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd MRET_2     eb LH_3       00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * de DIVU_2     90 NMI_2      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * df _LCSRRCI_1 90 NMI_2      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * e0 MRET_7     de Fetch      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00007003 close to load
 * e1 (null)     3d SRxI_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e2 Fetch2u    ee eILL0a     0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     0000700b close to ij
 * e3 MULH_3     3a SRxI_1     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 LDAF_a     71 aFaultc    00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * e6 jFault_1   7e NMI_1      00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * e7 aF_SW_1    45 WFI_3      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * e8 DIVU_1     82 DIV_1      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00007023 close to store
 * e9 (null)     d7 ECALL_3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ea ORI_1      58 DIV_A      00000010000000000000000011101100001xx0        Q = RS1                                           40007023 close to store
 * eb aF_SW_2    a2 DIV_14     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     e8 MUL_2      00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee MUL_2      fe ILLe       00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  40007033 sloppy and     
 * ef IJT_3      7e NMI_1      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * f0 MULHU_5    b1 aF_SW_3    00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * f1 (null)     45 WFI_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f2 LH_3       86 JAL_2      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f3 MULH_2     e7 aFault     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * f4 WFI_2      cb QINT_2     00010010000000000000101011101100100110        Check offset                                      00000000 
 * f5 SB_3       e6 StdIncPc   00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f6 (null)     f4 Fetch2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     c6 IJT_4      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)     e3 MUL_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00007067 close to jalr
 * fa (null)     9d DIV_11     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     ab EBREAK_2   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      b4 eFetch3    00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       9e SH_4       00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     da LDAF_a     00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0200, used ffff, inputs 4b
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       8e _LCSRRS_1  00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       86 JAL_2      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     96 SH_1       00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     96 SH_1       00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     b9 DIV_e      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       6b SB_4       00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     b9 DIV_e      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       d4 aFault_2   00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      94 SW_E4      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     96 SH_1       00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    6b SB_4       00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     4e eILL0b     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       96 SH_1       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    92 LDAF_3     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     b1 aF_SW_3    00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       96 SH_1       00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     81 unx81      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   82 DIV_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     96 SH_1       00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       c1 IJT_2      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    42 MULHU_2    00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      96 SH_1       00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      a9 ILL_4      00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     96 SH_1       00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     a1 ECALL_4    00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     6e DIV_C      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   50 LW_1       10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     6e DIV_C      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    7a SB_5       00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      af MRET_4     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     bf IJT_1      00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     96 SH_1       00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      96 SH_1       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   70 LHU_2      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      d4 aFault_2   00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       92 LDAF_3     00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   a5 MRET_3     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     91 LDAF_2     00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    96 SH_1       00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     ab EBREAK_2   00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     81 unx81      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    b5 SH_3       00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      a1 ECALL_4    00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    aa DIV_6      00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 CSRRW_2    1d ORI_2      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 42 IJ_3       bb SH_2       00010010000000000000110011101100100110        Construct Q = 1                                   0000200b close to ij
 * 43 jFault_1   77 eFetchu    00010000000000001110001011100x00100110        Store 1 to mcause                                 0000200f close to fence
 * 44 SLTI_0     70 LHU_2      00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 NMI_2      be IJ_1       00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 46 DIV_e      b4 eFetch3    00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 47 aF_SW_1    da LDAF_a     00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 aFault_1   41 JALR_1     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b IJ_2       f0 LBU_2      00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 4c SLT_0      7d unx7d      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   74 unx74      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e Fetchu     fe ILLe       00000010000000000000001111101010110000  Fr10u Read and latch instruction                        40002033 sloppy slt     
 * 4f eFetchu    96 SH_1       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 50 XORI_1     96 SH_1       00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 51 LDAF_2     f6 WFI_1      00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 52 SH_2       1e aFault_1   00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 53 DIVU_1     f6 WFI_1      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 54 MULHU_6    c3 DIVU_4     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 55 SW_E4      49 CSRRW_1    00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 56 IJ_4       b7 IJ_3       00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 57 ORI_1      6b SB_4       00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 58 DIV_4      c8 DIV_7      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00002063 close to branch
 * 59 DIV_5      78 DIV_4      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00002067 close to jalr
 * 5a OR_1       ba LHU_3      00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     81 unx81      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    b5 SH_3       00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       d7 ECALL_3    00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIV_1      3e SLL_1      00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 5f DIV_2      f6 WFI_1      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 60 XOR_1      10 SUB_1      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00003003 close to load
 * 61 ECALL_6    a7 EBRKWFI1   00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 62 IJT_2      c2 DIVU_3     00000000000000001100101011101000110000        Read word is to be masked with ~1u                0000300b close to ij
 * 63 aF_SW_2    26 OR_1       00110010000000000000101011001100100110        Q = 4                                             0000300f close to fence
 * 64 SLTIU_0    70 LHU_2      00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 ILL_4      9b unx9b      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 66 MRET_5     9e SH_4       00000010000000000000000011101100010xx0        ~302                                              00000000 
 * 67 MUL_2      dd aF_SW_1    00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 68 DIV_E      96 SH_1       01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003023 close to store
 * 69 DIV_F      6b SB_4       00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 6a DIVU_5     c7 QINT_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               40003023 close to store
 * 6b LB_6       ce _LCSRRCI_1 00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 6c SLTU_0     7d unx7d      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    74 unx74      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e SH_1       46 ILL_1      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        40003033 sloppy sltu    
 * 6f SW_E1SWH   e2 MUL_1      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 70 SLTIX_1    ffffffff (null)     00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 71 aF_SW_3    49 CSRRW_1    00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 72 IJT_4      3a SRxI_1     00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 73 IJT_3      29 XOR_1      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 74 MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 75 QINT_2        (use dinx) 00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 76 QINT_1     e6 StdIncPc   00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 77 MULHU_5    e6 StdIncPc   00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 78 DIV_10     eb LH_3       01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00003063 close to branch
 * 79 DIV_11     ea MULHU_5    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00003067 close to jalr
 * 7a SLTIX_2    9e SH_4       00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 7b _L0x7b     81 unx81      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    b5 SH_3       00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SLTX_1        (use dinx) 00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 7e DIV_14     45 WFI_3      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00000000 
 * 7f DIV_15        (use dinx) 00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 80 LBU_0      d0 ECALL_1    00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 JAL_1         (use dinx) 00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 82 ECAL_RET   ea MULHU_5    00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000400b close to ij
 * 83 EBRKWFI1   5e LHU_1      00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000400f close to fence
 * 84 XORI_0     50 LW_1       00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 JAL_3      9c DIV_10     00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 86 IJ_1       85 LBU_1      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * 87 IJT_1         (use dinx) 00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 88 DIVU_3     78 DIV_4      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00004023 close to store
 * 89 DIVU_4     96 SH_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 8a ECALL_1    3a SRxI_1     00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40004023 close to store
 * 8b MRET_1     96 SH_1       00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 8c XOR_0      60 MULHU_3    00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      5e LHU_1      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e LB_2       fe ILLe       00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     40004033 sloppy xor     
 * 8f aFaultd    65 WFI_4      00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 90 eILL0c     85 LBU_1      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 91 ECALL_3    db jFault_1   00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 92 Fetch      85 LBU_1      00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 93 eFetch     de Fetch      00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 94 MUL_1      85 LBU_1      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 95 MUL_3      55 aFaultb    00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 96 StdIncPc   52 LH_1       10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 97 aFault     dd aF_SW_1    00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a eILL0a     85 LBU_1      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 9b WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 9c LBU_2      36 SLLI_2     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00004073 close to csr/system 
 * 9d aFaulte    7e NMI_1      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 9e SW_2       e0 DIVU_1     00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 9f aF_SW      9e SH_4       00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SLLI_1     fb SB_3       00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * a2 Fetch2     6b SB_4       00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     0000500b close to ij
 * a3 jFault     96 SH_1       00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000500f close to fence
 * a4 SRxI_0     aa DIV_6      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SLLI_2     ef WFI_5      00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * a6 WFI_1      8a DIVU_5     00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * a7 EBREAK_1   bd IJ_4       00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * a8 ECALL_2    58 DIV_A      00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00005023 close to store
 * a9 MULHU_7    85 LBU_1      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * aa SRxI_1     c2 DIVU_3     00000000000000000100101001101100001xx1        Register to shift to Q                            40005023 close to store
 * ab SRxI_2     61 EBRKWFI2   00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * ac _L0xac     b0 CSRRW_3    00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     53 LDAF_LH    00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     b0 CSRRW_3    00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SLL_1      66 SW_1       00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * b0 SRx_1      f4 Fetch2     00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * b1 JALR_1     db jFault_1   00010010000000000000000011101100100110        Q=1                                               00000000 
 * b2 WFI_3      92 LDAF_3     00010010000000000000101011101100100110        More check offset                                 00000000 
 * b3 ILL_1         (use dinx) 00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * b4 ILL_2      cb QINT_2     00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * b5 CSRRW_1    df eFetch     00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * b6 LH_4       61 EBRKWFI2   00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * b7 LH_5       56 LH_4       00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SB_1       ffffffff (null)     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00005067 close to jalr
 * ba SB_2       3a SRxI_1     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * bb MULHU_3    fa WFI_2      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * bc CSRRWI_0   b5 SH_3       00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd EBRKWFI2   92 LDAF_3     00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * be WFI_4      4b CSRRW_2    00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * bf MULH_1     62 DIV_8      00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * c0 SB_4       68 DIV_12     00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00006003 close to load
 * c1 aFault_2   73 unalignd   00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * c2 DIV_7      d2 LB_2       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            0000600b close to ij
 * c3 LH_3       6a MULH_1     00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 0000600f close to fence
 * c4 ORI_0      57 LH_5       00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     c9 MRET_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c6 MRET_2     b4 eFetch3    00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * c7 MULH_2     75 unx75      00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * c8 DIV_C      32 JAL_1      00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00006023 close to store
 * c9 MRET_6     e9 IJT_3      00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * ca LBU_3      88 DIV_E      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       40006023 close to store
 * cb unalignd   96 SH_1       00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      5e LHU_1      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce SB_5       fe ILLe       00000000000000000010110011100100001xx0        Write d to a+k until accepted                     40006033 sloppy or      
 * cf NMI_1      13 condb_2    00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * d0 LBU_1      a8 DIV_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * d1 (null)     c6 IJT_4      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d2 DIVU_2     09 LB_5       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d3 WFI_2      49 CSRRW_1    00010010000000000000101011101100100110        Check offset                                      00000000 
 * d4 JAL_2      db jFault_1   10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * d5 (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d6 _LCSRRCI_1 fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d7 SB_3       e8 MUL_2      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 _LCSRRS_1  10 SUB_1      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00006067 close to jalr
 * da ILL_3      51 LDAF_LW    00000010000000000000101011101100100110        Q = 1                                             00000000 
 * db LDAF_3     db jFault_1   00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * dc CSRRSI_0   b5 SH_3       00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd SW_E2      63 DIV_9      00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * de SW_E3      a2 DIV_14     00110010000000000000101111001100100110        Q = 3                                             00000000 
 * df SH_4       a2 DIV_14     00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * e0 SH_5       d2 LB_2       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00007003 close to load
 * e1 (null)     3d SRxI_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e2 MRET_7     67 SW_E1SWE   00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               0000700b close to ij
 * e3 (null)     3a SRxI_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     71 aFaultc    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e6 Fetch2u    92 LDAF_3     0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * e7 (null)     49 CSRRW_1    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e8 ECALL_4    94 SW_E4      00110010000000000000101011001100100110        Q = 4                                             00007023 close to store
 * e9 MRET_3     72 LBU_3      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * ea DIV_3      54 LH_2       01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        40007023 close to store
 * eb DIV_6      b6 ECALL_5    00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     53 LDAF_LH    00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee EBREAK_2   fe ILLe       00000000000000001101101011101000001xx0        pc to mepc                                        40007033 sloppy and     
 * ef MRET_4     92 LDAF_3     00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * f0 CSRRW_3    ca DIVU_2     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * f1 (null)     49 CSRRW_1    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f2 MULH_3     96 SH_1       00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * f3 (null)     47 ILL_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 CSRRW_4    f9 MULH_2     00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * f5 (null)     43 MULHU_4    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f6 LDAF_a     d3 aFaultd    00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * f7 (null)     ee eILL0a     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 eFetch3    f2 SW_2       0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00007067 close to jalr
 * fa SH_3       b2 CSRRW_4    00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fb ECALL_5    c0 DIV_D      00110010000000000000101011001100100110        Q = 8                                             00000000 
 * fc CSRRCI_0   b5 SH_3       00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      cf MRET_7     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       b3 unxb3      00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     76 Fetchu     00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0200, used ffff, inputs 4d
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       8e _LCSRRS_1  00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       86 JAL_2      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     96 SH_1       00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     96 SH_1       00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     b0 CSRRW_3    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       6b SB_4       00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     b0 CSRRW_3    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       c0 DIV_D      00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      94 SW_E4      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     96 SH_1       00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    6b SB_4       00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     4e eILL0b     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       96 SH_1       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    92 LDAF_3     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     a1 ECALL_4    00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       96 SH_1       00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     62 DIV_8      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   82 DIV_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     96 SH_1       00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       c1 IJT_2      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    e0 DIVU_1     00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      96 SH_1       00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      76 Fetchu     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     96 SH_1       00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     70 LHU_2      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      52 LH_1       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     6e DIV_C      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     6e DIV_C      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    5d SB_2       00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      81 unx81      00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     b5 SH_3       00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     96 SH_1       00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      96 SH_1       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   56 LH_4       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      c0 DIV_D      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       92 LDAF_3     00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   72 LBU_3      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     91 LDAF_2     00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    96 SH_1       00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     7d unx7d      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     62 DIV_8      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    aa DIV_6      00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      70 LHU_2      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    7a SB_5       00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 CSRRW_2    1d ORI_2      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 42 aFault_1   b2 CSRRW_4    00110010000000000000101011001100100110        Q = 4                                             0000200b close to ij
 * 43 NMI_2      77 eFetchu    00000000110000001111010011101000110000        mtval = 0.                                        0000200f close to fence
 * 44 SLTI_0     56 LH_4       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 jFault_1   b4 eFetch3    00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 46 IJ_2       a9 ILL_4      00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 47 aF_SW_1    c6 IJT_4      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     41 JALR_1     00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    da LDAF_a     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      60 MULHU_3    00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   5a SB_1       00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e Fetchu     fe ILLe       00000010000000000000001111101010110000  Fr10u Read and latch instruction                        40002033 sloppy slt     
 * 4f eFetchu    96 SH_1       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 50 OR_1       96 SH_1       00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 51 LDAF_2     fb SB_3       00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 52 OR_2       1e aFault_1   00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 53 SW_E4      fb SB_3       00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 54 XOR_1      c5 MRET_5     00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 55 DIVU_1     42 MULHU_2    00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 56 SLTIX_1    af MRET_4     00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 57 ORI_1      6b SB_4       00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 58 DIV_4      b7 IJ_3       00000000000000001100000011101000110000        ~abs(divisor) to yy                               00002063 close to branch
 * 59 DIV_5      78 DIV_4      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00002067 close to jalr
 * 5a MULHU_1    b1 aF_SW_3    00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 5b _L0x5b     62 DIV_8      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    aa DIV_6      00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLTIX_2    d7 ECALL_3    00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 5e DIV_1      3e SLL_1      00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 5f DIV_2      fb SB_3       00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 60 SLTX_1     10 SUB_1      00000010000000000000111111101100000xx0        ~rs2 to Q                                         00003003 close to load
 * 61 ECALL_6    a7 EBRKWFI1   00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 62 JAL_1      ef WFI_5      00010000000000001100001011101000100000        Target adr to yy                                  0000300b close to ij
 * 63 ILL_4      26 OR_1       00010000110000001110100111100x00100110        Store 2 to mcause                                 0000300f close to fence
 * 64 SLTIU_0    56 LH_4       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 aF_SW_2    9b unx9b      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 66 JAL_3      9e SH_4       00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 67 MUL_2      c9 MRET_2     00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 68 DIV_E      96 SH_1       01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003023 close to store
 * 69 DIV_F      6b SB_4       00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 6a DIVU_5     c7 QINT_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               40003023 close to store
 * 6b LB_6       bd IJ_4       00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 6c SLTU_0     60 MULHU_3    00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    5a SB_1       00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e SH_1       e2 MUL_1      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        40003033 sloppy sltu    
 * 6f SW_E1SWH   f6 WFI_1      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 70 SLLI_1     ffffffff (null)     00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 71 aF_SW_3    42 MULHU_2    00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 72 SLLI_2     3a SRxI_1     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 73 QINT_2     29 XOR_1      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 74 ECALL_2       (use dinx) 00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 75 IJT_3         (use dinx) 00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 76 MULHU_7    f9 MULH_2     00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 77 MULHU_5    f9 MULH_2     00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 78 DIV_10     d4 aFault_2   01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00003063 close to branch
 * 79 DIV_11     d2 LB_2       01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00003067 close to jalr
 * 7a SRxI_1     9e SH_4       00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 7b _L0x7b     62 DIV_8      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    aa DIV_6      00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SRxI_2        (use dinx) 00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 7e DIV_14     43 MULHU_4    00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00000000 
 * 7f DIV_15        (use dinx) 00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 80 LBU_0      bf IJT_1      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLL_1         (use dinx) 00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 82 ECAL_RET   d2 LB_2       00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000400b close to ij
 * 83 EBRKWFI1   5e LHU_1      00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SRx_1      9c DIV_10     00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 86 IJ_1       66 SW_1       00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * 87 IJT_1         (use dinx) 00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 88 DIVU_3     78 DIV_4      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00004023 close to store
 * 89 DIVU_4     96 SH_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 8a ECALL_1    3a SRxI_1     00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40004023 close to store
 * 8b MRET_1     96 SH_1       00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 8c XOR_0      54 LH_2       00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      5e LHU_1      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e LB_2       fe ILLe       00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     40004033 sloppy xor     
 * 8f aFaultd    63 DIV_9      00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 90 eILL0c     66 SW_1       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 91 ECALL_3    c8 DIV_7      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 92 Fetch      66 SW_1       00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 93 eFetch     ca DIVU_2     00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 94 MUL_1      66 SW_1       00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 95 MUL_3      53 LDAF_LH    00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 96 StdIncPc   e6 StdIncPc   10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 97 aFault     c9 MRET_2     00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a eILL0a     66 SW_1       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 9b WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 9c LBU_2      36 SLLI_2     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00004073 close to csr/system 
 * 9d aFaulte    7e NMI_1      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 9e SW_2       ce _LCSRRCI_1 00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 9f aF_SW      9e SH_4       00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JALR_1     df eFetch     00010010000000000000000011101100100110        Q=1                                               00000000 
 * a2 Fetch2     6b SB_4       00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     0000500b close to ij
 * a3 jFault     96 SH_1       00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000500f close to fence
 * a4 SRxI_0     7a SB_5       00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 WFI_3      d9 MULH_3     00010010000000000000101011101100100110        More check offset                                 00000000 
 * a6 WFI_1      8a DIVU_5     00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * a7 EBREAK_1   b3 unxb3      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * a8 ILL_1      58 DIV_A      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00005023 close to store
 * a9 ILL_2      66 SW_1       00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * aa CSRRW_1    ef WFI_5      00010010000000000000000011101100100110        Construct PC storage adr                          40005023 close to store
 * ab LH_4       61 EBRKWFI2   00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * ac _L0xac     85 LBU_1      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     55 aFaultb    00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     85 LBU_1      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af LH_5       ea MULHU_5    00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * b0 SB_1       db jFault_1   00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * b1 SB_2       c8 DIV_7      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * b2 MULHU_3    92 LDAF_3     00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * b3 EBRKWFI2      (use dinx) 00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * b4 WFI_4      bb SH_2       00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * b5 MULH_1     cb QINT_2     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * b6 SB_4       61 EBRKWFI2   00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b7 DIV_C      e8 MUL_2      00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MRET_6     ffffffff (null)     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00005067 close to jalr
 * ba LBU_3      3a SRxI_1     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * bb unalignd   de Fetch      00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * bc CSRRWI_0   aa DIV_6      00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SB_5       92 LDAF_3     00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * be NMI_1      46 ILL_1      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * bf LBU_1      e9 IJT_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * c0 JAL_2      68 DIV_12     10110000000000000100110011000x00100110        Return address to TRG                             00006003 close to load
 * c1 aFault_2   75 unx75      00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * c2 _LCSRRS_1  f2 SW_2       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000600b close to ij
 * c3 (null)     6a MULH_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000600f close to fence
 * c4 ORI_0      57 LH_5       00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 LH_3       b9 DIV_e      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * c6 ILL_3      a9 ILL_4      00000010000000000000101011101100100110        Q = 1                                             00000000 
 * c7 MULH_2     73 unalignd   00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * c8 LDAF_3     32 JAL_1      00000000000000001101100111100x00001xx0        PC to mepc                                        00006023 close to store
 * c9 SW_E2      d0 ECALL_1    00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * ca SW_E3      88 DIV_E      00110010000000000000101111001100100110        Q = 3                                             40006023 close to store
 * cb SH_4       96 SH_1       00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * cc OR_0       50 LW_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      5e LHU_1      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce SH_5       fe ILLe       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     40006033 sloppy or      
 * cf ECALL_4    13 condb_2    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d0 MRET_3     74 unx74      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * d1 (null)     f0 LBU_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d2 DIV_3      09 LB_5       01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * d3 (null)     42 MULHU_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d4 DIV_6      c8 DIV_7      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * d5 WFI_2         (use dinx) 00010010000000000000101011101100100110        Check offset                                      00000000 
 * d6 EBREAK_2   fe ILLe       00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * d7 SB_3       cf MRET_7     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MRET_4     10 SUB_1      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00006067 close to jalr
 * da CSRRW_3    51 LDAF_LW    00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * db CSRRW_4    c8 DIV_7      00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * dc CSRRSI_0   aa DIV_6      00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd eFetch3    65 WFI_4      0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * de SH_3       a2 DIV_14     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * df ECALL_5    a2 DIV_14     00110010000000000000101011001100100110        Q = 8                                             00000000 
 * e0 IJ_3       f2 SW_2       00010010000000000000110011101100100110        Construct Q = 1                                   00007003 close to load
 * e1 (null)     3d SRxI_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e2 DIV_e      67 SW_E1SWE   00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      0000700b close to ij
 * e3 (null)     3a SRxI_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     71 aFaultc    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e6 SH_2       92 LDAF_3     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * e7 (null)     42 MULHU_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e8 IJ_4       94 SW_E4      00000100000010001010110111100100011xx0        Mask and use as PC                                00007023 close to store
 * e9 IJT_2      eb LH_3       00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * ea MRET_5     4b CSRRW_2    00000010000000000000000011101100010xx0        ~302                                              40007023 close to store
 * eb IJT_4      ab EBREAK_2   00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     55 aFaultb    00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee QINT_1     fe ILLe       00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40007033 sloppy and     
 * ef DIV_7      92 LDAF_3     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f0 MRET_2     ba LHU_3      00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * f1 (null)     42 MULHU_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f2 DIVU_2     96 SH_1       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f3 (null)     47 ILL_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 _LCSRRCI_1 dd aF_SW_1    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f5 (null)     45 WFI_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f6 MRET_7     d5 Fetch2u    00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f7 (null)     d6 eILL0c     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 Fetch2u    fa WFI_2      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00007067 close to jalr
 * fa MULH_3     a5 MRET_3     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * fb LDAF_a     b6 ECALL_5    00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * fc CSRRCI_0   aa DIV_6      00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      be IJ_1       00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       a8 DIV_3      00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     ee eILL0a     00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0008, used ffff, inputs 4e
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       8e _LCSRRS_1  00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       82 DIV_1      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     9a ECALL_6    00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     9a ECALL_6    00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 CSRRW_2    0b JALR_2     00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 07 NMI_2      1a ANDI_1     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 08 _L0x08     c5 MRET_5     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       6f MRET_6     00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     c5 MRET_5     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       dd aF_SW_1    00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      94 SW_E4      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     9a ECALL_6    00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 condb_5    6f MRET_6     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 11 condb_5t   3a SRxI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 12 MULHU_2    5e LHU_1      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 13 MULHU_4    2e MULHU_1    00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 14 eILL0b     39 MULHU_7    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 15 MRET_8     10 SUB_1      00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 16 LDAF_2     9a ECALL_6    00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 17 SW_E4      92 LDAF_3     00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     ba LHU_3      00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       9a ECALL_6    00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   7e NMI_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     9a ECALL_6    00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LW_1       86 JAL_2      00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 1f LDAF_LW    42 MULHU_2    00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 20 LH_0       30 SLTIX_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      9a ECALL_6    00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      b2 CSRRW_4    00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     9a ECALL_6    00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     af MRET_4     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 ECALL_6    5d SB_2       00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 27 ILL_4      3d SRxI_2     00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 28 _L0x28     70 LHU_2      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     70 LHU_2      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      b5 SH_3       00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     ce _LCSRRCI_1 00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    12 straddle   00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     9a ECALL_6    00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_1       9a ECALL_6    00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LH    7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 LH_2       dd aF_SW_1    00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 33 aFaultb       (use dinx) 00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 34 DIV_A      92 LDAF_3     00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 35 DIV_B      b0 CSRRW_3    00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 36 aF_SW_3    03 _L0x03     00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 37 QINT_2     91 LDAF_2     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    9a ECALL_6    00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     b4 eFetch3    00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    bf IJT_1      00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_1      af MRET_4     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LHU   b3 unxb3      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       1e aFault_1   00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 IJ_3       c9 MRET_2     00010010000000000000110011101100100110        Construct Q = 1                                   0000200b close to ij
 * 43 DIV_e      77 eFetchu    00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       cb QINT_2     00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 jFault_1   be IJ_1       00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 47 aF_SW_1    df eFetch     00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 48 _L0x48     50 LW_1       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     06 LB_3       00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     50 LW_1       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    f4 Fetch2     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_8      fe ILLe       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           40002033 sloppy slt     
 * 4f DIV_9      9a ECALL_6    01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 50 SW_1       9a ECALL_6    00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 51 SW_E1SWE   f3 aF_SW      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 52 SH_2       32 JAL_1      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 53 IJ_4       f3 aF_SW      00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 54 DIV_12     c6 IJT_4      00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 55 DIV_13     41 JALR_1     00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 56 DIVU_1     c1 IJT_2      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 57 ORI_1      6f MRET_6     00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 58 LHU_2      d0 ECALL_1    00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00002063 close to branch
 * 59 aFaultc    74 unx74      00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00002067 close to jalr
 * 5a OR_1       c8 DIV_7      00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    bf IJT_1      00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       d7 ECALL_3    00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e Fetchu     58 DIV_A      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00000000 
 * 5f eFetchu    f3 aF_SW      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 60 DIV_4      12 straddle   00000000000000001100000011101000110000        ~abs(divisor) to yy                               00003003 close to load
 * 61 DIV_5      ab EBREAK_2   00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 62 IJT_2      c2 DIVU_3     00000000000000001100101011101000110000        Read word is to be masked with ~1u                0000300b close to ij
 * 63 MRET_5     34 JAL_3      00000010000000000000000011101100010xx0        ~302                                              0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      9d DIV_11     00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 aF_SW_2    a2 DIV_14     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 67 MUL_2      e1 ORI_1      00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 68 DIV_1      9a ECALL_6    00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00003023 close to store
 * 69 DIV_2      6f MRET_6     00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 6a DIV_E      c7 QINT_1     01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             40003023 close to store
 * 6b DIV_F      d9 MULH_3     00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIVU_5     43 MULHU_4    00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               40003033 sloppy sltu    
 * 6f LB_6       e2 MUL_1      00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 70 SH_1       ffffffff (null)     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 71 SW_E1SWH   41 JALR_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 72 IJT_4      3a SRxI_1     00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 73 QINT_1     29 XOR_1      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 74 DIV_10        (use dinx) 01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 75 DIV_11        (use dinx) 01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 76 IJT_3      e3 MUL_3      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 77 MULHU_5    e3 MUL_3      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 78 DIV_14     ef WFI_5      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00003063 close to branch
 * 79 DIV_15     ee eILL0a     00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00003067 close to jalr
 * 7a SLTIX_1    a2 DIV_14     00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    bf IJT_1      00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e ECAL_RET   07 LB_4       00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 7f EBRKWFI1      (use dinx) 00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 80 LBU_0      db jFault_1   00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 IJ_1       ee eILL0a     00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   0000400b close to ij
 * 83 IJT_1      68 DIV_12     00000010000010000000101111101100001xx0        Exit CSR, enter trap                              0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     9e SH_4       00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 aFault_2   a5 MRET_3     00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 87 (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 88 DIVU_3     74 unx74      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00004023 close to store
 * 89 DIVU_4     9a ECALL_6    01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 8a ECALL_1    3a SRxI_1     00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40004023 close to store
 * 8b MRET_1     9a ECALL_6    00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      68 DIV_12     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e LB_2       fe ILLe       00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     40004033 sloppy xor     
 * 8f aFaultd    27 OR_2       00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 90 eILL0c     a5 MRET_3     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 91 ECALL_3    e0 DIVU_1     00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 92 Fetch      a5 MRET_3     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 93 eFetch     e5 aF_SW_2    00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 94 MUL_1      a5 MRET_3     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 95 MUL_3      17 condb_5t   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 96 (null)     52 LH_1       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 97 (null)     e1 ORI_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a StdIncPc   a5 MRET_3     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 9b aFault        (use dinx) 00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 9c eILL0a     54 LH_2       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00004073 close to csr/system 
 * 9d WFI_5      78 DIV_4      00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 9e LBU_2      e9 IJT_3      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 9f aFaulte    a2 DIV_14     00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * a0 LHU_0      3e SLL_1      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JAL_1      fb SB_3       00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * a2 SW_2       6f MRET_6     00000010000000000000001011x01000xxxxx0        Prepare read PC                                   0000500b close to ij
 * a3 aF_SW      9a ECALL_6    00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     0000500f close to fence
 * a4 SRxI_0     b3 unxb3      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 JAL_3      f1 aFaulte    00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a6 (null)     8a DIVU_5     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * a7 (null)     ca DIVU_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * a8 Fetch2     60 MULHU_3    00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00005023 close to store
 * a9 jFault     a5 MRET_3     00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * aa WFI_1      c2 DIVU_3     00110010000000000000000011001100100110 WFI    To check offset                                   40005023 close to store
 * ab EBREAK_1   26 OR_1       00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * ac _L0xac     b9 DIV_e      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     56 LH_4       00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     b9 DIV_e      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SLLI_1     63 DIV_9      00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * b0 SLLI_2     f5 jFault     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * b1 ECALL_2    e0 DIVU_1     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * b2 MULHU_7    92 LDAF_3     00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * b3 SRxI_1        (use dinx) 00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * b4 SRxI_2     d5 Fetch2u    00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * b5 SLL_1      e8 MUL_2      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * b6 (null)     26 OR_1       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b7 (null)     53 LDAF_LH    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SRx_1      ffffffff (null)     00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00005067 close to jalr
 * ba JALR_1     3a SRxI_1     00010010000000000000000011101100100110        Q=1                                               00000000 
 * bb WFI_3      fa WFI_2      00010010000000000000101011101100100110        More check offset                                 00000000 
 * bc CSRRWI_0   bf IJT_1      00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ILL_1      92 LDAF_3     00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * be ILL_2      45 WFI_3      00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * bf CSRRW_1    62 DIV_8      00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * c0 LH_4       6a MULH_1     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00006003 close to load
 * c1 LH_5       76 Fetchu     00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * c2 DIV_7      d2 LB_2       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            0000600b close to ij
 * c3 MRET_2     6e DIV_C      00010010000000000000011011001100100000        0xff+3 = 0x102                                    0000600f close to fence
 * c4 ORI_0      57 LH_5       00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 SB_1       d1 MRET_1     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * c6 LH_3       be IJ_1       00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * c7 MULH_2     37 ECALL_2    00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * c8 SB_2       4e eILL0b     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00006023 close to store
 * c9 MULHU_3    eb LH_3       00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * ca EBRKWFI2   88 DIV_E      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         40006023 close to store
 * cb WFI_4      9a ECALL_6    00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      68 DIV_12     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce MULH_1     fe ILLe       00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              40006033 sloppy or      
 * cf SB_4       15 condb_4    00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * d0 DIV_C      b1 aF_SW_3    00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * d1 MRET_6     c3 DIVU_4     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * d2 DIVU_2     09 LB_5       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d3 _LCSRRCI_1 41 JALR_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d4 LBU_3      e0 DIVU_1     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * d5 unalignd      (use dinx) 00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * d6 WFI_2      fe ILLe       00010010000000000000101011101100100110        Check offset                                      00000000 
 * d7 SB_3       ea MULHU_5    00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 SB_5       12 straddle   00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00006067 close to jalr
 * da NMI_1      16 condb_5    00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * db LBU_1      e0 DIVU_1     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * dc CSRRSI_0   bf IJT_1      00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd JAL_2      66 SW_1       10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * de _LCSRRS_1  a8 DIV_3      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * df ILL_3      a8 DIV_3      00000010000000000000101011101100100110        Q = 1                                             00000000 
 * e0 LDAF_3     d2 LB_2       00000000000000001101100111100x00001xx0        PC to mepc                                        00007003 close to load
 * e1 SW_E2      3d SRxI_2     00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * e2 MRET_7     67 SW_E1SWE   00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               0000700b close to ij
 * e3 Fetch2u    3a SRxI_1     0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SW_E3      36 SLLI_2     00110010000000000000101111001100100110        Q = 3                                             00000000 
 * e6 (null)     92 LDAF_3     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e7 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e8 SH_4       94 SW_E4      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00007023 close to store
 * e9 SH_5       72 LBU_3      00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * ea ECALL_4    4b CSRRW_2    00110010000000000000101011001100100110        Q = 4                                             40007023 close to store
 * eb MRET_3     c0 DIV_D      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     56 LH_4       00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee DIV_3      fe ILLe       01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        40007033 sloppy and     
 * ef DIV_6      92 LDAF_3     00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * f0 EBREAK_2   d4 aFault_2   00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * f1 MRET_4     41 JALR_1     00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * f2 MULH_3     9a ECALL_6    00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * f3 LDAF_a     47 ILL_2      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * f4 CSRRW_3    f9 MULH_2     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * f5 CSRRW_4    46 ILL_1      00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * f6 (null)     d6 eILL0c     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     f0 LBU_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 eFetch3    f2 SW_2       0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00007067 close to jalr
 * fa SH_3       bb SH_2       00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fb ECALL_5    cf MRET_7     00110010000000000000101011001100100110        Q = 8                                             00000000 
 * fc CSRRCI_0   bf IJT_1      00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      da LDAF_a     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       bd IJ_4       00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     73 unalignd   00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0040, used ffff, inputs 53
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       8e _LCSRRS_1  00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       86 JAL_2      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     a2 DIV_14     00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     a2 DIV_14     00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   13 condb_2    00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     b3 unxb3      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       75 unx75      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     b3 unxb3      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       ce _LCSRRCI_1 00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      9c DIV_10     00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      1d ORI_2      00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     a2 DIV_14     00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    75 unx75      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    2e MULHU_1    00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 CSRRW_2    60 MULHU_3    00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 13 LB_5       29 XOR_1      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 14 eILL0b     2b SLTIX_1    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 15 MRET_8     06 LB_3       00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 16 NMI_2      a2 DIV_14     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 17 JALR_2     94 SW_E4      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 18 BEQ        22 MULHU_6    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     93 SW_E2      00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LDAF_2     a2 DIV_14     00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 1b _L0x1b     5d SB_2       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   82 DIV_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d SUB_1      a2 DIV_14     00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 1e SW_E4      92 LDAF_3     00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 1f AND_1      e6 StdIncPc   00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 20 LH_0       30 SLTIX_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 straddle   a2 DIV_14     10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 22 condb_2    6e DIV_C      00000010000000000000111111101100000xx0        ~RS2 in Q                                         0000100b close to ij
 * 23 _L0x23     a2 DIV_14     00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     65 WFI_4      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 LW_1       42 MULHU_2    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LW    33 unx33      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     76 Fetchu     00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_3    3d SRxI_2     00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2a _L0x2a     76 Fetchu     00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_4    4e eILL0b     00000010000000000000000011101101001xx0        Branch on condition                               00000000 
 * 2c SLL_0      81 unx81      00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     bf IJT_1      00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e ANDI_1     10 SUB_1      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     a2 DIV_14     00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_1       a2 DIV_14     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LH    46 ILL_1      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 ECALL_6    ce _LCSRRCI_1 00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 33 ORI_2         (use dinx) 00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 34 LH_2       94 SW_E4      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 35 aFaultb    66 SW_1       00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 36 ILL_4      03 _L0x03     00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 37 aFault_1   91 LDAF_2     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 38 BNE        22 MULHU_6    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 IJ_2       a2 DIV_14     00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00001067 close to jalr
 * 3a aF_SW_3    7d unx7d      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 3b _L0x3b     5d SB_2       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d XORI_1     03 _L0x03     00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 3e QINT_2     65 WFI_4      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 3f MULHU_6    7a SB_5       00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 40 LW_0       26 OR_1       00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 OR_1       17 condb_5t   00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 42 OR_2       b9 DIV_e      00010010000000000000000011101100100000        Q = rs2                                           0000200b close to ij
 * 43 jFault_1   6f MRET_6     00010000000000001110001011100x00100110        Store 1 to mcause                                 0000200f close to fence
 * 44 SLTI_0     46 ILL_1      00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 XOR_1      bd IJ_4       00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 46 SLTIX_1    9f SH_5       00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 47 aF_SW_1    d1 MRET_1     00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 48 _L0x48     56 LH_4       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 MULHU_1    12 straddle   00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 4a _L0x4a     56 LH_4       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b DIVU_1     df eFetch     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 4c SLT_0      5a SB_1       00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   49 CSRRW_1    00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e SLTIX_2    fe ILLe       00000000000000000100001011101000110010        Registered ALU flag to rd                         40002033 sloppy slt     
 * 4f ORI_1      a2 DIV_14     00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 50 DIV_A      a2 DIV_14     00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 51 DIV_B      fb SB_3       00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 52 LHU_1      34 JAL_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 53 LDAF_LHU   fb SB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 54 DIV_8      c3 DIVU_4     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 55 DIV_9      37 ECALL_2    01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 56 SW_1       af MRET_4     00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 57 SW_E1SWE   75 unx75      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 58 DIV_12     c1 IJT_2      00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00002063 close to branch
 * 59 DIV_13     78 DIV_4      00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00002067 close to jalr
 * 5a SLTX_1     b7 IJ_3       00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 5b _L0x5b     5d SB_2       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d JAL_1      cf MRET_7     00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 5e LHU_2      5e LHU_1      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaultc    fb SB_3       00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 60 Fetchu     10 SUB_1      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00003003 close to load
 * 61 eFetchu    b5 SH_3       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 62 JAL_3      f3 aF_SW      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                0000300b close to ij
 * 63 aF_SW_2    50 LW_1       00110010000000000000101011001100100110        Q = 4                                             0000300f close to fence
 * 64 SLTIU_0    46 ILL_1      00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLLI_1     a7 EBRKWFI1   00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 66 SLLI_2     aa DIV_6      00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 67 MUL_2      d3 aFaultd    00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 68 DIV_4      a2 DIV_14     00000000000000001100000011101000110000        ~abs(divisor) to yy                               00003023 close to store
 * 69 DIV_5      75 unx75      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 6a ECALL_2    c7 QINT_1     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  40003023 close to store
 * 6b IJT_3      c8 DIV_7      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 6c SLTU_0     5a SB_1       00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    49 CSRRW_1    00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e MULHU_7    e8 MUL_2      00100000000000000100001011101000001xx0        Last shift.                                       40003033 sloppy sltu    
 * 6f MULHU_5    f7 EBREAK_1   00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 70 DIV_1      ffffffff (null)     00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 71 DIV_2      37 ECALL_2    00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 72 DIV_E      2e MULHU_1    01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 73 DIV_F      21 XORI_1     00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 74 DIVU_5        (use dinx) 00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 75 LB_6          (use dinx) 00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 76 SH_1       f9 MULH_2     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 77 SW_E1SWH   f9 MULH_2     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 78 DIV_10     db jFault_1   01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00003063 close to branch
 * 79 DIV_11     da LDAF_a     01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00003067 close to jalr
 * 7a SRxI_1     aa DIV_6      00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 7b _L0x7b     5d SB_2       00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SRxI_2        (use dinx) 00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 7e DIV_14     16 condb_5    00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00000000 
 * 7f DIV_15        (use dinx) 00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 80 LBU_0      ca DIVU_2     00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLL_1         (use dinx) 00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 82 ECAL_RET   da LDAF_a     00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000400b close to ij
 * 83 EBRKWFI1   70 LHU_2      00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000400f close to fence
 * 84 XORI_0     3d SRxI_2     00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SRx_1      a8 DIV_3      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 86 IJ_1       62 DIV_8      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * 87 IJT_1         (use dinx) 00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 88 DIVU_3     78 DIV_4      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00004023 close to store
 * 89 DIVU_4     a2 DIV_14     01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 8a ECALL_1    2e MULHU_1    00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40004023 close to store
 * 8b MRET_1     a2 DIV_14     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 8c XOR_0      45 WFI_3      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      70 LHU_2      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e LB_2       fe ILLe       00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     40004033 sloppy xor     
 * 8f aFaultd    36 SLLI_2     00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 90 eILL0c     62 DIV_8      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 91 ECALL_3    d2 LB_2       00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 92 aFault_2   62 DIV_8      00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 93 JALR_1     d4 aFault_2   00010010000000000000000011101100100110        Q=1                                               00000000 
 * 94 Fetch      62 DIV_8      00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 95 eFetch     1e aFault_1   00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 96 (null)     e9 IJT_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 97 WFI_3      d3 aFaultd    00010010000000000000101011101100100110        More check offset                                 00000000 
 * 98 BLT        22 MULHU_6    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a (null)     62 DIV_8      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 9b ILL_1         (use dinx) 00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 9c MUL_1      58 DIV_A      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00004073 close to csr/system 
 * 9d MUL_3      7e NMI_1      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 9e (null)     d6 eILL0c     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 9f ILL_2      aa DIV_6      00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * a0 LHU_0      52 LH_1       00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 CSRRW_1    e5 aF_SW_2    00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * a2 StdIncPc   75 unx75      10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    0000500b close to ij
 * a3 aFault     a2 DIV_14     00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          0000500f close to fence
 * a4 SRxI_0     7a SB_5       00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 LH_4       de Fetch      00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * a6 eILL0a     8a DIVU_5     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * a7 WFI_5      bb SH_2       00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * a8 LBU_2      68 DIV_12     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00005023 close to store
 * a9 aFaulte    62 DIV_8      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * aa SW_2       f3 aF_SW      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   40005023 close to store
 * ab aF_SW      32 JAL_1      00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * ac _L0xac     85 LBU_1      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     4b CSRRW_2    00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     85 LBU_1      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af LH_5       f0 LBU_2      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * b0 Fetch2     e0 DIVU_1     00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * b1 jFault     d2 LB_2       00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * b2 (null)     94 SW_E4      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b3 SB_1          (use dinx) 00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * b4 WFI_1      c6 IJT_4      00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * b5 EBREAK_1   d5 Fetch2u    00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * b6 (null)     32 JAL_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b7 SB_2       ea MULHU_5    00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * b8 BGE        22 MULHU_6    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MULHU_3    ffffffff (null)     00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00005067 close to jalr
 * ba (null)     2e MULHU_1    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * bb EBRKWFI2   e2 MUL_1      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * bc CSRRWI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd WFI_4      94 SW_E4      00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * be (null)     39 MULHU_7    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * bf MULH_1     ee eILL0a     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * c0 SB_4       72 LBU_3      00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00006003 close to load
 * c1 DIV_C      6b SB_4       00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * c2 MRET_6     f5 jFault     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            0000600b close to ij
 * c3 LH_3       74 unx74      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 0000600f close to fence
 * c4 ORI_0      4f MRET_8     00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 LBU_3      c2 DIVU_3     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * c6 unalignd   9f SH_5       00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * c7 MULH_2     3e SLL_1      00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * c8 SB_5       54 LH_2       00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00006023 close to store
 * c9 NMI_1      d9 MULH_3     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * ca LBU_1      88 DIV_E      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40006023 close to store
 * cb WFI_2      a2 DIV_14     00010010000000000000101011101100100110        Check offset                                      00000000 
 * cc OR_0       41 JALR_1     00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      70 LHU_2      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce JAL_2      fe ILLe       10110000000000000100110011000x00100110        Return address to TRG                             40006033 sloppy or      
 * cf SB_3       15 condb_4    00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d0 _LCSRRS_1  6a MULH_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d1 ILL_3      f4 Fetch2     00000010000000000000101011101100100110        Q = 1                                             00000000 
 * d2 LDAF_3     09 LB_5       00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * d3 SW_E2      37 ECALL_2    00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * d4 SW_E3      d2 LB_2       00110010000000000000101111001100100110        Q = 3                                             00000000 
 * d5 SH_4          (use dinx) 00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * d6 SH_5       fe ILLe       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * d7 ECALL_4    d7 ECALL_3    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d8 BLTU       22 MULHU_6    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MRET_3     10 SUB_1      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00006067 close to jalr
 * da DIV_3      1a ANDI_1     01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * db DIV_6      d2 LB_2       00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * dc CSRRSI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd EBREAK_2   63 DIV_9      00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * de MRET_4     b0 CSRRW_3    00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * df CSRRW_3    b0 CSRRW_3    00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * e0 CSRRW_4    f5 jFault     00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00007003 close to load
 * e1 eFetch3    33 unx33      0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * e2 SH_3       67 SW_E1SWE   00000010000000000000000011101000110000        Prepare get back address to use                   0000700b close to ij
 * e3 (null)     2e MULHU_1    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     2e MULHU_1    00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 ECALL_5    3a SRxI_1     00110010000000000000101011001100100110        Q = 8                                             00000000 
 * e6 IJ_3       94 SW_E4      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * e7 (null)     37 ECALL_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e8 DIV_e      9c DIV_10     00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00007023 close to store
 * e9 SH_2       f1 aFaulte    00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * ea IJ_4       3f SRx_1      00000100000010001010110111100100011xx0        Mask and use as PC                                40007023 close to store
 * eb (null)     a5 MRET_3     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ec AND_0      1f IJ_2       00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     4b CSRRW_2    00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee IJT_2      fe ILLe       00000000000000001100101011101000110000        Read word is to be masked with ~1u                40007033 sloppy and     
 * ef (null)     94 SW_E4      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f0 MRET_5     c5 MRET_5     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * f1 IJT_4      37 ECALL_2    00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * f2 QINT_1     a2 DIV_14     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * f3 DIV_7      47 ILL_2      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f4 MRET_2     e1 ORI_1      00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * f5 DIVU_2     43 MULHU_4    00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f6 _LCSRRCI_1 cb QINT_2     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f7 MRET_7     dd aF_SW_1    00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f8 BGEU       22 MULHU_6    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 Fetch2u    fa WFI_2      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00007067 close to jalr
 * fa MULH_3     97 SW_E1SWH   00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * fb LDAF_a     c0 DIV_D      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * fc CSRRCI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      c9 MRET_2     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       9b unx9b      00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     f2 SW_2       00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0080, used ffff, inputs 55
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       88 DIV_E      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       7e NMI_1      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     92 LDAF_3     00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     92 LDAF_3     00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   14 condb_3    00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     b4 eFetch3    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       71 aFaultc    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     b4 eFetch3    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       cf MRET_7     00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      90 NMI_2      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      1a ANDI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     92 LDAF_3     00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    71 aFaultc    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    2e MULHU_1    00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     58 DIV_A      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     29 XOR_1      00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LB_5       2b SLTIX_1    00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 15 CSRRW_2    06 LB_3       00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 16 JALR_2     92 LDAF_3     00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 17 NMI_2      8e _LCSRRS_1  00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 18 BEQ        22 MULHU_6    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     a1 ECALL_4    00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a SUB_1      92 LDAF_3     00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 1b _L0x1b     68 DIV_12     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   78 DIV_4      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d LDAF_2     92 LDAF_3     00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 1e AND_1      95 SW_E3      00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 1f SW_E4      e7 aFault     00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 20 LH_0       30 SLTIX_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 straddle   92 LDAF_3     10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 22 condb_2    85 LBU_1      00000010000000000000111111101100000xx0        ~RS2 in Q                                         0000100b close to ij
 * 23 _L0x23     92 LDAF_3     00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     7a SB_5       00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 LW_1       45 WFI_3      00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LW    34 JAL_3      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     72 LBU_3      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_3    3a SRxI_1     00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2a _L0x2a     72 LBU_3      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_4    62 DIV_8      00000010000000000000000011101101001xx0        Branch on condition                               00000000 
 * 2c SLL_0      9c DIV_10     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     be IJ_1       00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e ANDI_1     10 SUB_1      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     92 LDAF_3     00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_1       92 LDAF_3     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LH    5d SB_2       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 LH_2       cf MRET_7     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 33 aFaultb       (use dinx) 00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 34 ORI_2      8e _LCSRRS_1  00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 35 ECALL_6    7d unx7d      00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 36 aFault_1   03 _L0x03     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 37 ILL_4      8b LB_6       00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 38 BNE        22 MULHU_6    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 IJ_2       92 LDAF_3     00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00001067 close to jalr
 * 3a XORI_1     96 SH_1       00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 3b _L0x3b     68 DIV_12     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    b1 aF_SW_3    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d aF_SW_3    03 _L0x03     00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 3e MULHU_6    7a SB_5       00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 3f QINT_2     94 SW_E4      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 40 LW_0       26 OR_1       00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 jFault_1   16 condb_5    00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 42 OR_1       b9 DIV_e      00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              0000200b close to ij
 * 43 aF_SW_1    6b SB_4       00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      0000200f close to fence
 * 44 SLTI_0     5d SB_2       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 OR_2       bb SH_2       00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 46 DIV_A      b0 CSRRW_3    00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 47 DIV_B      d1 MRET_1     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 48 _L0x48     52 LH_1       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 DIVU_1     15 condb_4    00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 4a _L0x4a     52 LH_1       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b ORI_1      df eFetch     00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 4c SLT_0      65 WFI_4      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   60 MULHU_3    00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e LHU_1      fe ILLe       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40002033 sloppy slt     
 * 4f LDAF_LHU   92 LDAF_3     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 50 DIV_8      92 LDAF_3     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 51 DIV_9      fb SB_3       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 52 SW_1       32 JAL_1      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 53 SW_E1SWE   fb SB_3       00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 54 DIV_12     c1 IJT_2      00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 55 DIV_13     36 SLLI_2     00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 56 LHU_2      b3 unxb3      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 57 aFaultc    71 aFaultc    00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 58 Fetchu     c2 DIVU_3     00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00002063 close to branch
 * 59 eFetchu    74 unx74      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00002067 close to jalr
 * 5a XOR_1      b6 ECALL_5    00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 5b _L0x5b     68 DIV_12     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    b1 aF_SW_3    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLTIX_1    cb QINT_2     00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 5e DIV_4      56 LH_4       00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 5f DIV_5      fb SB_3       00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 60 MULHU_1    10 SUB_1      00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00003003 close to load
 * 61 aF_SW_2    ab EBREAK_2   00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 62 SLTIX_2    f3 aF_SW      00000000000000000100001011101000110010        Registered ALU flag to rd                         0000300b close to ij
 * 63 MUL_2      46 ILL_1      00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  0000300f close to fence
 * 64 SLTIU_0    5d SB_2       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLTX_1     9b unx9b      00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 66 DIV_1      a6 ECAL_RET   00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 67 DIV_2      d3 aFaultd    00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 68 JAL_1      92 LDAF_3     00010000000000001100001011101000100000        Target adr to yy                                  00003023 close to store
 * 69 IJT_3      71 aFaultc    00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 6a JAL_3      c3 DIVU_4     00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                40003023 close to store
 * 6b MULHU_5    c8 DIV_7      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 6c SLTU_0     65 WFI_4      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    60 MULHU_3    00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_E      e8 MUL_2      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             40003033 sloppy sltu    
 * 6f DIV_F      f7 EBREAK_1   00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 70 DIVU_5     ffffffff (null)     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 71 LB_6       36 SLLI_2     00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 72 SH_1       2e MULHU_1    00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 73 SW_E1SWH   21 XORI_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 74 DIV_10        (use dinx) 01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 75 DIV_11        (use dinx) 01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 76 DIV_14     f9 MULH_2     00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00000000 
 * 77 DIV_15     f9 MULH_2     00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 78 ECAL_RET   db jFault_1   00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00003063 close to branch
 * 79 EBRKWFI1   da LDAF_a     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00003067 close to jalr
 * 7a SLLI_1     a6 ECAL_RET   00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 7b _L0x7b     68 DIV_12     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    b1 aF_SW_3    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SLLI_2        (use dinx) 00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 7e IJ_1       17 condb_5t   00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * 7f IJT_1         (use dinx) 00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 80 LBU_0      ce _LCSRRCI_1 00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 ECALL_2       (use dinx) 00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 82 DIVU_3     da LDAF_a     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000400b close to ij
 * 83 DIVU_4     66 SW_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000400f close to fence
 * 84 XORI_0     3a SRxI_1     00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 MULHU_7    a2 DIV_14     00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 86 ECALL_1    6a MULH_1     00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 87 MRET_1        (use dinx) 00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 88 LB_2       74 unx74      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00004023 close to store
 * 89 aFaultd    92 LDAF_3     00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 8a eILL0c     2e MULHU_1    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40004023 close to store
 * 8b ECALL_3    92 LDAF_3     00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 8c XOR_0      5a SB_1       00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      66 SW_1       01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e Fetch      fe ILLe       00000001001010001000101111101010110000  Fr11  Read and latch instruction                        40004033 sloppy xor     
 * 8f eFetch     37 ECALL_2    00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 90 MUL_1      6a MULH_1     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 91 MUL_3      d2 LB_2       00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 92 StdIncPc   6a MULH_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 93 aFault     d4 aFault_2   00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 94 SRxI_1     6a MULH_1     00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 95 aFault_2   1f IJ_2       00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 96 SRxI_2     ea MULHU_5    00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 97 (null)     d3 aFaultd    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 98 BLT        22 MULHU_6    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a eILL0a     6a MULH_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 9b WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 9c SLL_1      54 LH_2       00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00004073 close to csr/system 
 * 9d (null)     76 Fetchu     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 9e SRx_1      d6 eILL0c     00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 9f (null)     a6 ECAL_RET   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * a0 LHU_0      4e eILL0b     00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JALR_1     e6 StdIncPc   00010010000000000000000011101100100110        Q=1                                               00000000 
 * a2 LBU_2      71 aFaultc    00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     0000500b close to ij
 * a3 aFaulte    92 LDAF_3     00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      0000500f close to fence
 * a4 SRxI_0     94 SW_E4      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 WFI_3      de Fetch      00010010000000000000101011101100100110        More check offset                                 00000000 
 * a6 SW_2       86 JAL_2      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * a7 aF_SW      ba LHU_3      00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * a8 Fetch2     5e LHU_1      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00005023 close to store
 * a9 jFault     6a MULH_1     00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * aa WFI_1      f3 aF_SW      00110010000000000000000011001100100110 WFI    To check offset                                   40005023 close to store
 * ab EBREAK_1   35 SLLI_1     00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * ac _L0xac     9e SH_4       00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     49 CSRRW_1    00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     9e SH_4       00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af ILL_1      f0 LBU_2      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * b0 ILL_2      e0 DIVU_1     00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * b1 CSRRW_1    d2 LB_2       00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * b2 LH_4       8e _LCSRRS_1  00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * b3 LH_5          (use dinx) 00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * b4 SB_1       c7 QINT_1     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * b5 (null)     d5 Fetch2u    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b6 SB_2       35 SLLI_1     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * b7 (null)     ee eILL0a     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b8 BGE        22 MULHU_6    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MULHU_3    ffffffff (null)     00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00005067 close to jalr
 * ba EBRKWFI2   2e MULHU_1    00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * bb WFI_4      e5 aF_SW_2    00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * bc CSRRWI_0   b1 aF_SW_3    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd (null)     8e _LCSRRS_1  000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * be MULH_1     39 MULHU_7    00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * bf (null)     ef WFI_5      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c0 SB_4       6e DIV_C      00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00006003 close to load
 * c1 LH_3       69 DIV_13     00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * c2 DIV_C      f5 jFault     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              0000600b close to ij
 * c3 MULH_2     70 LHU_2      00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                0000600f close to fence
 * c4 ORI_0      4b CSRRW_2    00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_6     c5 MRET_5     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * c6 LBU_3      b0 CSRRW_3    00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * c7 unalignd   3f SRx_1      00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * c8 SB_5       50 LW_1       00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00006023 close to store
 * c9 WFI_2      d9 MULH_3     00010010000000000000101011101100100110        Check offset                                      00000000 
 * ca NMI_1      82 DIV_1      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40006023 close to store
 * cb SB_3       92 LDAF_3     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * cc OR_0       42 MULHU_2    00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      66 SW_1       01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce LBU_1      fe ILLe       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40006033 sloppy or      
 * cf JAL_2      13 condb_2    10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * d0 _LCSRRS_1  81 unx81      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d1 ILL_3      f4 Fetch2     00000010000000000000101011101100100110        Q = 1                                             00000000 
 * d2 LDAF_3     09 LB_5       00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * d3 SW_E2      36 SLLI_2     00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * d4 SW_E3      d2 LB_2       00110010000000000000101111001100100110        Q = 3                                             00000000 
 * d5 SH_4          (use dinx) 00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * d6 SH_5       fe ILLe       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * d7 ECALL_4    d7 ECALL_3    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d8 BLTU       22 MULHU_6    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MRET_3     10 SUB_1      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00006067 close to jalr
 * da DIV_3      1d ORI_2      01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * db DIV_6      d2 LB_2       00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * dc CSRRSI_0   b1 aF_SW_3    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd EBREAK_2   61 EBRKWFI2   00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * de MRET_4     a8 DIV_3      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * df CSRRW_3    a8 DIV_3      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * e0 CSRRW_4    f5 jFault     00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00007003 close to load
 * e1 (null)     34 JAL_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e2 eFetch3    63 DIV_9      0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   0000700b close to ij
 * e3 (null)     2e MULHU_1    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     2e MULHU_1    00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SH_3       3d SRxI_2     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e6 ECALL_5    8e _LCSRRS_1  00110010000000000000101011001100100110        Q = 8                                             00000000 
 * e7 IJ_3       36 SLLI_2     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * e8 DIV_e      90 NMI_2      00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00007023 close to store
 * e9 (null)     f1 aFaulte    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ea SH_2       3e SLL_1      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      40007023 close to store
 * eb (null)     b2 CSRRW_4    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ec AND_0      1e aFault_1   00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     49 CSRRW_1    00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee IJ_4       fe ILLe       00000100000010001010110111100100011xx0        Mask and use as PC                                40007033 sloppy and     
 * ef IJT_2      8e _LCSRRS_1  00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * f0 MRET_5     c6 IJT_4      00000010000000000000000011101100010xx0        ~302                                              00000000 
 * f1 IJT_4      36 SLLI_2     00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * f2 QINT_1     92 LDAF_3     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * f3 DIV_7      43 MULHU_4    00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f4 MRET_2     e2 MUL_1      00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * f5 DIVU_2     41 JALR_1     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f6 _LCSRRCI_1 c9 MRET_2     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f7 MRET_7     dd aF_SW_1    00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f8 BGEU       22 MULHU_6    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 Fetch2u    fa WFI_2      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00007067 close to jalr
 * fa MULH_3     a5 MRET_3     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * fb LDAF_a     c0 DIV_D      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * fc CSRRCI_0   b1 aF_SW_3    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      ca DIVU_2     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       af MRET_4     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     f2 SW_2       00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0080, used ffff, inputs 56
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       7e NMI_1      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       74 unx74      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     8a DIVU_5     00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     8a DIVU_5     00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     b4 eFetch3    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       63 DIV_9      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     b4 eFetch3    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       cb QINT_2     00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      88 DIV_E      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     8a DIVU_5     00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    63 DIV_9      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     56 LH_4       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 CSRRW_2    8a DIVU_5     00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 17 NMI_2      86 JAL_2      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     aa DIV_6      00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       8a DIVU_5     00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     9c DIV_10     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   72 LBU_3      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     8a DIVU_5     00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LDAF_2     96 SH_1       00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 1f SW_E4      e5 aF_SW_2    00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 20 LH_0       26 OR_1       00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      8a DIVU_5     00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      a5 MRET_3     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     8a DIVU_5     00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     a1 ECALL_4    00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 LH_1       5d SB_2       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LH    3d SRxI_2     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     68 DIV_12     00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     68 DIV_12     00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      a8 DIV_3      00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     bd IJ_4       00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     8a DIVU_5     00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_2       8a DIVU_5     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 31 aFaultb    7a SB_5       00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 32 DIV_A      cb QINT_2     00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 33 DIV_B         (use dinx) 00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 34 LHU_1      86 JAL_2      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 35 LDAF_LHU   a2 DIV_14     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 36 ECALL_6    03 _L0x03     00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 37 ILL_4      83 DIV_2      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    8a DIVU_5     00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     a7 EBRKWFI1   00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     9c DIV_10     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    b1 aF_SW_3    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e aF_SW_3    a1 ECALL_4    00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 3f QINT_2     a6 ECAL_RET   00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 DIV_8      b9 DIV_e      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000200b close to ij
 * 43 DIV_9      6f MRET_6     01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       bb SH_2       00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 jFault_1   b0 CSRRW_3    00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 47 aF_SW_1    d1 MRET_1     00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 48 _L0x48     50 LW_1       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     16 condb_5    00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     50 LW_1       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    df eFetch     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIVU_1     fe ILLe       00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           40002033 sloppy slt     
 * 4f ORI_1      8a DIVU_5     00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 50 SW_1       8a DIVU_5     00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 51 SW_E1SWE   fb SB_3       00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 52 DIV_12     30 SLTIX_2    00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 53 DIV_13     fb SB_3       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 54 LHU_2      c6 IJT_4      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 55 aFaultc    41 JALR_1     00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 56 Fetchu     b3 unxb3      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00000000 
 * 57 eFetchu    63 DIV_9      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 58 DIV_4      c1 IJT_2      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00002063 close to branch
 * 59 DIV_5      6a MULH_1     00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00002067 close to jalr
 * 5a OR_1       b5 SH_3       00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     9c DIV_10     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    b1 aF_SW_3    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       cf MRET_7     00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIV_1      54 LH_2       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 5f DIV_2      fb SB_3       00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 60 DIV_E      10 SUB_1      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003003 close to load
 * 61 DIV_F      9b unx9b      00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 62 DIVU_5     f3 aF_SW      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               0000300b close to ij
 * 63 LB_6       32 JAL_1      00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      8f ILL_3      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 aF_SW_2    92 LDAF_3     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 67 MUL_2      d3 aFaultd    00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 68 SH_1       8a DIVU_5     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00003023 close to store
 * 69 SW_E1SWH   63 DIV_9      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 6a DIV_10     c7 QINT_1     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    40003023 close to store
 * 6b DIV_11     c8 DIV_7      01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e IJT_3      e8 MUL_2      00010010000000000000110011101100100110        Construct Q = 1                                   40003033 sloppy sltu    
 * 6f MULHU_5    f7 EBREAK_1   00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 70 DIV_14     ffffffff (null)     00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00000000 
 * 71 DIV_15     41 JALR_1     00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 72 ECAL_RET   3a SRxI_1     00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 73 EBRKWFI1   29 XOR_1      00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 74 IJ_1          (use dinx) 00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * 75 IJT_1         (use dinx) 00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 76 DIVU_3     f9 MULH_2     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 77 DIVU_4     f9 MULH_2     01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 78 ECALL_1    db jFault_1   00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00003063 close to branch
 * 79 MRET_1     da LDAF_a     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00003067 close to jalr
 * 7a SLTIX_1    92 LDAF_3     00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     9c DIV_10     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    b1 aF_SW_3    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e LB_2       17 condb_5t   00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 7f aFaultd       (use dinx) 00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 80 LBU_0      ca DIVU_2     00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 eILL0c     da LDAF_a     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000400b close to ij
 * 83 ECALL_3    5e LHU_1      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     90 NMI_2      00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 Fetch      9d DIV_11     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 87 eFetch        (use dinx) 00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 88 MUL_1      6a MULH_1     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00004023 close to store
 * 89 MUL_3      8a DIVU_5     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 8a StdIncPc   3a SRxI_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    40004023 close to store
 * 8b aFault     8a DIVU_5     00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      5e LHU_1      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e eILL0a     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40004033 sloppy xor     
 * 8f WFI_5      37 ECALL_2    00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 90 LBU_2      9d DIV_11     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 91 aFaulte    d2 LB_2       00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 92 SW_2       9d DIV_11     00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 93 aF_SW      d4 aFault_2   00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 94 Fetch2     9d DIV_11     00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 95 jFault     1f IJ_2       00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 96 aFault_2   e9 IJT_3      00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 97 (null)     d3 aFaultd    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a WFI_1      9d DIV_11     00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 9b EBREAK_1      (use dinx) 00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 9c JAL_1      52 LH_1       00010000000000001100001011101000100000        Target adr to yy                                  00004073 close to csr/system 
 * 9d JAL_3      70 LHU_2      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 9e (null)     d6 eILL0c     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 9f (null)     92 LDAF_3     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * a0 LHU_0      34 JAL_3      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SLLI_1     e3 MUL_3      00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * a2 SLLI_2     63 DIV_9      00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                0000500b close to ij
 * a3 ECALL_2    8a DIVU_5     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  0000500f close to fence
 * a4 SRxI_0     a6 ECAL_RET   00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MULHU_7    de Fetch      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * a6 SRxI_1     78 DIV_4      00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * a7 SRxI_2     ba LHU_3      00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * a8 SLL_1      58 DIV_A      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00005023 close to store
 * a9 SRx_1      9d DIV_11     00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * aa JALR_1     f3 aF_SW      00010010000000000000000011101100100110        Q=1                                               40005023 close to store
 * ab WFI_3      36 SLLI_2     00010010000000000000101011101100100110        More check offset                                 00000000 
 * ac _L0xac     a9 ILL_4      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     4e eILL0b     00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     a9 ILL_4      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af ILL_1      f0 LBU_2      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * b0 ILL_2      e0 DIVU_1     00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * b1 CSRRW_1    d2 LB_2       00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * b2 LH_4       86 JAL_2      00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * b3 LH_5          (use dinx) 00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * b4 SB_1       c5 MRET_5     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * b5 SB_2       d5 Fetch2u    00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * b6 (null)     36 SLLI_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b7 (null)     ea MULHU_5    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MULHU_3    ffffffff (null)     00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00005067 close to jalr
 * ba EBRKWFI2   3a SRxI_1     00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * bb WFI_4      e2 MUL_1      00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * bc CSRRWI_0   b1 aF_SW_3    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd MULH_1     86 JAL_2      00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * be (null)     45 WFI_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * bf (null)     eb LH_3       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c0 SB_4       60 MULHU_3    00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00006003 close to load
 * c1 DIV_C      6e DIV_C      00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * c2 MRET_6     f5 jFault     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            0000600b close to ij
 * c3 LBU_3      62 DIV_8      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       0000600f close to fence
 * c4 ORI_0      4f MRET_8     00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 unalignd   c2 DIVU_3     00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * c6 LH_3       b0 CSRRW_3    00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * c7 MULH_2     3f SRx_1      00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * c8 SB_5       42 MULHU_2    00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00006023 close to store
 * c9 NMI_1      d9 MULH_3     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * ca LBU_1      76 Fetchu     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40006023 close to store
 * cb JAL_2      8a DIVU_5     10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      5e LHU_1      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce WFI_2      fe ILLe       00010010000000000000101011101100100110        Check offset                                      40006033 sloppy or      
 * cf SB_3       13 condb_2    00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d0 _LCSRRS_1  a3 DIV_15     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d1 ILL_3      f4 Fetch2     00000010000000000000101011101100100110        Q = 1                                             00000000 
 * d2 LDAF_3     09 LB_5       00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * d3 SW_E2      41 JALR_1     00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * d4 SW_E3      d2 LB_2       00110010000000000000101111001100100110        Q = 3                                             00000000 
 * d5 SH_4          (use dinx) 00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * d6 SH_5       fe ILLe       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * d7 ECALL_4    d7 ECALL_3    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MRET_3     10 SUB_1      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00006067 close to jalr
 * da DIV_3      1e aFault_1   01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * db DIV_6      d2 LB_2       00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * dc CSRRSI_0   b1 aF_SW_3    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd EBREAK_2   66 SW_1       00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * de MRET_4     94 SW_E4      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * df CSRRW_3    94 SW_E4      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * e0 CSRRW_4    f5 jFault     00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00007003 close to load
 * e1 eFetch3    3d SRxI_2     0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * e2 SH_3       67 SW_E1SWE   00000010000000000000000011101000110000        Prepare get back address to use                   0000700b close to ij
 * e3 ECALL_5    3a SRxI_1     00110010000000000000101011001100100110        Q = 8                                             0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 IJ_3       3e SLL_1      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * e6 (null)     86 JAL_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e7 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e8 DIV_e      88 DIV_E      00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00007023 close to store
 * e9 SH_2       f1 aFaulte    00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * ea IJ_4       4b CSRRW_2    00000100000010001010110111100100011xx0        Mask and use as PC                                40007023 close to store
 * eb IJT_2      b2 CSRRW_4    00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     4e eILL0b     00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee (null)     fe ILLe       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   40007033 sloppy and     
 * ef (null)     86 JAL_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f0 MRET_5     c3 DIVU_4     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * f1 IJT_4      41 JALR_1     00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * f2 QINT_1     8a DIVU_5     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * f3 DIV_7      47 ILL_2      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f4 MRET_2     e1 ORI_1      00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * f5 DIVU_2     46 ILL_1      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f6 _LCSRRCI_1 ce _LCSRRCI_1 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f7 MRET_7     dd aF_SW_1    00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 Fetch2u    fa WFI_2      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00007067 close to jalr
 * fa MULH_3     ab EBREAK_2   00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * fb LDAF_a     c0 DIV_D      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * fc CSRRCI_0   b1 aF_SW_3    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      c9 MRET_2     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       af MRET_4     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     f2 SW_2       00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0010, used ffff, inputs 59
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       ba LHU_3      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       a6 ECAL_RET   00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     ce _LCSRRCI_1 00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     ce _LCSRRCI_1 00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     fb SB_3       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       8f ILL_3      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     fb SB_3       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       b3 unxb3      00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      ca DIVU_2     00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     ce _LCSRRCI_1 00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 CSRRW_2    8f ILL_3      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 11 SB_2       3a SRxI_1     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 12 NMI_2      82 DIV_1      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 13 MULHU_3    2e MULHU_1    00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * 14 LDAF_2     39 MULHU_7    00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 15 EBRKWFI2   06 LB_3       00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 16 SW_E4      ce _LCSRRCI_1 00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 17 WFI_4      c8 DIV_7      00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     d9 MULH_3     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       ce _LCSRRCI_1 00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     81 unx81      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   a2 DIV_14     00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     ce _LCSRRCI_1 00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e MULHU_2    90 NMI_2      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 1f MULHU_4    50 LW_1       00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 20 LH_0       4e eILL0b     00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      ce _LCSRRCI_1 00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      b9 DIV_e      00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     ce _LCSRRCI_1 00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     a1 ECALL_4    00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 eILL0b     5d SB_2       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     3d SRxI_2     00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     9a ECALL_6    00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     9a ECALL_6    00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    7a SB_5       00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      c2 DIVU_3     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     31 SLTX_1     00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    1e aFault_1   00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     ce _LCSRRCI_1 00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 ECALL_6    ce _LCSRRCI_1 00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 31 MULH_1     62 DIV_8      00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * 32 ILL_4      b3 unxb3      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 33 SB_4          (use dinx) 00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 34 aF_SW_3    c8 DIV_7      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 35 DIV_C      a5 MRET_3     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * 36 QINT_2     03 _L0x03     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 37 MRET_6     bf IJT_1      00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    ce _LCSRRCI_1 00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     c0 DIV_D      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     81 unx81      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    e6 StdIncPc   00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LW_1       a1 ECALL_4    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    bd IJ_4       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 LDAF_3     1d ORI_2      00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 42 aFault_1   13 condb_2    00110010000000000000101011001100100110        Q = 4                                             0000200b close to ij
 * 43 SW_E2      77 eFetchu    00000000000000001101101111101000001xx0        Store address that faulted                        0000200f close to fence
 * 44 SLTI_0     62 DIV_8      00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 SW_E3      17 condb_5t   00110010000000000000101111001100100110        Q = 3                                             00000000 
 * 46 IJ_2       e2 MUL_1      00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 47 SH_4       b7 IJ_3       00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 48 _L0x48     6e DIV_C      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     10 SUB_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     6e DIV_C      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    c7 QINT_1     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      7d unx7d      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   66 SW_1       00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e LH_1       fe ILLe       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40002033 sloppy slt     
 * 4f LDAF_LH    ce _LCSRRCI_1 00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 50 IJ_3       ce _LCSRRCI_1 00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 51 jFault_1   f6 WFI_1      00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 52 DIV_e      58 DIV_A      00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 53 aF_SW_1    f6 WFI_1      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 54 SH_2       d1 MRET_1     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 55 DIVU_1     42 MULHU_2    00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 56 IJ_4       fa WFI_2      00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 57 ORI_1      8f ILL_3      00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 58 LH_2       35 SLLI_1     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00002063 close to branch
 * 59 aFaultb    9c DIV_10     00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00002067 close to jalr
 * 5a OR_1       11 AND_1      00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     81 unx81      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    e6 StdIncPc   00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       d7 ECALL_3    00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIV_A      7e NMI_1      00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 5f DIV_B      f6 WFI_1      00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 60 XOR_1      1e aFault_1   00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00003003 close to load
 * 61 SH_5       ef WFI_5      00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 62 SLTIX_1    d0 ECALL_1    00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             0000300b close to ij
 * 63 ECALL_4    5e LHU_1      00110010000000000000101011001100100110        Q = 4                                             0000300f close to fence
 * 64 SLTIU_0    62 DIV_8      00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 MRET_3     db jFault_1   00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * 66 MULHU_1    e8 MUL_2      00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 67 DIV_3      43 MULHU_4    01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * 68 LHU_1      ce _LCSRRCI_1 00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00003023 close to store
 * 69 LDAF_LHU   8f ILL_3      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 6a DIV_8      d3 aFaultd    00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           40003023 close to store
 * 6b DIV_9      95 SW_E3      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 6c SLTU_0     7d unx7d      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    66 SW_1       00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e SW_1       52 LH_1       00000000000000000011111011100100001xx0        Write d to a+k until accepted                     40003033 sloppy sltu    
 * 6f SW_E1SWE   f0 LBU_2      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 70 IJT_2      ffffffff (null)     00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * 71 aF_SW_2    42 MULHU_2    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 72 MRET_5     3a SRxI_1     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * 73 MUL_2      29 XOR_1      00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 74 IJT_4         (use dinx) 00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 75 IJT_3         (use dinx) 00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 76 QINT_1     f2 SW_2       00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 77 MULHU_5    f2 SW_2       00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 78 DIV_12     c1 IJT_2      00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00003063 close to branch
 * 79 DIV_13     67 SW_E1SWE   00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00003067 close to jalr
 * 7a SLTIX_2    e8 MUL_2      00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 7b _L0x7b     81 unx81      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    e6 StdIncPc   00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SLTX_1        (use dinx) 00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 7e LHU_2      12 straddle   00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 7f aFaultc       (use dinx) 00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 80 LBU_0      b1 aF_SW_3    00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 JAL_1         (use dinx) 00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 82 Fetchu     67 SW_E1SWE   00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000400b close to ij
 * 83 eFetchu    88 DIV_E      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 JAL_3      de Fetch      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 86 DIV_4      85 LBU_1      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 87 DIV_5         (use dinx) 00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 88 DIV_1      9c DIV_10     00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00004023 close to store
 * 89 DIV_2      ce _LCSRRCI_1 00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 8a DIV_E      3a SRxI_1     01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             40004023 close to store
 * 8b DIV_F      ce _LCSRRCI_1 00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 8c XOR_0      60 MULHU_3    00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      88 DIV_E      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e DIVU_5     fe ILLe       00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               40004033 sloppy xor     
 * 8f LB_6       32 JAL_1      00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 90 aFault_2   85 LBU_1      00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 91 LBU_3      41 JALR_1     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 92 (null)     85 LBU_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 93 unalignd   45 WFI_3      00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * 94 (null)     85 LBU_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 95 SB_5       16 condb_5    00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 96 (null)     54 LH_2       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 97 NMI_1      43 MULHU_4    00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a SH_1       85 LBU_1      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 9b SW_E1SWH      (use dinx) 00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 9c DIV_10     78 DIV_4      01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00004073 close to csr/system 
 * 9d DIV_11     9e SH_4       01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 9e DIV_14     61 EBRKWFI2   00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00000000 
 * 9f DIV_15     e8 MUL_2      00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * a0 LHU_0      68 DIV_12     00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SLLI_1     e7 aFault     00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * a2 ECAL_RET   8f ILL_3      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000500b close to ij
 * a3 EBRKWFI1   ce _LCSRRCI_1 00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000500f close to fence
 * a4 SRxI_0     bd IJ_4       00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SLLI_2     c5 MRET_5     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * a6 IJ_1       aa DIV_6      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * a7 IJT_1      15 condb_4    00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * a8 DIVU_3     86 JAL_2      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00005023 close to store
 * a9 DIVU_4     85 LBU_1      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * aa ECALL_1    d0 ECALL_1    00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40005023 close to store
 * ab MRET_1     30 SLTIX_2    00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * ac _L0xac     c6 IJT_4      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     55 aFaultb    00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     c6 IJT_4      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af ECALL_2    72 LBU_3      00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * b0 (null)     e1 ORI_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b1 LBU_1      41 JALR_1     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * b2 (null)     c8 DIV_7      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b3 JAL_2         (use dinx) 10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * b4 (null)     93 SW_E2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b5 _LCSRRS_1  47 ILL_2      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b6 (null)     30 SLTIX_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b7 ILL_3      56 LH_4       00000010000000000000101011101100100110        Q = 1                                             00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MULHU_7    ffffffff (null)     00100000000000000100001011101000001xx0        Last shift.                                       00005067 close to jalr
 * ba LB_2       3a SRxI_1     00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * bb aFaultd    e5 aF_SW_2    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * bc CSRRWI_0   e6 StdIncPc   00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SRxI_1     c8 DIV_7      00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * be eILL0c     46 ILL_1      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bf ECALL_3    70 LHU_2      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * c0 SRxI_2     8a DIVU_5     00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00006003 close to load
 * c1 DIV_6      75 unx75      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * c2 SLL_1      d4 aFault_2   00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              0000600b close to ij
 * c3 EBREAK_2   8e _LCSRRS_1  00000000000000001101101011101000001xx0        pc to mepc                                        0000600f close to fence
 * c4 ORI_0      57 LH_5       00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_4     37 ECALL_2    00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * c6 SRx_1      e2 MUL_1      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * c7 CSRRW_3    36 SLLI_2     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * c8 Fetch      6a MULH_1     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00006023 close to store
 * c9 eFetch     65 WFI_4      00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * ca MUL_1      a8 DIV_3      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           40006023 close to store
 * cb MUL_3      ce _LCSRRCI_1 00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      88 DIV_E      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce StdIncPc   fe ILLe       10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    40006033 sloppy or      
 * cf aFault     27 OR_2       00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * d0 DIV_7      af MRET_4     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d1 LH_3       d2 LB_2       00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * d2 MRET_2     09 LB_5       00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * d3 MULH_2     42 MULHU_2    00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * d4 DIVU_2     41 JALR_1     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d5 WFI_2         (use dinx) 00010010000000000000101011101100100110        Check offset                                      00000000 
 * d6 _LCSRRCI_1 fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d7 SB_3       63 DIV_9      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 JALR_1     1e aFault_1   00010010000000000000000011101100100110        Q=1                                               00006067 close to jalr
 * da eILL0a     14 condb_3    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * db WFI_5      41 JALR_1     00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * dc CSRRSI_0   e6 StdIncPc   00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd WFI_3      71 aFaultc    00010010000000000000101011101100100110        More check offset                                 00000000 
 * de LBU_2      ea MULHU_5    00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * df aFaulte    ea MULHU_5    00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * e0 ILL_1      d4 aFault_2   00000000000000001101101011100x00001xx0        Store PC to mepc                                  00007003 close to load
 * e1 CSRRW_4    3d SRxI_2     00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * e2 ILL_2      73 unalignd   00000000000000001111101011101000001xx0        Store 0 to mtval                                  0000700b close to ij
 * e3 eFetch3    3a SRxI_1     0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SH_3       34 JAL_3      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e6 CSRRW_1    c8 DIV_7      00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * e7 ECALL_5    42 MULHU_2    00110010000000000000101011001100100110        Q = 8                                             00000000 
 * e8 SW_2       ca DIVU_2     00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00007023 close to store
 * e9 aF_SW      74 unx74      00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * ea Fetch2     4b CSRRW_2    00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     40007023 close to store
 * eb jFault     f9 MULH_2     00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     55 aFaultb    00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee WFI_1      fe ILLe       00110010000000000000000011001100100110 WFI    To check offset                                   40007033 sloppy and     
 * ef EBREAK_1   c8 DIV_7      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * f0 MRET_7     91 LDAF_2     00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f1 (null)     42 MULHU_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f2 Fetch2u    ce _LCSRRCI_1 0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f3 (null)     53 LDAF_LH    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 MULH_3     e3 MUL_3      00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * f5 (null)     51 LDAF_LW    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f6 LDAF_a     d5 Fetch2u    00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * f7 (null)     c3 DIVU_4     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 LH_4       f4 Fetch2     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00007067 close to jalr
 * fa LH_5       dd aF_SW_1    00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * fb SB_1       33 unx33      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * fc CSRRCI_0   e6 StdIncPc   00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      97 SW_E1SWH   00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       e0 DIVU_1     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     76 Fetchu     00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0010, used ffff, inputs 5a
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       aa DIV_6      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       a2 DIV_14     00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     c8 DIV_7      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     c8 DIV_7      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     fb SB_3       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       8b LB_6       00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     fb SB_3       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       b3 unxb3      00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      c0 DIV_D      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     c8 DIV_7      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 CSRRW_2    8b LB_6       00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 11 NMI_2      3a SRxI_1     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 12 SB_2       7e NMI_1      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 13 MULHU_3    2e MULHU_1    00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * 14 LDAF_2     39 MULHU_7    00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 15 SW_E4      06 LB_3       00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 16 EBRKWFI2   c8 DIV_7      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 17 WFI_4      be IJ_1       00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     e9 IJT_3      00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       c8 DIV_7      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   9e SH_4       00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     c8 DIV_7      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e MULHU_2    90 NMI_2      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 1f MULHU_4    50 LW_1       00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 20 LH_0       4e eILL0b     00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      c8 DIV_7      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      c5 MRET_5     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     c8 DIV_7      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     af MRET_4     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 eILL0b     5d SB_2       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     3d SRxI_2     00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     8e _LCSRRS_1  00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     8e _LCSRRS_1  00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      e5 aF_SW_2    00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     32 JAL_1      00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    1e aFault_1   00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     c8 DIV_7      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 ECALL_6    c8 DIV_7      00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 31 ILL_4      7a SB_5       00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 32 MULH_1     b3 unxb3      00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * 33 SB_4          (use dinx) 00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 34 aF_SW_3    be IJ_1       00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 35 QINT_2     b9 DIV_e      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 36 DIV_C      03 _L0x03     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * 37 MRET_6     bb SH_2       00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    c8 DIV_7      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     dd aF_SW_1    00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    ef WFI_5      00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LW_1       af MRET_4     00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    d9 MULH_3     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 LDAF_3     13 condb_2    00000000000000001101100111100x00001xx0        PC to mepc                                        0000200b close to ij
 * 43 SW_E2      77 eFetchu    00000000000000001101101111101000001xx0        Store address that faulted                        0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       17 condb_5t   00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 SW_E3      ee eILL0a     00110010000000000000101111001100100110        Q = 3                                             00000000 
 * 47 SH_4       b7 IJ_3       00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 48 _L0x48     6a MULH_1     00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     10 SUB_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     6a MULH_1     00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    c7 QINT_1     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e LH_1       fe ILLe       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40002033 sloppy slt     
 * 4f LDAF_LH    c8 DIV_7      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 50 IJ_3       c8 DIV_7      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 51 DIV_e      f5 jFault     00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 52 jFault_1   58 DIV_A      00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 53 aF_SW_1    f5 jFault     00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 54 SH_2       d2 LB_2       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 55 IJ_4       41 JALR_1     00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 56 DIVU_1     fa WFI_2      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 57 ORI_1      8b LB_6       00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 58 LH_2       36 SLLI_2     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00002063 close to branch
 * 59 aFaultb    9a ECALL_6    00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00002067 close to jalr
 * 5a OR_1       12 straddle   00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    ef WFI_5      00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       d7 ECALL_3    00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIV_A      78 DIV_4      00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 5f DIV_B      f5 jFault     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 60 LHU_1      1e aFault_1   00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00003003 close to load
 * 61 LDAF_LHU   e1 ORI_1      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 62 SH_5       d0 ECALL_1    00000000000000000001110011100100001xx0        Write d to a+k until accepted                     0000300b close to ij
 * 63 ECALL_4    5e LHU_1      00110010000000000000101011001100100110        Q = 4                                             0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      cb QINT_2     00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 MRET_3     da LDAF_a     00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * 67 DIV_3      43 MULHU_4    01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * 68 DIV_8      c8 DIV_7      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00003023 close to store
 * 69 DIV_9      8b LB_6       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 6a SW_1       d3 aFaultd    00000000000000000011111011100100001xx0        Write d to a+k until accepted                     40003023 close to store
 * 6b SW_E1SWE   96 SH_1       00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_12     51 LDAF_LW    00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              40003033 sloppy sltu    
 * 6f DIV_13     f0 LBU_2      00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 70 IJT_2      ffffffff (null)     00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * 71 MRET_5     41 JALR_1     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * 72 aF_SW_2    3a SRxI_1     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 73 MUL_2      29 XOR_1      00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 74 IJT_4         (use dinx) 00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 75 QINT_1        (use dinx) 00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 76 IJT_3      f1 aFaulte    00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 77 MULHU_5    f1 aFaulte    00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 78 LHU_2      c2 DIVU_3     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00003063 close to branch
 * 79 aFaultc    67 SW_E1SWE   00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00003067 close to jalr
 * 7a SLTIX_1    da LDAF_a     00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    ef WFI_5      00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e Fetchu     11 AND_1      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00000000 
 * 7f eFetchu       (use dinx) 00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 80 LBU_0      b2 CSRRW_4    00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 DIV_4      67 SW_E1SWE   00000000000000001100000011101000110000        ~abs(divisor) to yy                               0000400b close to ij
 * 83 DIV_5      86 JAL_2      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     ce _LCSRRCI_1 00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 DIV_1      a5 MRET_3     00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 87 DIV_2         (use dinx) 00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 88 DIV_E      9a ECALL_6    01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00004023 close to store
 * 89 DIV_F      c8 DIV_7      00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 8a DIVU_5     3a SRxI_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               40004023 close to store
 * 8b LB_6       c8 DIV_7      00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      86 JAL_2      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e SH_1       fe ILLe       00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        40004033 sloppy xor     
 * 8f SW_E1SWH   31 SLTX_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 90 aFault_2   a5 MRET_3     00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 91 (null)     42 MULHU_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 92 LBU_3      a5 MRET_3     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 93 unalignd   46 ILL_1      00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * 94 (null)     a5 MRET_3     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 95 (null)     15 condb_4    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 96 SB_5       54 LH_2       00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 97 NMI_1      43 MULHU_4    00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a DIV_10     a5 MRET_3     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 9b DIV_11        (use dinx) 01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 9c DIV_14     6e DIV_C      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00004073 close to csr/system 
 * 9d DIV_15     9c DIV_10     00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 9e ECAL_RET   62 DIV_8      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 9f EBRKWFI1   da LDAF_a     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * a0 LHU_0      60 MULHU_3    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JAL_1      e7 aFault     00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * a2 IJ_1       8b LB_6       00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   0000500b close to ij
 * a3 IJT_1      c8 DIV_7      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              0000500f close to fence
 * a4 SRxI_0     d9 MULH_3     00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 JAL_3      c6 IJT_4      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a6 DIVU_3     a8 DIV_3      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * a7 DIVU_4     16 condb_5    01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * a8 ECALL_1    82 DIV_1      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00005023 close to store
 * a9 MRET_1     a5 MRET_3     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * aa LB_2       d0 ECALL_1    00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     40005023 close to store
 * ab aFaultd    30 SLTIX_2    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * ac _L0xac     e8 MUL_2      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     56 LH_4       00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     e8 MUL_2      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SLLI_1     71 aFaultc    00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * b0 (null)     e2 MUL_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b1 (null)     42 MULHU_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b2 LBU_1      be IJ_1       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * b3 JAL_2         (use dinx) 10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * b4 (null)     93 SW_E2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b5 (null)     47 ILL_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b6 _LCSRRS_1  30 SLTIX_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b7 ILL_3      55 aFaultb    00000010000000000000101011101100100110        Q = 1                                             00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SLLI_2     ffffffff (null)     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00005067 close to jalr
 * ba eILL0c     3a SRxI_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bb ECALL_3    e6 StdIncPc   00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * bc CSRRWI_0   ef WFI_5      00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ECALL_2    be IJ_1       00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * be Fetch      45 WFI_3      00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * bf eFetch     70 LHU_2      00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * c0 MUL_1      88 DIV_E      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00006003 close to load
 * c1 MUL_3      76 Fetchu     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * c2 DIV_6      d4 aFault_2   00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            0000600b close to ij
 * c3 EBREAK_2   8a DIVU_5     00000000000000001101101011101000001xx0        pc to mepc                                        0000600f close to fence
 * c4 ORI_0      57 LH_5       00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MULHU_7    37 ECALL_2    00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * c6 MRET_4     ee eILL0a     00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * c7 CSRRW_3    35 SLLI_1     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * c8 StdIncPc   68 DIV_12     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00006023 close to store
 * c9 aFault     66 SW_1       00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * ca eILL0a     a6 ECAL_RET   00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006023 close to store
 * cb WFI_5      c8 DIV_7      00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      86 JAL_2      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce LBU_2      fe ILLe       00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40006033 sloppy or      
 * cf aFaulte    27 OR_2       00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * d0 DIV_7      bd IJ_4       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d1 MRET_2     d1 MRET_1     00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * d2 LH_3       09 LB_5       00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * d3 MULH_2     41 JALR_1     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * d4 DIVU_2     42 MULHU_2    00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d5 _LCSRRCI_1    (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d6 WFI_2      fe ILLe       00010010000000000000101011101100100110        Check offset                                      00000000 
 * d7 SB_3       63 DIV_9      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 SRxI_1     1e aFault_1   00000000000000000100101001101100001xx1        Register to shift to Q                            00006067 close to jalr
 * da SW_2       14 condb_3    00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * db aF_SW      42 MULHU_2    00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * dc CSRRSI_0   ef WFI_5      00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd SRxI_2     72 LBU_3      00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * de Fetch2     de Fetch      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * df jFault     de Fetch      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * e0 WFI_1      d4 aFault_2   00110010000000000000000011001100100110 WFI    To check offset                                   00007003 close to load
 * e1 EBREAK_1   3d SRxI_2     00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * e2 CSRRW_4    73 unalignd   00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      0000700b close to ij
 * e3 eFetch3    3a SRxI_1     0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SLL_1      34 JAL_3      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * e6 SH_3       be IJ_1       00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e7 ECALL_5    41 JALR_1     00110010000000000000101011001100100110        Q = 8                                             00000000 
 * e8 SRx_1      c0 DIV_D      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00007023 close to store
 * e9 JALR_1     74 unx74      00010010000000000000000011101100100110        Q=1                                               00000000 
 * ea WFI_3      4b CSRRW_2    00010010000000000000101011101100100110        More check offset                                 40007023 close to store
 * eb ILL_1      f9 MULH_2     00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     56 LH_4       00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee ILL_2      fe ILLe       00000000000000001111101011101000001xx0        Store 0 to mtval                                  40007033 sloppy and     
 * ef CSRRW_1    be IJ_1       00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * f0 MRET_7     92 LDAF_3     00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f1 Fetch2u    41 JALR_1     0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f2 (null)     c8 DIV_7      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f3 (null)     53 LDAF_LH    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 MULH_3     e3 MUL_3      00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * f5 LDAF_a     52 LH_1       00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * f6 (null)     d6 eILL0c     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     c3 DIVU_4     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 LH_4       f4 Fetch2     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00007067 close to jalr
 * fa LH_5       ea MULHU_5    00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * fb SB_1       33 unx33      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * fc CSRRCI_0   ef WFI_5      00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      97 SW_E1SWH   00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       eb LH_3       00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     75 unx75      00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0010, used ffff, inputs 5c
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       9e SH_4       00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       8e _LCSRRS_1  00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     aa DIV_6      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     aa DIV_6      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     df eFetch     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       7f unx7f      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     df eFetch     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       f9 MULH_2     00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      a8 DIV_3      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     aa DIV_6      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 CSRRW_2    7f unx7f      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 11 NMI_2      3a SRxI_1     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 12 LDAF_2     68 DIV_12     00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 13 SW_E4      2e MULHU_1    00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 14 LDAF_3     39 MULHU_7    00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 15 SW_E2      06 LB_3       00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 16 SW_E3      aa DIV_6      00110010000000000000101111001100100110        Q = 3                                             00000000 
 * 17 SH_4       a6 ECAL_RET   00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     ce _LCSRRCI_1 00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       aa DIV_6      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   8a DIVU_5     00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     aa DIV_6      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e MULHU_2    90 NMI_2      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 1f MULHU_4    50 LW_1       00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 20 LH_0       42 MULHU_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      aa DIV_6      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      c5 MRET_5     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     aa DIV_6      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     af MRET_4     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 eILL0b     5d SB_2       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     3d SRxI_2     00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     82 DIV_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     82 DIV_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      ca DIVU_2     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     e5 aF_SW_2    00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    1e aFault_1   00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     aa DIV_6      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 ECALL_6    aa DIV_6      00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 31 ILL_4      7a SB_5       00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 32 aF_SW_3    f9 MULH_2     00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 33 QINT_2        (use dinx) 00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 34 SH_5       a6 ECAL_RET   00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 ECALL_4    b9 DIV_e      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 36 MRET_3     03 _L0x03     00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * 37 DIV_3      a3 DIV_15     01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    aa DIV_6      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     c9 MRET_2     00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    db jFault_1   00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LW_1       af MRET_4     00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    c8 DIV_7      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 LH_1       e1 ORI_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH    77 eFetchu    00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       e3 MUL_3      00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 LH_2       da LDAF_a     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    fb SB_3       00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     10 SUB_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    97 SW_E1SWH   00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_A      fe ILLe       00110010000000000000101111101100001xx1        Transfer rM to rDee                               40002033 sloppy slt     
 * 4f DIV_B      aa DIV_6      00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 50 IJ_3       aa DIV_6      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 51 DIV_e      f3 aF_SW      00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 52 SH_2       46 ILL_1      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 53 IJ_4       f3 aF_SW      00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 54 jFault_1   d4 aFault_2   00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 55 aF_SW_1    41 JALR_1     00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 56 DIVU_1     de Fetch      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 57 ORI_1      7f unx7f      00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 58 LHU_1      e7 aFault     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00002063 close to branch
 * 59 LDAF_LHU   86 JAL_2      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00002067 close to jalr
 * 5a OR_1       e0 DIVU_1     00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    db jFault_1   00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       d7 ECALL_3    00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIV_8      66 SW_1       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 5f DIV_9      f3 aF_SW      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 60 SW_1       1e aFault_1   00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00003003 close to load
 * 61 SW_E1SWE   c7 QINT_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 DIV_12     d0 ECALL_1    00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              0000300b close to ij
 * 63 DIV_13     4e eILL0b     00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      bb SH_2       00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 LHU_2      c0 DIV_D      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 67 aFaultc    15 condb_4    00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 68 Fetchu     aa DIV_6      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00003023 close to store
 * 69 eFetchu    7f unx7f      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 6a DIV_4      d5 Fetch2u    00000000000000001100000011101000110000        ~abs(divisor) to yy                               40003023 close to store
 * 6b DIV_5      eb LH_3       00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_1      51 LDAF_LW    00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40003033 sloppy sltu    
 * 6f DIV_2      f0 LBU_2      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 70 IJT_2      ffffffff (null)     00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * 71 MRET_5     41 JALR_1     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * 72 IJT_4      3a SRxI_1     00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 73 QINT_1     29 XOR_1      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 74 aF_SW_2       (use dinx) 00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 75 MUL_2         (use dinx) 00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 76 IJT_3      f1 aFaulte    00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 77 MULHU_5    f1 aFaulte    00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 78 DIV_E      94 SW_E4      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003063 close to branch
 * 79 DIV_F      37 ECALL_2    00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00003067 close to jalr
 * 7a SLTIX_1    c0 DIV_D      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    db jFault_1   00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e DIVU_5     11 AND_1      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 7f LB_6          (use dinx) 00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 80 LBU_0      ef WFI_5      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 SH_1       37 ECALL_2    00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        0000400b close to ij
 * 83 SW_E1SWH   6e DIV_C      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     be IJ_1       00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 DIV_10     a5 MRET_3     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 87 DIV_11        (use dinx) 01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 88 DIV_14     86 JAL_2      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00004023 close to store
 * 89 DIV_15     aa DIV_6      00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 8a ECAL_RET   3a SRxI_1     00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40004023 close to store
 * 8b EBRKWFI1   aa DIV_6      00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      6e DIV_C      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e IJ_1       fe ILLe       00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   40004033 sloppy xor     
 * 8f IJT_1      31 SLTX_1     00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 90 aFault_2   a5 MRET_3     00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 91 (null)     14 condb_3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 92 (null)     a5 MRET_3     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 93 (null)     16 condb_5    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 94 DIV_6      a5 MRET_3     00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * 95 EBREAK_2   13 condb_2    00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * 96 MRET_4     52 LH_1       00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * 97 CSRRW_3    15 condb_4    00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a DIVU_3     a5 MRET_3     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 9b DIVU_4        (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 9c ECALL_1    62 DIV_8      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00004073 close to csr/system 
 * 9d MRET_1     88 DIV_E      00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 9e LB_2       34 JAL_3      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 9f aFaultd    c0 DIV_D      00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * a0 LHU_0      58 DIV_A      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JAL_1      b7 IJ_3       00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * a2 eILL0c     7f unx7f      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000500b close to ij
 * a3 ECALL_3    aa DIV_6      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    0000500f close to fence
 * a4 SRxI_0     c8 DIV_7      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 JAL_3      96 SH_1       00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a6 Fetch      9c DIV_10     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * a7 eFetch     e2 MUL_1      00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * a8 MUL_1      6a MULH_1     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00005023 close to store
 * a9 MUL_3      a5 MRET_3     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * aa StdIncPc   d0 ECALL_1    10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    40005023 close to store
 * ab aFault     30 SLTIX_2    00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * ac _L0xac     cb QINT_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     56 LH_4       00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     cb QINT_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SLLI_1     71 aFaultc    00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * b0 (null)     b4 eFetch3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b1 (null)     14 condb_3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b2 (null)     a6 ECAL_RET   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b3 (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b4 CSRRW_4    ea MULHU_5    00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b5 eFetch3    17 condb_5t   0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * b6 SH_3       30 SLTIX_2    00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b7 ECALL_5    53 LDAF_LH    00110010000000000000101011001100100110        Q = 8                                             00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SLLI_2     ffffffff (null)     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00005067 close to jalr
 * ba eILL0a     3a SRxI_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bb WFI_5      b6 ECALL_5    00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * bc CSRRWI_0   db jFault_1   00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ECALL_2    a6 ECAL_RET   00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * be LBU_2      45 WFI_3      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * bf aFaulte    70 LHU_2      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * c0 SW_2       78 DIV_4      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00006003 close to load
 * c1 aF_SW      76 Fetchu     00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * c2 Fetch2     d2 LB_2       00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     0000600b close to ij
 * c3 jFault     7e NMI_1      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000600f close to fence
 * c4 ORI_0      57 LH_5       00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MULHU_7    e8 MUL_2      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * c6 WFI_1      da LDAF_a     00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * c7 EBREAK_1   33 unx33      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * c8 SRxI_1     5e LHU_1      00000000000000000100101001101100001xx1        Register to shift to Q                            00006023 close to store
 * c9 SRxI_2     36 SLLI_2     00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * ca SLL_1      9a ECALL_6    00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              40006023 close to store
 * cb SRx_1      aa DIV_6      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      6e DIV_C      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce JALR_1     fe ILLe       00010010000000000000000011101100100110        Q=1                                               40006033 sloppy or      
 * cf WFI_3      27 OR_2       00010010000000000000101011101100100110        More check offset                                 00000000 
 * d0 DIV_7      bd IJ_4       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d1 MRET_2     d1 MRET_1     00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * d2 DIVU_2     09 LB_5       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d3 _LCSRRCI_1 41 JALR_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d4 LH_3       14 condb_3    00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * d5 MULH_2        (use dinx) 00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * d6 WFI_2      fe ILLe       00010010000000000000101011101100100110        Check offset                                      00000000 
 * d7 SB_3       35 SLLI_1     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 ILL_1      1e aFault_1   00000000000000001101101011100x00001xx0        Store PC to mepc                                  00006067 close to jalr
 * da ILL_2      12 straddle   00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * db CSRRW_1    14 condb_3    00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * dc CSRRSI_0   db jFault_1   00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd LH_4       74 unx74      00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * de LH_5       c2 DIVU_3     00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * df SB_1       c2 DIVU_3     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * e0 SB_2       d2 LB_2       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00007003 close to load
 * e1 MULHU_3    3d SRxI_2     00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * e2 EBRKWFI2   75 unx75      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         0000700b close to ij
 * e3 WFI_4      3a SRxI_1     00000010000000000000001011x01001xxxxx0        Prepare read PC                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 MULH_1     32 JAL_1      00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * e6 SB_4       a6 ECAL_RET   00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * e7 DIV_C      41 JALR_1     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * e8 MRET_6     a8 DIV_3      00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00007023 close to store
 * e9 LBU_3      72 LBU_3      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * ea unalignd   4b CSRRW_2    00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                40007023 close to store
 * eb SB_5       dd aF_SW_1    00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     56 LH_4       00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee NMI_1      fe ILLe       00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40007033 sloppy and     
 * ef LBU_1      a6 ECAL_RET   00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * f0 MRET_7     e9 IJT_3      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f1 Fetch2u    41 JALR_1     0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f2 MULH_3     aa DIV_6      00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * f3 LDAF_a     55 aFaultb    00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * f4 (null)     b5 SH_3       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f5 (null)     54 LH_2       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f6 (null)     d6 eILL0c     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     95 SW_E3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 JAL_2      f2 SW_2       10110000000000000100110011000x00100110        Return address to TRG                             00007067 close to jalr
 * fa _LCSRRS_1  cf MRET_7     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * fb ILL_3      e6 StdIncPc   00000010000000000000101011101100100110        Q = 1                                             00000000 
 * fc CSRRCI_0   db jFault_1   00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      ee eILL0a     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       d9 MULH_3     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     73 unalignd   00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0800, used ffff, inputs 66
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       6a MULH_1     00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     7e NMI_1      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     7e NMI_1      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     a5 MRET_3     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       59 DIV_B      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     a5 MRET_3     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       b6 ECALL_5    00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      78 DIV_4      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     7e NMI_1      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    59 DIV_B      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       7e NMI_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    76 Fetchu     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     9c DIV_10     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       7e NMI_1      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   68 DIV_12     00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     7e NMI_1      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       c6 IJT_4      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    d2 LB_2       00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      7e NMI_1      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      95 SW_E3      00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     7e NMI_1      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     92 LDAF_3     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     60 MULHU_3    00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     60 MULHU_3    00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      9a ECALL_6    00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     aa DIV_6      00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     7e NMI_1      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      7e NMI_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      b6 ECALL_5    00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       76 Fetchu     00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   93 SW_E2      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     75 unx75      00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    7e NMI_1      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     97 SW_E1SWH   00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      92 LDAF_3     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    96 SH_1       00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     a7 EBRKWFI1   00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    f2 SW_2       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       a9 ILL_4      00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 CSRRW_2    9f SH_5       00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 47 NMI_2      b9 DIV_e      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     46 ILL_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    c9 MRET_2     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e LDAF_2     fe ILLe       00110000110000001110001011000x00100110        Store 4 to mcause                                 40002033 sloppy slt     
 * 4f SW_E4      7e NMI_1      00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 50 DIV_4      7e NMI_1      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 51 DIV_5      e8 MUL_2      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 52 DIV_1      1e aFault_1   00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 53 DIV_2      e8 MUL_2      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 54 DIV_E      f3 aF_SW      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 55 DIV_F      41 JALR_1     00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 56 ECALL_6    a3 DIV_15     00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 57 ILL_4      59 DIV_B      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 58 DIVU_5     af MRET_4     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00002063 close to branch
 * 59 LB_6       62 DIV_8      00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00002067 close to jalr
 * 5a OR_1       a6 ECAL_RET   00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       f6 WFI_1      00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e aF_SW_3    3e SLL_1      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 5f QINT_2     e8 MUL_2      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 60 SH_1       10 SUB_1      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00003003 close to load
 * 61 SW_E1SWH   8f ILL_3      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 DIV_10     e0 DIVU_1     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    0000300b close to ij
 * 63 DIV_11     26 OR_1       01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      83 DIV_2      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 DIV_14     88 DIV_E      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00000000 
 * 67 DIV_15     bb SH_2       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 68 ECAL_RET   7e NMI_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00003023 close to store
 * 69 EBRKWFI1   59 DIV_B      00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 6a IJ_1       f4 Fetch2     00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   40003023 close to store
 * 6b IJT_1      b3 unxb3      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIVU_3     d3 aFaultd    00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           40003033 sloppy sltu    
 * 6f DIVU_4     e5 aF_SW_2    01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 70 ECALL_1    ffffffff (null)     00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 71 MRET_1     41 JALR_1     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 72 LB_2       3a SRxI_1     00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 73 aFaultd    29 XOR_1      00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 74 eILL0c        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 ECALL_3       (use dinx) 00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 76 Fetch      e6 StdIncPc   00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 77 eFetch     e6 StdIncPc   00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 78 MUL_1      c3 DIVU_4     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00003063 close to branch
 * 79 MUL_3      c2 DIVU_3     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00003067 close to jalr
 * 7a SLTIX_1    88 DIV_E      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e StdIncPc   47 ILL_2      10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 7f aFault        (use dinx) 00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 80 LBU_0      b5 SH_3       00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 eILL0a     c2 DIVU_3     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000400b close to ij
 * 83 WFI_5      52 LH_1       00110100000010001010110111000100100110        IncPC, OpFetch                                    0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     86 JAL_2      00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 LBU_2      91 LDAF_2     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 87 aFaulte       (use dinx) 00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 88 SW_2       62 DIV_8      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00004023 close to store
 * 89 aF_SW      7e NMI_1      00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 8a Fetch2     3a SRxI_1     00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     40004023 close to store
 * 8b jFault     7e NMI_1      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      52 LH_1       01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e WFI_1      fe ILLe       00110010000000000000000011001100100110 WFI    To check offset                                   40004033 sloppy xor     
 * 8f EBREAK_1   57 LH_5       00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 90 JAL_1      91 LDAF_2     00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 91 JAL_3      ba LHU_3      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 92 SLLI_1     91 LDAF_2     00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 93 SLLI_2     bd IJ_4       00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 94 ECALL_2    91 LDAF_2     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 95 MULHU_7    4f MRET_8     00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 96 SRxI_1     d4 aFault_2   00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 97 SRxI_2     bb SH_2       00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a SLL_1      91 LDAF_2     00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 9b SRx_1         (use dinx) 00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 9c JALR_1     36 SLLI_2     00010010000000000000000011101100100110        Q=1                                               00004073 close to csr/system 
 * 9d WFI_3      66 SW_1       00010010000000000000101011101100100110        More check offset                                 00000000 
 * 9e ILL_1      bf IJT_1      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 9f ILL_2      88 DIV_E      00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 CSRRW_1    d1 MRET_1     00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * a2 LH_4       59 DIV_B      00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      0000500b close to ij
 * a3 LH_5       7e NMI_1      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               0000500f close to fence
 * a4 SRxI_0     96 SH_1       00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SB_1       c8 DIV_7      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * a6 SB_2       70 LHU_2      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * a7 MULHU_3    a8 DIV_3      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * a8 EBRKWFI2   50 LW_1       00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00005023 close to store
 * a9 WFI_4      91 LDAF_2     00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * aa MULH_1     e0 DIVU_1     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              40005023 close to store
 * ab SB_4       56 LH_4       00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * ac _L0xac     9b unx9b      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     eb LH_3       00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     9b unx9b      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af DIV_C      da LDAF_a     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b0 MRET_6     ca DIVU_2     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * b1 LBU_3      ba LHU_3      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * b2 unalignd   76 Fetchu     00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * b3 SB_5          (use dinx) 00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b4 NMI_1      b2 CSRRW_4    00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * b5 LBU_1      be IJ_1       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * b6 JAL_2      56 LH_4       10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * b7 _LCSRRS_1  d5 Fetch2u    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 ILL_3      ffffffff (null)     00000010000000000000101011101100100110        Q = 1                                             00005067 close to jalr
 * ba LDAF_3     3a SRxI_1     00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * bb SW_E2      d0 ECALL_1    00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * bc CSRRWI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SW_E3      76 Fetchu     00110010000000000000101111001100100110        Q = 3                                             00000000 
 * be SH_4       45 WFI_3      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * bf SH_5       d9 MULH_3     00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * c0 ECALL_4    54 LH_2       00110010000000000000101011001100100110        Q = 4                                             00006003 close to load
 * c1 MRET_3     f1 aFaulte    00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * c2 DIV_3      e2 MUL_1      01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        0000600b close to ij
 * c3 DIV_6      58 DIV_A      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            0000600f close to fence
 * c4 ORI_0      ee eILL0a     00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 EBREAK_2   b0 CSRRW_3    00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * c6 aFault_2   9f SH_5       00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * c7 (null)     5f LDAF_LHU   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c8 MRET_4     32 JAL_1      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00006023 close to store
 * c9 CSRRW_3    c1 IJT_2      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * ca CSRRW_4    6e DIV_C      00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      40006023 close to store
 * cb eFetch3    7e NMI_1      0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      52 LH_1       01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce (null)     fe ILLe       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   40006033 sloppy or      
 * cf (null)     13 condb_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d0 SH_3       94 SW_E4      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d1 ECALL_5    e1 ORI_1      00110010000000000000101011001100100110        Q = 8                                             00000000 
 * d2 IJ_3       09 LB_5       00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * d3 DIV_e      41 JALR_1     00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * d4 SH_2       ba LHU_3      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d5 IJ_4          (use dinx) 00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * d6 (null)     fe ILLe       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d7 (null)     c0 DIV_D      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 IJT_2      10 SUB_1      00000000000000001100101011101000110000        Read word is to be masked with ~1u                00006067 close to jalr
 * da MRET_5     4e eILL0b     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * db IJT_4      ba LHU_3      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * dc CSRRSI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd QINT_1     ef WFI_5      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * de (null)     8a DIVU_5     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * df (null)     8a DIVU_5     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e0 DIV_7      e2 MUL_1      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00007003 close to load
 * e1 MRET_2     3d SRxI_2     00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * e2 DIVU_2     f0 LBU_2      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            0000700b close to ij
 * e3 _LCSRRCI_1 3a SRxI_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 MRET_7     5e LHU_1      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * e6 Fetch2u    76 Fetchu     0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * e7 MULH_3     41 JALR_1     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * e8 LDAF_a     78 DIV_4      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00007023 close to store
 * e9 jFault_1   db jFault_1   00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * ea aF_SW_1    4b CSRRW_2    00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      40007023 close to store
 * eb DIVU_1     a2 DIV_14     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     eb LH_3       00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee ORI_1      fe ILLe       00000010000000000000000011101100001xx0        Q = RS1                                           40007033 sloppy and     
 * ef aF_SW_2    76 Fetchu     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * f0 MUL_2      b1 aF_SW_3    00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * f1 IJT_3      41 JALR_1     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * f2 MULHU_5    7e NMI_1      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * f3 LH_3       ea MULHU_5    00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f4 MULH_2     cb QINT_2     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * f5 WFI_2      e9 IJT_3      00010010000000000000101011101100100110        Check offset                                      00000000 
 * f6 SB_3       f5 jFault     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f7 (null)     c5 MRET_5     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)     e7 aFault     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00007067 close to jalr
 * fa (null)     9d DIV_11     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     ab EBREAK_2   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      b4 eFetch3    00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       9e SH_4       00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     dd aF_SW_1    00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0200, used ffff, inputs 69
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       8e _LCSRRS_1  00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       86 JAL_2      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     96 SH_1       00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     96 SH_1       00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     b0 CSRRW_3    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       6b SB_4       00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     b0 CSRRW_3    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       c0 DIV_D      00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      94 SW_E4      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     96 SH_1       00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    6b SB_4       00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     4e eILL0b     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       96 SH_1       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    92 LDAF_3     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     a1 ECALL_4    00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       96 SH_1       00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     62 DIV_8      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   82 DIV_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     96 SH_1       00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       c1 IJT_2      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    e0 DIVU_1     00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      96 SH_1       00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      76 Fetchu     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     96 SH_1       00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     70 LHU_2      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      52 LH_1       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     6e DIV_C      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     6e DIV_C      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    5d SB_2       00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      81 unx81      00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     b5 SH_3       00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     96 SH_1       00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      96 SH_1       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   56 LH_4       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      c0 DIV_D      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       92 LDAF_3     00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   72 LBU_3      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     91 LDAF_2     00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    96 SH_1       00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     7d unx7d      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     62 DIV_8      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    aa DIV_6      00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      70 LHU_2      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    7a SB_5       00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 CSRRW_2    1d ORI_2      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 42 aFault_1   b2 CSRRW_4    00110010000000000000101011001100100110        Q = 4                                             0000200b close to ij
 * 43 NMI_2      77 eFetchu    00000000110000001111010011101000110000        mtval = 0.                                        0000200f close to fence
 * 44 SLTI_0     56 LH_4       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 LDAF_2     b4 eFetch3    00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 46 IJ_2       a9 ILL_4      00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 47 SW_E4      c6 IJT_4      00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     41 JALR_1     00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    da LDAF_a     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      60 MULHU_3    00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   5a SB_1       00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e Fetchu     fe ILLe       00000010000000000000001111101010110000  Fr10u Read and latch instruction                        40002033 sloppy slt     
 * 4f eFetchu    96 SH_1       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 50 OR_1       96 SH_1       00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 51 ECALL_6    fb SB_3       00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 52 OR_2       1e aFault_1   00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 53 ILL_4      fb SB_3       00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 54 XOR_1      e1 ORI_1      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 55 aF_SW_3    42 MULHU_2    00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 56 SLTIX_1    af MRET_4     00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 57 QINT_2     6b SB_4       00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 58 DIV_4      b7 IJ_3       00000000000000001100000011101000110000        ~abs(divisor) to yy                               00002063 close to branch
 * 59 DIV_5      78 DIV_4      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00002067 close to jalr
 * 5a MULHU_1    b1 aF_SW_3    00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 5b _L0x5b     62 DIV_8      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    aa DIV_6      00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLTIX_2    e7 aFault     00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 5e DIV_1      3e SLL_1      00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 5f DIV_2      fb SB_3       00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 60 SLTX_1     10 SUB_1      00000010000000000000111111101100000xx0        ~rs2 to Q                                         00003003 close to load
 * 61 jFault_1   a7 EBRKWFI1   00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 62 JAL_1      ef WFI_5      00010000000000001100001011101000100000        Target adr to yy                                  0000300b close to ij
 * 63 aF_SW_1    26 OR_1       00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      0000300f close to fence
 * 64 SLTIU_0    56 LH_4       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 DIVU_1     9b unx9b      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 66 JAL_3      9e SH_4       00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 67 ORI_1      c9 MRET_2     00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 68 DIV_E      96 SH_1       01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003023 close to store
 * 69 DIV_F      6b SB_4       00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 6a DIVU_5     e3 MUL_3      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               40003023 close to store
 * 6b LB_6       bd IJ_4       00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 6c SLTU_0     60 MULHU_3    00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    5a SB_1       00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e SH_1       e2 MUL_1      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        40003033 sloppy sltu    
 * 6f SW_E1SWH   f6 WFI_1      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 70 SLLI_1     ffffffff (null)     00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 71 aF_SW_2    42 MULHU_2    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 72 SLLI_2     3a SRxI_1     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 73 MUL_2      29 XOR_1      00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 74 ECALL_2       (use dinx) 00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 75 IJT_3         (use dinx) 00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 76 MULHU_7    f9 MULH_2     00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 77 MULHU_5    f9 MULH_2     00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 78 DIV_10     d4 aFault_2   01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00003063 close to branch
 * 79 DIV_11     d2 LB_2       01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00003067 close to jalr
 * 7a SRxI_1     9e SH_4       00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 7b _L0x7b     62 DIV_8      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    aa DIV_6      00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SRxI_2        (use dinx) 00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 7e DIV_14     43 MULHU_4    00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00000000 
 * 7f DIV_15        (use dinx) 00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 80 LBU_0      bf IJT_1      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLL_1         (use dinx) 00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 82 ECAL_RET   d2 LB_2       00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000400b close to ij
 * 83 EBRKWFI1   5e LHU_1      00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SRx_1      9c DIV_10     00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 86 IJ_1       66 SW_1       00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * 87 IJT_1         (use dinx) 00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 88 DIVU_3     78 DIV_4      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00004023 close to store
 * 89 DIVU_4     96 SH_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 8a ECALL_1    3a SRxI_1     00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40004023 close to store
 * 8b MRET_1     96 SH_1       00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 8c XOR_0      54 LH_2       00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      5e LHU_1      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e LB_2       fe ILLe       00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     40004033 sloppy xor     
 * 8f aFaultd    53 LDAF_LH    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 90 eILL0c     66 SW_1       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 91 ECALL_3    c8 DIV_7      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 92 Fetch      66 SW_1       00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 93 eFetch     ca DIVU_2     00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 94 MUL_1      66 SW_1       00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 95 MUL_3      47 ILL_2      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 96 StdIncPc   e6 StdIncPc   10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 97 aFault     c9 MRET_2     00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a eILL0a     66 SW_1       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 9b WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 9c LBU_2      36 SLLI_2     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00004073 close to csr/system 
 * 9d aFaulte    7e NMI_1      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 9e SW_2       ce _LCSRRCI_1 00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 9f aF_SW      9e SH_4       00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JALR_1     df eFetch     00010010000000000000000011101100100110        Q=1                                               00000000 
 * a2 Fetch2     6b SB_4       00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     0000500b close to ij
 * a3 jFault     96 SH_1       00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000500f close to fence
 * a4 SRxI_0     7a SB_5       00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 WFI_3      d9 MULH_3     00010010000000000000101011101100100110        More check offset                                 00000000 
 * a6 WFI_1      8a DIVU_5     00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * a7 EBREAK_1   b3 unxb3      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * a8 ILL_1      58 DIV_A      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00005023 close to store
 * a9 ILL_2      66 SW_1       00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * aa CSRRW_1    ef WFI_5      00010010000000000000000011101100100110        Construct PC storage adr                          40005023 close to store
 * ab LH_4       51 LDAF_LW    00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * ac _L0xac     85 LBU_1      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     65 WFI_4      00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     85 LBU_1      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af LH_5       ea MULHU_5    00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * b0 SB_1       db jFault_1   00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * b1 SB_2       c8 DIV_7      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * b2 MULHU_3    92 LDAF_3     00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * b3 EBRKWFI2      (use dinx) 00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * b4 WFI_4      bb SH_2       00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * b5 MULH_1     cb QINT_2     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * b6 SB_4       51 LDAF_LW    00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b7 DIV_C      e8 MUL_2      00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MRET_6     ffffffff (null)     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00005067 close to jalr
 * ba LBU_3      3a SRxI_1     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * bb unalignd   de Fetch      00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * bc CSRRWI_0   aa DIV_6      00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SB_5       92 LDAF_3     00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * be NMI_1      46 ILL_1      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * bf LBU_1      e9 IJT_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * c0 JAL_2      68 DIV_12     10110000000000000100110011000x00100110        Return address to TRG                             00006003 close to load
 * c1 aFault_2   75 unx75      00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * c2 _LCSRRS_1  f2 SW_2       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000600b close to ij
 * c3 (null)     6a MULH_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000600f close to fence
 * c4 ORI_0      67 SW_E1SWE   00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     b9 DIV_e      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c6 ILL_3      a9 ILL_4      00000010000000000000101011101100100110        Q = 1                                             00000000 
 * c7 (null)     57 LH_5       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c8 LDAF_3     32 JAL_1      00000000000000001101100111100x00001xx0        PC to mepc                                        00006023 close to store
 * c9 SW_E2      d0 ECALL_1    00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * ca SW_E3      88 DIV_E      00110010000000000000101111001100100110        Q = 3                                             40006023 close to store
 * cb SH_4       96 SH_1       00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * cc OR_0       50 LW_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      5e LHU_1      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce SH_5       fe ILLe       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     40006033 sloppy or      
 * cf ECALL_4    13 condb_2    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d0 MRET_3     74 unx74      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * d1 (null)     f0 LBU_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d2 DIV_3      09 LB_5       01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * d3 (null)     42 MULHU_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d4 DIV_6      c8 DIV_7      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * d5 (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d6 EBREAK_2   fe ILLe       00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * d7 (null)     cf MRET_7     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MRET_4     10 SUB_1      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00006067 close to jalr
 * da CSRRW_3    45 WFI_3      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * db CSRRW_4    c8 DIV_7      00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * dc CSRRSI_0   aa DIV_6      00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd eFetch3    71 aFaultc    0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * de SH_3       a2 DIV_14     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * df ECALL_5    a2 DIV_14     00110010000000000000101011001100100110        Q = 8                                             00000000 
 * e0 IJ_3       f2 SW_2       00010010000000000000110011101100100110        Construct Q = 1                                   00007003 close to load
 * e1 LH_3       3d SRxI_2     00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * e2 DIV_e      73 unalignd   00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      0000700b close to ij
 * e3 MULH_2     3a SRxI_1     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 WFI_2      55 aFaultb    00010010000000000000101011101100100110        Check offset                                      00000000 
 * e6 SH_2       92 LDAF_3     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * e7 SB_3       42 MULHU_2    00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e8 IJ_4       94 SW_E4      00000100000010001010110111100100011xx0        Mask and use as PC                                00007023 close to store
 * e9 IJT_2      eb LH_3       00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * ea MRET_5     4b CSRRW_2    00000010000000000000000011101100010xx0        ~302                                              40007023 close to store
 * eb IJT_4      ab EBREAK_2   00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     65 WFI_4      00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee QINT_1     fe ILLe       00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40007033 sloppy and     
 * ef DIV_7      92 LDAF_3     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f0 MRET_2     ba LHU_3      00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * f1 (null)     42 MULHU_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f2 DIVU_2     96 SH_1       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f3 (null)     63 DIV_9      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 _LCSRRCI_1 dd aF_SW_1    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f5 (null)     61 EBRKWFI2   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f6 MRET_7     e5 aF_SW_2    00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f7 (null)     d6 eILL0c     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 Fetch2u    fa WFI_2      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00007067 close to jalr
 * fa MULH_3     a5 MRET_3     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * fb LDAF_a     b6 ECALL_5    00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * fc CSRRCI_0   aa DIV_6      00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      be IJ_1       00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       a8 DIV_3      00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     ee eILL0a     00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0200, used ffff, inputs 6a
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       7e NMI_1      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       70 LHU_2      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     8a DIVU_5     00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     8a DIVU_5     00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     b0 CSRRW_3    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       5f LDAF_LHU   00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     b0 CSRRW_3    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       c0 DIV_D      00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      88 DIV_E      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     8a DIVU_5     00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    5f LDAF_LHU   00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     4e eILL0b     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       8a DIVU_5     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    86 JAL_2      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     a6 ECAL_RET   00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       8a DIVU_5     00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     9a ECALL_6    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   6e DIV_C      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     8a DIVU_5     00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       c2 DIVU_3     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    e0 DIVU_1     00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      8a DIVU_5     00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      9f SH_5       00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     8a DIVU_5     00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     9c DIV_10     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     60 MULHU_3    00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     60 MULHU_3    00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      a3 DIV_15     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     b5 SH_3       00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     8a DIVU_5     00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      8a DIVU_5     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      c0 DIV_D      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       86 JAL_2      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   9d DIV_11     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     83 DIV_2      00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    8a DIVU_5     00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     a2 DIV_14     00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     9a ECALL_6    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    aa DIV_6      00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      9c DIV_10     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    a1 ECALL_4    00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 CSRRW_2    b2 CSRRW_4    00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    0000200b close to ij
 * 43 NMI_2      77 eFetchu    00000000110000001111010011101000110000        mtval = 0.                                        0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       b4 eFetch3    00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 LDAF_2     a9 ILL_4      00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 47 SW_E4      c5 MRET_5     00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     42 MULHU_2    00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    da LDAF_a     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e Fetchu     fe ILLe       00000010000000000000001111101010110000  Fr10u Read and latch instruction                        40002033 sloppy slt     
 * 4f eFetchu    8a DIVU_5     00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 50 DIV_4      8a DIVU_5     00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 51 DIV_5      fb SB_3       00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 52 ECALL_6    1e aFault_1   00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 53 ILL_4      fb SB_3       00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 54 DIV_1      e2 MUL_1      00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 55 DIV_2      41 JALR_1     00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 56 aF_SW_3    af MRET_4     00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 57 QINT_2     5f LDAF_LHU   00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 58 DIV_E      b7 IJ_3       01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00002063 close to branch
 * 59 DIV_F      68 DIV_12     00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00002067 close to jalr
 * 5a OR_1       b1 aF_SW_3    00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     9a ECALL_6    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    aa DIV_6      00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       e7 aFault     00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIVU_5     3e SLL_1      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 5f LB_6       fb SB_3       00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 60 SH_1       10 SUB_1      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00003003 close to load
 * 61 SW_E1SWH   97 SW_E1SWH   00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 jFault_1   ef WFI_5      00010000000000001110001011100x00100110        Store 1 to mcause                                 0000300b close to ij
 * 63 aF_SW_1    26 OR_1       00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      8f ILL_3      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 DIVU_1     92 LDAF_3     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 67 ORI_1      c9 MRET_2     00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 68 DIV_10     8a DIVU_5     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00003023 close to store
 * 69 DIV_11     5f LDAF_LHU   01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 6a DIV_14     e3 MUL_3      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 40003023 close to store
 * 6b DIV_15     bd IJ_4       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e ECAL_RET   e1 ORI_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40003033 sloppy sltu    
 * 6f EBRKWFI1   f5 jFault     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 70 IJ_1       ffffffff (null)     00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * 71 IJT_1      41 JALR_1     00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 72 aF_SW_2    3a SRxI_1     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 73 MUL_2      29 XOR_1      00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 74 DIVU_3        (use dinx) 00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 75 DIVU_4        (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 76 IJT_3      f9 MULH_2     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 77 MULHU_5    f9 MULH_2     00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 78 ECALL_1    d4 aFault_2   00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00003063 close to branch
 * 79 MRET_1     d1 MRET_1     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00003067 close to jalr
 * 7a SLTIX_1    92 LDAF_3     00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     9a ECALL_6    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    aa DIV_6      00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e LB_2       43 MULHU_4    00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 7f aFaultd       (use dinx) 00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 80 LBU_0      bf IJT_1      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 eILL0c     d1 MRET_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000400b close to ij
 * 83 ECALL_3    54 LH_2       00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     90 NMI_2      00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 Fetch      9b unx9b      00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 87 eFetch        (use dinx) 00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 88 MUL_1      68 DIV_12     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00004023 close to store
 * 89 MUL_3      8a DIVU_5     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 8a StdIncPc   3a SRxI_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    40004023 close to store
 * 8b aFault     8a DIVU_5     00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      54 LH_2       01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e eILL0a     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40004033 sloppy xor     
 * 8f WFI_5      53 LDAF_LH    00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 90 LBU_2      9b unx9b      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 91 aFaulte    c8 DIV_7      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 92 SW_2       9b unx9b      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 93 aF_SW      ca DIVU_2     00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 94 Fetch2     9b unx9b      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 95 jFault     47 ILL_2      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 96 WFI_1      e5 aF_SW_2    00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 97 EBREAK_1   c9 MRET_2     00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a JAL_1      9b unx9b      00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 9b JAL_3         (use dinx) 00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 9c SLLI_1     36 SLLI_2     00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00004073 close to csr/system 
 * 9d SLLI_2     6a MULH_1     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 9e ECALL_2    ce _LCSRRCI_1 00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 9f MULHU_7    92 LDAF_3     00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SRxI_1     df eFetch     00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * a2 SRxI_2     5f LDAF_LHU   00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                0000500b close to ij
 * a3 SLL_1      8a DIVU_5     00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              0000500f close to fence
 * a4 SRxI_0     a1 ECALL_4    00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SRx_1      d9 MULH_3     00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * a6 JALR_1     78 DIV_4      00010010000000000000000011101100100110        Q=1                                               00000000 
 * a7 WFI_3      b3 unxb3      00010010000000000000101011101100100110        More check offset                                 00000000 
 * a8 ILL_1      50 LW_1       00000000000000001101101011100x00001xx0        Store PC to mepc                                  00005023 close to store
 * a9 ILL_2      9b unx9b      00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * aa CSRRW_1    ef WFI_5      00010010000000000000000011101100100110        Construct PC storage adr                          40005023 close to store
 * ab LH_4       52 LH_1       00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * ac _L0xac     a5 MRET_3     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     66 SW_1       00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     a5 MRET_3     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af LH_5       ea MULHU_5    00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * b0 SB_1       db jFault_1   00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * b1 SB_2       c8 DIV_7      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * b2 MULHU_3    86 JAL_2      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * b3 EBRKWFI2      (use dinx) 00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * b4 WFI_4      bb SH_2       00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * b5 MULH_1     cb QINT_2     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * b6 SB_4       52 LH_1       00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b7 DIV_C      e8 MUL_2      00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MRET_6     ffffffff (null)     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00005067 close to jalr
 * ba LBU_3      3a SRxI_1     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * bb unalignd   de Fetch      00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * bc CSRRWI_0   aa DIV_6      00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SB_5       86 JAL_2      00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * be NMI_1      45 WFI_3      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * bf LBU_1      e9 IJT_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * c0 JAL_2      58 DIV_A      10110000000000000100110011000x00100110        Return address to TRG                             00006003 close to load
 * c1 _LCSRRS_1  76 Fetchu     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * c2 aFault_2   f1 aFaulte    00010000110000001110001011100x00100110        Store 5 to mcause                                 0000600b close to ij
 * c3 (null)     5e LHU_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000600f close to fence
 * c4 ORI_0      67 SW_E1SWE   00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 ILL_3      b9 DIV_e      00000010000000000000101011101100100110        Q = 1                                             00000000 
 * c6 (null)     a9 ILL_4      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c7 (null)     57 LH_5       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c8 LDAF_3     32 JAL_1      00000000000000001101100111100x00001xx0        PC to mepc                                        00006023 close to store
 * c9 SW_E2      d0 ECALL_1    00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * ca SW_E3      74 unx74      00110010000000000000101111001100100110        Q = 3                                             40006023 close to store
 * cb SH_4       8a DIVU_5     00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      54 LH_2       01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce SH_5       fe ILLe       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     40006033 sloppy or      
 * cf ECALL_4    13 condb_2    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d0 MRET_3     9e SH_4       00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * d1 DIV_3      f0 LBU_2      01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * d2 (null)     09 LB_5       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d3 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d4 DIV_6      c8 DIV_7      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * d5 EBREAK_2      (use dinx) 00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * d6 (null)     fe ILLe       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d7 (null)     cf MRET_7     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MRET_4     10 SUB_1      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00006067 close to jalr
 * da CSRRW_3    46 ILL_1      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * db CSRRW_4    c8 DIV_7      00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * dc CSRRSI_0   aa DIV_6      00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd eFetch3    72 LBU_3      0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * de SH_3       94 SW_E4      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * df ECALL_5    94 SW_E4      00110010000000000000101011001100100110        Q = 8                                             00000000 
 * e0 IJ_3       f1 aFaulte    00010010000000000000110011101100100110        Construct Q = 1                                   00007003 close to load
 * e1 DIV_e      3d SRxI_2     00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * e2 LH_3       73 unalignd   00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 0000700b close to ij
 * e3 MULH_2     3a SRxI_1     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SH_2       56 LH_4       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * e6 WFI_2      86 JAL_2      00010010000000000000101011101100100110        Check offset                                      00000000 
 * e7 SB_3       41 JALR_1     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e8 IJ_4       88 DIV_E      00000100000010001010110111100100011xx0        Mask and use as PC                                00007023 close to store
 * e9 IJT_2      eb LH_3       00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * ea MRET_5     4b CSRRW_2    00000010000000000000000011101100010xx0        ~302                                              40007023 close to store
 * eb IJT_4      ab EBREAK_2   00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     66 SW_1       00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee QINT_1     fe ILLe       00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40007033 sloppy and     
 * ef DIV_7      86 JAL_2      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f0 MRET_2     ba LHU_3      00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * f1 DIVU_2     41 JALR_1     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f2 (null)     8a DIVU_5     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f3 (null)     63 DIV_9      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 _LCSRRCI_1 dd aF_SW_1    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f5 MRET_7     62 DIV_8      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f6 (null)     e6 StdIncPc   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     d5 Fetch2u    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 Fetch2u    fa WFI_2      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00007067 close to jalr
 * fa MULH_3     a7 EBRKWFI1   00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * fb LDAF_a     b6 ECALL_5    00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * fc CSRRCI_0   aa DIV_6      00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      be IJ_1       00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       a8 DIV_3      00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     ee eILL0a     00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 1000, used ffff, inputs 6c
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       6e DIV_C      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       66 SW_1       00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     7e NMI_1      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     7e NMI_1      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     a5 MRET_3     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       53 LDAF_LH    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     a5 MRET_3     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       b6 ECALL_5    00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      78 DIV_4      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     7e NMI_1      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    53 LDAF_LH    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       7e NMI_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    76 Fetchu     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     9c DIV_10     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       7e NMI_1      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   5e LHU_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     7e NMI_1      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       e0 DIVU_1     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    ce _LCSRRCI_1 00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      7e NMI_1      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      95 SW_E3      00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     7e NMI_1      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     92 LDAF_3     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      9a ECALL_6    00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     aa DIV_6      00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     7e NMI_1      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      7e NMI_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      b6 ECALL_5    00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       76 Fetchu     00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   93 SW_E2      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     75 unx75      00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    7e NMI_1      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     97 SW_E1SWH   00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      92 LDAF_3     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    96 SH_1       00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     a7 EBRKWFI1   00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    ee eILL0a     00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       a9 ILL_4      00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 DIV_4      9f SH_5       00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 47 DIV_5      b9 DIV_e      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     60 MULHU_3    00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    c7 QINT_1     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_1      fe ILLe       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40002033 sloppy slt     
 * 4f DIV_2      7e NMI_1      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 50 DIV_E      7e NMI_1      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 51 DIV_F      df eFetch     00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 52 DIVU_5     1e aFault_1   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 53 LB_6       df eFetch     00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 54 SH_1       ef WFI_5      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 55 SW_E1SWH   41 JALR_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 DIV_10     a3 DIV_15     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 57 DIV_11     53 LDAF_LH    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 58 DIV_14     af MRET_4     00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00002063 close to branch
 * 59 DIV_15     56 LH_4       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00002067 close to jalr
 * 5a OR_1       a6 ECAL_RET   00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       f6 WFI_1      00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e ECAL_RET   3e SLL_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 5f EBRKWFI1   df eFetch     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 60 CSRRW_2    10 SUB_1      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00003003 close to load
 * 61 NMI_2      8f ILL_3      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 62 LDAF_2     d6 eILL0c     00110000110000001110001011000x00100110        Store 4 to mcause                                 0000300b close to ij
 * 63 SW_E4      26 OR_1       00000000110000001110100111100x00101000        Store 6 to mcause                                 0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      83 DIV_2      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 IJ_1       88 DIV_E      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * 67 IJT_1      bb SH_2       00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 68 DIVU_3     7e NMI_1      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00003023 close to store
 * 69 DIVU_4     53 LDAF_LH    01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 6a ECALL_1    f4 Fetch2     00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40003023 close to store
 * 6b MRET_1     b3 unxb3      00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e LB_2       cf MRET_7     00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     40003033 sloppy sltu    
 * 6f aFaultd    db jFault_1   00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 70 ECALL_6    ffffffff (null)     00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 71 ILL_4      41 JALR_1     00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 72 aF_SW_3    3a SRxI_1     00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 73 QINT_2     29 XOR_1      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 74 eILL0c        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 ECALL_3       (use dinx) 00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 76 Fetch      dd aF_SW_1    00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 77 eFetch     dd aF_SW_1    00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 78 MUL_1      c3 DIVU_4     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00003063 close to branch
 * 79 MUL_3      c2 DIVU_3     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00003067 close to jalr
 * 7a SLTIX_1    88 DIV_E      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e StdIncPc   61 EBRKWFI2   10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 7f aFault        (use dinx) 00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 80 LBU_0      b5 SH_3       00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 eILL0a     c2 DIVU_3     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000400b close to ij
 * 83 WFI_5      4e eILL0b     00110100000010001010110111000100100110        IncPC, OpFetch                                    0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     86 JAL_2      00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 LBU_2      91 LDAF_2     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 87 aFaulte       (use dinx) 00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 88 SW_2       56 LH_4       00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00004023 close to store
 * 89 aF_SW      7e NMI_1      00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 8a Fetch2     3a SRxI_1     00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     40004023 close to store
 * 8b jFault     7e NMI_1      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      4e eILL0b     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e WFI_1      fe ILLe       00110010000000000000000011001100100110 WFI    To check offset                                   40004033 sloppy xor     
 * 8f EBREAK_1   71 aFaultc    00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 90 JAL_1      91 LDAF_2     00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 91 JAL_3      ba LHU_3      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 92 SLLI_1     91 LDAF_2     00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 93 SLLI_2     bd IJ_4       00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 94 ECALL_2    91 LDAF_2     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 95 MULHU_7    63 DIV_9      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 96 SRxI_1     d0 ECALL_1    00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 97 SRxI_2     bb SH_2       00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a SLL_1      91 LDAF_2     00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 9b SRx_1         (use dinx) 00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 9c JALR_1     36 SLLI_2     00010010000000000000000011101100100110        Q=1                                               00004073 close to csr/system 
 * 9d WFI_3      58 DIV_A      00010010000000000000101011101100100110        More check offset                                 00000000 
 * 9e ILL_1      bf IJT_1      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 9f ILL_2      88 DIV_E      00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 CSRRW_1    cb QINT_2     00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * a2 LH_4       53 LDAF_LH    00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      0000500b close to ij
 * a3 LH_5       7e NMI_1      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               0000500f close to fence
 * a4 SRxI_0     96 SH_1       00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SB_1       c6 IJT_4      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * a6 SB_2       6a MULH_1     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * a7 MULHU_3    a8 DIV_3      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * a8 EBRKWFI2   46 ILL_1      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00005023 close to store
 * a9 WFI_4      91 LDAF_2     00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * aa MULH_1     d6 eILL0c     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              40005023 close to store
 * ab SB_4       70 LHU_2      00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * ac _L0xac     9b unx9b      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     e7 aFault     00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     9b unx9b      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af DIV_C      d3 aFaultd    00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b0 MRET_6     c8 DIV_7      00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * b1 LBU_3      ba LHU_3      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * b2 unalignd   76 Fetchu     00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * b3 SB_5          (use dinx) 00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b4 NMI_1      b2 CSRRW_4    00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * b5 LBU_1      be IJ_1       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * b6 JAL_2      70 LHU_2      10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * b7 _LCSRRS_1  d1 MRET_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 ILL_3      ffffffff (null)     00000010000000000000101011101100100110        Q = 1                                             00005067 close to jalr
 * ba LDAF_3     3a SRxI_1     00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * bb SW_E2      ca DIVU_2     00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * bc CSRRWI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SW_E3      76 Fetchu     00110010000000000000101111001100100110        Q = 3                                             00000000 
 * be SH_4       45 WFI_3      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * bf SH_5       d2 LB_2       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * c0 ECALL_4    50 LW_1       00110010000000000000101011001100100110        Q = 4                                             00006003 close to load
 * c1 MRET_3     eb LH_3       00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * c2 DIV_3      d9 MULH_3     01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        0000600b close to ij
 * c3 DIV_6      52 LH_1       00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            0000600f close to fence
 * c4 ORI_0      e8 MUL_2      00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 EBREAK_2   b0 CSRRW_3    00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * c6 MRET_4     9f SH_5       00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * c7 CSRRW_3    73 unalignd   00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * c8 CSRRW_4    32 JAL_1      00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00006023 close to store
 * c9 eFetch3    c1 IJT_2      0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * ca SH_3       68 DIV_12     00000010000000000000000011101000110000        Prepare get back address to use                   40006023 close to store
 * cb ECALL_5    7e NMI_1      00110010000000000000101011001100100110        Q = 8                                             00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      4e eILL0b     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce IJ_3       fe ILLe       00010010000000000000110011101100100110        Construct Q = 1                                   40006033 sloppy or      
 * cf DIV_e      13 condb_2    00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * d0 SH_2       94 SW_E4      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d1 IJ_4       d7 ECALL_3    00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * d2 IJT_2      09 LB_5       00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * d3 MRET_5     41 JALR_1     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * d4 IJT_4      ba LHU_3      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * d5 QINT_1        (use dinx) 00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * d6 DIV_7      fe ILLe       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d7 MRET_2     c0 DIV_D      00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 DIVU_2     10 SUB_1      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00006067 close to jalr
 * da _LCSRRCI_1 62 DIV_8      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * db MRET_7     ba LHU_3      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * dc CSRRSI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd Fetch2u    e9 IJT_3      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * de MULH_3     8a DIVU_5     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * df LDAF_a     8a DIVU_5     00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * e0 aFault_2   d9 MULH_3     00010000110000001110001011100x00100110        Store 5 to mcause                                 00007003 close to load
 * e1 (null)     3d SRxI_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e2 (null)     ea MULHU_5    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700b close to ij
 * e3 (null)     3a SRxI_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 jFault_1   72 LBU_3      00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * e6 aF_SW_1    76 Fetchu     00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * e7 DIVU_1     41 JALR_1     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * e8 ORI_1      78 DIV_4      00000010000000000000000011101100001xx0        Q = RS1                                           00007023 close to store
 * e9 aF_SW_2    d4 aFault_2   00110010000000000000101011001100100110        Q = 4                                             00000000 
 * ea MUL_2      4b CSRRW_2    00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  40007023 close to store
 * eb IJT_3      a2 DIV_14     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     e7 aFault     00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee MULHU_5    fe ILLe       00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          40007033 sloppy and     
 * ef LH_3       76 Fetchu     00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f0 (null)     b1 aF_SW_3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f1 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f2 (null)     7e NMI_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f3 (null)     e6 StdIncPc   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 MULH_2     c9 MRET_2     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * f5 WFI_2      e5 aF_SW_2    00010010000000000000101011101100100110        Check offset                                      00000000 
 * f6 SB_3       f5 jFault     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f7 (null)     c5 MRET_5     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)     de Fetch      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00007067 close to jalr
 * fa (null)     9d DIV_11     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     ab EBREAK_2   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      b4 eFetch3    00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       9e SH_4       00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     d5 Fetch2u    00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 2000, used ffff, inputs 72
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       60 MULHU_3    00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     7e NMI_1      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     7e NMI_1      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     a5 MRET_3     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       53 LDAF_LH    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     a5 MRET_3     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       b6 ECALL_5    00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      78 DIV_4      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     7e NMI_1      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    53 LDAF_LH    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       7e NMI_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    76 Fetchu     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     9c DIV_10     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       7e NMI_1      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   5e LHU_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     7e NMI_1      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       e2 MUL_1      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    ce _LCSRRCI_1 00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      7e NMI_1      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      95 SW_E3      00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     7e NMI_1      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     92 LDAF_3     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      9a ECALL_6    00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     aa DIV_6      00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     7e NMI_1      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      7e NMI_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      b6 ECALL_5    00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       76 Fetchu     00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   93 SW_E2      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     75 unx75      00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    7e NMI_1      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     97 SW_E1SWH   00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      92 LDAF_3     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    96 SH_1       00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     a7 EBRKWFI1   00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    f2 SW_2       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       a9 ILL_4      00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 DIV_4      9f SH_5       00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 47 DIV_5      b9 DIV_e      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     62 DIV_8      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    c7 QINT_1     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_1      fe ILLe       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40002033 sloppy slt     
 * 4f DIV_2      7e NMI_1      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 50 DIV_E      7e NMI_1      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 51 DIV_F      df eFetch     00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 52 DIVU_5     1e aFault_1   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 53 LB_6       df eFetch     00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 54 SH_1       f3 aF_SW      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 55 SW_E1SWH   41 JALR_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 DIV_10     a3 DIV_15     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 57 DIV_11     53 LDAF_LH    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 58 DIV_14     af MRET_4     00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00002063 close to branch
 * 59 DIV_15     56 LH_4       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00002067 close to jalr
 * 5a OR_1       a6 ECAL_RET   00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       f6 WFI_1      00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e ECAL_RET   3e SLL_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 5f EBRKWFI1   df eFetch     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 60 IJ_1       10 SUB_1      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00003003 close to load
 * 61 IJT_1      8f ILL_3      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 62 CSRRW_2    d6 eILL0c     00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    0000300b close to ij
 * 63 NMI_2      26 OR_1       00000000110000001111010011101000110000        mtval = 0.                                        0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      83 DIV_2      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 LDAF_2     88 DIV_E      00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 67 SW_E4      bb SH_2       00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 68 DIVU_3     7e NMI_1      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00003023 close to store
 * 69 DIVU_4     53 LDAF_LH    01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 6a ECALL_6    f4 Fetch2     00010000110000001110100111000x00100000        mcause = 11                                       40003023 close to store
 * 6b ILL_4      b3 unxb3      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e aF_SW_3    cf MRET_7     00010000110000001110001011000x00100000        Store 7 to mcause                                 40003033 sloppy sltu    
 * 6f QINT_2     db jFault_1   00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 70 ECALL_1    ffffffff (null)     00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 71 MRET_1     41 JALR_1     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 72 LB_2       3a SRxI_1     00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 73 aFaultd    29 XOR_1      00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 74 eILL0c        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 ECALL_3       (use dinx) 00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 76 Fetch      dd aF_SW_1    00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 77 eFetch     dd aF_SW_1    00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 78 MUL_1      c3 DIVU_4     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00003063 close to branch
 * 79 MUL_3      c2 DIVU_3     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00003067 close to jalr
 * 7a SLTIX_1    88 DIV_E      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e StdIncPc   63 DIV_9      10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 7f aFault        (use dinx) 00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 80 LBU_0      b5 SH_3       00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 eILL0a     c2 DIVU_3     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000400b close to ij
 * 83 WFI_5      4e eILL0b     00110100000010001010110111000100100110        IncPC, OpFetch                                    0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     86 JAL_2      00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 LBU_2      91 LDAF_2     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 87 aFaulte       (use dinx) 00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 88 SW_2       56 LH_4       00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00004023 close to store
 * 89 aF_SW      7e NMI_1      00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 8a Fetch2     3a SRxI_1     00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     40004023 close to store
 * 8b jFault     7e NMI_1      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      4e eILL0b     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e WFI_1      fe ILLe       00110010000000000000000011001100100110 WFI    To check offset                                   40004033 sloppy xor     
 * 8f EBREAK_1   6b SB_4       00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 90 JAL_1      91 LDAF_2     00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 91 JAL_3      ba LHU_3      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 92 SLLI_1     91 LDAF_2     00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 93 SLLI_2     bd IJ_4       00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 94 ECALL_2    91 LDAF_2     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 95 MULHU_7    67 SW_E1SWE   00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 96 SRxI_1     d0 ECALL_1    00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 97 SRxI_2     bb SH_2       00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a SLL_1      91 LDAF_2     00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 9b SRx_1         (use dinx) 00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 9c JALR_1     36 SLLI_2     00010010000000000000000011101100100110        Q=1                                               00004073 close to csr/system 
 * 9d WFI_3      58 DIV_A      00010010000000000000101011101100100110        More check offset                                 00000000 
 * 9e ILL_1      bf IJT_1      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 9f ILL_2      88 DIV_E      00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 CSRRW_1    cb QINT_2     00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * a2 LH_4       53 LDAF_LH    00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      0000500b close to ij
 * a3 LH_5       7e NMI_1      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               0000500f close to fence
 * a4 SRxI_0     96 SH_1       00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SB_1       c6 IJT_4      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * a6 SB_2       70 LHU_2      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * a7 MULHU_3    a8 DIV_3      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * a8 EBRKWFI2   46 ILL_1      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00005023 close to store
 * a9 WFI_4      91 LDAF_2     00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * aa MULH_1     d6 eILL0c     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              40005023 close to store
 * ab SB_4       6a MULH_1     00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * ac _L0xac     9b unx9b      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     e5 aF_SW_2    00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     9b unx9b      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af DIV_C      d3 aFaultd    00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b0 MRET_6     c8 DIV_7      00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * b1 LBU_3      ba LHU_3      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * b2 unalignd   76 Fetchu     00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * b3 SB_5          (use dinx) 00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b4 NMI_1      b2 CSRRW_4    00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * b5 LBU_1      be IJ_1       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * b6 JAL_2      6a MULH_1     10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * b7 _LCSRRS_1  d1 MRET_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 ILL_3      ffffffff (null)     00000010000000000000101011101100100110        Q = 1                                             00005067 close to jalr
 * ba LDAF_3     3a SRxI_1     00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * bb SW_E2      ca DIVU_2     00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * bc CSRRWI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SW_E3      76 Fetchu     00110010000000000000101111001100100110        Q = 3                                             00000000 
 * be SH_4       45 WFI_3      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * bf SH_5       d2 LB_2       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * c0 ECALL_4    50 LW_1       00110010000000000000101011001100100110        Q = 4                                             00006003 close to load
 * c1 MRET_3     f1 aFaulte    00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * c2 DIV_3      d9 MULH_3     01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        0000600b close to ij
 * c3 DIV_6      52 LH_1       00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            0000600f close to fence
 * c4 ORI_0      e8 MUL_2      00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 EBREAK_2   b0 CSRRW_3    00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * c6 MRET_4     9f SH_5       00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * c7 CSRRW_3    6f MRET_6     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * c8 CSRRW_4    32 JAL_1      00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00006023 close to store
 * c9 eFetch3    c1 IJT_2      0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * ca SH_3       68 DIV_12     00000010000000000000000011101000110000        Prepare get back address to use                   40006023 close to store
 * cb ECALL_5    7e NMI_1      00110010000000000000101011001100100110        Q = 8                                             00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      4e eILL0b     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce IJ_3       fe ILLe       00010010000000000000110011101100100110        Construct Q = 1                                   40006033 sloppy or      
 * cf DIV_e      13 condb_2    00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * d0 SH_2       94 SW_E4      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d1 IJ_4       d7 ECALL_3    00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * d2 IJT_2      09 LB_5       00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * d3 MRET_5     41 JALR_1     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * d4 IJT_4      ba LHU_3      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * d5 QINT_1        (use dinx) 00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * d6 DIV_7      fe ILLe       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d7 MRET_2     c0 DIV_D      00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 DIVU_2     10 SUB_1      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00006067 close to jalr
 * da _LCSRRCI_1 66 SW_1       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * db MRET_7     ba LHU_3      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * dc CSRRSI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd Fetch2u    e9 IJT_3      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * de MULH_3     8a DIVU_5     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * df LDAF_a     8a DIVU_5     00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * e0 jFault_1   d9 MULH_3     00010000000000001110001011100x00100110        Store 1 to mcause                                 00007003 close to load
 * e1 aF_SW_1    3d SRxI_2     00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * e2 aFault_2   f0 LBU_2      00010000110000001110001011100x00100110        Store 5 to mcause                                 0000700b close to ij
 * e3 (null)     3a SRxI_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 DIVU_1     6e DIV_C      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * e6 (null)     76 Fetchu     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e7 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e8 ORI_1      78 DIV_4      00000010000000000000000011101100001xx0        Q = RS1                                           00007023 close to store
 * e9 aF_SW_2    d4 aFault_2   00110010000000000000101011001100100110        Q = 4                                             00000000 
 * ea (null)     4b CSRRW_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   40007023 close to store
 * eb (null)     a2 DIV_14     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     e5 aF_SW_2    00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee (null)     fe ILLe       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   40007033 sloppy and     
 * ef (null)     76 Fetchu     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f0 MUL_2      b1 aF_SW_3    00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * f1 IJT_3      41 JALR_1     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * f2 MULHU_5    7e NMI_1      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * f3 LH_3       e1 ORI_1      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f4 MULH_2     c9 MRET_2     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * f5 WFI_2      e0 DIVU_1     00010010000000000000101011101100100110        Check offset                                      00000000 
 * f6 SB_3       f5 jFault     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f7 (null)     c5 MRET_5     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)     de Fetch      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00007067 close to jalr
 * fa (null)     9d DIV_11     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     ab EBREAK_2   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      b4 eFetch3    00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       9e SH_4       00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     d5 Fetch2u    00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 1000, used ffff, inputs 74
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       66 SW_1       00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     7e NMI_1      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     7e NMI_1      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     a5 MRET_3     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       53 LDAF_LH    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     a5 MRET_3     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       b6 ECALL_5    00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      78 DIV_4      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     7e NMI_1      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    53 LDAF_LH    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       7e NMI_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    76 Fetchu     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     9c DIV_10     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       7e NMI_1      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   5e LHU_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     7e NMI_1      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       e0 DIVU_1     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    ce _LCSRRCI_1 00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      7e NMI_1      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      95 SW_E3      00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     7e NMI_1      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     92 LDAF_3     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      9a ECALL_6    00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     aa DIV_6      00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     7e NMI_1      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      7e NMI_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      b6 ECALL_5    00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       76 Fetchu     00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   93 SW_E2      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     75 unx75      00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    7e NMI_1      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     97 SW_E1SWH   00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      92 LDAF_3     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    96 SH_1       00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     a7 EBRKWFI1   00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    f2 SW_2       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       a9 ILL_4      00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 DIV_4      9f SH_5       00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 47 DIV_5      b9 DIV_e      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     60 MULHU_3    00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    c7 QINT_1     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_1      fe ILLe       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40002033 sloppy slt     
 * 4f DIV_2      7e NMI_1      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 50 DIV_E      7e NMI_1      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 51 DIV_F      df eFetch     00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 52 DIVU_5     1e aFault_1   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 53 LB_6       df eFetch     00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 54 SH_1       f3 aF_SW      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 55 SW_E1SWH   41 JALR_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 DIV_10     a3 DIV_15     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 57 DIV_11     53 LDAF_LH    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 58 DIV_14     af MRET_4     00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00002063 close to branch
 * 59 DIV_15     56 LH_4       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00002067 close to jalr
 * 5a OR_1       a6 ECAL_RET   00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       f6 WFI_1      00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e ECAL_RET   3e SLL_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 5f EBRKWFI1   df eFetch     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 60 CSRRW_2    10 SUB_1      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00003003 close to load
 * 61 NMI_2      8f ILL_3      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 62 LDAF_2     d6 eILL0c     00110000110000001110001011000x00100110        Store 4 to mcause                                 0000300b close to ij
 * 63 SW_E4      26 OR_1       00000000110000001110100111100x00101000        Store 6 to mcause                                 0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      83 DIV_2      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 IJ_1       88 DIV_E      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * 67 IJT_1      bb SH_2       00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 68 ECALL_6    7e NMI_1      00010000110000001110100111000x00100000        mcause = 11                                       00003023 close to store
 * 69 ILL_4      53 LDAF_LH    00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 6a aF_SW_3    f4 Fetch2     00010000110000001110001011000x00100000        Store 7 to mcause                                 40003023 close to store
 * 6b QINT_2     b3 unxb3      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIVU_3     cf MRET_7     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           40003033 sloppy sltu    
 * 6f DIVU_4     db jFault_1   01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 70 ECALL_1    ffffffff (null)     00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 71 MRET_1     41 JALR_1     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 72 LB_2       3a SRxI_1     00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 73 aFaultd    29 XOR_1      00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 74 eILL0c        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 ECALL_3       (use dinx) 00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 76 Fetch      dd aF_SW_1    00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 77 eFetch     dd aF_SW_1    00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 78 MUL_1      c3 DIVU_4     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00003063 close to branch
 * 79 MUL_3      c2 DIVU_3     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00003067 close to jalr
 * 7a SLTIX_1    88 DIV_E      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e StdIncPc   61 EBRKWFI2   10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 7f aFault        (use dinx) 00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 80 LBU_0      b5 SH_3       00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 eILL0a     c2 DIVU_3     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000400b close to ij
 * 83 WFI_5      4e eILL0b     00110100000010001010110111000100100110        IncPC, OpFetch                                    0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     86 JAL_2      00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 LBU_2      91 LDAF_2     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 87 aFaulte       (use dinx) 00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 88 SW_2       56 LH_4       00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00004023 close to store
 * 89 aF_SW      7e NMI_1      00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 8a Fetch2     3a SRxI_1     00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     40004023 close to store
 * 8b jFault     7e NMI_1      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      4e eILL0b     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e WFI_1      fe ILLe       00110010000000000000000011001100100110 WFI    To check offset                                   40004033 sloppy xor     
 * 8f EBREAK_1   69 DIV_13     00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 90 JAL_1      91 LDAF_2     00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 91 JAL_3      ba LHU_3      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 92 SLLI_1     91 LDAF_2     00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 93 SLLI_2     bd IJ_4       00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 94 ECALL_2    91 LDAF_2     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 95 MULHU_7    63 DIV_9      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 96 SRxI_1     d0 ECALL_1    00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 97 SRxI_2     bb SH_2       00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a SLL_1      91 LDAF_2     00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 9b SRx_1         (use dinx) 00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 9c JALR_1     36 SLLI_2     00010010000000000000000011101100100110        Q=1                                               00004073 close to csr/system 
 * 9d WFI_3      58 DIV_A      00010010000000000000101011101100100110        More check offset                                 00000000 
 * 9e ILL_1      bf IJT_1      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 9f ILL_2      88 DIV_E      00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 CSRRW_1    cb QINT_2     00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * a2 LH_4       53 LDAF_LH    00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      0000500b close to ij
 * a3 LH_5       7e NMI_1      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               0000500f close to fence
 * a4 SRxI_0     96 SH_1       00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SB_1       c6 IJT_4      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * a6 SB_2       70 LHU_2      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * a7 MULHU_3    a8 DIV_3      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * a8 EBRKWFI2   46 ILL_1      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00005023 close to store
 * a9 WFI_4      91 LDAF_2     00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * aa MULH_1     d6 eILL0c     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              40005023 close to store
 * ab SB_4       68 DIV_12     00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * ac _L0xac     9b unx9b      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     e7 aFault     00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     9b unx9b      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af DIV_C      d3 aFaultd    00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b0 MRET_6     c8 DIV_7      00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * b1 LBU_3      ba LHU_3      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * b2 unalignd   76 Fetchu     00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * b3 SB_5          (use dinx) 00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b4 NMI_1      b2 CSRRW_4    00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * b5 LBU_1      be IJ_1       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * b6 JAL_2      68 DIV_12     10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * b7 _LCSRRS_1  d1 MRET_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 ILL_3      ffffffff (null)     00000010000000000000101011101100100110        Q = 1                                             00005067 close to jalr
 * ba LDAF_3     3a SRxI_1     00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * bb SW_E2      ca DIVU_2     00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * bc CSRRWI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SW_E3      76 Fetchu     00110010000000000000101111001100100110        Q = 3                                             00000000 
 * be SH_4       45 WFI_3      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * bf SH_5       d2 LB_2       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * c0 ECALL_4    50 LW_1       00110010000000000000101011001100100110        Q = 4                                             00006003 close to load
 * c1 MRET_3     f1 aFaulte    00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * c2 DIV_3      d9 MULH_3     01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        0000600b close to ij
 * c3 DIV_6      52 LH_1       00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            0000600f close to fence
 * c4 ORI_0      ee eILL0a     00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 EBREAK_2   b0 CSRRW_3    00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * c6 MRET_4     9f SH_5       00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * c7 CSRRW_3    6b SB_4       00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * c8 CSRRW_4    32 JAL_1      00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00006023 close to store
 * c9 eFetch3    c1 IJT_2      0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * ca SH_3       6e DIV_C      00000010000000000000000011101000110000        Prepare get back address to use                   40006023 close to store
 * cb ECALL_5    7e NMI_1      00110010000000000000101011001100100110        Q = 8                                             00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      4e eILL0b     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce IJ_3       fe ILLe       00010010000000000000110011101100100110        Construct Q = 1                                   40006033 sloppy or      
 * cf DIV_e      13 condb_2    00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * d0 SH_2       94 SW_E4      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d1 IJ_4       d7 ECALL_3    00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * d2 IJT_2      09 LB_5       00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * d3 MRET_5     41 JALR_1     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * d4 IJT_4      ba LHU_3      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * d5 QINT_1        (use dinx) 00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * d6 DIV_7      fe ILLe       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d7 MRET_2     c0 DIV_D      00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 DIVU_2     10 SUB_1      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00006067 close to jalr
 * da _LCSRRCI_1 62 DIV_8      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * db MRET_7     ba LHU_3      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * dc CSRRSI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd Fetch2u    ef WFI_5      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * de MULH_3     8a DIVU_5     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * df LDAF_a     8a DIVU_5     00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * e0 aFault_2   d9 MULH_3     00010000110000001110001011100x00100110        Store 5 to mcause                                 00007003 close to load
 * e1 (null)     3d SRxI_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e2 (null)     f0 LBU_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700b close to ij
 * e3 (null)     3a SRxI_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 jFault_1   6a MULH_1     00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * e6 aF_SW_1    76 Fetchu     00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * e7 DIVU_1     41 JALR_1     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * e8 (null)     78 DIV_4      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00007023 close to store
 * e9 (null)     d4 aFault_2   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ea (null)     4b CSRRW_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   40007023 close to store
 * eb (null)     a2 DIV_14     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     e7 aFault     00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee ORI_1      fe ILLe       00000010000000000000000011101100001xx0        Q = RS1                                           40007033 sloppy and     
 * ef aF_SW_2    76 Fetchu     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * f0 MUL_2      b1 aF_SW_3    00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * f1 IJT_3      41 JALR_1     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * f2 MULHU_5    7e NMI_1      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * f3 LH_3       e6 StdIncPc   00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f4 MULH_2     c9 MRET_2     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * f5 WFI_2      e5 aF_SW_2    00010010000000000000101011101100100110        Check offset                                      00000000 
 * f6 SB_3       f5 jFault     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f7 (null)     c5 MRET_5     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)     de Fetch      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00007067 close to jalr
 * fa (null)     9d DIV_11     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     ab EBREAK_2   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      b4 eFetch3    00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       9e SH_4       00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     d5 Fetch2u    00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0004, used ffff, inputs 78
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       9e SH_4       00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       8e _LCSRRS_1  00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     aa DIV_6      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     aa DIV_6      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     df eFetch     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       7f unx7f      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     df eFetch     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       f9 MULH_2     00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      a8 DIV_3      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     aa DIV_6      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 CSRRW_2    7f unx7f      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 11 NMI_2      3a SRxI_1     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 12 LDAF_2     68 DIV_12     00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 13 SW_E4      2e MULHU_1    00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 14 ECALL_6    39 MULHU_7    00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 15 ILL_4      06 LB_3       00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 16 aF_SW_3    aa DIV_6      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 17 QINT_2     a6 ECAL_RET   00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     ce _LCSRRCI_1 00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       aa DIV_6      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   8a DIVU_5     00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     aa DIV_6      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e MULHU_2    90 NMI_2      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 1f MULHU_4    50 LW_1       00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 20 LH_0       42 MULHU_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      aa DIV_6      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      c5 MRET_5     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     aa DIV_6      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     af MRET_4     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 eILL0b     5d SB_2       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     3d SRxI_2     00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     82 DIV_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     82 DIV_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      ca DIVU_2     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     e5 aF_SW_2    00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    1e aFault_1   00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     aa DIV_6      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LDAF_3     aa DIV_6      00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 31 SW_E2      7a SB_5       00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 32 SW_E3      f9 MULH_2     00110010000000000000101111001100100110        Q = 3                                             00000000 
 * 33 SH_4          (use dinx) 00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 34 SH_5       a6 ECAL_RET   00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 ECALL_4    b9 DIV_e      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 36 MRET_3     03 _L0x03     00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * 37 DIV_3      a3 DIV_15     01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    aa DIV_6      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     c9 MRET_2     00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    db jFault_1   00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LW_1       af MRET_4     00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    c8 DIV_7      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 LH_1       e1 ORI_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH    77 eFetchu    00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       e3 MUL_3      00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 LH_2       da LDAF_a     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    fb SB_3       00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     10 SUB_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    b3 unxb3      00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_A      fe ILLe       00110010000000000000101111101100001xx1        Transfer rM to rDee                               40002033 sloppy slt     
 * 4f DIV_B      aa DIV_6      00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 50 IJ_3       aa DIV_6      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 51 DIV_e      d7 ECALL_3    00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 52 SH_2       46 ILL_1      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 53 IJ_4       d7 ECALL_3    00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 54 IJT_2      f0 LBU_2      00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * 55 MRET_5     41 JALR_1     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * 56 IJT_4      de Fetch      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 57 QINT_1     7f unx7f      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 58 LHU_1      e7 aFault     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00002063 close to branch
 * 59 LDAF_LHU   86 JAL_2      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00002067 close to jalr
 * 5a OR_1       e0 DIVU_1     00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    db jFault_1   00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       f3 aF_SW      00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIV_8      66 SW_1       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 5f DIV_9      d7 ECALL_3    01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 60 SW_1       1e aFault_1   00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00003003 close to load
 * 61 SW_E1SWE   c7 QINT_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 DIV_12     d0 ECALL_1    00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              0000300b close to ij
 * 63 DIV_13     4e eILL0b     00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      bb SH_2       00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 LHU_2      c0 DIV_D      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 67 aFaultc    31 SLTX_1     00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 68 Fetchu     aa DIV_6      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00003023 close to store
 * 69 eFetchu    7f unx7f      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 6a DIV_4      f1 aFaulte    00000000000000001100000011101000110000        ~abs(divisor) to yy                               40003023 close to store
 * 6b DIV_5      eb LH_3       00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_1      51 LDAF_LW    00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40003033 sloppy sltu    
 * 6f DIV_2      d4 aFault_2   00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 70 jFault_1   ffffffff (null)     00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 71 aF_SW_1    41 JALR_1     00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 72 DIVU_1     3a SRxI_1     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 73 ORI_1      29 XOR_1      00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 74 aF_SW_2       (use dinx) 00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 75 MUL_2         (use dinx) 00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 76 IJT_3      d5 Fetch2u    00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 77 MULHU_5    d5 Fetch2u    00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * 78 DIV_E      b0 CSRRW_3    01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003063 close to branch
 * 79 DIV_F      37 ECALL_2    00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00003067 close to jalr
 * 7a SLTIX_1    c0 DIV_D      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    db jFault_1   00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e DIVU_5     11 AND_1      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 7f LB_6          (use dinx) 00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 80 LBU_0      ef WFI_5      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 SH_1       37 ECALL_2    00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        0000400b close to ij
 * 83 SW_E1SWH   6e DIV_C      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     be IJ_1       00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 DIV_10     a5 MRET_3     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 87 DIV_11        (use dinx) 01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 88 DIV_14     86 JAL_2      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00004023 close to store
 * 89 DIV_15     aa DIV_6      00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 8a ECAL_RET   3a SRxI_1     00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40004023 close to store
 * 8b EBRKWFI1   aa DIV_6      00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      6e DIV_C      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e IJ_1       fe ILLe       00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   40004033 sloppy xor     
 * 8f IJT_1      15 condb_4    00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 90 aFault_2   a5 MRET_3     00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 91 (null)     30 SLTIX_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 92 (null)     a5 MRET_3     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 93 (null)     32 JAL_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 94 (null)     a5 MRET_3     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 95 (null)     13 condb_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 96 (null)     52 LH_1       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 97 (null)     31 SLTX_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a DIVU_3     a5 MRET_3     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 9b DIVU_4        (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 9c ECALL_1    62 DIV_8      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00004073 close to csr/system 
 * 9d MRET_1     88 DIV_E      00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 9e LB_2       34 JAL_3      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 9f aFaultd    c0 DIV_D      00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * a0 LHU_0      58 DIV_A      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JAL_1      b7 IJ_3       00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * a2 eILL0c     7f unx7f      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000500b close to ij
 * a3 ECALL_3    aa DIV_6      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    0000500f close to fence
 * a4 SRxI_0     c8 DIV_7      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 JAL_3      b2 CSRRW_4    00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a6 Fetch      9c DIV_10     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * a7 eFetch     e2 MUL_1      00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * a8 MUL_1      6a MULH_1     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00005023 close to store
 * a9 MUL_3      a5 MRET_3     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * aa StdIncPc   d0 ECALL_1    10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    40005023 close to store
 * ab aFault     14 condb_3    00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * ac _L0xac     cb QINT_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     72 LBU_3      00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     cb QINT_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SLLI_1     55 aFaultb    00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * b0 DIV_6      b4 eFetch3    00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * b1 EBREAK_2   30 SLTIX_2    00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * b2 MRET_4     a6 ECAL_RET   00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b3 CSRRW_3       (use dinx) 00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b4 CSRRW_4    ea MULHU_5    00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b5 eFetch3    33 unx33      0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * b6 SH_3       14 condb_3    00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b7 ECALL_5    53 LDAF_LH    00110010000000000000101011001100100110        Q = 8                                             00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SLLI_2     ffffffff (null)     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00005067 close to jalr
 * ba eILL0a     3a SRxI_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bb WFI_5      b6 ECALL_5    00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * bc CSRRWI_0   db jFault_1   00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ECALL_2    a6 ECAL_RET   00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * be LBU_2      45 WFI_3      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * bf aFaulte    54 LH_2       00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * c0 SW_2       78 DIV_4      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00006003 close to load
 * c1 aF_SW      76 Fetchu     00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * c2 Fetch2     d2 LB_2       00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     0000600b close to ij
 * c3 jFault     7e NMI_1      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000600f close to fence
 * c4 ORI_0      73 unalignd   00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MULHU_7    e8 MUL_2      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * c6 WFI_1      da LDAF_a     00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * c7 EBREAK_1   17 condb_5t   00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * c8 SRxI_1     5e LHU_1      00000000000000000100101001101100001xx1        Register to shift to Q                            00006023 close to store
 * c9 SRxI_2     36 SLLI_2     00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * ca SLL_1      9a ECALL_6    00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              40006023 close to store
 * cb SRx_1      aa DIV_6      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      6e DIV_C      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce JALR_1     fe ILLe       00010010000000000000000011101100100110        Q=1                                               40006033 sloppy or      
 * cf WFI_3      27 OR_2       00010010000000000000101011101100100110        More check offset                                 00000000 
 * d0 DIV_7      bd IJ_4       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d1 MRET_2     d1 MRET_1     00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * d2 DIVU_2     09 LB_5       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d3 _LCSRRCI_1 41 JALR_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d4 MRET_7     30 SLTIX_2    00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * d5 Fetch2u       (use dinx) 0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * d6 MULH_3     fe ILLe       00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * d7 LDAF_a     35 SLLI_1     00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 ILL_1      1e aFault_1   00000000000000001101101011100x00001xx0        Store PC to mepc                                  00006067 close to jalr
 * da ILL_2      12 straddle   00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * db CSRRW_1    30 SLTIX_2    00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * dc CSRRSI_0   db jFault_1   00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd LH_4       74 unx74      00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * de LH_5       c2 DIVU_3     00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * df SB_1       c2 DIVU_3     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * e0 SB_2       d2 LB_2       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00007003 close to load
 * e1 MULHU_3    3d SRxI_2     00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * e2 EBRKWFI2   75 unx75      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         0000700b close to ij
 * e3 WFI_4      3a SRxI_1     00000010000000000000001011x01001xxxxx0        Prepare read PC                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 MULH_1     16 condb_5    00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * e6 SB_4       a6 ECAL_RET   00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * e7 DIV_C      41 JALR_1     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * e8 MRET_6     a8 DIV_3      00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00007023 close to store
 * e9 LBU_3      56 LH_4       00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * ea unalignd   4b CSRRW_2    00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                40007023 close to store
 * eb SB_5       dd aF_SW_1    00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     72 LBU_3      00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee NMI_1      fe ILLe       00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40007033 sloppy and     
 * ef LBU_1      a6 ECAL_RET   00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * f0 LH_3       e9 IJT_3      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f1 MULH_2     41 JALR_1     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * f2 WFI_2      aa DIV_6      00010010000000000000101011101100100110        Check offset                                      00000000 
 * f3 SB_3       71 aFaultc    00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f4 (null)     b5 SH_3       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f5 (null)     70 LHU_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f6 (null)     f2 SW_2       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     b1 aF_SW_3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 JAL_2      d6 eILL0c     10110000000000000100110011000x00100110        Return address to TRG                             00007067 close to jalr
 * fa _LCSRRS_1  cf MRET_7     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * fb ILL_3      e6 StdIncPc   00000010000000000000101011101100100110        Q = 1                                             00000000 
 * fc CSRRCI_0   db jFault_1   00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      ee eILL0a     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       d9 MULH_3     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     57 LH_5       00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0400, used ffff, inputs 87
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       68 DIV_12     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       60 MULHU_3    00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     72 LBU_3      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     a7 EBRKWFI1   00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       53 LDAF_LH    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     a7 EBRKWFI1   00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       c0 DIV_D      00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      70 LHU_2      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    53 LDAF_LH    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    6e DIV_C      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     9c DIV_10     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       72 LBU_3      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     88 DIV_E      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   5e LHU_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     72 LBU_3      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       c2 DIVU_3     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    e0 DIVU_1     00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      72 LBU_3      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      91 LDAF_2     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     8e _LCSRRS_1  00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      96 SH_1       00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     b1 aF_SW_3    00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      c0 DIV_D      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       6e DIV_C      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   8f ILL_3      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     6b SB_4       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    72 LBU_3      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     95 SW_E3      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     88 DIV_E      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      8e _LCSRRS_1  00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    94 SW_E4      00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     a9 ILL_4      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    bb SH_2       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       b0 CSRRW_3    00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 DIV_4      9f SH_5       00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 47 DIV_5      c5 MRET_5     00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     82 DIV_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    d7 ECALL_3    00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_1      fe ILLe       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40002033 sloppy slt     
 * 4f DIV_2      72 LBU_3      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 50 DIV_E      72 LBU_3      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 51 DIV_F      f9 MULH_2     00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 52 DIVU_5     1e aFault_1   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 53 LB_6       f9 MULH_2     00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 54 SH_1       c3 DIVU_4     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 55 SW_E1SWH   41 JALR_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 DIV_10     a6 ECAL_RET   01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 57 DIV_11     53 LDAF_LH    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 58 DIV_14     b5 SH_3       00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00002063 close to branch
 * 59 DIV_15     56 LH_4       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00002067 close to jalr
 * 5a OR_1       a8 DIV_3      00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     88 DIV_E      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       db jFault_1   00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e ECAL_RET   3e SLL_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 5f EBRKWFI1   f9 MULH_2     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 60 IJ_1       10 SUB_1      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00003003 close to load
 * 61 IJT_1      87 unx87      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 62 DIVU_3     ef WFI_5      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIVU_4     26 OR_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      75 unx75      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 ECALL_1    78 DIV_4      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 67 MRET_1     c7 QINT_1     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 68 LB_2       72 LBU_3      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd    53 LDAF_LH    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c     cb QINT_2     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    bd IJ_4       00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e Fetch      e1 ORI_1      00000001001010001000101111101010110000  Fr11  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     f5 jFault     00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 MUL_1      ffffffff (null)     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 71 MUL_3      41 JALR_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 72 StdIncPc   3a SRxI_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 73 aFault     29 XOR_1      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 74 eILL0a        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 76 LBU_2      f6 WFI_1      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 77 aFaulte    f6 WFI_1      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 78 SW_2       d4 aFault_2   00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00003063 close to branch
 * 79 aF_SW      d1 MRET_1     00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00003067 close to jalr
 * 7a SLTIX_1    78 DIV_4      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     88 DIV_E      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e Fetch2     8a DIVU_5     00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 7f jFault        (use dinx) 00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 80 LBU_0      bf IJT_1      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 CSRRW_2    d1 MRET_1     00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    0000400b close to ij
 * 83 jFault_1   4e eILL0b     00010000000000001110001011100x00100110        Store 1 to mcause                                 0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     76 Fetchu     00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 WFI_1      89 DIV_F      00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 87 EBREAK_1      (use dinx) 00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 88 JAL_1      56 LH_4       00010000000000001100001011101000100000        Target adr to yy                                  00004023 close to store
 * 89 JAL_3      72 LBU_3      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 8a NMI_2      3a SRxI_1     00000000110000001111010011101000110000        mtval = 0.                                        40004023 close to store
 * 8b aF_SW_1    72 LBU_3      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      4e eILL0b     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e SLLI_1     fe ILLe       00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      40004033 sloppy xor     
 * 8f SLLI_2     aa DIV_6      00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 90 ECALL_2    89 DIV_F      00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 91 MULHU_7    c6 IJT_4      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 92 LDAF_2     89 DIV_F      00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 93 DIVU_1     c8 DIV_7      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 94 SRxI_1     89 DIV_F      00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 95 SRxI_2     9a ECALL_6    00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 96 SLL_1      e5 aF_SW_2    00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 97 SRx_1      c7 QINT_1     00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a SW_E4      89 DIV_F      00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 9b ORI_1         (use dinx) 00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 9c JALR_1     36 SLLI_2     00010010000000000000000011101100100110        Q=1                                               00004073 close to csr/system 
 * 9d WFI_3      58 DIV_A      00010010000000000000101011101100100110        More check offset                                 00000000 
 * 9e ILL_1      ce _LCSRRCI_1 00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 9f ILL_2      78 DIV_4      00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 CSRRW_1    df eFetch     00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * a2 ECALL_6    53 LDAF_LH    00010000110000001110100111000x00100000        mcause = 11                                       0000500b close to ij
 * a3 aF_SW_2    72 LBU_3      00110010000000000000101011001100100110        Q = 4                                             0000500f close to fence
 * a4 SRxI_0     94 SW_E4      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 LH_4       d6 eILL0c     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * a6 LH_5       66 SW_1       00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * a7 SB_1       af MRET_4     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * a8 SB_2       46 ILL_1      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00005023 close to store
 * a9 MULHU_3    89 DIV_F      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * aa ILL_4      ef WFI_5      00010000110000001110100111100x00100110        Store 2 to mcause                                 40005023 close to store
 * ab MUL_2      a2 DIV_14     00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * ac _L0xac     97 SW_E1SWH   00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     93 SW_E2      00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     97 SW_E1SWH   00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af EBRKWFI2   e8 MUL_2      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * b0 WFI_4      d9 MULH_3     00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * b1 MULH_1     c6 IJT_4      00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * b2 aF_SW_3    6e DIV_C      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * b3 IJT_3         (use dinx) 00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * b4 SB_4       b9 DIV_e      00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b5 DIV_C      c9 MRET_2     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b6 MRET_6     a2 DIV_14     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * b7 LBU_3      e6 StdIncPc   00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 unalignd   ffffffff (null)     00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00005067 close to jalr
 * ba QINT_2     3a SRxI_1     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * bb MULHU_5    de Fetch      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * bc CSRRWI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SB_5       6e DIV_C      00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * be NMI_1      45 WFI_3      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * bf LBU_1      e7 aFault     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * c0 JAL_2      50 LW_1       10110000000000000100110011000x00100110        Return address to TRG                             00006003 close to load
 * c1 _LCSRRS_1  b3 unxb3      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * c2 aFault_2   f1 aFaulte    00010000110000001110001011100x00100110        Store 5 to mcause                                 0000600b close to ij
 * c3 LH_3       52 LH_1       00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 0000600f close to fence
 * c4 ORI_0      9b unx9b      00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 ILL_3      b6 ECALL_5    00000010000000000000101011101100100110        Q = 1                                             00000000 
 * c6 LDAF_3     9f SH_5       00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * c7 SW_E2      ba LHU_3      00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * c8 SW_E3      32 JAL_1      00110010000000000000101111001100100110        Q = 3                                             00006023 close to store
 * c9 SH_4       d0 ECALL_1    00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * ca (null)     62 DIV_8      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   40006023 close to store
 * cb MULH_2     72 LBU_3      00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      4e eILL0b     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce SH_5       fe ILLe       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     40006033 sloppy or      
 * cf ECALL_4    13 condb_2    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d0 MRET_3     90 NMI_2      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * d1 DIV_3      f0 LBU_2      01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * d2 (null)     09 LB_5       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d3 WFI_2      41 JALR_1     00010010000000000000101011101100100110        Check offset                                      00000000 
 * d4 DIV_6      c6 IJT_4      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * d5 EBREAK_2      (use dinx) 00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * d6 MRET_4     fe ILLe       00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * d7 CSRRW_3    cf MRET_7     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 CSRRW_4    10 SUB_1      00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00006067 close to jalr
 * da (null)     92 LDAF_3     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * db SB_3       c6 IJT_4      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * dc CSRRSI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd eFetch3    a3 DIV_15     0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * de SH_3       7e NMI_1      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * df ECALL_5    7e NMI_1      00110010000000000000101011001100100110        Q = 8                                             00000000 
 * e0 IJ_3       f1 aFaulte    00010010000000000000110011101100100110        Construct Q = 1                                   00007003 close to load
 * e1 DIV_e      3d SRxI_2     00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * e2 (null)     ab EBREAK_2   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700b close to ij
 * e3 (null)     3a SRxI_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SH_2       b2 CSRRW_4    00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * e6 IJ_4       6e DIV_C      00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * e7 IJT_2      41 JALR_1     00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * e8 MRET_5     70 LHU_2      00000010000000000000000011101100010xx0        ~302                                              00007023 close to store
 * e9 IJT_4      e9 IJT_3      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * ea (null)     4b CSRRW_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   40007023 close to store
 * eb (null)     a5 MRET_3     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     93 SW_E2      00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee QINT_1     fe ILLe       00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40007033 sloppy and     
 * ef DIV_7      6e DIV_C      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f0 MRET_2     b7 IJ_3       00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * f1 DIVU_2     41 JALR_1     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f2 (null)     72 LBU_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f3 (null)     8b LB_6       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 _LCSRRCI_1 dd aF_SW_1    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f5 MRET_7     83 DIV_2      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f6 Fetch2u    d3 aFaultd    0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f7 MULH_3     d5 Fetch2u    00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 LDAF_a     f7 EBREAK_1   00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00007067 close to jalr
 * fa (null)     9d DIV_11     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     b4 eFetch3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      be IJ_1       00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       9e SH_4       00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     ee eILL0a     00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0200, used ffff, inputs 8b
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       68 DIV_12     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       60 MULHU_3    00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     72 LBU_3      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     b9 DIV_e      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       53 LDAF_LH    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     b9 DIV_e      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       d4 aFault_2   00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      70 LHU_2      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    53 LDAF_LH    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    6e DIV_C      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     a8 DIV_3      00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       72 LBU_3      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     8e _LCSRRS_1  00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   5e LHU_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     72 LBU_3      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       c1 IJT_2      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    82 DIV_1      00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      72 LBU_3      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      9b unx9b      00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     90 NMI_2      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    8a DIVU_5     00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      9e SH_4       00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     bf IJT_1      00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      d4 aFault_2   00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       6e DIV_C      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   94 SW_E4      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     6b SB_4       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    72 LBU_3      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     9d DIV_11     00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     8e _LCSRRS_1  00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    af MRET_4     00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      90 NMI_2      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    9c DIV_10     00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     bb SH_2       00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    b7 IJ_3       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       be IJ_1       00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 DIV_4      ab EBREAK_2   00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 47 DIV_5      da LDAF_a     00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     81 unx81      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    f0 LBU_2      00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      8b LB_6       00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_1      fe ILLe       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40002033 sloppy slt     
 * 4f DIV_2      72 LBU_3      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 50 DIV_E      72 LBU_3      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 51 DIV_F      f6 WFI_1      00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 52 DIVU_5     1e aFault_1   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 53 LB_6       f6 WFI_1      00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 54 SH_1       c3 DIVU_4     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 55 SW_E1SWH   41 JALR_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 DIV_10     b4 eFetch3    01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 57 DIV_11     53 LDAF_LH    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 58 DIV_14     c8 DIV_7      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00002063 close to branch
 * 59 DIV_15     56 LH_4       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00002067 close to jalr
 * 5a OR_1       ba LHU_3      00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     8e _LCSRRS_1  00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    af MRET_4     00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       d7 ECALL_3    00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e ECAL_RET   3e SLL_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 5f EBRKWFI1   f6 WFI_1      00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 60 IJ_1       10 SUB_1      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00003003 close to load
 * 61 IJT_1      89 DIV_F      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 62 DIVU_3     c2 DIVU_3     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIVU_4     26 OR_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      75 unx75      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 ECALL_1    78 DIV_4      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 67 MRET_1     dd aF_SW_1    00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 68 LB_2       72 LBU_3      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd    53 LDAF_LH    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c     c7 QINT_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    ce _LCSRRCI_1 00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     8b LB_6       00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e Fetch      86 JAL_2      00000001001010001000101111101010110000  Fr11  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     e2 MUL_1      00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 MUL_1      ffffffff (null)     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 71 MUL_3      41 JALR_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 72 StdIncPc   3a SRxI_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 73 aFault     29 XOR_1      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 74 eILL0a        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 76 LBU_2      e6 StdIncPc   00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 77 aFaulte    e6 StdIncPc   00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 78 SW_2       eb LH_3       00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00003063 close to branch
 * 79 aF_SW      ea MULHU_5    00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00003067 close to jalr
 * 7a SLTIX_1    78 DIV_4      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     8e _LCSRRS_1  00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    af MRET_4     00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e Fetch2     85 LBU_1      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 7f jFault        (use dinx) 00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 80 LBU_0      d0 ECALL_1    00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 CSRRW_2       (use dinx) 00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 82 IJ_3       ea MULHU_5    00010010000000000000110011101100100110        Construct Q = 1                                   0000400b close to ij
 * 83 jFault_1   4e eILL0b     00010000000000001110001011100x00100110        Store 1 to mcause                                 0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 NMI_2      76 Fetchu     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 86 DIV_e      8f ILL_3      00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 87 aF_SW_1       (use dinx) 00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 88 WFI_1      56 LH_4       00110010000000000000000011001100100110 WFI    To check offset                                   00004023 close to store
 * 89 EBREAK_1   72 LBU_3      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 8a SLTIX_2    3a SRxI_1     00000000000000000100001011101000110010        Registered ALU flag to rd                         40004023 close to store
 * 8b SLTX_1     72 LBU_3      00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      4e eILL0b     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e JAL_1      fe ILLe       00010000000000001100001011101000100000        Target adr to yy                                  40004033 sloppy xor     
 * 8f JAL_3      a5 MRET_3     00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 90 SLLI_1     8f ILL_3      00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 91 LDAF_2     db jFault_1   00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 92 SH_2       8f ILL_3      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 93 DIVU_1     de Fetch      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 94 SLLI_2     8f ILL_3      00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 95 SW_E4      95 SW_E3      00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 96 IJ_4       92 LDAF_3     00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 97 ORI_1      dd aF_SW_1    00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a ECALL_2    8f ILL_3      00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 9b MULHU_7       (use dinx) 00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 9c SRxI_1     36 SLLI_2     00000000000000000100101001101100001xx1        Register to shift to Q                            00004073 close to csr/system 
 * 9d SRxI_2     58 DIV_A      00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 9e SLL_1      e0 DIVU_1     00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 9f SRx_1      78 DIV_4      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_6    fb SB_3       00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * a2 IJT_2      53 LDAF_LH    00000000000000001100101011101000110000        Read word is to be masked with ~1u                0000500b close to ij
 * a3 aF_SW_2    72 LBU_3      00110010000000000000101011001100100110        Q = 4                                             0000500f close to fence
 * a4 SRxI_0     9c DIV_10     00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 ILL_4      ef WFI_5      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * a6 MRET_5     66 SW_1       00000010000000000000000011101100010xx0        ~302                                              00000000 
 * a7 MUL_2      bd IJ_4       00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * a8 JALR_1     46 ILL_1      00010010000000000000000011101100100110        Q=1                                               00005023 close to store
 * a9 WFI_3      8f ILL_3      00010010000000000000101011101100100110        More check offset                                 00000000 
 * aa ILL_1      c2 DIVU_3     00000000000000001101101011100x00001xx0        Store PC to mepc                                  40005023 close to store
 * ab ILL_2      a1 ECALL_4    00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * ac _L0xac     9f SH_5       00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     93 SW_E2      00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     9f SH_5       00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af CSRRW_1    a6 ECAL_RET   00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * b0 LH_4       f4 Fetch2     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * b1 aF_SW_3    db jFault_1   00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * b2 IJT_4      6e DIV_C      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * b3 IJT_3         (use dinx) 00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * b4 LH_5       cb QINT_2     00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * b5 QINT_2     df eFetch     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * b6 QINT_1     a1 ECALL_4    00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * b7 MULHU_5    96 SH_1       00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SB_1       ffffffff (null)     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00005067 close to jalr
 * ba SB_2       3a SRxI_1     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * bb MULHU_3    fa WFI_2      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * bc CSRRWI_0   af MRET_4     00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd EBRKWFI2   6e DIV_C      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * be WFI_4      45 WFI_3      00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * bf MULH_1     a2 DIV_14     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * c0 SB_4       50 LW_1       00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00006003 close to load
 * c1 aFault_2   b3 unxb3      00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * c2 DIV_7      d2 LB_2       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            0000600b close to ij
 * c3 LH_3       52 LH_1       00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 0000600f close to fence
 * c4 ORI_0      97 SW_E1SWH   00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     c9 MRET_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c6 MRET_2     ab EBREAK_2   00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * c7 MULH_2     b5 SH_3       00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * c8 DIV_C      32 JAL_1      00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00006023 close to store
 * c9 MRET_6     e9 IJT_3      00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * ca LBU_3      62 DIV_8      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       40006023 close to store
 * cb unalignd   72 LBU_3      00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      4e eILL0b     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce SB_5       fe ILLe       00000000000000000010110011100100001xx0        Write d to a+k until accepted                     40006033 sloppy or      
 * cf NMI_1      13 condb_2    00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * d0 LBU_1      9a ECALL_6    00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * d1 (null)     c6 IJT_4      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d2 DIVU_2     09 LB_5       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d3 WFI_2      41 JALR_1     00010010000000000000101011101100100110        Check offset                                      00000000 
 * d4 JAL_2      db jFault_1   10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * d5 (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d6 _LCSRRCI_1 fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d7 SB_3       e8 MUL_2      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 _LCSRRS_1  10 SUB_1      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00006067 close to jalr
 * da ILL_3      91 LDAF_2     00000010000000000000101011101100100110        Q = 1                                             00000000 
 * db LDAF_3     db jFault_1   00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * dc CSRRSI_0   af MRET_4     00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd SW_E2      a3 DIV_15     00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * de SW_E3      7e NMI_1      00110010000000000000101111001100100110        Q = 3                                             00000000 
 * df SH_4       7e NMI_1      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * e0 SH_5       d2 LB_2       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00007003 close to load
 * e1 (null)     3d SRxI_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e2 MRET_7     a7 EBRKWFI1   00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               0000700b close to ij
 * e3 (null)     3a SRxI_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     b1 aF_SW_3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e6 Fetch2u    6e DIV_C      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * e7 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e8 ECALL_4    70 LHU_2      00110010000000000000101011001100100110        Q = 4                                             00007023 close to store
 * e9 MRET_3     b2 CSRRW_4    00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * ea DIV_3      4b CSRRW_2    01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        40007023 close to store
 * eb DIV_6      b0 CSRRW_3    00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     93 SW_E2      00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee EBREAK_2   fe ILLe       00000000000000001101101011101000001xx0        pc to mepc                                        40007033 sloppy and     
 * ef MRET_4     6e DIV_C      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * f0 CSRRW_3    ca DIVU_2     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * f1 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f2 MULH_3     72 LBU_3      00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * f3 (null)     87 unx87      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 CSRRW_4    f9 MULH_2     00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * f5 (null)     83 DIV_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f6 LDAF_a     d3 aFaultd    00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * f7 (null)     ee eILL0a     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 eFetch3    f2 SW_2       0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00007067 close to jalr
 * fa SH_3       a9 ILL_4      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fb ECALL_5    c0 DIV_D      00110010000000000000101011001100100110        Q = 8                                             00000000 
 * fc CSRRCI_0   af MRET_4     00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      cf MRET_7     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       aa DIV_6      00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     b6 ECALL_5    00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0200, used ffff, inputs 8d
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       68 DIV_12     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       60 MULHU_3    00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     72 LBU_3      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     a9 ILL_4      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       53 LDAF_LH    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     a9 ILL_4      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       c0 DIV_D      00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      70 LHU_2      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    53 LDAF_LH    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    6e DIV_C      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     9c DIV_10     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       72 LBU_3      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     8a DIVU_5     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   5e LHU_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     72 LBU_3      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       c1 IJT_2      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    e0 DIVU_1     00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      72 LBU_3      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      92 LDAF_3     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     8e _LCSRRS_1  00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    82 DIV_1      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      9a ECALL_6    00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     b2 CSRRW_4    00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      c0 DIV_D      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       6e DIV_C      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   8f ILL_3      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     6b SB_4       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    72 LBU_3      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     96 SH_1       00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     8a DIVU_5     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    a2 DIV_14     00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      8e _LCSRRS_1  00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    94 SW_E4      00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     ab EBREAK_2   00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    b7 IJ_3       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       b0 CSRRW_3    00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 DIV_4      9f SH_5       00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 47 DIV_5      c6 IJT_4      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     81 unx81      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    da LDAF_a     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      86 JAL_2      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_1      fe ILLe       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40002033 sloppy slt     
 * 4f DIV_2      72 LBU_3      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 50 DIV_E      72 LBU_3      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 51 DIV_F      fb SB_3       00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 52 DIVU_5     1e aFault_1   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 53 LB_6       fb SB_3       00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 54 SH_1       c5 MRET_5     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 55 SW_E1SWH   41 JALR_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 DIV_10     a8 DIV_3      01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 57 DIV_11     53 LDAF_LH    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 58 DIV_14     b6 ECALL_5    00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00002063 close to branch
 * 59 DIV_15     56 LH_4       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00002067 close to jalr
 * 5a OR_1       aa DIV_6      00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     8a DIVU_5     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    a2 DIV_14     00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       d7 ECALL_3    00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e ECAL_RET   3e SLL_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 5f EBRKWFI1   fb SB_3       00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 60 IJ_1       10 SUB_1      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00003003 close to load
 * 61 IJT_1      89 DIV_F      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 62 DIVU_3     ef WFI_5      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIVU_4     26 OR_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      75 unx75      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 ECALL_1    78 DIV_4      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 67 MRET_1     c9 MRET_2     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 68 LB_2       72 LBU_3      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd    53 LDAF_LH    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c     c7 QINT_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    bd IJ_4       00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     86 JAL_2      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e Fetch      e2 MUL_1      00000001001010001000101111101010110000  Fr11  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     f6 WFI_1      00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 MUL_1      ffffffff (null)     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 71 MUL_3      41 JALR_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 72 StdIncPc   3a SRxI_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 73 aFault     29 XOR_1      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 74 eILL0a        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 76 LBU_2      f9 MULH_2     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 77 aFaulte    f9 MULH_2     00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 78 SW_2       d4 aFault_2   00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00003063 close to branch
 * 79 aF_SW      d2 LB_2       00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00003067 close to jalr
 * 7a SLTIX_1    78 DIV_4      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     8a DIVU_5     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    a2 DIV_14     00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e Fetch2     83 DIV_2      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 7f jFault        (use dinx) 00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 80 LBU_0      bf IJT_1      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 CSRRW_2       (use dinx) 00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 82 SLTIX_2    d2 LB_2       00000000000000000100001011101000110010        Registered ALU flag to rd                         0000400b close to ij
 * 83 NMI_2      4e eILL0b     00000000110000001111010011101000110000        mtval = 0.                                        0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 jFault_1   76 Fetchu     00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 86 SLTX_1     8b LB_6       00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 87 aF_SW_1       (use dinx) 00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 88 WFI_1      56 LH_4       00110010000000000000000011001100100110 WFI    To check offset                                   00004023 close to store
 * 89 EBREAK_1   72 LBU_3      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 8a JAL_1      3a SRxI_1     00010000000000001100001011101000100000        Target adr to yy                                  40004023 close to store
 * 8b JAL_3      72 LBU_3      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      4e eILL0b     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e SLLI_1     fe ILLe       00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      40004033 sloppy xor     
 * 8f SLLI_2     a3 DIV_15     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 90 ECALL_2    8b LB_6       00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 91 LDAF_2     c8 DIV_7      00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 92 MULHU_7    8b LB_6       00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 93 SW_E4      ca DIVU_2     00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 94 SRxI_1     8b LB_6       00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 95 DIVU_1     93 SW_E2      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 96 SRxI_2     e6 StdIncPc   00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 97 ORI_1      c9 MRET_2     00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a SLL_1      8b LB_6       00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 9b SRx_1         (use dinx) 00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 9c JALR_1     36 SLLI_2     00010010000000000000000011101100100110        Q=1                                               00004073 close to csr/system 
 * 9d WFI_3      58 DIV_A      00010010000000000000101011101100100110        More check offset                                 00000000 
 * 9e ILL_1      ce _LCSRRCI_1 00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 9f ILL_2      78 DIV_4      00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_6    df eFetch     00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * a2 CSRRW_1    53 LDAF_LH    00010010000000000000000011101100100110        Construct PC storage adr                          0000500b close to ij
 * a3 ILL_4      72 LBU_3      00010000110000001110100111100x00100110        Store 2 to mcause                                 0000500f close to fence
 * a4 SRxI_0     94 SW_E4      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 aF_SW_2    d9 MULH_3     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * a6 LH_4       66 SW_1       00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * a7 MUL_2      af MRET_4     00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * a8 LH_5       46 ILL_1      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00005023 close to store
 * a9 SB_1       8b LB_6       00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * aa SB_2       ef WFI_5      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   40005023 close to store
 * ab MULHU_3    a1 ECALL_4    00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * ac _L0xac     9b unx9b      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     95 SW_E3      00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     9b unx9b      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af EBRKWFI2   ea MULHU_5    00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * b0 WFI_4      db jFault_1   00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * b1 aF_SW_3    c8 DIV_7      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * b2 MULH_1     6e DIV_C      00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * b3 QINT_2        (use dinx) 00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * b4 SB_4       bb SH_2       00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b5 IJT_3      cb QINT_2     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * b6 DIV_C      a1 ECALL_4    00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b7 MULHU_5    e8 MUL_2      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MRET_6     ffffffff (null)     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00005067 close to jalr
 * ba LBU_3      3a SRxI_1     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * bb unalignd   de Fetch      00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * bc CSRRWI_0   a2 DIV_14     00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SB_5       6e DIV_C      00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * be NMI_1      45 WFI_3      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * bf LBU_1      e9 IJT_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * c0 JAL_2      50 LW_1       10110000000000000100110011000x00100110        Return address to TRG                             00006003 close to load
 * c1 aFault_2   b5 SH_3       00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * c2 _LCSRRS_1  f2 SW_2       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000600b close to ij
 * c3 (null)     52 LH_1       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000600f close to fence
 * c4 ORI_0      97 SW_E1SWH   00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 LH_3       b9 DIV_e      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * c6 ILL_3      9f SH_5       00000010000000000000101011101100100110        Q = 1                                             00000000 
 * c7 MULH_2     b3 unxb3      00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * c8 LDAF_3     32 JAL_1      00000000000000001101100111100x00001xx0        PC to mepc                                        00006023 close to store
 * c9 SW_E2      d0 ECALL_1    00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * ca SW_E3      62 DIV_8      00110010000000000000101111001100100110        Q = 3                                             40006023 close to store
 * cb SH_4       72 LBU_3      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      4e eILL0b     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce SH_5       fe ILLe       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     40006033 sloppy or      
 * cf ECALL_4    13 condb_2    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d0 MRET_3     90 NMI_2      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * d1 (null)     f0 LBU_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d2 DIV_3      09 LB_5       01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * d3 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d4 DIV_6      c8 DIV_7      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * d5 WFI_2         (use dinx) 00010010000000000000101011101100100110        Check offset                                      00000000 
 * d6 EBREAK_2   fe ILLe       00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * d7 SB_3       cf MRET_7     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MRET_4     10 SUB_1      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00006067 close to jalr
 * da CSRRW_3    91 LDAF_2     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * db CSRRW_4    c8 DIV_7      00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * dc CSRRSI_0   a2 DIV_14     00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd eFetch3    a5 MRET_3     0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * de SH_3       7e NMI_1      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * df ECALL_5    7e NMI_1      00110010000000000000101011001100100110        Q = 8                                             00000000 
 * e0 IJ_3       f2 SW_2       00010010000000000000110011101100100110        Construct Q = 1                                   00007003 close to load
 * e1 (null)     3d SRxI_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e2 DIV_e      a7 EBRKWFI1   00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      0000700b close to ij
 * e3 (null)     3a SRxI_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     b1 aF_SW_3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e6 SH_2       6e DIV_C      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * e7 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e8 IJ_4       70 LHU_2      00000100000010001010110111100100011xx0        Mask and use as PC                                00007023 close to store
 * e9 IJT_2      eb LH_3       00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * ea MRET_5     4b CSRRW_2    00000010000000000000000011101100010xx0        ~302                                              40007023 close to store
 * eb IJT_4      a6 ECAL_RET   00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     95 SW_E3      00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee QINT_1     fe ILLe       00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40007033 sloppy and     
 * ef DIV_7      6e DIV_C      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f0 MRET_2     ba LHU_3      00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * f1 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f2 DIVU_2     72 LBU_3      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f3 (null)     87 unx87      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 _LCSRRCI_1 dd aF_SW_1    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f5 (null)     85 LBU_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f6 MRET_7     d5 Fetch2u    00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f7 (null)     d6 eILL0c     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 Fetch2u    fa WFI_2      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00007067 close to jalr
 * fa MULH_3     9d DIV_11     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * fb LDAF_a     b4 eFetch3    00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * fc CSRRCI_0   a2 DIV_14     00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      be IJ_1       00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       9e SH_4       00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     ee eILL0a     00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0008, used ffff, inputs 8e
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       7e NMI_1      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       72 LBU_3      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     94 SW_E4      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     94 SW_E4      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 CSRRW_2    0b JALR_2     00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 07 NMI_2      1a ANDI_1     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 08 _L0x08     d5 Fetch2u    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       63 DIV_9      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     d5 Fetch2u    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       f4 Fetch2     00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      90 NMI_2      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     94 SW_E4      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 condb_5    63 DIV_9      00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 11 condb_5t   3a SRxI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 12 MULHU_2    54 LH_2       00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 13 MULHU_4    2e MULHU_1    00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 14 eILL0b     39 MULHU_7    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 15 MRET_8     10 SUB_1      00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 16 LDAF_2     94 SW_E4      00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 17 SW_E4      8e _LCSRRS_1  00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     c8 DIV_7      00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       94 SW_E4      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   70 LHU_2      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     94 SW_E4      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LW_1       46 ILL_1      00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 1f LDAF_LW    86 JAL_2      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 20 LH_0       30 SLTIX_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      94 SW_E4      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      be IJ_1       00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     94 SW_E4      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     af MRET_4     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 ECALL_6    5d SB_2       00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 27 ILL_4      3d SRxI_2     00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 28 _L0x28     68 DIV_12     00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     68 DIV_12     00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      c1 IJT_2      00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     e0 DIVU_1     00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    12 straddle   00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     94 SW_E4      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_1       94 SW_E4      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LH    7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 LH_2       f4 Fetch2     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 33 aFaultb       (use dinx) 00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 34 DIV_A      8e _LCSRRS_1  00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 35 DIV_B      b9 DIV_e      00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 36 aF_SW_3    03 _L0x03     00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 37 QINT_2     89 DIV_F      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    94 SW_E4      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     c0 DIV_D      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    d0 ECALL_1    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_1      af MRET_4     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LHU   bf IJT_1      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       1e aFault_1   00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 DIV_8      dd aF_SW_1    00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000200b close to ij
 * 43 DIV_9      bb SH_2       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       df eFetch     00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 aFault_2   cf MRET_7     00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 47 (null)     f9 MULH_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 48 _L0x48     4e eILL0b     00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     06 LB_3       00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     4e eILL0b     00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    d3 aFaultd    00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e SW_1       fe ILLe       00000000000000000011111011100100001xx0        Write d to a+k until accepted                     40002033 sloppy slt     
 * 4f SW_E1SWE   94 SW_E4      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 50 DIV_12     94 SW_E4      00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 51 DIV_13     f7 EBREAK_1   00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 52 LHU_2      32 JAL_1      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 53 aFaultc    f7 EBREAK_1   00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 54 Fetchu     ca DIVU_2     00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00000000 
 * 55 eFetchu    41 JALR_1     00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 56 (null)     d4 aFault_2   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 57 (null)     63 DIV_9      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 58 DIV_4      e5 aF_SW_2    00000000000000001100000011101000110000        ~abs(divisor) to yy                               00002063 close to branch
 * 59 DIV_5      6a MULH_1     00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00002067 close to jalr
 * 5a OR_1       d9 MULH_3     00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    d0 ECALL_1    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       db jFault_1   00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIV_1      52 LH_1       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 5f DIV_2      f7 EBREAK_1   00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 60 DIV_E      12 straddle   01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003003 close to load
 * 61 DIV_F      b5 SH_3       00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 62 DIVU_5     c6 IJT_4      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               0000300b close to ij
 * 63 LB_6       34 JAL_3      00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      9d DIV_11     00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 (null)     a8 DIV_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 67 (null)     83 DIV_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 68 SH_1       94 SW_E4      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00003023 close to store
 * 69 SW_E1SWH   63 DIV_9      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 6a DIV_10     cb QINT_2     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    40003023 close to store
 * 6b DIV_11     ef WFI_5      01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_14     87 unx87      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 40003033 sloppy sltu    
 * 6f DIV_15     e6 StdIncPc   00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 70 ECAL_RET   ffffffff (null)     00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 71 EBRKWFI1   41 JALR_1     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 72 IJ_1       3a SRxI_1     00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * 73 IJT_1      29 XOR_1      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 74 DIVU_3        (use dinx) 00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 75 DIVU_4        (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 76 (null)     e7 aFault     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 77 (null)     e7 aFault     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 78 ECALL_1    c2 DIVU_3     00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00003063 close to branch
 * 79 MRET_1     b3 unxb3      00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00003067 close to jalr
 * 7a SLTIX_1    a8 DIV_3      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    d0 ECALL_1    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e LB_2       07 LB_4       00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 7f aFaultd       (use dinx) 00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 80 LBU_0      f1 aFaulte    00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 LDAF_3     b3 unxb3      00000000000000001101100111100x00001xx0        PC to mepc                                        0000400b close to ij
 * 83 SW_E2      5e LHU_1      00000000000000001101101111101000001xx0        Store address that faulted                        0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     9e SH_4       00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 IJ_3       a5 MRET_3     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 87 DIV_e         (use dinx) 00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 88 eILL0c     6a MULH_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00004023 close to store
 * 89 ECALL_3    94 SW_E4      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 8a jFault_1   3a SRxI_1     00010000000000001110001011100x00100110        Store 1 to mcause                                 40004023 close to store
 * 8b aF_SW_1    94 SW_E4      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      5e LHU_1      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e Fetch      fe ILLe       00000001001010001000101111101010110000  Fr11  Read and latch instruction                        40004033 sloppy xor     
 * 8f eFetch     27 OR_2       00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 90 MUL_1      a5 MRET_3     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 91 MUL_3      82 DIV_1      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 92 SW_E3      a5 MRET_3     00110010000000000000101111001100100110        Q = 3                                             00000000 
 * 93 SH_4       92 LDAF_3     00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 94 StdIncPc   a5 MRET_3     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 95 aFault     17 condb_5t   00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 96 SH_2       96 SH_1       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 97 IJ_4       83 DIV_2      00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a DIVU_1     a5 MRET_3     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 9b ORI_1         (use dinx) 00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 9c eILL0a     50 LW_1       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00004073 close to csr/system 
 * 9d WFI_5      6e DIV_C      00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 9e LBU_2      a2 DIV_14     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 9f aFaulte    a8 DIV_3      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * a0 LHU_0      3e SLL_1      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JAL_1      f3 aF_SW      00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * a2 SH_5       63 DIV_9      00000000000000000001110011100100001xx0        Write d to a+k until accepted                     0000500b close to ij
 * a3 ECALL_4    94 SW_E4      00110010000000000000101011001100100110        Q = 4                                             0000500f close to fence
 * a4 SRxI_0     bf IJT_1      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 JAL_3      d2 LB_2       00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a6 IJT_2      78 DIV_4      00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * a7 MRET_5     de Fetch      00000010000000000000000011101100010xx0        ~302                                              00000000 
 * a8 SW_2       58 DIV_A      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00005023 close to store
 * a9 aF_SW      a5 MRET_3     00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * aa aF_SW_2    c6 IJT_4      00110010000000000000101011001100100110        Q = 4                                             40005023 close to store
 * ab MUL_2      26 OR_1       00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * ac _L0xac     c5 MRET_5     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     9a ECALL_6    00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     c5 MRET_5     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SLLI_1     a7 EBRKWFI1   00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * b0 Fetch2     e2 MUL_1      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * b1 jFault     82 DIV_1      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * b2 MRET_3     8e _LCSRRS_1  00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * b3 DIV_3         (use dinx) 01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * b4 WFI_1      ee eILL0a     00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * b5 EBREAK_1   93 SW_E2      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * b6 IJT_4      26 OR_1       00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * b7 QINT_1     97 SW_E1SWH   00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SLLI_2     ffffffff (null)     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00005067 close to jalr
 * ba IJT_3      3a SRxI_1     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * bb MULHU_5    f2 SW_2       00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * bc CSRRWI_0   d0 ECALL_1    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ECALL_2    8e _LCSRRS_1  00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * be MULHU_7    45 WFI_3      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * bf SRxI_1     a6 ECAL_RET   00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * c0 SRxI_2     60 MULHU_3    00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00006003 close to load
 * c1 SLL_1      ba LHU_3      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * c2 DIV_6      d6 eILL0c     00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            0000600b close to ij
 * c3 EBREAK_2   62 DIV_8      00000000000000001101101011101000001xx0        pc to mepc                                        0000600f close to fence
 * c4 ORI_0      9b unx9b      00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 SRx_1      e8 MUL_2      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * c6 DIV_7      cf MRET_7     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * c7 MRET_2     37 ECALL_2    00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * c8 JALR_1     42 MULHU_2    00010010000000000000000011101100100110        Q=1                                               00006023 close to store
 * c9 WFI_3      b2 CSRRW_4    00010010000000000000101011101100100110        More check offset                                 00000000 
 * ca LH_3       74 unx74      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 40006023 close to store
 * cb MULH_2     94 SW_E4      00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      5e LHU_1      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce ILL_1      fe ILLe       00000000000000001101101011100x00001xx0        Store PC to mepc                                  40006033 sloppy or      
 * cf ILL_2      15 condb_4    00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * d0 CSRRW_1    bd IJ_4       00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * d1 LH_4       c7 QINT_1     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * d2 MRET_4     09 LB_5       00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * d3 CSRRW_3    41 JALR_1     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * d4 LH_5       82 DIV_1      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * d5 SB_1          (use dinx) 00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * d6 DIVU_2     fe ILLe       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d7 _LCSRRCI_1 a3 DIV_15     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 SB_2       12 straddle   00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00006067 close to jalr
 * da WFI_2      16 condb_5    00010010000000000000101011101100100110        Check offset                                      00000000 
 * db SB_3       82 DIV_1      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * dc CSRRSI_0   d0 ECALL_1    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd MULHU_3    aa DIV_6      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * de EBRKWFI2   b0 CSRRW_3    00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * df WFI_4      b0 CSRRW_3    00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * e0 MULH_1     d6 eILL0c     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00007003 close to load
 * e1 SB_4       3d SRxI_2     00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * e2 CSRRW_4    ab EBREAK_2   00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      0000700b close to ij
 * e3 eFetch3    3a SRxI_1     0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 DIV_C      36 SLLI_2     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * e6 MRET_7     8e _LCSRRS_1  00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * e7 Fetch2u    41 JALR_1     0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * e8 MRET_6     90 NMI_2      00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00007023 close to store
 * e9 LBU_3      b6 ECALL_5    00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * ea (null)     4b CSRRW_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   40007023 close to store
 * eb (null)     d1 MRET_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     9a ECALL_6    00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee unalignd   fe ILLe       00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                40007033 sloppy and     
 * ef SB_5       8e _LCSRRS_1  00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * f0 NMI_1      e9 IJT_3      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * f1 LBU_1      41 JALR_1     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * f2 SH_3       94 SW_E4      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f3 ECALL_5    8b LB_6       00110010000000000000101011001100100110        Q = 8                                             00000000 
 * f4 JAL_2      e3 MUL_3      10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * f5 _LCSRRS_1  8a DIVU_5     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f6 MULH_3     da LDAF_a     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * f7 LDAF_a     c3 DIVU_4     00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 ILL_3      f6 WFI_1      00000010000000000000101011101100100110        Q = 1                                             00007067 close to jalr
 * fa (null)     c9 MRET_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     e1 ORI_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   d0 ECALL_1    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      f0 LBU_2      00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       ce _LCSRRCI_1 00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     b7 IJ_3       00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0040, used ffff, inputs 93
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       94 SW_E4      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       88 DIV_E      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     9e SH_4       00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     9e SH_4       00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   13 condb_2    00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     b9 DIV_e      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       6b SB_4       00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     b9 DIV_e      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       ce _LCSRRCI_1 00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      9c DIV_10     00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      1d ORI_2      00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     9e SH_4       00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    6b SB_4       00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    2e MULHU_1    00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 CSRRW_2    60 MULHU_3    00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 13 LB_5       29 XOR_1      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 14 eILL0b     2b SLTIX_1    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 15 MRET_8     06 LB_3       00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 16 NMI_2      9e SH_4       00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 17 JALR_2     9a ECALL_6    00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 18 BEQ        22 MULHU_6    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     8a DIVU_5     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LDAF_2     9e SH_4       00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 1b _L0x1b     5f LDAF_LHU   00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   78 DIV_4      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d SUB_1      9e SH_4       00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 1e SW_E4      52 LH_1       00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 1f AND_1      e6 StdIncPc   00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 20 LH_0       30 SLTIX_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 straddle   9e SH_4       10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 22 condb_2    7f unx7f      00000010000000000000111111101100000xx0        ~RS2 in Q                                         0000100b close to ij
 * 23 _L0x23     9e SH_4       00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     73 unalignd   00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 LW_1       45 WFI_3      00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LW    33 unx33      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     6e DIV_C      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_3    3d SRxI_2     00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2a _L0x2a     6e DIV_C      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_4    57 LH_5       00000010000000000000000011101101001xx0        Branch on condition                               00000000 
 * 2c SLL_0      85 LBU_1      00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     bf IJT_1      00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e ANDI_1     10 SUB_1      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     9e SH_4       00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_1       9e SH_4       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LH    4b CSRRW_2    00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 ECALL_6    ce _LCSRRCI_1 00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 33 ORI_2         (use dinx) 00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 34 LH_2       9a ECALL_6    00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 35 aFaultb    77 eFetchu    00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 36 ILL_4      03 _L0x03     00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 37 aFault_1   97 SW_E1SWH   00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 38 BNE        22 MULHU_6    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 IJ_2       9e SH_4       00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00001067 close to jalr
 * 3a aF_SW_3    82 DIV_1      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 3b _L0x3b     5f LDAF_LHU   00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    a5 MRET_3     00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d XORI_1     03 _L0x03     00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 3e QINT_2     73 unalignd   00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 3f MULHU_6    81 unx81      00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 40 LW_0       26 OR_1       00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 OR_1       17 condb_5t   00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 42 DIV_A      bb SH_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               0000200b close to ij
 * 43 DIV_B      af MRET_4     00000000000000001100111111101000110000        REM = Q to yy                                     0000200f close to fence
 * 44 SLTI_0     4b CSRRW_2    00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 OR_2       be IJ_1       00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 46 LHU_1      a2 DIV_14     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 47 LDAF_LHU   d1 MRET_1     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 48 _L0x48     50 LW_1       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XOR_1      12 straddle   00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 4a _L0x4a     50 LW_1       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b SLTIX_1    df eFetch     00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 4c SLT_0      5d SB_2       00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   53 LDAF_LH    00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_8      fe ILLe       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           40002033 sloppy slt     
 * 4f DIV_9      9e SH_4       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 50 SW_1       9e SH_4       00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 51 SW_E1SWE   fb SB_3       00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 52 aFault_2   34 JAL_3      00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 53 MULHU_1    fb SB_3       00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 54 DIV_12     c3 DIVU_4     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 55 DIV_13     37 ECALL_2    00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 56 (null)     aa DIV_6      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 57 SLTIX_2    6b SB_4       00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 58 LHU_2      c1 IJT_2      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00002063 close to branch
 * 59 aFaultc    70 LHU_2      00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00002067 close to jalr
 * 5a (null)     ba LHU_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 5b _L0x5b     5f LDAF_LHU   00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    a5 MRET_3     00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLTX_1     cf MRET_7     00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 5e (null)     58 DIV_A      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 5f JAL_1      fb SB_3       00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 60 Fetchu     10 SUB_1      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00003003 close to load
 * 61 eFetchu    b7 IJ_3       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 62 DIV_4      f3 aF_SW      00000000000000001100000011101000110000        ~abs(divisor) to yy                               0000300b close to ij
 * 63 DIV_5      42 MULHU_2    00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               0000300f close to fence
 * 64 SLTIU_0    4b CSRRW_2    00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 JAL_3      a9 ILL_4      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 66 DIV_1      b2 CSRRW_4    00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 67 DIV_2      d3 aFaultd    00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 68 DIV_E      9e SH_4       01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003023 close to store
 * 69 DIV_F      6b SB_4       00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 6a DIVU_5     c7 QINT_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               40003023 close to store
 * 6b LB_6       c8 DIV_7      00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 6c SLTU_0     5d SB_2       00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    53 LDAF_LH    00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e SH_1       e8 MUL_2      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        40003033 sloppy sltu    
 * 6f SW_E1SWH   f7 EBREAK_1   00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 70 DIV_10     ffffffff (null)     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 71 DIV_11     37 ECALL_2    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 72 (null)     2e MULHU_1    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 73 SLLI_1     21 XORI_1     00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 74 DIV_14        (use dinx) 00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00000000 
 * 75 DIV_15        (use dinx) 00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 76 (null)     f9 MULH_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 77 SLLI_2     f9 MULH_2     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 78 ECAL_RET   db jFault_1   00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00003063 close to branch
 * 79 EBRKWFI1   da LDAF_a     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00003067 close to jalr
 * 7a (null)     b2 CSRRW_4    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 7b _L0x7b     5f LDAF_LHU   00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    a5 MRET_3     00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d ECALL_2       (use dinx) 00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 7e (null)     16 condb_5    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 7f MULHU_7       (use dinx) 00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 80 LBU_0      ca DIVU_2     00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SRxI_1        (use dinx) 00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 82 SRxI_2     da LDAF_a     00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                0000400b close to ij
 * 83 jFault_1   66 SW_1       00010000000000001110001011100x00100110        Store 1 to mcause                                 0000400f close to fence
 * 84 XORI_0     3d SRxI_2     00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLL_1      b0 CSRRW_3    00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 86 SRx_1      65 WFI_4      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 87 aF_SW_1       (use dinx) 00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 88 IJ_1       70 LHU_2      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00004023 close to store
 * 89 IJT_1      9e SH_4       00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 8a JALR_1     2e MULHU_1    00010010000000000000000011101100100110        Q=1                                               40004023 close to store
 * 8b DIVU_1     9e SH_4       00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 8c XOR_0      49 CSRRW_1    00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      66 SW_1       01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e WFI_3      fe ILLe       00010010000000000000101011101100100110        More check offset                                 40004033 sloppy xor     
 * 8f ORI_1      36 SLLI_2     00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 90 DIVU_3     65 WFI_4      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 91 DIVU_4     d2 LB_2       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 92 ECALL_1    65 WFI_4      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 93 MRET_1     d4 aFault_2   00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 94 LB_2       65 WFI_4      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 95 aFaultd    1e aFault_1   00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 96 eILL0c     e9 IJT_3      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 97 ECALL_3    d3 aFaultd    00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 98 BLT        22 MULHU_6    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a Fetch      65 WFI_4      00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 9b eFetch        (use dinx) 00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 9c MUL_1      54 LH_2       00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00004073 close to csr/system 
 * 9d MUL_3      74 unx74      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 9e StdIncPc   d6 eILL0c     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 9f aFault     b2 CSRRW_4    00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * a0 LHU_0      46 ILL_1      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ILL_1      e5 aF_SW_2    00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * a2 ILL_2      6b SB_4       00000000000000001111101011101000001xx0        Store 0 to mtval                                  0000500b close to ij
 * a3 aF_SW_2    9e SH_4       00110010000000000000101011001100100110        Q = 4                                             0000500f close to fence
 * a4 SRxI_0     81 unx81      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 CSRRW_1    de Fetch      00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * a6 LH_4       92 LDAF_3     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * a7 MUL_2      bd IJ_4       00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * a8 eILL0a     62 DIV_8      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00005023 close to store
 * a9 WFI_5      65 WFI_4      00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * aa LH_5       f3 aF_SW      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               40005023 close to store
 * ab IJT_3      32 JAL_1      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * ac _L0xac     86 JAL_2      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     8b LB_6       00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     86 JAL_2      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MULHU_5    f0 LBU_2      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * b0 LBU_2      e0 DIVU_1     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * b1 aFaulte    d2 LB_2       00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * b2 SW_2       9a ECALL_6    00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * b3 aF_SW         (use dinx) 00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * b4 Fetch2     c6 IJT_4      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * b5 jFault     d5 Fetch2u    00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * b6 WFI_1      32 JAL_1      00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * b7 EBREAK_1   ea MULHU_5    00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * b8 BGE        22 MULHU_6    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SB_1       ffffffff (null)     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00005067 close to jalr
 * ba SB_2       2e MULHU_1    00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * bb MULHU_3    e2 MUL_1      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * bc CSRRWI_0   a5 MRET_3     00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd EBRKWFI2   9a ECALL_6    00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * be WFI_4      39 MULHU_7    00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * bf MULH_1     ee eILL0a     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * c0 SB_4       68 DIV_12     00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00006003 close to load
 * c1 DIV_C      ab EBREAK_2   00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * c2 MRET_6     f5 jFault     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            0000600b close to ij
 * c3 LH_3       6a MULH_1     00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 0000600f close to fence
 * c4 ORI_0      8f ILL_3      00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 LBU_3      c2 DIVU_3     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * c6 unalignd   a2 DIV_14     00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * c7 MULH_2     3e SLL_1      00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * c8 SB_5       4e eILL0b     00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00006023 close to store
 * c9 NMI_1      d9 MULH_3     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * ca LBU_1      90 NMI_2      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40006023 close to store
 * cb WFI_2      9e SH_4       00010010000000000000101011101100100110        Check offset                                      00000000 
 * cc OR_0       41 JALR_1     00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      66 SW_1       01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce JAL_2      fe ILLe       10110000000000000100110011000x00100110        Return address to TRG                             40006033 sloppy or      
 * cf SB_3       15 condb_4    00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d0 _LCSRRS_1  7d unx7d      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d1 ILL_3      f4 Fetch2     00000010000000000000101011101100100110        Q = 1                                             00000000 
 * d2 LDAF_3     09 LB_5       00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * d3 SW_E2      37 ECALL_2    00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * d4 SW_E3      d2 LB_2       00110010000000000000101111001100100110        Q = 3                                             00000000 
 * d5 SH_4          (use dinx) 00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * d6 SH_5       fe ILLe       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * d7 ECALL_4    d7 ECALL_3    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d8 BLTU       22 MULHU_6    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MRET_3     10 SUB_1      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00006067 close to jalr
 * da DIV_3      1a ANDI_1     01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * db DIV_6      d2 LB_2       00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * dc CSRRSI_0   a5 MRET_3     00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd EBREAK_2   a3 DIV_15     00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * de MRET_4     b4 eFetch3    00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * df CSRRW_3    b4 eFetch3    00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * e0 CSRRW_4    f5 jFault     00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00007003 close to load
 * e1 eFetch3    33 unx33      0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * e2 SH_3       a7 EBRKWFI1   00000010000000000000000011101000110000        Prepare get back address to use                   0000700b close to ij
 * e3 (null)     2e MULHU_1    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     2e MULHU_1    00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 ECALL_5    3a SRxI_1     00110010000000000000101011001100100110        Q = 8                                             00000000 
 * e6 IJ_3       9a ECALL_6    00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * e7 (null)     37 ECALL_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e8 DIV_e      9c DIV_10     00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00007023 close to store
 * e9 SH_2       f1 aFaulte    00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * ea IJ_4       3f SRx_1      00000100000010001010110111100100011xx0        Mask and use as PC                                40007023 close to store
 * eb (null)     a6 ECAL_RET   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ec AND_0      1f IJ_2       00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     8b LB_6       00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee IJT_2      fe ILLe       00000000000000001100101011101000110000        Read word is to be masked with ~1u                40007033 sloppy and     
 * ef (null)     9a ECALL_6    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f0 MRET_5     c5 MRET_5     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * f1 IJT_4      37 ECALL_2    00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * f2 QINT_1     9e SH_4       00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * f3 DIV_7      87 unx87      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f4 MRET_2     e1 ORI_1      00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * f5 DIVU_2     83 DIV_2      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f6 _LCSRRCI_1 cb QINT_2     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f7 MRET_7     dd aF_SW_1    00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f8 BGEU       22 MULHU_6    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 Fetch2u    fa WFI_2      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00007067 close to jalr
 * fa MULH_3     8e _LCSRRS_1  00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * fb LDAF_a     c0 DIV_D      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * fc CSRRCI_0   a5 MRET_3     00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      c9 MRET_2     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       a1 ECALL_4    00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     f2 SW_2       00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0080, used ffff, inputs 95
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       92 LDAF_3     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       86 JAL_2      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     9c DIV_10     00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     9c DIV_10     00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   14 condb_3    00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     b9 DIV_e      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       6b SB_4       00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     b9 DIV_e      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       cf MRET_7     00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      9a ECALL_6    00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      1a ANDI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     9c DIV_10     00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    6b SB_4       00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    2e MULHU_1    00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     60 MULHU_3    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     29 XOR_1      00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LB_5       2b SLTIX_1    00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 15 CSRRW_2    06 LB_3       00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 16 JALR_2     9c DIV_10     00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 17 NMI_2      96 SH_1       00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 18 BEQ        22 MULHU_6    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     a2 DIV_14     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a SUB_1      9c DIV_10     00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 1b _L0x1b     5e LHU_1      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   78 DIV_4      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d LDAF_2     9c DIV_10     00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 1e AND_1      55 aFaultb    00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 1f SW_E4      e7 aFault     00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 20 LH_0       30 SLTIX_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 straddle   9c DIV_10     10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 22 condb_2    7e NMI_1      00000010000000000000111111101100000xx0        ~RS2 in Q                                         0000100b close to ij
 * 23 _L0x23     9c DIV_10     00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     74 unx74      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 LW_1       45 WFI_3      00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LW    34 JAL_3      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     6e DIV_C      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_3    3a SRxI_1     00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2a _L0x2a     6e DIV_C      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_4    56 LH_4       00000010000000000000000011101101001xx0        Branch on condition                               00000000 
 * 2c SLL_0      88 DIV_E      00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     bf IJT_1      00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e ANDI_1     10 SUB_1      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     9c DIV_10     00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_1       9c DIV_10     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LH    4b CSRRW_2    00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 LH_2       cf MRET_7     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 33 aFaultb       (use dinx) 00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 34 ORI_2      96 SH_1       00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 35 ECALL_6    76 Fetchu     00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 36 aFault_1   03 _L0x03     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 37 ILL_4      95 SW_E3      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 38 BNE        22 MULHU_6    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 IJ_2       9c DIV_10     00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00001067 close to jalr
 * 3a XORI_1     85 LBU_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 3b _L0x3b     5e LHU_1      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    af MRET_4     00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d aF_SW_3    03 _L0x03     00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 3e MULHU_6    74 unx74      00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 3f QINT_2     82 DIV_1      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 40 LW_0       26 OR_1       00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 OR_1       16 condb_5    00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 42 DIV_A      bb SH_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               0000200b close to ij
 * 43 DIV_B      ab EBREAK_2   00000000000000001100111111101000110000        REM = Q to yy                                     0000200f close to fence
 * 44 SLTI_0     4b CSRRW_2    00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 OR_2       be IJ_1       00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 46 LHU_1      aa DIV_6      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 47 LDAF_LHU   d1 MRET_1     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 48 _L0x48     50 LW_1       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XOR_1      15 condb_4    00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 4a _L0x4a     50 LW_1       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b SLTIX_1    df eFetch     00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 4c SLT_0      5a SB_1       00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   54 LH_2       00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_8      fe ILLe       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           40002033 sloppy slt     
 * 4f DIV_9      9c DIV_10     01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 50 SW_1       9c DIV_10     00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 51 SW_E1SWE   fb SB_3       00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 52 DIV_12     32 JAL_1      00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 53 DIV_13     fb SB_3       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 54 MULHU_1    c1 IJT_2      00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 55 aFault_2   36 SLLI_2     00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 56 SLTIX_2    b7 IJ_3       00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 57 (null)     6b SB_4       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 58 LHU_2      c2 DIVU_3     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00002063 close to branch
 * 59 aFaultc    70 LHU_2      00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00002067 close to jalr
 * 5a SLTX_1     ba LHU_3      00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 5b _L0x5b     5e LHU_1      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    af MRET_4     00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d (null)     cb QINT_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 5e JAL_1      58 DIV_A      00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 5f (null)     fb SB_3       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 60 Fetchu     10 SUB_1      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00003003 close to load
 * 61 eFetchu    b5 SH_3       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 62 DIV_4      f3 aF_SW      00000000000000001100000011101000110000        ~abs(divisor) to yy                               0000300b close to ij
 * 63 DIV_5      42 MULHU_2    00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               0000300f close to fence
 * 64 SLTIU_0    4b CSRRW_2    00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 JAL_3      9f SH_5       00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 66 DIV_1      b0 CSRRW_3    00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 67 DIV_2      d3 aFaultd    00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 68 DIV_E      9c DIV_10     01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003023 close to store
 * 69 DIV_F      6b SB_4       00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 6a DIVU_5     c3 DIVU_4     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               40003023 close to store
 * 6b LB_6       c8 DIV_7      00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 6c SLTU_0     5a SB_1       00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    54 LH_2       00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e SH_1       e8 MUL_2      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        40003033 sloppy sltu    
 * 6f SW_E1SWH   f7 EBREAK_1   00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 70 DIV_10     ffffffff (null)     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 71 DIV_11     36 SLLI_2     01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 72 DIV_14     2e MULHU_1    00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00000000 
 * 73 DIV_15     21 XORI_1     00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 74 SLLI_1        (use dinx) 00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 75 (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 76 SLLI_2     f9 MULH_2     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 77 (null)     f9 MULH_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 78 ECAL_RET   db jFault_1   00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00003063 close to branch
 * 79 EBRKWFI1   da LDAF_a     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00003067 close to jalr
 * 7a ECALL_2    b0 CSRRW_3    00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 7b _L0x7b     5e LHU_1      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    af MRET_4     00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 7e MULHU_7    17 condb_5t   00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 7f (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 80 LBU_0      ce _LCSRRCI_1 00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 jFault_1      (use dinx) 00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 82 SRxI_1     da LDAF_a     00000000000000000100101001101100001xx1        Register to shift to Q                            0000400b close to ij
 * 83 aF_SW_1    66 SW_1       00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      0000400f close to fence
 * 84 XORI_0     3a SRxI_1     00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SRxI_2     a6 ECAL_RET   00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 86 IJ_1       65 WFI_4      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * 87 IJT_1         (use dinx) 00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 88 SLL_1      70 LHU_2      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00004023 close to store
 * 89 DIVU_1     9c DIV_10     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 8a SRx_1      2e MULHU_1    00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  40004023 close to store
 * 8b ORI_1      9c DIV_10     00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 8c XOR_0      49 CSRRW_1    00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      66 SW_1       01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e DIVU_3     fe ILLe       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           40004033 sloppy xor     
 * 8f DIVU_4     37 ECALL_2    01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 90 ECALL_1    65 WFI_4      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 91 MRET_1     d2 LB_2       00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 92 LB_2       65 WFI_4      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 93 aFaultd    d4 aFault_2   00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 94 eILL0c     65 WFI_4      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 95 ECALL_3    1f IJ_2       00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 96 Fetch      ea MULHU_5    00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * 97 eFetch     d3 aFaultd    00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 98 BLT        22 MULHU_6    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a MUL_1      65 WFI_4      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 9b MUL_3         (use dinx) 00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 9c StdIncPc   52 LH_1       10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00004073 close to csr/system 
 * 9d aFault     72 LBU_3      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 9e eILL0a     d6 eILL0c     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 9f WFI_5      b0 CSRRW_3    00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * a0 LHU_0      46 ILL_1      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 aF_SW_2    e6 StdIncPc   00110010000000000000101011001100100110        Q = 4                                             00000000 
 * a2 JALR_1     6b SB_4       00010010000000000000000011101100100110        Q=1                                               0000500b close to ij
 * a3 MUL_2      9c DIV_10     00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  0000500f close to fence
 * a4 SRxI_0     82 DIV_1      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 WFI_3      de Fetch      00010010000000000000101011101100100110        More check offset                                 00000000 
 * a6 LBU_2      90 NMI_2      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * a7 aFaulte    bd IJ_4       00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * a8 ILL_1      62 DIV_8      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00005023 close to store
 * a9 IJT_3      65 WFI_4      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * aa ILL_2      f3 aF_SW      00000000000000001111101011101000001xx0        Store 0 to mtval                                  40005023 close to store
 * ab MULHU_5    35 SLLI_1     00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * ac _L0xac     8a DIVU_5     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     89 DIV_F      00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     8a DIVU_5     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af CSRRW_1    f0 LBU_2      00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * b0 SW_2       e0 DIVU_1     00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * b1 aF_SW      d2 LB_2       00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * b2 Fetch2     96 SH_1       00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * b3 jFault        (use dinx) 00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * b4 WFI_1      c7 QINT_1     00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * b5 EBREAK_1   d5 Fetch2u    00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * b6 LH_4       35 SLLI_1     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * b7 LH_5       ee eILL0a     00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * b8 BGE        22 MULHU_6    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SB_1       ffffffff (null)     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00005067 close to jalr
 * ba SB_2       2e MULHU_1    00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * bb MULHU_3    e5 aF_SW_2    00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * bc CSRRWI_0   af MRET_4     00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd EBRKWFI2   96 SH_1       00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * be WFI_4      39 MULHU_7    00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * bf MULH_1     ef WFI_5      00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * c0 SB_4       68 DIV_12     00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00006003 close to load
 * c1 LH_3       a9 ILL_4      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * c2 DIV_C      f5 jFault     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              0000600b close to ij
 * c3 MULH_2     6a MULH_1     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                0000600f close to fence
 * c4 ORI_0      8b LB_6       00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_6     c5 MRET_5     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * c6 LBU_3      aa DIV_6      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * c7 unalignd   3f SRx_1      00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * c8 SB_5       4e eILL0b     00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00006023 close to store
 * c9 WFI_2      d9 MULH_3     00010010000000000000101011101100100110        Check offset                                      00000000 
 * ca NMI_1      8e _LCSRRS_1  00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40006023 close to store
 * cb SB_3       9c DIV_10     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * cc OR_0       41 JALR_1     00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      66 SW_1       01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce LBU_1      fe ILLe       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40006033 sloppy or      
 * cf JAL_2      13 condb_2    10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * d0 _LCSRRS_1  7a SB_5       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d1 ILL_3      f4 Fetch2     00000010000000000000101011101100100110        Q = 1                                             00000000 
 * d2 LDAF_3     09 LB_5       00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * d3 SW_E2      36 SLLI_2     00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * d4 SW_E3      d2 LB_2       00110010000000000000101111001100100110        Q = 3                                             00000000 
 * d5 SH_4          (use dinx) 00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * d6 SH_5       fe ILLe       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * d7 ECALL_4    d7 ECALL_3    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d8 BLTU       22 MULHU_6    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MRET_3     10 SUB_1      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00006067 close to jalr
 * da DIV_3      1d ORI_2      01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * db DIV_6      d2 LB_2       00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * dc CSRRSI_0   af MRET_4     00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd EBREAK_2   a1 ECALL_4    00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * de MRET_4     b2 CSRRW_4    00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * df CSRRW_3    b2 CSRRW_4    00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * e0 CSRRW_4    f5 jFault     00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00007003 close to load
 * e1 (null)     34 JAL_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e2 eFetch3    a3 DIV_15     0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   0000700b close to ij
 * e3 (null)     2e MULHU_1    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     2e MULHU_1    00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SH_3       3d SRxI_2     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e6 ECALL_5    96 SH_1       00110010000000000000101011001100100110        Q = 8                                             00000000 
 * e7 IJ_3       36 SLLI_2     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * e8 DIV_e      9a ECALL_6    00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00007023 close to store
 * e9 (null)     f1 aFaulte    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ea SH_2       3e SLL_1      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      40007023 close to store
 * eb (null)     b6 ECALL_5    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ec AND_0      1e aFault_1   00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     89 DIV_F      00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee IJ_4       fe ILLe       00000100000010001010110111100100011xx0        Mask and use as PC                                40007033 sloppy and     
 * ef IJT_2      96 SH_1       00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * f0 MRET_5     c6 IJT_4      00000010000000000000000011101100010xx0        ~302                                              00000000 
 * f1 IJT_4      36 SLLI_2     00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * f2 QINT_1     9c DIV_10     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * f3 DIV_7      83 DIV_2      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f4 MRET_2     e2 MUL_1      00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * f5 DIVU_2     81 unx81      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f6 _LCSRRCI_1 c9 MRET_2     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f7 MRET_7     dd aF_SW_1    00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f8 BGEU       22 MULHU_6    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 Fetch2u    fa WFI_2      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00007067 close to jalr
 * fa MULH_3     a5 MRET_3     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * fb LDAF_a     c0 DIV_D      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * fc CSRRCI_0   af MRET_4     00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      ca DIVU_2     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       a8 DIV_3      00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     f2 SW_2       00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0080, used ffff, inputs 96
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       78 DIV_4      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       70 LHU_2      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     90 NMI_2      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     90 NMI_2      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     c5 MRET_5     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       63 DIV_9      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     c5 MRET_5     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       dd aF_SW_1    00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      8e _LCSRRS_1  00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     90 NMI_2      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    63 DIV_9      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     52 LH_1       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 CSRRW_2    90 NMI_2      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 17 NMI_2      88 DIV_E      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     b7 IJ_3       00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       90 NMI_2      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   6e DIV_C      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     90 NMI_2      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LDAF_2     56 LH_4       00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 1f SW_E4      82 DIV_1      00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 20 LH_0       26 OR_1       00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      90 NMI_2      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      b0 CSRRW_3    00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     90 NMI_2      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     a8 DIV_3      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 LH_1       5d SB_2       00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LH    3d SRxI_2     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     66 SW_1       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     66 SW_1       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      b5 SH_3       00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     ce _LCSRRCI_1 00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     90 NMI_2      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_2       90 NMI_2      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 31 aFaultb    7a SB_5       00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 32 DIV_A      dd aF_SW_1    00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 33 DIV_B         (use dinx) 00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 34 LHU_1      88 DIV_E      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 35 LDAF_LHU   a9 ILL_4      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 36 ECALL_6    03 _L0x03     00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 37 ILL_4      87 unx87      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    90 NMI_2      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     b4 eFetch3    00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    bf IJT_1      00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e aF_SW_3    a8 DIV_3      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 3f QINT_2     b1 aF_SW_3    00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 DIV_8      c7 QINT_1     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000200b close to ij
 * 43 DIV_9      bb SH_2       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       c9 MRET_2     00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 SW_1       be IJ_1       00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 47 SW_E1SWE   df eFetch     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 48 _L0x48     46 ILL_1      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     16 condb_5    00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     46 ILL_1      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    f4 Fetch2     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_12     fe ILLe       00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              40002033 sloppy slt     
 * 4f DIV_13     90 NMI_2      00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 50 LHU_2      90 NMI_2      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 51 aFaultc    eb LH_3       00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 52 Fetchu     30 SLTIX_2    00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00000000 
 * 53 eFetchu    eb LH_3       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 54 DIV_4      d2 LB_2       00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 55 DIV_5      41 JALR_1     00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 56 aFault_2   c1 IJT_2      00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 57 (null)     63 DIV_9      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 58 DIV_1      d0 ECALL_1    00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00002063 close to branch
 * 59 DIV_2      68 DIV_12     00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00002067 close to jalr
 * 5a OR_1       c6 IJT_4      00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    bf IJT_1      00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       db jFault_1   00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e (null)     50 LW_1       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 5f (null)     eb LH_3       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 60 DIV_E      10 SUB_1      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003003 close to load
 * 61 DIV_F      a7 EBRKWFI1   00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 62 DIVU_5     c2 DIVU_3     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               0000300b close to ij
 * 63 LB_6       32 JAL_1      00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      95 SW_E3      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 SH_1       9c DIV_10     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 67 SW_E1SWH   e1 ORI_1      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 68 DIV_10     90 NMI_2      01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00003023 close to store
 * 69 DIV_11     63 DIV_9      01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 6a DIV_14     d3 aFaultd    00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 40003023 close to store
 * 6b DIV_15     d6 eILL0c     00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e ECAL_RET   83 DIV_2      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40003033 sloppy sltu    
 * 6f EBRKWFI1   e2 MUL_1      00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 70 IJ_1       ffffffff (null)     00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * 71 IJT_1      41 JALR_1     00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 72 DIVU_3     3a SRxI_1     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 73 DIVU_4     29 XOR_1      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 74 ECALL_1       (use dinx) 00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 75 MRET_1        (use dinx) 00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 76 (null)     e3 MUL_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 77 (null)     e3 MUL_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 78 LB_2       ef WFI_5      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003063 close to branch
 * 79 aFaultd    ee eILL0a     00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00003067 close to jalr
 * 7a SLTIX_1    9c DIV_10     00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    bf IJT_1      00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e (null)     17 condb_5t   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 7f (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 80 LBU_0      d9 MULH_3     00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 IJ_3       ee eILL0a     00010010000000000000110011101100100110        Construct Q = 1                                   0000400b close to ij
 * 83 DIV_e      58 DIV_A      00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     96 SH_1       00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 eILL0c     a5 MRET_3     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 87 ECALL_3       (use dinx) 00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 88 Fetch      68 DIV_12     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00004023 close to store
 * 89 eFetch     90 NMI_2      00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 8a SH_2       3a SRxI_1     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      40004023 close to store
 * 8b IJ_4       90 NMI_2      00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      58 DIV_A      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e MUL_1      fe ILLe       00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           40004033 sloppy xor     
 * 8f MUL_3      37 ECALL_2    00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 90 StdIncPc   a5 MRET_3     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 91 aFault     e0 DIVU_1     00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 92 jFault_1   a5 MRET_3     00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 93 aF_SW_1    e5 aF_SW_2    00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 94 eILL0a     a5 MRET_3     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 95 WFI_5      1f IJ_2       00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 96 LBU_2      8a DIVU_5     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 97 aFaulte    e1 ORI_1      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a DIVU_1     a5 MRET_3     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 9b ORI_1         (use dinx) 00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 9c SW_2       4e eILL0b     00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00004073 close to csr/system 
 * 9d aF_SW      6a MULH_1     00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 9e Fetch2     e7 aFault     00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 9f jFault     9c DIV_10     00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * a0 LHU_0      34 JAL_3      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JAL_1      f9 MULH_2     00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * a2 IJT_2      63 DIV_9      00000000000000001100101011101000110000        Read word is to be masked with ~1u                0000500b close to ij
 * a3 MRET_5     90 NMI_2      00000010000000000000000011101100010xx0        ~302                                              0000500f close to fence
 * a4 SRxI_0     b1 aF_SW_3    00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 JAL_3      f1 aFaulte    00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a6 WFI_1      74 unx74      00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * a7 EBREAK_1   c8 DIV_7      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * a8 SLLI_1     54 LH_2       00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00005023 close to store
 * a9 SLLI_2     a5 MRET_3     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * aa IJT_4      c2 DIVU_3     00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    40005023 close to store
 * ab QINT_1     36 SLLI_2     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * ac _L0xac     b6 ECALL_5    00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     9a ECALL_6    00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     b6 ECALL_5    00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af ECALL_2    a3 DIV_15     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * b0 MULHU_7    f5 jFault     00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * b1 SRxI_1     e0 DIVU_1     00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * b2 aF_SW_2    88 DIV_E      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * b3 MUL_2         (use dinx) 00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * b4 SRxI_2     d5 Fetch2u    00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * b5 SLL_1      e6 StdIncPc   00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * b6 SRx_1      36 SLLI_2     00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * b7 JALR_1     8b LB_6       00010010000000000000000011101100100110        Q=1                                               00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 WFI_3      ffffffff (null)     00010010000000000000101011101100100110        More check offset                                 00005067 close to jalr
 * ba IJT_3      3a SRxI_1     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * bb MULHU_5    f7 EBREAK_1   00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * bc CSRRWI_0   bf IJT_1      00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ILL_1      88 DIV_E      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * be ILL_2      45 WFI_3      00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * bf CSRRW_1    a2 DIV_14     00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * c0 LH_4       60 MULHU_3    00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00006003 close to load
 * c1 LH_5       ba LHU_3      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * c2 DIV_7      ca DIVU_2     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            0000600b close to ij
 * c3 MRET_2     62 DIV_8      00010010000000000000011011001100100000        0xff+3 = 0x102                                    0000600f close to fence
 * c4 ORI_0      9b unx9b      00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 SB_1       d1 MRET_1     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * c6 SB_2       be IJ_1       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * c7 MULHU_3    3f SRx_1      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * c8 EBRKWFI2   42 MULHU_2    00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00006023 close to store
 * c9 WFI_4      e9 IJT_3      00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * ca DIVU_2     72 LBU_3      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            40006023 close to store
 * cb _LCSRRCI_1 90 NMI_2      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      58 DIV_A      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce MULH_1     fe ILLe       00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              40006033 sloppy or      
 * cf SB_4       13 condb_2    00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * d0 DIV_C      af MRET_4     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * d1 MRET_6     c3 DIVU_4     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * d2 LH_3       09 LB_5       00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * d3 MULH_2     41 JALR_1     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * d4 LBU_3      e0 DIVU_1     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * d5 unalignd      (use dinx) 00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * d6 SB_5       fe ILLe       00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * d7 NMI_1      e8 MUL_2      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 LBU_1      10 SUB_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00006067 close to jalr
 * da WFI_2      1e aFault_1   00010010000000000000101011101100100110        Check offset                                      00000000 
 * db SB_3       e0 DIVU_1     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * dc CSRRSI_0   bf IJT_1      00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd JAL_2      b2 CSRRW_4    10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * de _LCSRRS_1  9e SH_4       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * df ILL_3      9e SH_4       00000010000000000000101011101100100110        Q = 1                                             00000000 
 * e0 LDAF_3     ca DIVU_2     00000000000000001101100111100x00001xx0        PC to mepc                                        00007003 close to load
 * e1 SW_E2      3d SRxI_2     00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * e2 MRET_7     b3 unxb3      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               0000700b close to ij
 * e3 Fetch2u    3a SRxI_1     0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SW_E3      3e SLL_1      00110010000000000000101111001100100110        Q = 3                                             00000000 
 * e6 SH_4       88 DIV_E      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * e7 SH_5       41 JALR_1     00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * e8 ECALL_4    8e _LCSRRS_1  00110010000000000000101011001100100110        Q = 4                                             00007023 close to store
 * e9 MRET_3     aa DIV_6      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * ea MULH_3     4b CSRRW_2    00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              40007023 close to store
 * eb LDAF_a     c0 DIV_D      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     9a ECALL_6    00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee DIV_3      fe ILLe       01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        40007033 sloppy and     
 * ef DIV_6      88 DIV_E      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * f0 EBREAK_2   d4 aFault_2   00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * f1 MRET_4     41 JALR_1     00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * f2 (null)     90 NMI_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f3 (null)     93 SW_E2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 CSRRW_3    f6 WFI_1      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * f5 CSRRW_4    92 LDAF_3     00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * f6 eFetch3    da LDAF_a     0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * f7 SH_3       f0 LBU_2      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 ECALL_5    ea MULHU_5    00110010000000000000101011001100100110        Q = 8                                             00007067 close to jalr
 * fa (null)     b9 DIV_e      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     cf MRET_7     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   bf IJT_1      00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      d7 ECALL_3    00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       bd IJ_4       00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     ab EBREAK_2   00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0010, used ffff, inputs 99
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       aa DIV_6      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       9c DIV_10     00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     ca DIVU_2     00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     ca DIVU_2     00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     fb SB_3       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       7f unx7f      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     fb SB_3       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       73 unalignd   00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      c8 DIV_7      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     ca DIVU_2     00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 CSRRW_2    7f unx7f      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 11 SB_2       3a SRxI_1     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 12 NMI_2      68 DIV_12     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 13 MULHU_3    2e MULHU_1    00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * 14 LDAF_2     39 MULHU_7    00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 15 EBRKWFI2   06 LB_3       00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 16 SW_E4      ca DIVU_2     00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 17 WFI_4      be IJ_1       00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     e0 DIVU_1     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       ca DIVU_2     00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     a2 DIV_14     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   9a ECALL_6    00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     ca DIVU_2     00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e MULHU_2    50 LW_1       00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 1f MULHU_4    90 NMI_2      00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 20 LH_0       42 MULHU_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      ca DIVU_2     00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      c0 DIV_D      00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     ca DIVU_2     00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     af MRET_4     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 eILL0b     5d SB_2       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     3d SRxI_2     00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     88 DIV_E      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     88 DIV_E      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    82 DIV_1      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      d9 MULH_3     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     31 SLTX_1     00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    1e aFault_1   00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     ca DIVU_2     00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 ECALL_6    ca DIVU_2     00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 31 MULH_1     7a SB_5       00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * 32 ILL_4      73 unalignd   00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 33 SB_4          (use dinx) 00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 34 aF_SW_3    be IJ_1       00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 35 DIV_C      b9 DIV_e      00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * 36 QINT_2     03 _L0x03     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 37 MRET_6     bb SH_2       00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    ca DIVU_2     00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     c6 IJT_4      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     a2 DIV_14     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    ef WFI_5      00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LW_1       af MRET_4     00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    c2 DIVU_3     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 LH_1       13 condb_2    00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH    b7 IJ_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       17 condb_5t   00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 LH_2       ee eILL0a     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    77 eFetchu    00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     10 SUB_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    c7 QINT_1     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      86 JAL_2      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_A      fe ILLe       00110010000000000000101111101100001xx1        Transfer rM to rDee                               40002033 sloppy slt     
 * 4f DIV_B      ca DIVU_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 50 aFault_2   ca DIVU_2     00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 51 LBU_3      f6 WFI_1      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 52 (null)     46 ILL_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 53 unalignd   f6 WFI_1      00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * 54 (null)     d1 MRET_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 55 SB_5       41 JALR_1     00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 56 (null)     fa WFI_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 57 NMI_1      7f unx7f      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 58 LHU_1      35 SLLI_1     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00002063 close to branch
 * 59 LDAF_LHU   8a DIVU_5     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00002067 close to jalr
 * 5a OR_1       11 AND_1      00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     a2 DIV_14     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    ef WFI_5      00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       d7 ECALL_3    00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIV_8      66 SW_1       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 5f DIV_9      f6 WFI_1      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 60 SW_1       1e aFault_1   00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00003003 close to load
 * 61 SW_E1SWE   eb LH_3       00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 DIV_12     d0 ECALL_1    00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              0000300b close to ij
 * 63 DIV_13     4e eILL0b     00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      cf MRET_7     00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 LHU_2      de Fetch      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 67 aFaultc    83 DIV_2      00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 68 Fetchu     ca DIVU_2     00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00003023 close to store
 * 69 eFetchu    7f unx7f      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 6a DIV_4      d3 aFaultd    00000000000000001100000011101000110000        ~abs(divisor) to yy                               40003023 close to store
 * 6b DIV_5      55 aFaultb    00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 6c SLTU_0     86 JAL_2      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_1      92 LDAF_3     00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40003033 sloppy sltu    
 * 6f DIV_2      f0 LBU_2      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 70 (null)     ffffffff (null)     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 71 LBU_1      41 JALR_1     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 72 (null)     3a SRxI_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 73 JAL_2      29 XOR_1      10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 74 (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 75 _LCSRRS_1     (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 76 (null)     f2 SW_2       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 77 ILL_3      f2 SW_2       00000010000000000000101011101100100110        Q = 1                                             00000000 
 * 78 DIV_E      c1 IJT_2      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003063 close to branch
 * 79 DIV_F      a7 EBRKWFI1   00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00003067 close to jalr
 * 7a SLTIX_1    de Fetch      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     a2 DIV_14     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    ef WFI_5      00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e DIVU_5     12 straddle   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 7f LB_6          (use dinx) 00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 80 LBU_0      71 aFaultc    00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 LDAF_3        (use dinx) 00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 82 SLTIX_2    a7 EBRKWFI1   00000000000000000100001011101000110010        Registered ALU flag to rd                         0000400b close to ij
 * 83 SW_E2      6e DIV_C      00000000000000001101101111101000001xx0        Store address that faulted                        0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SW_E3      da LDAF_a     00110010000000000000101111001100100110        Q = 3                                             00000000 
 * 86 SLTX_1     a6 ECAL_RET   00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 87 SH_4          (use dinx) 00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 88 SH_1       8a DIVU_5     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00004023 close to store
 * 89 SW_E1SWH   ca DIVU_2     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 8a DIV_10     3a SRxI_1     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    40004023 close to store
 * 8b DIV_11     ca DIVU_2     01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      6e DIV_C      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e DIV_14     fe ILLe       00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 40004033 sloppy xor     
 * 8f DIV_15     32 JAL_1      00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 90 IJ_3       a6 ECAL_RET   00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 91 jFault_1   81 unx81      00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 92 DIV_e      a6 ECAL_RET   00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 93 aF_SW_1    85 LBU_1      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 94 SH_2       a6 ECAL_RET   00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 95 DIVU_1     16 condb_5    00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 96 IJ_4       94 SW_E4      00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 97 ORI_1      83 DIV_2      00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a ECAL_RET   a6 ECAL_RET   00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 9b EBRKWFI1      (use dinx) 00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 9c IJ_1       62 DIV_8      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00004073 close to csr/system 
 * 9d IJT_1      8e _LCSRRS_1  00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 9e DIVU_3     a1 ECALL_4    00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 9f DIVU_4     de Fetch      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * a0 LHU_0      58 DIV_A      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SH_5       e7 aFault     00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * a2 JAL_1      7f unx7f      00010000000000001100001011101000100000        Target adr to yy                                  0000500b close to ij
 * a3 ECALL_4    ca DIVU_2     00110010000000000000101011001100100110        Q = 4                                             0000500f close to fence
 * a4 SRxI_0     c2 DIVU_3     00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_3     c5 MRET_5     00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * a6 JAL_3      a8 DIV_3      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a7 DIV_3      15 condb_4    01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * a8 ECALL_1    6a MULH_1     00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00005023 close to store
 * a9 MRET_1     a6 ECAL_RET   00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * aa LB_2       d0 ECALL_1    00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     40005023 close to store
 * ab aFaultd    30 SLTIX_2    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * ac _L0xac     dd aF_SW_1    00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     95 SW_E3      00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     dd aF_SW_1    00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SLLI_1     b2 CSRRW_4    00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * b0 IJT_2      e1 ORI_1      00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * b1 aF_SW_2    81 unx81      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * b2 MRET_5     be IJ_1       00000010000000000000000011101100010xx0        ~302                                              00000000 
 * b3 MUL_2         (use dinx) 00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * b4 IJT_4      53 LDAF_LH    00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * b5 IJT_3      87 unx87      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * b6 QINT_1     30 SLTIX_2    00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * b7 MULHU_5    96 SH_1       00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SLLI_2     ffffffff (null)     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00005067 close to jalr
 * ba eILL0c     3a SRxI_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bb ECALL_3    e5 aF_SW_2    00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * bc CSRRWI_0   ef WFI_5      00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ECALL_2    be IJ_1       00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * be Fetch      45 WFI_3      00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * bf eFetch     b0 CSRRW_3    00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * c0 MULHU_7    78 DIV_4      00100000000000000100001011101000001xx0        Last shift.                                       00006003 close to load
 * c1 DIV_6      b5 SH_3       00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * c2 SRxI_1     d4 aFault_2   00000000000000000100101001101100001xx1        Register to shift to Q                            0000600b close to ij
 * c3 EBREAK_2   7e NMI_1      00000000000000001101101011101000001xx0        pc to mepc                                        0000600f close to fence
 * c4 ORI_0      97 SW_E1SWH   00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_4     37 ECALL_2    00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * c6 SRxI_2     ee eILL0a     00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * c7 CSRRW_3    36 SLLI_2     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * c8 MUL_1      5e LHU_1      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00006023 close to store
 * c9 MUL_3      a5 MRET_3     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * ca StdIncPc   9e SH_4       10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    40006023 close to store
 * cb aFault     ca DIVU_2     00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      6e DIV_C      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce eILL0a     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006033 sloppy or      
 * cf WFI_5      27 OR_2       00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * d0 DIV_7      bd IJ_4       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d1 LH_3       d2 LB_2       00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * d2 MRET_2     09 LB_5       00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * d3 MULH_2     41 JALR_1     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * d4 DIVU_2     81 unx81      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d5 WFI_2         (use dinx) 00010010000000000000101011101100100110        Check offset                                      00000000 
 * d6 _LCSRRCI_1 fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d7 SB_3       a3 DIV_15     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 SLL_1      1e aFault_1   00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00006067 close to jalr
 * da LBU_2      14 condb_3    00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * db aFaulte    81 unx81      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * dc CSRRSI_0   ef WFI_5      00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd SRx_1      b1 aF_SW_3    00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * de SW_2       e8 MUL_2      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * df aF_SW      e8 MUL_2      00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * e0 JALR_1     d4 aFault_2   00010010000000000000000011101100100110        Q=1                                               00007003 close to load
 * e1 CSRRW_4    3d SRxI_2     00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * e2 WFI_3      b3 unxb3      00010010000000000000101011101100100110        More check offset                                 0000700b close to ij
 * e3 eFetch3    3a SRxI_1     0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SH_3       34 JAL_3      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e6 ILL_1      be IJ_1       00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * e7 ECALL_5    41 JALR_1     00110010000000000000101011001100100110        Q = 8                                             00000000 
 * e8 Fetch2     c8 DIV_7      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00007023 close to store
 * e9 jFault     b4 eFetch3    00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * ea WFI_1      4b CSRRW_2    00110010000000000000000011001100100110 WFI    To check offset                                   40007023 close to store
 * eb EBREAK_1   f9 MULH_2     00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     95 SW_E3      00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee ILL_2      fe ILLe       00000000000000001111101011101000001xx0        Store 0 to mtval                                  40007033 sloppy and     
 * ef CSRRW_1    be IJ_1       00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * f0 MRET_7     51 LDAF_LW    00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f1 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f2 Fetch2u    ca DIVU_2     0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f3 (null)     93 SW_E2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 MULH_3     e3 MUL_3      00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * f5 (null)     91 LDAF_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f6 LDAF_a     d5 Fetch2u    00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * f7 (null)     c3 DIVU_4     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 LH_4       f4 Fetch2     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00007067 close to jalr
 * fa LH_5       e2 MUL_1      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * fb SB_1       33 unx33      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * fc CSRRCI_0   ef WFI_5      00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      57 LH_5       00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       e6 StdIncPc   00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     b6 ECALL_5    00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0010, used ffff, inputs 9a
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       aa DIV_6      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       9c DIV_10     00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     c8 DIV_7      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     c8 DIV_7      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     fb SB_3       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       7f unx7f      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     fb SB_3       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       73 unalignd   00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      c0 DIV_D      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     c8 DIV_7      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 CSRRW_2    7f unx7f      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 11 NMI_2      3a SRxI_1     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 12 SB_2       68 DIV_12     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 13 MULHU_3    2e MULHU_1    00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * 14 LDAF_2     39 MULHU_7    00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 15 SW_E4      06 LB_3       00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 16 EBRKWFI2   c8 DIV_7      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 17 WFI_4      be IJ_1       00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     e9 IJT_3      00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       c8 DIV_7      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   9a ECALL_6    00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     c8 DIV_7      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e MULHU_2    50 LW_1       00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 1f MULHU_4    90 NMI_2      00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 20 LH_0       42 MULHU_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      c8 DIV_7      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      c5 MRET_5     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     c8 DIV_7      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     af MRET_4     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 eILL0b     5d SB_2       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     3d SRxI_2     00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     88 DIV_E      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     88 DIV_E      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      e5 aF_SW_2    00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     32 JAL_1      00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    1e aFault_1   00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     c8 DIV_7      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 ECALL_6    c8 DIV_7      00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 31 ILL_4      7a SB_5       00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 32 MULH_1     73 unalignd   00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * 33 SB_4          (use dinx) 00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 34 aF_SW_3    be IJ_1       00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 35 QINT_2     b9 DIV_e      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 36 DIV_C      03 _L0x03     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * 37 MRET_6     bb SH_2       00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    c8 DIV_7      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     dd aF_SW_1    00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    ef WFI_5      00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LW_1       af MRET_4     00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    d9 MULH_3     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 LH_1       13 condb_2    00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH    b7 IJ_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       17 condb_5t   00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 LH_2       ee eILL0a     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    77 eFetchu    00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     10 SUB_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    c7 QINT_1     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_A      fe ILLe       00110010000000000000101111101100001xx1        Transfer rM to rDee                               40002033 sloppy slt     
 * 4f DIV_B      c8 DIV_7      00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 50 aFault_2   c8 DIV_7      00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 51 (null)     f5 jFault     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 52 LBU_3      46 ILL_1      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 53 unalignd   f5 jFault     00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * 54 (null)     d2 LB_2       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 55 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 56 SB_5       fa WFI_2      00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 57 NMI_1      7f unx7f      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 58 LHU_1      36 SLLI_2     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00002063 close to branch
 * 59 LDAF_LHU   8a DIVU_5     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00002067 close to jalr
 * 5a OR_1       12 straddle   00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    ef WFI_5      00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       d7 ECALL_3    00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIV_8      66 SW_1       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 5f DIV_9      f5 jFault     01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 60 SW_1       1e aFault_1   00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00003003 close to load
 * 61 SW_E1SWE   e1 ORI_1      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 DIV_12     d0 ECALL_1    00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              0000300b close to ij
 * 63 DIV_13     4e eILL0b     00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      cb QINT_2     00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 LHU_2      da LDAF_a     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 67 aFaultc    83 DIV_2      00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 68 Fetchu     c8 DIV_7      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00003023 close to store
 * 69 eFetchu    7f unx7f      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 6a DIV_4      d3 aFaultd    00000000000000001100000011101000110000        ~abs(divisor) to yy                               40003023 close to store
 * 6b DIV_5      56 LH_4       00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_1      91 LDAF_2     00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40003033 sloppy sltu    
 * 6f DIV_2      f0 LBU_2      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 70 (null)     ffffffff (null)     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 71 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 72 LBU_1      3a SRxI_1     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 73 JAL_2      29 XOR_1      10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 74 (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 75 (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 76 _LCSRRS_1  f1 aFaulte    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 77 ILL_3      f1 aFaulte    00000010000000000000101011101100100110        Q = 1                                             00000000 
 * 78 DIV_E      c2 DIVU_3     01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003063 close to branch
 * 79 DIV_F      a7 EBRKWFI1   00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00003067 close to jalr
 * 7a SLTIX_1    da LDAF_a     00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    ef WFI_5      00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e DIVU_5     11 AND_1      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 7f LB_6          (use dinx) 00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 80 LBU_0      72 LBU_3      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 LDAF_3     a7 EBRKWFI1   00000000000000001101100111100x00001xx0        PC to mepc                                        0000400b close to ij
 * 83 SW_E2      6e DIV_C      00000000000000001101101111101000001xx0        Store address that faulted                        0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     ce _LCSRRCI_1 00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 SW_E3      a5 MRET_3     00110010000000000000101111001100100110        Q = 3                                             00000000 
 * 87 SH_4          (use dinx) 00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 88 SH_1       8a DIVU_5     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00004023 close to store
 * 89 SW_E1SWH   c8 DIV_7      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 8a DIV_10     3a SRxI_1     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    40004023 close to store
 * 8b DIV_11     c8 DIV_7      01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      6e DIV_C      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e DIV_14     fe ILLe       00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 40004033 sloppy xor     
 * 8f DIV_15     31 SLTX_1     00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 90 IJ_3       a5 MRET_3     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 91 DIV_e      82 DIV_1      00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 92 jFault_1   a5 MRET_3     00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 93 aF_SW_1    86 JAL_2      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 94 SH_2       a5 MRET_3     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 95 IJ_4       15 condb_4    00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 96 DIVU_1     94 SW_E4      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 97 ORI_1      83 DIV_2      00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a ECAL_RET   a5 MRET_3     00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 9b EBRKWFI1      (use dinx) 00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 9c IJ_1       62 DIV_8      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00004073 close to csr/system 
 * 9d IJT_1      8e _LCSRRS_1  00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 9e DIVU_3     a2 DIV_14     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 9f DIVU_4     da LDAF_a     01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * a0 LHU_0      58 DIV_A      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JAL_1      e7 aFault     00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * a2 SH_5       7f unx7f      00000000000000000001110011100100001xx0        Write d to a+k until accepted                     0000500b close to ij
 * a3 ECALL_4    c8 DIV_7      00110010000000000000101011001100100110        Q = 4                                             0000500f close to fence
 * a4 SRxI_0     d9 MULH_3     00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 JAL_3      c6 IJT_4      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a6 MRET_3     a8 DIV_3      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * a7 DIV_3      16 condb_5    01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * a8 ECALL_1    6a MULH_1     00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00005023 close to store
 * a9 MRET_1     a5 MRET_3     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * aa LB_2       d0 ECALL_1    00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     40005023 close to store
 * ab aFaultd    30 SLTIX_2    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * ac _L0xac     e8 MUL_2      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     96 SH_1       00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     e8 MUL_2      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SLLI_1     b1 aF_SW_3    00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * b0 IJT_2      e2 MUL_1      00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * b1 MRET_5     82 DIV_1      00000010000000000000000011101100010xx0        ~302                                              00000000 
 * b2 aF_SW_2    be IJ_1       00110010000000000000101011001100100110        Q = 4                                             00000000 
 * b3 MUL_2         (use dinx) 00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * b4 IJT_4      53 LDAF_LH    00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * b5 QINT_1     87 unx87      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * b6 IJT_3      30 SLTIX_2    00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * b7 MULHU_5    95 SW_E3      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SLLI_2     ffffffff (null)     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00005067 close to jalr
 * ba eILL0c     3a SRxI_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bb ECALL_3    e6 StdIncPc   00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * bc CSRRWI_0   ef WFI_5      00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ECALL_2    be IJ_1       00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * be Fetch      45 WFI_3      00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * bf eFetch     b0 CSRRW_3    00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * c0 MUL_1      78 DIV_4      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00006003 close to load
 * c1 MUL_3      b6 ECALL_5    00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * c2 DIV_6      d4 aFault_2   00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            0000600b close to ij
 * c3 EBREAK_2   7e NMI_1      00000000000000001101101011101000001xx0        pc to mepc                                        0000600f close to fence
 * c4 ORI_0      97 SW_E1SWH   00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MULHU_7    37 ECALL_2    00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * c6 MRET_4     ee eILL0a     00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * c7 CSRRW_3    35 SLLI_1     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * c8 StdIncPc   5e LHU_1      10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00006023 close to store
 * c9 aFault     a6 ECAL_RET   00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * ca eILL0a     9e SH_4       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006023 close to store
 * cb WFI_5      c8 DIV_7      00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      6e DIV_C      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce LBU_2      fe ILLe       00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40006033 sloppy or      
 * cf aFaulte    27 OR_2       00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * d0 DIV_7      bd IJ_4       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d1 MRET_2     d1 MRET_1     00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * d2 LH_3       09 LB_5       00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * d3 MULH_2     41 JALR_1     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * d4 DIVU_2     82 DIV_1      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d5 _LCSRRCI_1    (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d6 WFI_2      fe ILLe       00010010000000000000101011101100100110        Check offset                                      00000000 
 * d7 SB_3       a3 DIV_15     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 SRxI_1     1e aFault_1   00000000000000000100101001101100001xx1        Register to shift to Q                            00006067 close to jalr
 * da SW_2       14 condb_3    00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * db aF_SW      82 DIV_1      00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * dc CSRRSI_0   ef WFI_5      00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd SRxI_2     b2 CSRRW_4    00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * de Fetch2     de Fetch      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * df jFault     de Fetch      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * e0 WFI_1      d4 aFault_2   00110010000000000000000011001100100110 WFI    To check offset                                   00007003 close to load
 * e1 EBREAK_1   3d SRxI_2     00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * e2 CSRRW_4    b3 unxb3      00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      0000700b close to ij
 * e3 eFetch3    3a SRxI_1     0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SLL_1      34 JAL_3      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * e6 SH_3       be IJ_1       00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e7 ECALL_5    41 JALR_1     00110010000000000000101011001100100110        Q = 8                                             00000000 
 * e8 SRx_1      c0 DIV_D      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00007023 close to store
 * e9 JALR_1     b4 eFetch3    00010010000000000000000011101100100110        Q=1                                               00000000 
 * ea WFI_3      4b CSRRW_2    00010010000000000000101011101100100110        More check offset                                 40007023 close to store
 * eb ILL_1      f9 MULH_2     00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     96 SH_1       00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee ILL_2      fe ILLe       00000000000000001111101011101000001xx0        Store 0 to mtval                                  40007033 sloppy and     
 * ef CSRRW_1    be IJ_1       00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * f0 MRET_7     52 LH_1       00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f1 Fetch2u    41 JALR_1     0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f2 (null)     c8 DIV_7      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f3 (null)     93 SW_E2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 MULH_3     e3 MUL_3      00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * f5 LDAF_a     92 LDAF_3     00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * f6 (null)     d6 eILL0c     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     c3 DIVU_4     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 LH_4       f4 Fetch2     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00007067 close to jalr
 * fa LH_5       ea MULHU_5    00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * fb SB_1       33 unx33      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * fc CSRRCI_0   ef WFI_5      00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      57 LH_5       00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       eb LH_3       00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     b5 SH_3       00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0010, used ffff, inputs 9c
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       a6 ECAL_RET   00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       9c DIV_10     00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     c2 DIVU_3     00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     c2 DIVU_3     00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     fb SB_3       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       7f unx7f      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     fb SB_3       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       75 unx75      00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      c0 DIV_D      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     c2 DIVU_3     00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 CSRRW_2    7f unx7f      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 11 NMI_2      3a SRxI_1     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 12 LDAF_2     68 DIV_12     00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 13 SW_E4      2e MULHU_1    00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 14 SB_2       39 MULHU_7    00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 15 MULHU_3    06 LB_3       00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * 16 EBRKWFI2   c2 DIVU_3     00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 17 WFI_4      be IJ_1       00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     e5 aF_SW_2    00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       c2 DIVU_3     00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   9a ECALL_6    00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     c2 DIVU_3     00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e MULHU_2    50 LW_1       00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 1f MULHU_4    90 NMI_2      00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 20 LH_0       42 MULHU_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      c2 DIVU_3     00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      c5 MRET_5     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     c2 DIVU_3     00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     af MRET_4     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 eILL0b     5d SB_2       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     3d SRxI_2     00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     82 DIV_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     82 DIV_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      e2 MUL_1      00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     34 JAL_3      00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    1e aFault_1   00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     c2 DIVU_3     00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 ECALL_6    c2 DIVU_3     00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 31 ILL_4      7a SB_5       00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 32 aF_SW_3    75 unx75      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 33 QINT_2        (use dinx) 00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 34 MULH_1     be IJ_1       00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * 35 SB_4       b9 DIV_e      00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 36 DIV_C      03 _L0x03     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * 37 MRET_6     bb SH_2       00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    c2 DIVU_3     00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     dd aF_SW_1    00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    ef WFI_5      00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LW_1       af MRET_4     00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    d9 MULH_3     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 LH_1       15 condb_4    00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH    b7 IJ_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       17 condb_5t   00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 LH_2       ee eILL0a     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    77 eFetchu    00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     10 SUB_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    cb QINT_2     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_A      fe ILLe       00110010000000000000101111101100001xx1        Transfer rM to rDee                               40002033 sloppy slt     
 * 4f DIV_B      c2 DIVU_3     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 50 aFault_2   c2 DIVU_3     00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 51 (null)     f3 aF_SW      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 52 (null)     46 ILL_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 53 (null)     f3 aF_SW      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 54 LBU_3      d4 aFault_2   00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 55 unalignd   41 JALR_1     00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * 56 SB_5       fa WFI_2      00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 57 NMI_1      7f unx7f      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 58 LHU_1      36 SLLI_2     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00002063 close to branch
 * 59 LDAF_LHU   86 JAL_2      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00002067 close to jalr
 * 5a OR_1       14 condb_3    00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    ef WFI_5      00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       d7 ECALL_3    00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIV_8      66 SW_1       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 5f DIV_9      f3 aF_SW      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 60 SW_1       1e aFault_1   00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00003003 close to load
 * 61 SW_E1SWE   e1 ORI_1      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 DIV_12     d0 ECALL_1    00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              0000300b close to ij
 * 63 DIV_13     4e eILL0b     00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      c7 QINT_1     00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 LHU_2      da LDAF_a     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 67 aFaultc    89 DIV_F      00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 68 Fetchu     c2 DIVU_3     00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00003023 close to store
 * 69 eFetchu    7f unx7f      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 6a DIV_4      d5 Fetch2u    00000000000000001100000011101000110000        ~abs(divisor) to yy                               40003023 close to store
 * 6b DIV_5      56 LH_4       00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_1      91 LDAF_2     00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40003033 sloppy sltu    
 * 6f DIV_2      f0 LBU_2      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 70 (null)     ffffffff (null)     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 71 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 72 (null)     3a SRxI_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 73 (null)     29 XOR_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 74 LBU_1         (use dinx) 00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 75 JAL_2         (use dinx) 10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 76 _LCSRRS_1  f1 aFaulte    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 77 ILL_3      f1 aFaulte    00000010000000000000101011101100100110        Q = 1                                             00000000 
 * 78 DIV_E      c8 DIV_7      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003063 close to branch
 * 79 DIV_F      ab EBREAK_2   00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00003067 close to jalr
 * 7a SLTIX_1    da LDAF_a     00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    ef WFI_5      00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e DIVU_5     11 AND_1      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 7f LB_6          (use dinx) 00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 80 LBU_0      74 unx74      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 SH_1       ab EBREAK_2   00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        0000400b close to ij
 * 83 SW_E1SWH   6e DIV_C      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     ce _LCSRRCI_1 00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 DIV_10     a5 MRET_3     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 87 DIV_11        (use dinx) 01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 88 LDAF_3     86 JAL_2      00000000000000001101100111100x00001xx0        PC to mepc                                        00004023 close to store
 * 89 SW_E2      c2 DIVU_3     00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 8a SW_E3      3a SRxI_1     00110010000000000000101111001100100110        Q = 3                                             40004023 close to store
 * 8b SH_4       c2 DIVU_3     00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      6e DIV_C      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e DIV_14     fe ILLe       00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 40004033 sloppy xor     
 * 8f DIV_15     31 SLTX_1     00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 90 IJ_3       a5 MRET_3     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 91 DIV_e      88 DIV_E      00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 92 SH_2       a5 MRET_3     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 93 IJ_4       8a DIVU_5     00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 94 jFault_1   a5 MRET_3     00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 95 aF_SW_1    13 condb_2    00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 96 DIVU_1     92 LDAF_3     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 97 ORI_1      89 DIV_F      00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a ECAL_RET   a5 MRET_3     00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 9b EBRKWFI1      (use dinx) 00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 9c IJ_1       62 DIV_8      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00004073 close to csr/system 
 * 9d IJT_1      8e _LCSRRS_1  00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 9e DIVU_3     a8 DIV_3      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 9f DIVU_4     da LDAF_a     01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * a0 LHU_0      58 DIV_A      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JAL_1      eb LH_3       00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * a2 ECALL_1    7f unx7f      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 0000500b close to ij
 * a3 MRET_1     c2 DIVU_3     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    0000500f close to fence
 * a4 SRxI_0     d9 MULH_3     00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 JAL_3      ca DIVU_2     00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a6 LB_2       a2 DIV_14     00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * a7 aFaultd    16 condb_5    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * a8 SH_5       6a MULH_1     00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00005023 close to store
 * a9 ECALL_4    a5 MRET_3     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * aa MRET_3     d0 ECALL_1    00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          40005023 close to store
 * ab DIV_3      30 SLTIX_2    01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * ac _L0xac     e3 MUL_3      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     96 SH_1       00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     e3 MUL_3      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SLLI_1     b1 aF_SW_3    00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * b0 IJT_2      e8 MUL_2      00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * b1 MRET_5     88 DIV_E      00000010000000000000000011101100010xx0        ~302                                              00000000 
 * b2 IJT_4      be IJ_1       00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * b3 QINT_1        (use dinx) 00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * b4 aF_SW_2    55 aFaultb    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * b5 MUL_2      8b LB_6       00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * b6 IJT_3      30 SLTIX_2    00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * b7 MULHU_5    93 SW_E2      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SLLI_2     ffffffff (null)     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00005067 close to jalr
 * ba eILL0c     3a SRxI_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bb ECALL_3    ea MULHU_5    00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * bc CSRRWI_0   ef WFI_5      00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ECALL_2    be IJ_1       00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * be Fetch      45 WFI_3      00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * bf eFetch     b0 CSRRW_3    00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * c0 MUL_1      78 DIV_4      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00006003 close to load
 * c1 MUL_3      b6 ECALL_5    00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * c2 StdIncPc   d2 LB_2       10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    0000600b close to ij
 * c3 aFault     7e NMI_1      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          0000600f close to fence
 * c4 ORI_0      97 SW_E1SWH   00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MULHU_7    37 ECALL_2    00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * c6 eILL0a     ee eILL0a     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * c7 WFI_5      33 unx33      00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * c8 DIV_6      5e LHU_1      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00006023 close to store
 * c9 EBREAK_2   aa DIV_6      00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * ca MRET_4     9e SH_4       00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          40006023 close to store
 * cb CSRRW_3    c2 DIVU_3     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      6e DIV_C      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce LBU_2      fe ILLe       00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40006033 sloppy or      
 * cf aFaulte    27 OR_2       00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * d0 DIV_7      bd IJ_4       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d1 MRET_2     d1 MRET_1     00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * d2 DIVU_2     09 LB_5       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d3 _LCSRRCI_1 41 JALR_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d4 LH_3       88 DIV_E      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * d5 MULH_2        (use dinx) 00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * d6 WFI_2      fe ILLe       00010010000000000000101011101100100110        Check offset                                      00000000 
 * d7 SB_3       a9 ILL_4      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 SRxI_1     1e aFault_1   00000000000000000100101001101100001xx1        Register to shift to Q                            00006067 close to jalr
 * da SW_2       12 straddle   00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * db aF_SW      88 DIV_E      00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * dc CSRRSI_0   ef WFI_5      00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd SRxI_2     b4 eFetch3    00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * de Fetch2     de Fetch      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * df jFault     de Fetch      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * e0 WFI_1      d2 LB_2       00110010000000000000000011001100100110 WFI    To check offset                                   00007003 close to load
 * e1 EBREAK_1   3d SRxI_2     00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * e2 SLL_1      b5 SH_3       00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              0000700b close to ij
 * e3 SRx_1      3a SRxI_1     00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 JALR_1     32 JAL_1      00010010000000000000000011101100100110        Q=1                                               00000000 
 * e6 WFI_3      be IJ_1       00010010000000000000101011101100100110        More check offset                                 00000000 
 * e7 ILL_1      41 JALR_1     00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * e8 CSRRW_4    c0 DIV_D      00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00007023 close to store
 * e9 eFetch3    b2 CSRRW_4    0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * ea SH_3       4b CSRRW_2    00000010000000000000000011101000110000        Prepare get back address to use                   40007023 close to store
 * eb ECALL_5    f9 MULH_2     00110010000000000000101011001100100110        Q = 8                                             00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     96 SH_1       00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee ILL_2      fe ILLe       00000000000000001111101011101000001xx0        Store 0 to mtval                                  40007033 sloppy and     
 * ef CSRRW_1    be IJ_1       00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * f0 MRET_7     54 LH_2       00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f1 Fetch2u    41 JALR_1     0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f2 MULH_3     c2 DIVU_3     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * f3 LDAF_a     95 SW_E3      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * f4 (null)     e9 IJT_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f5 (null)     94 SW_E4      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f6 (null)     d6 eILL0c     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     c9 MRET_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 LH_4       f2 SW_2       00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00007067 close to jalr
 * fa LH_5       e6 StdIncPc   00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * fb SB_1       35 SLLI_1     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * fc CSRRCI_0   ef WFI_5      00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      57 LH_5       00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       e7 aFault     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     b3 unxb3      00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0400, used ffff, inputs a3
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       68 DIV_12     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       60 MULHU_3    00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     72 LBU_3      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     b0 CSRRW_3    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       53 LDAF_LH    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     b0 CSRRW_3    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       c0 DIV_D      00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      70 LHU_2      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    53 LDAF_LH    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    6e DIV_C      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     a6 ECAL_RET   00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       72 LBU_3      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   5e LHU_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     72 LBU_3      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       c2 DIVU_3     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    e9 IJT_3      00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      72 LBU_3      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      9d DIV_11     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     94 SW_E4      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      a3 DIV_15     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     b5 SH_3       00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      c0 DIV_D      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       6e DIV_C      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   95 SW_E3      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     6b SB_4       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    72 LBU_3      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     a2 DIV_14     00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    aa DIV_6      00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      94 SW_E4      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    a1 ECALL_4    00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     b2 CSRRW_4    00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    9f SH_5       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       b4 eFetch3    00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 DIV_4      a9 ILL_4      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 47 DIV_5      c5 MRET_5     00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     82 DIV_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    e3 MUL_3      00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_1      fe ILLe       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40002033 sloppy slt     
 * 4f DIV_2      72 LBU_3      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 50 DIV_E      72 LBU_3      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 51 DIV_F      fb SB_3       00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 52 DIVU_5     1e aFault_1   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 53 LB_6       fb SB_3       00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 54 SH_1       c3 DIVU_4     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 55 SW_E1SWH   41 JALR_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 DIV_10     af MRET_4     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 57 DIV_11     53 LDAF_LH    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 58 DIV_14     b7 IJ_3       00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00002063 close to branch
 * 59 DIV_15     56 LH_4       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00002067 close to jalr
 * 5a OR_1       b1 aF_SW_3    00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    aa DIV_6      00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       cf MRET_7     00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e ECAL_RET   3e SLL_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 5f EBRKWFI1   fb SB_3       00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 60 IJ_1       10 SUB_1      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00003003 close to load
 * 61 IJT_1      89 DIV_F      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 62 DIVU_3     f3 aF_SW      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIVU_4     26 OR_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      75 unx75      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 ECALL_1    78 DIV_4      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 67 MRET_1     c9 MRET_2     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 68 LB_2       72 LBU_3      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd    53 LDAF_LH    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c     c7 QINT_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    bd IJ_4       00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e Fetch      ea MULHU_5    00000001001010001000101111101010110000  Fr11  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     f7 EBREAK_1   00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 MUL_1      ffffffff (null)     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 71 MUL_3      41 JALR_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 72 StdIncPc   3a SRxI_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 73 aFault     29 XOR_1      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 74 eILL0a        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 76 LBU_2      f9 MULH_2     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 77 aFaulte    f9 MULH_2     00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 78 SW_2       e0 DIVU_1     00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00003063 close to branch
 * 79 aF_SW      dd aF_SW_1    00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00003067 close to jalr
 * 7a SLTIX_1    78 DIV_4      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    aa DIV_6      00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e Fetch2     86 JAL_2      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 7f jFault        (use dinx) 00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 80 LBU_0      bf IJT_1      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 CSRRW_2    dd aF_SW_1    00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    0000400b close to ij
 * 83 jFault_1   4e eILL0b     00010000000000001110001011100x00100110        Store 1 to mcause                                 0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     76 Fetchu     00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 NMI_2      91 LDAF_2     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 87 aF_SW_1       (use dinx) 00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 88 WFI_1      56 LH_4       00110010000000000000000011001100100110 WFI    To check offset                                   00004023 close to store
 * 89 EBREAK_1   72 LBU_3      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 8a LDAF_2     3a SRxI_1     00110000110000001110001011000x00100110        Store 4 to mcause                                 40004023 close to store
 * 8b DIVU_1     72 LBU_3      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      4e eILL0b     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e SW_E4      fe ILLe       00000000110000001110100111100x00101000        Store 6 to mcause                                 40004033 sloppy xor     
 * 8f ORI_1      96 SH_1       00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 90 JAL_1      91 LDAF_2     00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 91 JAL_3      c8 DIV_7      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 92 ECALL_6    91 LDAF_2     00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 93 aF_SW_2    d0 ECALL_1    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 94 SLLI_1     91 LDAF_2     00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 95 SLLI_2     8e _LCSRRS_1  00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 96 ILL_4      eb LH_3       00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 97 MUL_2      c9 MRET_2     00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a aF_SW_3    91 LDAF_2     00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 9b IJT_3         (use dinx) 00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 9c ECALL_2    36 SLLI_2     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00004073 close to csr/system 
 * 9d MULHU_7    58 DIV_A      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 9e QINT_2     d4 aFault_2   00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 9f MULHU_5    78 DIV_4      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SRxI_1     e8 MUL_2      00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * a2 SRxI_2     53 LDAF_LH    00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                0000500b close to ij
 * a3 SLL_1      72 LBU_3      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              0000500f close to fence
 * a4 SRxI_0     a1 ECALL_4    00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SRx_1      e2 MUL_1      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * a6 JALR_1     66 SW_1       00010010000000000000000011101100100110        Q=1                                               00000000 
 * a7 WFI_3      b3 unxb3      00010010000000000000101011101100100110        More check offset                                 00000000 
 * a8 ILL_1      46 ILL_1      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00005023 close to store
 * a9 ILL_2      91 LDAF_2     00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * aa CSRRW_1    f3 aF_SW      00010010000000000000000011101100100110        Construct PC storage adr                          40005023 close to store
 * ab LH_4       92 LDAF_3     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * ac _L0xac     a5 MRET_3     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     8b LB_6       00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     a5 MRET_3     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af LH_5       f0 LBU_2      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * b0 SB_1       e5 aF_SW_2    00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * b1 SB_2       c8 DIV_7      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * b2 MULHU_3    6e DIV_C      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * b3 EBRKWFI2      (use dinx) 00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * b4 WFI_4      bb SH_2       00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * b5 MULH_1     d1 MRET_1     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * b6 SB_4       92 LDAF_3     00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b7 DIV_C      ee eILL0a     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MRET_6     ffffffff (null)     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00005067 close to jalr
 * ba LBU_3      3a SRxI_1     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * bb unalignd   e7 aFault     00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * bc CSRRWI_0   aa DIV_6      00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SB_5       6e DIV_C      00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * be NMI_1      45 WFI_3      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * bf LBU_1      ef WFI_5      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * c0 JAL_2      50 LW_1       10110000000000000100110011000x00100110        Return address to TRG                             00006003 close to load
 * c1 _LCSRRS_1  9b unx9b      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * c2 aFault_2   f5 jFault     00010000110000001110001011100x00100110        Store 5 to mcause                                 0000600b close to ij
 * c3 LH_3       52 LH_1       00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 0000600f close to fence
 * c4 ORI_0      8f ILL_3      00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 ILL_3      b9 DIV_e      00000010000000000000101011101100100110        Q = 1                                             00000000 
 * c6 (null)     a9 ILL_4      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c7 MULH_2     9e SH_4       00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * c8 LDAF_3     32 JAL_1      00000000000000001101100111100x00001xx0        PC to mepc                                        00006023 close to store
 * c9 SW_E2      d9 MULH_3     00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * ca (null)     62 DIV_8      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   40006023 close to store
 * cb WFI_2      72 LBU_3      00010010000000000000101011101100100110        Check offset                                      00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      4e eILL0b     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce (null)     fe ILLe       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   40006033 sloppy or      
 * cf SB_3       13 condb_2    00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d0 SW_E3      9c DIV_10     00110010000000000000101111001100100110        Q = 3                                             00000000 
 * d1 SH_4       f4 Fetch2     00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * d2 (null)     09 LB_5       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d3 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d4 SH_5       c8 DIV_7      00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * d5 ECALL_4       (use dinx) 00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d6 (null)     fe ILLe       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d7 (null)     d5 Fetch2u    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MRET_3     10 SUB_1      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00006067 close to jalr
 * da (null)     8a DIVU_5     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * db (null)     c8 DIV_7      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * dc CSRRSI_0   aa DIV_6      00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd DIV_3      93 SW_E2      01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * de (null)     7e NMI_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * df (null)     7e NMI_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e0 DIV_6      f5 jFault     00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00007003 close to load
 * e1 EBREAK_2   3d SRxI_2     00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * e2 MRET_4     97 SW_E1SWH   00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          0000700b close to ij
 * e3 CSRRW_3    3a SRxI_1     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 CSRRW_4    9a ECALL_6    00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * e6 eFetch3    6e DIV_C      0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * e7 SH_3       41 JALR_1     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e8 ECALL_5    70 LHU_2      00110010000000000000101011001100100110        Q = 8                                             00007023 close to store
 * e9 IJ_3       f1 aFaulte    00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * ea DIV_e      4b CSRRW_2    00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      40007023 close to store
 * eb SH_2       ab EBREAK_2   00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     8b LB_6       00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee IJ_4       fe ILLe       00000100000010001010110111100100011xx0        Mask and use as PC                                40007033 sloppy and     
 * ef IJT_2      6e DIV_C      00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * f0 MRET_5     ba LHU_3      00000010000000000000000011101100010xx0        ~302                                              00000000 
 * f1 IJT_4      41 JALR_1     00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * f2 QINT_1     72 LBU_3      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * f3 DIV_7      87 unx87      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f4 MRET_2     e6 StdIncPc   00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * f5 DIVU_2     83 DIV_2      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f6 _LCSRRCI_1 cb QINT_2     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f7 MRET_7     e1 ORI_1      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 Fetch2u    fa WFI_2      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00007067 close to jalr
 * fa MULH_3     a7 EBRKWFI1   00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * fb LDAF_a     b6 ECALL_5    00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * fc CSRRCI_0   aa DIV_6      00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      be IJ_1       00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       a8 DIV_3      00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     f2 SW_2       00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 2000, used ffff, inputs a5
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       68 DIV_12     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       60 MULHU_3    00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     72 LBU_3      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     9b unx9b      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       53 LDAF_LH    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     9b unx9b      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       b4 eFetch3    00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      70 LHU_2      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    53 LDAF_LH    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    6e DIV_C      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     92 LDAF_3     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       72 LBU_3      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   5e LHU_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     72 LBU_3      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       e1 ORI_1      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    ce _LCSRRCI_1 00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      72 LBU_3      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      8b LB_6       00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     88 DIV_E      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      90 NMI_2      00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     a2 DIV_14     00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      b4 eFetch3    00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       6e DIV_C      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   89 DIV_F      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     6b SB_4       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    72 LBU_3      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     8f ILL_3      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    96 SH_1       00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      88 DIV_E      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    8e _LCSRRS_1  00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     9d DIV_11     00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    ee eILL0a     00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       9f SH_5       00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 DIV_4      95 SW_E3      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 47 DIV_5      b6 ECALL_5    00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     a1 ECALL_4    00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    c7 QINT_1     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_1      fe ILLe       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40002033 sloppy slt     
 * 4f DIV_2      72 LBU_3      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 50 DIV_E      72 LBU_3      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 51 DIV_F      df eFetch     00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 52 DIVU_5     1e aFault_1   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 53 LB_6       df eFetch     00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 54 SH_1       ef WFI_5      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 55 SW_E1SWH   41 JALR_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 DIV_10     9a ECALL_6    01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 57 DIV_11     53 LDAF_LH    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 58 DIV_14     a6 ECAL_RET   00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00002063 close to branch
 * 59 DIV_15     56 LH_4       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00002067 close to jalr
 * 5a OR_1       9c DIV_10     00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    96 SH_1       00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       f4 Fetch2     00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e ECAL_RET   3e SLL_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 5f EBRKWFI1   df eFetch     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 60 IJ_1       10 SUB_1      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00003003 close to load
 * 61 IJT_1      83 DIV_2      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 62 DIVU_3     d6 eILL0c     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIVU_4     26 OR_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      75 unx75      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 ECALL_1    78 DIV_4      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 67 MRET_1     ba LHU_3      00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 68 LB_2       72 LBU_3      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd    53 LDAF_LH    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c     f0 LBU_2      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    af MRET_4     00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e Fetch      cf MRET_7     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     db jFault_1   00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 MUL_1      ffffffff (null)     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 71 MUL_3      41 JALR_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 72 StdIncPc   3a SRxI_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 73 aFault     29 XOR_1      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 74 eILL0a        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 76 LBU_2      dd aF_SW_1    00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 77 aFaulte    dd aF_SW_1    00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 78 SW_2       c3 DIVU_4     00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00003063 close to branch
 * 79 aF_SW      c2 DIVU_3     00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00003067 close to jalr
 * 7a SLTIX_1    78 DIV_4      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    96 SH_1       00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e Fetch2     a3 DIV_15     00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 7f jFault        (use dinx) 00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 80 LBU_0      b2 CSRRW_4    00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 WFI_1      c2 DIVU_3     00110010000000000000000011001100100110 WFI    To check offset                                   0000400b close to ij
 * 83 EBREAK_1   4e eILL0b     00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     76 Fetchu     00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 JAL_1      87 unx87      00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 87 JAL_3         (use dinx) 00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 88 SLLI_1     56 LH_4       00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00004023 close to store
 * 89 SLLI_2     72 LBU_3      00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 8a ECALL_2    3a SRxI_1     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  40004023 close to store
 * 8b MULHU_7    72 LBU_3      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      4e eILL0b     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e SRxI_1     fe ILLe       00000000000000000100101001101100001xx1        Register to shift to Q                            40004033 sloppy xor     
 * 8f SRxI_2     b3 unxb3      00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 90 SLL_1      87 unx87      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 91 SRx_1      b7 IJ_3       00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 92 JALR_1     87 unx87      00010010000000000000000011101100100110        Q=1                                               00000000 
 * 93 WFI_3      bd IJ_4       00010010000000000000101011101100100110        More check offset                                 00000000 
 * 94 ILL_1      87 unx87      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 95 ILL_2      ab EBREAK_2   00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 96 CSRRW_1    d0 ECALL_1    00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 97 LH_4       ba LHU_3      00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a LH_5       87 unx87      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 9b SB_1          (use dinx) 00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 9c SB_2       36 SLLI_2     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00004073 close to csr/system 
 * 9d MULHU_3    58 DIV_A      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * 9e EBRKWFI2   bf IJT_1      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 9f WFI_4      78 DIV_4      00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 CSRRW_2    cb QINT_2     00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * a2 MULH_1     53 LDAF_LH    00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              0000500b close to ij
 * a3 NMI_2      72 LBU_3      00000000110000001111010011101000110000        mtval = 0.                                        0000500f close to fence
 * a4 SRxI_0     8e _LCSRRS_1  00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SB_4       c6 IJT_4      00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * a6 DIV_C      66 SW_1       00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * a7 MRET_6     9e SH_4       00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * a8 LBU_3      46 ILL_1      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00005023 close to store
 * a9 LDAF_2     87 unx87      00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * aa unalignd   d6 eILL0c     00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                40005023 close to store
 * ab SW_E4      b1 aF_SW_3    00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * ac _L0xac     91 LDAF_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     e5 aF_SW_2    00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     91 LDAF_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SB_5       d3 aFaultd    00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b0 NMI_1      c8 DIV_7      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * b1 ECALL_6    b7 IJ_3       00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * b2 LBU_1      6e DIV_C      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * b3 ILL_4         (use dinx) 00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * b4 JAL_2      aa DIV_6      10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * b5 _LCSRRS_1  be IJ_1       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b6 ILL_3      b1 aF_SW_3    00000010000000000000101011101100100110        Q = 1                                             00000000 
 * b7 LDAF_3     d1 MRET_1     00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 aF_SW_3    ffffffff (null)     00010000110000001110001011000x00100000        Store 7 to mcause                                 00005067 close to jalr
 * ba SW_E2      3a SRxI_1     00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * bb QINT_2     ca DIVU_2     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * bc CSRRWI_0   96 SH_1       00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SW_E3      6e DIV_C      00110010000000000000101111001100100110        Q = 3                                             00000000 
 * be SH_4       45 WFI_3      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * bf SH_5       d2 LB_2       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * c0 ECALL_4    50 LW_1       00110010000000000000101011001100100110        Q = 4                                             00006003 close to load
 * c1 MRET_3     ea MULHU_5    00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * c2 DIV_3      d9 MULH_3     01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        0000600b close to ij
 * c3 DIV_6      52 LH_1       00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            0000600f close to fence
 * c4 ORI_0      e6 StdIncPc   00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 EBREAK_2   a7 EBRKWFI1   00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * c6 MRET_4     95 SW_E3      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * c7 CSRRW_3    bb SH_2       00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * c8 CSRRW_4    32 JAL_1      00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00006023 close to store
 * c9 eFetch3    c1 IJT_2      0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * ca SH_3       62 DIV_8      00000010000000000000000011101000110000        Prepare get back address to use                   40006023 close to store
 * cb ECALL_5    72 LBU_3      00110010000000000000101011001100100110        Q = 8                                             00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      4e eILL0b     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce IJ_3       fe ILLe       00010010000000000000110011101100100110        Construct Q = 1                                   40006033 sloppy or      
 * cf DIV_e      13 condb_2    00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * d0 SH_2       8a DIVU_5     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d1 IJ_4       d7 ECALL_3    00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * d2 IJT_2      09 LB_5       00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * d3 MRET_5     41 JALR_1     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * d4 IJT_4      b7 IJ_3       00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * d5 QINT_1        (use dinx) 00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * d6 DIV_7      fe ILLe       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d7 MRET_2     c0 DIV_D      00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 DIVU_2     10 SUB_1      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00006067 close to jalr
 * da _LCSRRCI_1 a9 ILL_4      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * db MRET_7     b7 IJ_3       00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * dc CSRRSI_0   96 SH_1       00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd Fetch2u    e7 aFault     0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * de MULH_3     7e NMI_1      00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * df LDAF_a     7e NMI_1      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * e0 jFault_1   d9 MULH_3     00010000000000001110001011100x00100110        Store 1 to mcause                                 00007003 close to load
 * e1 aFault_2   3d SRxI_2     00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * e2 aF_SW_1    e8 MUL_2      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      0000700b close to ij
 * e3 (null)     3a SRxI_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 DIVU_1     b9 DIV_e      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * e6 ORI_1      6e DIV_C      00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * e7 aF_SW_2    41 JALR_1     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * e8 MUL_2      70 LHU_2      00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00007023 close to store
 * e9 (null)     d4 aFault_2   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ea IJT_3      4b CSRRW_2    00010010000000000000110011101100100110        Construct Q = 1                                   40007023 close to store
 * eb (null)     97 SW_E1SWH   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     e5 aF_SW_2    00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee MULHU_5    fe ILLe       00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          40007033 sloppy and     
 * ef LH_3       6e DIV_C      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f0 MULH_2     a8 DIV_3      00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * f1 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f2 WFI_2      72 LBU_3      00010010000000000000101011101100100110        Check offset                                      00000000 
 * f3 (null)     e2 MUL_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 SB_3       c9 MRET_2     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f5 (null)     e0 DIVU_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f6 (null)     f2 SW_2       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     c5 MRET_5     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)     de Fetch      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00007067 close to jalr
 * fa (null)     93 SW_E2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     a5 MRET_3     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   96 SH_1       00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      b0 CSRRW_3    00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       94 SW_E4      00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     d5 Fetch2u    00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0200, used ffff, inputs a6
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       68 DIV_12     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       60 MULHU_3    00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     72 LBU_3      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     b6 ECALL_5    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       53 LDAF_LH    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     b6 ECALL_5    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       d5 Fetch2u    00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      70 LHU_2      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    53 LDAF_LH    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    6e DIV_C      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     a8 DIV_3      00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       72 LBU_3      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   5e LHU_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     72 LBU_3      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       c2 DIVU_3     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    86 JAL_2      00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      72 LBU_3      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      9d DIV_11     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     94 SW_E4      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      a6 ECAL_RET   00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     bf IJT_1      00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      d5 Fetch2u    00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       6e DIV_C      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   95 SW_E3      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     6b SB_4       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    72 LBU_3      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     a5 MRET_3     00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    b1 aF_SW_3    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      94 SW_E4      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    a1 ECALL_4    00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     b9 DIV_e      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    bb SH_2       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       be IJ_1       00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 DIV_4      b0 CSRRW_3    00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 47 DIV_5      dd aF_SW_1    00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     82 DIV_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    f4 Fetch2     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_1      fe ILLe       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40002033 sloppy slt     
 * 4f DIV_2      72 LBU_3      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 50 DIV_E      72 LBU_3      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 51 DIV_F      df eFetch     00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 52 DIVU_5     1e aFault_1   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 53 LB_6       df eFetch     00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 54 SH_1       e2 MUL_1      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 55 SW_E1SWH   41 JALR_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 DIV_10     b5 SH_3       01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 57 DIV_11     53 LDAF_LH    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 58 DIV_14     c1 IJT_2      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00002063 close to branch
 * 59 DIV_15     56 LH_4       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00002067 close to jalr
 * 5a OR_1       b7 IJ_3       00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    b1 aF_SW_3    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       eb LH_3       00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e ECAL_RET   3e SLL_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 5f EBRKWFI1   df eFetch     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 60 IJ_1       10 SUB_1      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00003003 close to load
 * 61 IJT_1      89 DIV_F      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 62 DIVU_3     c6 IJT_4      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIVU_4     26 OR_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      75 unx75      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 ECALL_1    78 DIV_4      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 67 MRET_1     e1 ORI_1      00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 68 LB_2       72 LBU_3      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd    53 LDAF_LH    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c     e3 MUL_3      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    d0 ECALL_1    00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e Fetch      87 unx87      00000001001010001000101111101010110000  Fr11  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     d6 eILL0c     00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 MUL_1      ffffffff (null)     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 71 MUL_3      41 JALR_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 72 StdIncPc   3a SRxI_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 73 aFault     29 XOR_1      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 74 eILL0a        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 76 LBU_2      d7 ECALL_3    00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 77 aFaulte    d7 ECALL_3    00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 78 SW_2       ef WFI_5      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00003063 close to branch
 * 79 aF_SW      ee eILL0a     00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00003067 close to jalr
 * 7a SLTIX_1    78 DIV_4      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    b1 aF_SW_3    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e Fetch2     83 DIV_2      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 7f jFault        (use dinx) 00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 80 LBU_0      d4 aFault_2   00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 CSRRW_2    ee eILL0a     00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    0000400b close to ij
 * 83 NMI_2      4e eILL0b     00000000110000001111010011101000110000        mtval = 0.                                        0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     76 Fetchu     00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 IJ_3       91 LDAF_2     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 87 DIV_e         (use dinx) 00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 88 WFI_1      56 LH_4       00110010000000000000000011001100100110 WFI    To check offset                                   00004023 close to store
 * 89 EBREAK_1   72 LBU_3      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 8a LDAF_2     3a SRxI_1     00110000110000001110001011000x00100110        Store 4 to mcause                                 40004023 close to store
 * 8b SW_E4      72 LBU_3      00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      4e eILL0b     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e SH_2       fe ILLe       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      40004033 sloppy xor     
 * 8f IJ_4       93 SW_E2      00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 90 JAL_1      91 LDAF_2     00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 91 JAL_3      e0 DIVU_1     00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 92 ECALL_6    91 LDAF_2     00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 93 ILL_4      e5 aF_SW_2    00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 94 SLLI_1     91 LDAF_2     00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 95 SLLI_2     8b LB_6       00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 96 IJT_2      8e _LCSRRS_1  00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * 97 MRET_5     e1 ORI_1      00000010000000000000000011101100010xx0        ~302                                              00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a aF_SW_3    91 LDAF_2     00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 9b QINT_2        (use dinx) 00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 9c ECALL_2    36 SLLI_2     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00004073 close to csr/system 
 * 9d MULHU_7    58 DIV_A      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 9e IJT_4      e7 aFault     00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 9f QINT_1     78 DIV_4      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SRxI_1     f9 MULH_2     00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * a2 jFault_1   53 LDAF_LH    00010000000000001110001011100x00100110        Store 1 to mcause                                 0000500b close to ij
 * a3 aF_SW_1    72 LBU_3      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      0000500f close to fence
 * a4 SRxI_0     a1 ECALL_4    00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SRxI_2     f1 aFaulte    00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * a6 SLL_1      66 SW_1       00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * a7 SRx_1      bd IJ_4       00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * a8 JALR_1     46 ILL_1      00010010000000000000000011101100100110        Q=1                                               00005023 close to store
 * a9 WFI_3      91 LDAF_2     00010010000000000000101011101100100110        More check offset                                 00000000 
 * aa DIVU_1     c6 IJT_4      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           40005023 close to store
 * ab ORI_1      92 LDAF_3     00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * ac _L0xac     a7 EBRKWFI1   00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     aa DIV_6      00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     a7 EBRKWFI1   00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af ILL_1      97 SW_E1SWH   00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * b0 ILL_2      f5 jFault     00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * b1 CSRRW_1    e0 DIVU_1     00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * b2 aF_SW_2    6e DIV_C      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * b3 MUL_2         (use dinx) 00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * b4 LH_4       c9 MRET_2     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * b5 LH_5       e6 StdIncPc   00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * b6 SB_1       92 LDAF_3     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * b7 SB_2       8f ILL_3      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MULHU_3    ffffffff (null)     00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00005067 close to jalr
 * ba IJT_3      3a SRxI_1     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * bb MULHU_5    f7 EBREAK_1   00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * bc CSRRWI_0   b1 aF_SW_3    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd EBRKWFI2   6e DIV_C      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * be WFI_4      45 WFI_3      00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * bf MULH_1     96 SH_1       00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * c0 SB_4       50 LW_1       00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00006003 close to load
 * c1 DIV_C      ba LHU_3      00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * c2 aFault_2   ce _LCSRRCI_1 00010000110000001110001011100x00100110        Store 5 to mcause                                 0000600b close to ij
 * c3 (null)     52 LH_1       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000600f close to fence
 * c4 ORI_0      ab EBREAK_2   00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_6     c5 MRET_5     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * c6 DIV_7      b0 CSRRW_3    00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * c7 MRET_2     9b unx9b      00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * c8 LBU_3      32 JAL_1      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00006023 close to store
 * c9 unalignd   e9 IJT_3      00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * ca (null)     62 DIV_8      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   40006023 close to store
 * cb (null)     72 LBU_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      4e eILL0b     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce DIVU_2     fe ILLe       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            40006033 sloppy or      
 * cf _LCSRRCI_1 13 condb_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d0 SB_5       9c DIV_10     00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * d1 NMI_1      c7 QINT_1     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * d2 (null)     09 LB_5       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d3 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d4 LBU_1      e0 DIVU_1     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * d5 JAL_2         (use dinx) 10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * d6 MRET_7     fe ILLe       00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * d7 Fetch2u    e8 MUL_2      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 _LCSRRS_1  10 SUB_1      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00006067 close to jalr
 * da (null)     8a DIVU_5     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * db (null)     e0 DIVU_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * dc CSRRSI_0   b1 aF_SW_3    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd ILL_3      b2 CSRRW_4    00000010000000000000101011101100100110        Q = 1                                             00000000 
 * de MULH_3     7e NMI_1      00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * df LDAF_a     7e NMI_1      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * e0 LDAF_3     ce _LCSRRCI_1 00000000000000001101100111100x00001xx0        PC to mepc                                        00007003 close to load
 * e1 SW_E2      3d SRxI_2     00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * e2 LH_3       b3 unxb3      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 0000700b close to ij
 * e3 MULH_2     3a SRxI_1     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SW_E3      9a ECALL_6    00110010000000000000101111001100100110        Q = 3                                             00000000 
 * e6 SH_4       6e DIV_C      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * e7 SH_5       41 JALR_1     00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * e8 ECALL_4    70 LHU_2      00110010000000000000101011001100100110        Q = 4                                             00007023 close to store
 * e9 MRET_3     9e SH_4       00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * ea WFI_2      4b CSRRW_2    00010010000000000000101011101100100110        Check offset                                      40007023 close to store
 * eb SB_3       b4 eFetch3    00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     aa DIV_6      00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee DIV_3      fe ILLe       01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        40007033 sloppy and     
 * ef DIV_6      6e DIV_C      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * f0 EBREAK_2   c8 DIV_7      00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * f1 MRET_4     41 JALR_1     00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * f2 (null)     72 LBU_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f3 (null)     a3 DIV_15     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 CSRRW_3    f6 WFI_1      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * f5 CSRRW_4    a2 DIV_14     00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * f6 eFetch3    ea MULHU_5    0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * f7 SH_3       f0 LBU_2      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 ECALL_5    de Fetch      00110010000000000000101011001100100110        Q = 8                                             00007067 close to jalr
 * fa (null)     a9 ILL_4      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     c0 DIV_D      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   b1 aF_SW_3    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      d1 MRET_1     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       af MRET_4     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     9f SH_5       00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0200, used ffff, inputs a9
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       68 DIV_12     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       60 MULHU_3    00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     72 LBU_3      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     a9 ILL_4      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       53 LDAF_LH    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     a9 ILL_4      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       c0 DIV_D      00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      70 LHU_2      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    53 LDAF_LH    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    6e DIV_C      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     9c DIV_10     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       72 LBU_3      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     8a DIVU_5     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   5e LHU_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     72 LBU_3      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       c1 IJT_2      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    e0 DIVU_1     00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      72 LBU_3      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      92 LDAF_3     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     8e _LCSRRS_1  00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    82 DIV_1      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      9a ECALL_6    00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     b2 CSRRW_4    00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      c0 DIV_D      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       6e DIV_C      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   8f ILL_3      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     6b SB_4       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    72 LBU_3      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     96 SH_1       00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     8a DIVU_5     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    a2 DIV_14     00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      8e _LCSRRS_1  00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    94 SW_E4      00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     ab EBREAK_2   00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    b7 IJ_3       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       b0 CSRRW_3    00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 DIV_4      9f SH_5       00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 47 DIV_5      c6 IJT_4      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     81 unx81      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    da LDAF_a     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      86 JAL_2      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_1      fe ILLe       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40002033 sloppy slt     
 * 4f DIV_2      72 LBU_3      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 50 DIV_E      72 LBU_3      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 51 DIV_F      fb SB_3       00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 52 DIVU_5     1e aFault_1   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 53 LB_6       fb SB_3       00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 54 SH_1       e1 ORI_1      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 55 SW_E1SWH   41 JALR_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 DIV_10     a8 DIV_3      01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 57 DIV_11     53 LDAF_LH    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 58 DIV_14     b6 ECALL_5    00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00002063 close to branch
 * 59 DIV_15     56 LH_4       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00002067 close to jalr
 * 5a OR_1       aa DIV_6      00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     8a DIVU_5     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    a2 DIV_14     00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       e7 aFault     00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e ECAL_RET   3e SLL_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 5f EBRKWFI1   fb SB_3       00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 60 IJ_1       10 SUB_1      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00003003 close to load
 * 61 IJT_1      89 DIV_F      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 62 DIVU_3     ef WFI_5      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIVU_4     26 OR_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      75 unx75      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 ECALL_1    78 DIV_4      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 67 MRET_1     c9 MRET_2     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 68 LB_2       72 LBU_3      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd    53 LDAF_LH    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c     e3 MUL_3      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    bd IJ_4       00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     86 JAL_2      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e Fetch      e2 MUL_1      00000001001010001000101111101010110000  Fr11  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     f6 WFI_1      00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 MUL_1      ffffffff (null)     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 71 MUL_3      41 JALR_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 72 StdIncPc   3a SRxI_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 73 aFault     29 XOR_1      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 74 eILL0a        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 76 LBU_2      f9 MULH_2     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 77 aFaulte    f9 MULH_2     00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 78 SW_2       d4 aFault_2   00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00003063 close to branch
 * 79 aF_SW      d2 LB_2       00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00003067 close to jalr
 * 7a SLTIX_1    78 DIV_4      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     8a DIVU_5     00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    a2 DIV_14     00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e Fetch2     83 DIV_2      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 7f jFault        (use dinx) 00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 80 LBU_0      bf IJT_1      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 CSRRW_2       (use dinx) 00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 82 SLTIX_2    d2 LB_2       00000000000000000100001011101000110010        Registered ALU flag to rd                         0000400b close to ij
 * 83 NMI_2      4e eILL0b     00000000110000001111010011101000110000        mtval = 0.                                        0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 LDAF_2     76 Fetchu     00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 86 SLTX_1     8b LB_6       00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 87 SW_E4         (use dinx) 00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 88 WFI_1      56 LH_4       00110010000000000000000011001100100110 WFI    To check offset                                   00004023 close to store
 * 89 EBREAK_1   72 LBU_3      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 8a JAL_1      3a SRxI_1     00010000000000001100001011101000100000        Target adr to yy                                  40004023 close to store
 * 8b JAL_3      72 LBU_3      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      4e eILL0b     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e SLLI_1     fe ILLe       00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      40004033 sloppy xor     
 * 8f SLLI_2     93 SW_E2      00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 90 ECALL_2    8b LB_6       00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 91 ECALL_6    c8 DIV_7      00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 92 MULHU_7    8b LB_6       00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 93 ILL_4      ca DIVU_2     00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 94 SRxI_1     8b LB_6       00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 95 aF_SW_3    87 unx87      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 96 SRxI_2     e6 StdIncPc   00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 97 QINT_2     c9 MRET_2     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a SLL_1      8b LB_6       00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 9b SRx_1         (use dinx) 00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 9c JALR_1     36 SLLI_2     00010010000000000000000011101100100110        Q=1                                               00004073 close to csr/system 
 * 9d WFI_3      58 DIV_A      00010010000000000000101011101100100110        More check offset                                 00000000 
 * 9e ILL_1      ce _LCSRRCI_1 00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 9f ILL_2      78 DIV_4      00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 jFault_1   df eFetch     00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * a2 CSRRW_1    53 LDAF_LH    00010010000000000000000011101100100110        Construct PC storage adr                          0000500b close to ij
 * a3 aF_SW_1    72 LBU_3      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      0000500f close to fence
 * a4 SRxI_0     94 SW_E4      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 DIVU_1     d9 MULH_3     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * a6 LH_4       66 SW_1       00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * a7 ORI_1      af MRET_4     00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * a8 LH_5       46 ILL_1      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00005023 close to store
 * a9 SB_1       8b LB_6       00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * aa SB_2       ef WFI_5      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   40005023 close to store
 * ab MULHU_3    91 LDAF_2     00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * ac _L0xac     9b unx9b      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     a5 MRET_3     00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     9b unx9b      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af EBRKWFI2   ea MULHU_5    00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * b0 WFI_4      db jFault_1   00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * b1 aF_SW_2    c8 DIV_7      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * b2 MULH_1     6e DIV_C      00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * b3 MUL_2         (use dinx) 00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * b4 SB_4       bb SH_2       00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b5 IJT_3      cb QINT_2     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * b6 DIV_C      91 LDAF_2     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b7 MULHU_5    e8 MUL_2      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MRET_6     ffffffff (null)     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00005067 close to jalr
 * ba LBU_3      3a SRxI_1     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * bb unalignd   de Fetch      00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * bc CSRRWI_0   a2 DIV_14     00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SB_5       6e DIV_C      00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * be NMI_1      45 WFI_3      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * bf LBU_1      e9 IJT_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * c0 JAL_2      50 LW_1       10110000000000000100110011000x00100110        Return address to TRG                             00006003 close to load
 * c1 aFault_2   b5 SH_3       00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * c2 _LCSRRS_1  f2 SW_2       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000600b close to ij
 * c3 (null)     52 LH_1       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000600f close to fence
 * c4 ORI_0      a7 EBRKWFI1   00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     b9 DIV_e      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c6 ILL_3      9f SH_5       00000010000000000000101011101100100110        Q = 1                                             00000000 
 * c7 (null)     97 SW_E1SWH   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c8 LDAF_3     32 JAL_1      00000000000000001101100111100x00001xx0        PC to mepc                                        00006023 close to store
 * c9 SW_E2      d0 ECALL_1    00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * ca SW_E3      62 DIV_8      00110010000000000000101111001100100110        Q = 3                                             40006023 close to store
 * cb SH_4       72 LBU_3      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      4e eILL0b     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce SH_5       fe ILLe       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     40006033 sloppy or      
 * cf ECALL_4    13 condb_2    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d0 MRET_3     90 NMI_2      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * d1 (null)     f0 LBU_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d2 DIV_3      09 LB_5       01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * d3 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d4 DIV_6      c8 DIV_7      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * d5 (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d6 EBREAK_2   fe ILLe       00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * d7 (null)     cf MRET_7     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MRET_4     10 SUB_1      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00006067 close to jalr
 * da CSRRW_3    85 LBU_1      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * db CSRRW_4    c8 DIV_7      00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * dc CSRRSI_0   a2 DIV_14     00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd eFetch3    b1 aF_SW_3    0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * de SH_3       7e NMI_1      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * df ECALL_5    7e NMI_1      00110010000000000000101011001100100110        Q = 8                                             00000000 
 * e0 IJ_3       f2 SW_2       00010010000000000000110011101100100110        Construct Q = 1                                   00007003 close to load
 * e1 LH_3       3d SRxI_2     00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * e2 DIV_e      b3 unxb3      00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      0000700b close to ij
 * e3 MULH_2     3a SRxI_1     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 WFI_2      95 SW_E3      00010010000000000000101011101100100110        Check offset                                      00000000 
 * e6 SH_2       6e DIV_C      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * e7 SB_3       41 JALR_1     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e8 IJ_4       70 LHU_2      00000100000010001010110111100100011xx0        Mask and use as PC                                00007023 close to store
 * e9 IJT_2      eb LH_3       00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * ea MRET_5     4b CSRRW_2    00000010000000000000000011101100010xx0        ~302                                              40007023 close to store
 * eb IJT_4      a6 ECAL_RET   00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     a5 MRET_3     00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee QINT_1     fe ILLe       00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40007033 sloppy and     
 * ef DIV_7      6e DIV_C      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f0 MRET_2     ba LHU_3      00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * f1 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f2 DIVU_2     72 LBU_3      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f3 (null)     a3 DIV_15     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 _LCSRRCI_1 dd aF_SW_1    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f5 (null)     a1 ECALL_4    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f6 MRET_7     e5 aF_SW_2    00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f7 (null)     d6 eILL0c     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 Fetch2u    fa WFI_2      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00007067 close to jalr
 * fa MULH_3     9d DIV_11     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * fb LDAF_a     b4 eFetch3    00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * fc CSRRCI_0   a2 DIV_14     00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      be IJ_1       00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       9e SH_4       00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     ee eILL0a     00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0200, used ffff, inputs aa
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       68 DIV_12     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       60 MULHU_3    00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     72 LBU_3      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     b9 DIV_e      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       53 LDAF_LH    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     b9 DIV_e      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       d5 Fetch2u    00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      70 LHU_2      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    53 LDAF_LH    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    6e DIV_C      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     aa DIV_6      00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       72 LBU_3      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   5e LHU_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     72 LBU_3      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       c2 DIVU_3     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    8a DIVU_5     00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      72 LBU_3      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      9d DIV_11     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     94 SW_E4      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      a8 DIV_3      00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     bf IJT_1      00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      d5 Fetch2u    00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       6e DIV_C      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   95 SW_E3      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     6b SB_4       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    72 LBU_3      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     a5 MRET_3     00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    b1 aF_SW_3    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      94 SW_E4      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    a1 ECALL_4    00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     bb SH_2       00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    b7 IJ_3       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       be IJ_1       00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 DIV_4      b0 CSRRW_3    00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 47 DIV_5      dd aF_SW_1    00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     82 DIV_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    f4 Fetch2     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_1      fe ILLe       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40002033 sloppy slt     
 * 4f DIV_2      72 LBU_3      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 50 DIV_E      72 LBU_3      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 51 DIV_F      df eFetch     00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 52 DIVU_5     1e aFault_1   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 53 LB_6       df eFetch     00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 54 SH_1       e2 MUL_1      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 55 SW_E1SWH   41 JALR_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 DIV_10     b5 SH_3       01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 57 DIV_11     53 LDAF_LH    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 58 DIV_14     c1 IJT_2      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00002063 close to branch
 * 59 DIV_15     56 LH_4       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00002067 close to jalr
 * 5a OR_1       ba LHU_3      00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    b1 aF_SW_3    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       e7 aFault     00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e ECAL_RET   3e SLL_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 5f EBRKWFI1   df eFetch     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 60 IJ_1       10 SUB_1      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00003003 close to load
 * 61 IJT_1      89 DIV_F      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 62 DIVU_3     ca DIVU_2     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIVU_4     26 OR_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      75 unx75      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 ECALL_1    78 DIV_4      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 67 MRET_1     e1 ORI_1      00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 68 LB_2       72 LBU_3      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd    53 LDAF_LH    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c     e3 MUL_3      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    d0 ECALL_1    00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e Fetch      8b LB_6       00000001001010001000101111101010110000  Fr11  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     da LDAF_a     00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 MUL_1      ffffffff (null)     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 71 MUL_3      41 JALR_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 72 StdIncPc   3a SRxI_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 73 aFault     29 XOR_1      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 74 eILL0a        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 76 LBU_2      db jFault_1   00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 77 aFaulte    db jFault_1   00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 78 SW_2       ef WFI_5      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00003063 close to branch
 * 79 aF_SW      ee eILL0a     00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00003067 close to jalr
 * 7a SLTIX_1    78 DIV_4      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    b1 aF_SW_3    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e Fetch2     83 DIV_2      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 7f jFault        (use dinx) 00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 80 LBU_0      d4 aFault_2   00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 CSRRW_2    ee eILL0a     00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    0000400b close to ij
 * 83 NMI_2      4e eILL0b     00000000110000001111010011101000110000        mtval = 0.                                        0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     76 Fetchu     00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 LDAF_2     91 LDAF_2     00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 87 SW_E4         (use dinx) 00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 88 WFI_1      56 LH_4       00110010000000000000000011001100100110 WFI    To check offset                                   00004023 close to store
 * 89 EBREAK_1   72 LBU_3      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 8a IJ_3       3a SRxI_1     00010010000000000000110011101100100110        Construct Q = 1                                   40004023 close to store
 * 8b DIV_e      72 LBU_3      00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      4e eILL0b     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e SH_2       fe ILLe       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      40004033 sloppy xor     
 * 8f IJ_4       93 SW_E2      00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 90 JAL_1      91 LDAF_2     00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 91 JAL_3      e0 DIVU_1     00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 92 ECALL_6    91 LDAF_2     00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 93 ILL_4      e5 aF_SW_2    00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 94 SLLI_1     91 LDAF_2     00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 95 SLLI_2     87 unx87      00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 96 aF_SW_3    8e _LCSRRS_1  00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 97 QINT_2     e1 ORI_1      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a IJT_2      91 LDAF_2     00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * 9b MRET_5        (use dinx) 00000010000000000000000011101100010xx0        ~302                                              00000000 
 * 9c ECALL_2    36 SLLI_2     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00004073 close to csr/system 
 * 9d MULHU_7    58 DIV_A      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 9e IJT_4      e9 IJT_3      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 9f QINT_1     78 DIV_4      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SRxI_1     fb SB_3       00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * a2 jFault_1   53 LDAF_LH    00010000000000001110001011100x00100110        Store 1 to mcause                                 0000500b close to ij
 * a3 aF_SW_1    72 LBU_3      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      0000500f close to fence
 * a4 SRxI_0     a1 ECALL_4    00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SRxI_2     f1 aFaulte    00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * a6 DIVU_1     66 SW_1       00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * a7 ORI_1      bd IJ_4       00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * a8 SLL_1      46 ILL_1      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00005023 close to store
 * a9 SRx_1      91 LDAF_2     00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * aa JALR_1     ca DIVU_2     00010010000000000000000011101100100110        Q=1                                               40005023 close to store
 * ab WFI_3      92 LDAF_3     00010010000000000000101011101100100110        More check offset                                 00000000 
 * ac _L0xac     a9 ILL_4      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     a6 ECAL_RET   00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     a9 ILL_4      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af ILL_1      9b unx9b      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * b0 ILL_2      f5 jFault     00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * b1 CSRRW_1    e0 DIVU_1     00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * b2 aF_SW_2    6e DIV_C      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * b3 MUL_2         (use dinx) 00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * b4 LH_4       c9 MRET_2     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * b5 LH_5       e8 MUL_2      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * b6 IJT_3      92 LDAF_3     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * b7 MULHU_5    8f ILL_3      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SB_1       ffffffff (null)     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00005067 close to jalr
 * ba SB_2       3a SRxI_1     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * bb MULHU_3    fa WFI_2      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * bc CSRRWI_0   b1 aF_SW_3    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd EBRKWFI2   6e DIV_C      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * be WFI_4      45 WFI_3      00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * bf MULH_1     9a ECALL_6    00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * c0 SB_4       50 LW_1       00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00006003 close to load
 * c1 DIV_C      b6 ECALL_5    00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * c2 aFault_2   ce _LCSRRCI_1 00010000110000001110001011100x00100110        Store 5 to mcause                                 0000600b close to ij
 * c3 (null)     52 LH_1       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000600f close to fence
 * c4 ORI_0      a7 EBRKWFI1   00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_6     c5 MRET_5     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * c6 (null)     b0 CSRRW_3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c7 (null)     97 SW_E1SWH   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c8 LBU_3      32 JAL_1      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00006023 close to store
 * c9 unalignd   eb LH_3       00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * ca DIV_7      62 DIV_8      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            40006023 close to store
 * cb MRET_2     72 LBU_3      00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      4e eILL0b     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce DIVU_2     fe ILLe       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            40006033 sloppy or      
 * cf _LCSRRCI_1 13 condb_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d0 SB_5       9c DIV_10     00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * d1 NMI_1      cb QINT_2     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * d2 (null)     09 LB_5       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d3 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d4 LBU_1      e0 DIVU_1     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * d5 JAL_2         (use dinx) 10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * d6 (null)     fe ILLe       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d7 (null)     ea MULHU_5    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 _LCSRRS_1  10 SUB_1      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00006067 close to jalr
 * da MRET_7     86 JAL_2      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * db Fetch2u    e0 DIVU_1     0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * dc CSRRSI_0   b1 aF_SW_3    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd ILL_3      b2 CSRRW_4    00000010000000000000101011101100100110        Q = 1                                             00000000 
 * de MULH_3     7e NMI_1      00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * df LDAF_a     7e NMI_1      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * e0 LDAF_3     ce _LCSRRCI_1 00000000000000001101100111100x00001xx0        PC to mepc                                        00007003 close to load
 * e1 SW_E2      3d SRxI_2     00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * e2 LH_3       b3 unxb3      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 0000700b close to ij
 * e3 MULH_2     3a SRxI_1     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SW_E3      96 SH_1       00110010000000000000101111001100100110        Q = 3                                             00000000 
 * e6 WFI_2      6e DIV_C      00010010000000000000101011101100100110        Check offset                                      00000000 
 * e7 SB_3       41 JALR_1     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e8 SH_4       70 LHU_2      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00007023 close to store
 * e9 SH_5       9e SH_4       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * ea ECALL_4    4b CSRRW_2    00110010000000000000101011001100100110        Q = 4                                             40007023 close to store
 * eb MRET_3     b4 eFetch3    00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     a6 ECAL_RET   00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee DIV_3      fe ILLe       01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        40007033 sloppy and     
 * ef DIV_6      6e DIV_C      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * f0 EBREAK_2   c8 DIV_7      00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * f1 MRET_4     41 JALR_1     00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * f2 (null)     72 LBU_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f3 (null)     a3 DIV_15     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 CSRRW_3    f9 MULH_2     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * f5 CSRRW_4    a2 DIV_14     00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * f6 (null)     e6 StdIncPc   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     f0 LBU_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 eFetch3    de Fetch      0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00007067 close to jalr
 * fa SH_3       ab EBREAK_2   00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fb ECALL_5    c0 DIV_D      00110010000000000000101011001100100110        Q = 8                                             00000000 
 * fc CSRRCI_0   b1 aF_SW_3    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      d1 MRET_1     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       af MRET_4     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     9f SH_5       00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0200, used ffff, inputs b2
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       68 DIV_12     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       60 MULHU_3    00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     72 LBU_3      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     b0 CSRRW_3    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       53 LDAF_LH    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     b0 CSRRW_3    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       c0 DIV_D      00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      70 LHU_2      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    53 LDAF_LH    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    6e DIV_C      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     a6 ECAL_RET   00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       72 LBU_3      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   5e LHU_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     72 LBU_3      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       c2 DIVU_3     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    e9 IJT_3      00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      72 LBU_3      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      9d DIV_11     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     94 SW_E4      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      a3 DIV_15     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     b5 SH_3       00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      c0 DIV_D      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       6e DIV_C      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   95 SW_E3      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     6b SB_4       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    72 LBU_3      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     a2 DIV_14     00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    aa DIV_6      00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      94 SW_E4      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    a1 ECALL_4    00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     b2 CSRRW_4    00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    9f SH_5       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       b4 eFetch3    00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 DIV_4      a9 ILL_4      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 47 DIV_5      c5 MRET_5     00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     82 DIV_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    e3 MUL_3      00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_1      fe ILLe       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40002033 sloppy slt     
 * 4f DIV_2      72 LBU_3      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 50 DIV_E      72 LBU_3      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 51 DIV_F      fb SB_3       00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 52 DIVU_5     1e aFault_1   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 53 LB_6       fb SB_3       00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 54 SH_1       d2 LB_2       00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 55 SW_E1SWH   41 JALR_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 DIV_10     af MRET_4     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 57 DIV_11     53 LDAF_LH    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 58 DIV_14     b7 IJ_3       00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00002063 close to branch
 * 59 DIV_15     56 LH_4       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00002067 close to jalr
 * 5a OR_1       b1 aF_SW_3    00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    aa DIV_6      00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       d7 ECALL_3    00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e ECAL_RET   3e SLL_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 5f EBRKWFI1   fb SB_3       00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 60 IJ_1       10 SUB_1      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00003003 close to load
 * 61 IJT_1      89 DIV_F      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 62 DIVU_3     f3 aF_SW      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIVU_4     26 OR_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      75 unx75      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 ECALL_1    78 DIV_4      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 67 MRET_1     c9 MRET_2     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 68 LB_2       72 LBU_3      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd    53 LDAF_LH    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c     d3 aFaultd    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    bd IJ_4       00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e Fetch      ea MULHU_5    00000001001010001000101111101010110000  Fr11  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     f7 EBREAK_1   00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 MUL_1      ffffffff (null)     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 71 MUL_3      41 JALR_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 72 StdIncPc   3a SRxI_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 73 aFault     29 XOR_1      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 74 eILL0a        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 76 LBU_2      f9 MULH_2     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 77 aFaulte    f9 MULH_2     00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 78 SW_2       e0 DIVU_1     00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00003063 close to branch
 * 79 aF_SW      dd aF_SW_1    00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00003067 close to jalr
 * 7a SLTIX_1    78 DIV_4      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    aa DIV_6      00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e Fetch2     83 DIV_2      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 7f jFault        (use dinx) 00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 80 LBU_0      bf IJT_1      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 CSRRW_2    dd aF_SW_1    00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    0000400b close to ij
 * 83 NMI_2      4e eILL0b     00000000110000001111010011101000110000        mtval = 0.                                        0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     76 Fetchu     00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 LDAF_2     91 LDAF_2     00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 87 SW_E4         (use dinx) 00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 88 WFI_1      56 LH_4       00110010000000000000000011001100100110 WFI    To check offset                                   00004023 close to store
 * 89 EBREAK_1   72 LBU_3      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 8a ECALL_6    3a SRxI_1     00010000110000001110100111000x00100000        mcause = 11                                       40004023 close to store
 * 8b ILL_4      72 LBU_3      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      4e eILL0b     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e aF_SW_3    fe ILLe       00010000110000001110001011000x00100000        Store 7 to mcause                                 40004033 sloppy xor     
 * 8f QINT_2     8b LB_6       00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 90 JAL_1      91 LDAF_2     00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 91 JAL_3      c8 DIV_7      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 92 jFault_1   91 LDAF_2     00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 93 aF_SW_1    d0 ECALL_1    00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 94 SLLI_1     91 LDAF_2     00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 95 SLLI_2     87 unx87      00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 96 DIVU_1     eb LH_3       00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * 97 ORI_1      c9 MRET_2     00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a aF_SW_2    91 LDAF_2     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 9b MUL_2         (use dinx) 00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * 9c ECALL_2    36 SLLI_2     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00004073 close to csr/system 
 * 9d MULHU_7    58 DIV_A      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 9e IJT_3      d4 aFault_2   00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 9f MULHU_5    78 DIV_4      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SRxI_1     e8 MUL_2      00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * a2 SRxI_2     53 LDAF_LH    00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                0000500b close to ij
 * a3 SLL_1      72 LBU_3      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              0000500f close to fence
 * a4 SRxI_0     a1 ECALL_4    00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SRx_1      e2 MUL_1      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * a6 JALR_1     66 SW_1       00010010000000000000000011101100100110        Q=1                                               00000000 
 * a7 WFI_3      b3 unxb3      00010010000000000000101011101100100110        More check offset                                 00000000 
 * a8 ILL_1      46 ILL_1      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00005023 close to store
 * a9 ILL_2      91 LDAF_2     00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * aa CSRRW_1    f3 aF_SW      00010010000000000000000011101100100110        Construct PC storage adr                          40005023 close to store
 * ab LH_4       8a DIVU_5     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * ac _L0xac     a5 MRET_3     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     96 SH_1       00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     a5 MRET_3     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af LH_5       f0 LBU_2      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * b0 SB_1       e5 aF_SW_2    00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * b1 SB_2       c8 DIV_7      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * b2 MULHU_3    6e DIV_C      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * b3 EBRKWFI2      (use dinx) 00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * b4 WFI_4      bb SH_2       00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * b5 MULH_1     d1 MRET_1     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * b6 SB_4       8a DIVU_5     00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b7 DIV_C      ee eILL0a     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MRET_6     ffffffff (null)     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00005067 close to jalr
 * ba LBU_3      3a SRxI_1     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * bb unalignd   e7 aFault     00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * bc CSRRWI_0   aa DIV_6      00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SB_5       6e DIV_C      00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * be NMI_1      45 WFI_3      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * bf LBU_1      ef WFI_5      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * c0 JAL_2      50 LW_1       10110000000000000100110011000x00100110        Return address to TRG                             00006003 close to load
 * c1 _LCSRRS_1  9e SH_4       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * c2 aFault_2   f5 jFault     00010000110000001110001011100x00100110        Store 5 to mcause                                 0000600b close to ij
 * c3 (null)     52 LH_1       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000600f close to fence
 * c4 ORI_0      97 SW_E1SWH   00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 ILL_3      b9 DIV_e      00000010000000000000101011101100100110        Q = 1                                             00000000 
 * c6 (null)     a9 ILL_4      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c7 (null)     8f ILL_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c8 LDAF_3     32 JAL_1      00000000000000001101100111100x00001xx0        PC to mepc                                        00006023 close to store
 * c9 SW_E2      d9 MULH_3     00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * ca (null)     62 DIV_8      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   40006023 close to store
 * cb (null)     72 LBU_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      4e eILL0b     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce (null)     fe ILLe       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   40006033 sloppy or      
 * cf (null)     13 condb_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * d0 SW_E3      9c DIV_10     00110010000000000000101111001100100110        Q = 3                                             00000000 
 * d1 SH_4       f4 Fetch2     00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * d2 LH_3       09 LB_5       00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * d3 MULH_2     41 JALR_1     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * d4 SH_5       c8 DIV_7      00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * d5 ECALL_4       (use dinx) 00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d6 WFI_2      fe ILLe       00010010000000000000101011101100100110        Check offset                                      00000000 
 * d7 SB_3       d5 Fetch2u    00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MRET_3     10 SUB_1      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00006067 close to jalr
 * da (null)     86 JAL_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * db (null)     c8 DIV_7      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * dc CSRRSI_0   aa DIV_6      00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd DIV_3      9a ECALL_6    01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * de (null)     7e NMI_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * df (null)     7e NMI_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e0 DIV_6      f5 jFault     00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00007003 close to load
 * e1 EBREAK_2   3d SRxI_2     00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * e2 MRET_4     9b unx9b      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          0000700b close to ij
 * e3 CSRRW_3    3a SRxI_1     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 CSRRW_4    8e _LCSRRS_1  00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * e6 eFetch3    6e DIV_C      0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * e7 SH_3       41 JALR_1     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e8 ECALL_5    70 LHU_2      00110010000000000000101011001100100110        Q = 8                                             00007023 close to store
 * e9 IJ_3       f1 aFaulte    00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * ea DIV_e      4b CSRRW_2    00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      40007023 close to store
 * eb SH_2       ab EBREAK_2   00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     96 SH_1       00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee IJ_4       fe ILLe       00000100000010001010110111100100011xx0        Mask and use as PC                                40007033 sloppy and     
 * ef IJT_2      6e DIV_C      00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * f0 MRET_5     ba LHU_3      00000010000000000000000011101100010xx0        ~302                                              00000000 
 * f1 IJT_4      41 JALR_1     00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * f2 QINT_1     72 LBU_3      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * f3 DIV_7      93 SW_E2      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f4 MRET_2     e6 StdIncPc   00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * f5 DIVU_2     92 LDAF_3     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f6 _LCSRRCI_1 d6 eILL0c     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f7 MRET_7     e1 ORI_1      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 Fetch2u    fa WFI_2      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00007067 close to jalr
 * fa MULH_3     a7 EBRKWFI1   00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * fb LDAF_a     b6 ECALL_5    00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * fc CSRRCI_0   aa DIV_6      00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      be IJ_1       00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       a8 DIV_3      00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     f2 SW_2       00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0004, used ffff, inputs b8
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       9e SH_4       00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       8e _LCSRRS_1  00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     aa DIV_6      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     aa DIV_6      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     df eFetch     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       7f unx7f      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     df eFetch     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       f9 MULH_2     00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      a8 DIV_3      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     aa DIV_6      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 CSRRW_2    7f unx7f      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 11 NMI_2      3a SRxI_1     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 12 LDAF_2     68 DIV_12     00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 13 SW_E4      2e MULHU_1    00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 14 ECALL_6    39 MULHU_7    00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 15 ILL_4      06 LB_3       00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 16 aF_SW_3    aa DIV_6      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 17 QINT_2     a6 ECAL_RET   00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     ce _LCSRRCI_1 00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       aa DIV_6      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   8a DIVU_5     00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     aa DIV_6      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e MULHU_2    50 LW_1       00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 1f MULHU_4    90 NMI_2      00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 20 LH_0       42 MULHU_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      aa DIV_6      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      c5 MRET_5     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     aa DIV_6      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     af MRET_4     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 eILL0b     5d SB_2       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     3d SRxI_2     00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     82 DIV_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     82 DIV_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      ca DIVU_2     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     e5 aF_SW_2    00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    1e aFault_1   00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     aa DIV_6      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LDAF_3     aa DIV_6      00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 31 SW_E2      7a SB_5       00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 32 SW_E3      f9 MULH_2     00110010000000000000101111001100100110        Q = 3                                             00000000 
 * 33 SH_4          (use dinx) 00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 34 SH_5       a6 ECAL_RET   00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 ECALL_4    b9 DIV_e      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 36 MRET_3     03 _L0x03     00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * 37 DIV_3      a3 DIV_15     01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    aa DIV_6      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     c9 MRET_2     00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    db jFault_1   00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LW_1       af MRET_4     00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    c8 DIV_7      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 LH_1       e1 ORI_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH    b7 IJ_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       e3 MUL_3      00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 LH_2       da LDAF_a     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    fb SB_3       00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     10 SUB_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    73 unalignd   00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_A      fe ILLe       00110010000000000000101111101100001xx1        Transfer rM to rDee                               40002033 sloppy slt     
 * 4f DIV_B      aa DIV_6      00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 50 aFault_2   aa DIV_6      00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 51 (null)     d7 ECALL_3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 52 (null)     46 ILL_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 53 (null)     d7 ECALL_3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 54 (null)     f0 LBU_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 55 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 56 (null)     de Fetch      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 57 (null)     7f unx7f      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 58 LHU_1      e7 aFault     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00002063 close to branch
 * 59 LDAF_LHU   86 JAL_2      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00002067 close to jalr
 * 5a OR_1       e0 DIVU_1     00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    db jFault_1   00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       f3 aF_SW      00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIV_8      66 SW_1       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 5f DIV_9      d7 ECALL_3    01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 60 SW_1       1e aFault_1   00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00003003 close to load
 * 61 SW_E1SWE   c7 QINT_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 DIV_12     d0 ECALL_1    00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              0000300b close to ij
 * 63 DIV_13     4e eILL0b     00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      bb SH_2       00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 LHU_2      c0 DIV_D      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 67 aFaultc    31 SLTX_1     00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 68 Fetchu     aa DIV_6      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00003023 close to store
 * 69 eFetchu    7f unx7f      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 6a DIV_4      f1 aFaulte    00000000000000001100000011101000110000        ~abs(divisor) to yy                               40003023 close to store
 * 6b DIV_5      eb LH_3       00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_1      91 LDAF_2     00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40003033 sloppy sltu    
 * 6f DIV_2      d4 aFault_2   00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 70 DIV_6      ffffffff (null)     00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * 71 EBREAK_2   41 JALR_1     00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * 72 MRET_4     3a SRxI_1     00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * 73 CSRRW_3    29 XOR_1      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * 74 CSRRW_4       (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * 75 eFetch3       (use dinx) 0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * 76 SH_3       d5 Fetch2u    00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * 77 ECALL_5    d5 Fetch2u    00110010000000000000101011001100100110        Q = 8                                             00000000 
 * 78 DIV_E      70 LHU_2      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003063 close to branch
 * 79 DIV_F      37 ECALL_2    00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00003067 close to jalr
 * 7a SLTIX_1    c0 DIV_D      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    db jFault_1   00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e DIVU_5     11 AND_1      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 7f LB_6          (use dinx) 00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 80 LBU_0      ef WFI_5      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 SH_1       37 ECALL_2    00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        0000400b close to ij
 * 83 SW_E1SWH   6e DIV_C      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     be IJ_1       00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 DIV_10     a5 MRET_3     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 87 DIV_11        (use dinx) 01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 88 DIV_14     86 JAL_2      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00004023 close to store
 * 89 DIV_15     aa DIV_6      00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 8a ECAL_RET   3a SRxI_1     00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40004023 close to store
 * 8b EBRKWFI1   aa DIV_6      00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      6e DIV_C      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e IJ_1       fe ILLe       00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   40004033 sloppy xor     
 * 8f IJT_1      15 condb_4    00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 90 IJ_3       a5 MRET_3     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 91 DIV_e      30 SLTIX_2    00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 92 SH_2       a5 MRET_3     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 93 IJ_4       32 JAL_1      00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 94 IJT_2      a5 MRET_3     00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * 95 MRET_5     13 condb_2    00000010000000000000000011101100010xx0        ~302                                              00000000 
 * 96 IJT_4      92 LDAF_3     00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 97 QINT_1     31 SLTX_1     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a DIVU_3     a5 MRET_3     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 9b DIVU_4        (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 9c ECALL_1    62 DIV_8      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00004073 close to csr/system 
 * 9d MRET_1     88 DIV_E      00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 9e LB_2       34 JAL_3      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 9f aFaultd    c0 DIV_D      00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * a0 LHU_0      58 DIV_A      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JAL_1      77 eFetchu    00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * a2 eILL0c     7f unx7f      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000500b close to ij
 * a3 ECALL_3    aa DIV_6      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    0000500f close to fence
 * a4 SRxI_0     c8 DIV_7      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 JAL_3      72 LBU_3      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a6 Fetch      9c DIV_10     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * a7 eFetch     e2 MUL_1      00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * a8 MUL_1      6a MULH_1     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00005023 close to store
 * a9 MUL_3      a5 MRET_3     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * aa StdIncPc   d0 ECALL_1    10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    40005023 close to store
 * ab aFault     14 condb_3    00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * ac _L0xac     cb QINT_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     b2 CSRRW_4    00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     cb QINT_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SLLI_1     95 SW_E3      00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * b0 jFault_1   74 unx74      00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * b1 aF_SW_1    30 SLTIX_2    00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * b2 DIVU_1     a6 ECAL_RET   00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * b3 ORI_1         (use dinx) 00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * b4 aF_SW_2    ea MULHU_5    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * b5 MUL_2      33 unx33      00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * b6 IJT_3      14 condb_3    00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * b7 MULHU_5    93 SW_E2      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SLLI_2     ffffffff (null)     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00005067 close to jalr
 * ba eILL0a     3a SRxI_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bb WFI_5      76 Fetchu     00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * bc CSRRWI_0   db jFault_1   00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ECALL_2    a6 ECAL_RET   00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * be LBU_2      45 WFI_3      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * bf aFaulte    94 SW_E4      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * c0 SW_2       78 DIV_4      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00006003 close to load
 * c1 aF_SW      b6 ECALL_5    00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * c2 Fetch2     d2 LB_2       00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     0000600b close to ij
 * c3 jFault     7e NMI_1      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000600f close to fence
 * c4 ORI_0      b3 unxb3      00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MULHU_7    e8 MUL_2      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * c6 WFI_1      da LDAF_a     00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * c7 EBREAK_1   17 condb_5t   00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * c8 SRxI_1     5e LHU_1      00000000000000000100101001101100001xx1        Register to shift to Q                            00006023 close to store
 * c9 SRxI_2     36 SLLI_2     00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * ca SLL_1      9a ECALL_6    00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              40006023 close to store
 * cb SRx_1      aa DIV_6      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      6e DIV_C      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce JALR_1     fe ILLe       00010010000000000000000011101100100110        Q=1                                               40006033 sloppy or      
 * cf WFI_3      27 OR_2       00010010000000000000101011101100100110        More check offset                                 00000000 
 * d0 DIV_7      bd IJ_4       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d1 MRET_2     d1 MRET_1     00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * d2 DIVU_2     09 LB_5       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d3 _LCSRRCI_1 41 JALR_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d4 MRET_7     30 SLTIX_2    00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * d5 Fetch2u       (use dinx) 0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * d6 MULH_3     fe ILLe       00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * d7 LDAF_a     35 SLLI_1     00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 ILL_1      1e aFault_1   00000000000000001101101011100x00001xx0        Store PC to mepc                                  00006067 close to jalr
 * da ILL_2      12 straddle   00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * db CSRRW_1    30 SLTIX_2    00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * dc CSRRSI_0   db jFault_1   00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd LH_4       b4 eFetch3    00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * de LH_5       c2 DIVU_3     00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * df SB_1       c2 DIVU_3     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * e0 SB_2       d2 LB_2       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00007003 close to load
 * e1 MULHU_3    3d SRxI_2     00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * e2 EBRKWFI2   b5 SH_3       00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         0000700b close to ij
 * e3 WFI_4      3a SRxI_1     00000010000000000000001011x01001xxxxx0        Prepare read PC                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 MULH_1     16 condb_5    00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * e6 SB_4       a6 ECAL_RET   00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * e7 DIV_C      41 JALR_1     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * e8 MRET_6     a8 DIV_3      00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00007023 close to store
 * e9 LBU_3      96 SH_1       00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * ea unalignd   4b CSRRW_2    00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                40007023 close to store
 * eb SB_5       dd aF_SW_1    00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     b2 CSRRW_4    00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee NMI_1      fe ILLe       00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40007033 sloppy and     
 * ef LBU_1      a6 ECAL_RET   00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * f0 LH_3       e9 IJT_3      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f1 MULH_2     41 JALR_1     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * f2 WFI_2      aa DIV_6      00010010000000000000101011101100100110        Check offset                                      00000000 
 * f3 SB_3       b1 aF_SW_3    00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f4 (null)     75 unx75      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f5 (null)     b0 CSRRW_3    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f6 (null)     f2 SW_2       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     71 aFaultc    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 JAL_2      d6 eILL0c     10110000000000000100110011000x00100110        Return address to TRG                             00007067 close to jalr
 * fa _LCSRRS_1  cf MRET_7     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * fb ILL_3      e6 StdIncPc   00000010000000000000101011101100100110        Q = 1                                             00000000 
 * fc CSRRCI_0   db jFault_1   00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      ee eILL0a     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       d9 MULH_3     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     97 SW_E1SWH   00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0800, used ffff, inputs c3
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       68 DIV_12     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       60 MULHU_3    00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     72 LBU_3      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     a6 ECAL_RET   00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       53 LDAF_LH    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     a6 ECAL_RET   00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       c0 DIV_D      00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      70 LHU_2      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    53 LDAF_LH    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    6e DIV_C      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     9a ECALL_6    00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       72 LBU_3      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     85 LBU_1      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   5e LHU_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     72 LBU_3      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       a3 DIV_15     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    d6 eILL0c     00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      72 LBU_3      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      91 LDAF_2     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     8a DIVU_5     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      95 SW_E3      00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     b1 aF_SW_3    00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      c0 DIV_D      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       6e DIV_C      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   8e _LCSRRS_1  00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     6b SB_4       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    72 LBU_3      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     94 SW_E4      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     85 LBU_1      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      8a DIVU_5     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    92 LDAF_3     00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     a9 ILL_4      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    f2 SW_2       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       b0 CSRRW_3    00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 DIV_4      9e SH_4       00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 47 DIV_5      c2 DIVU_3     00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     83 DIV_2      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    d1 MRET_1     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      82 DIV_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_1      fe ILLe       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40002033 sloppy slt     
 * 4f DIV_2      72 LBU_3      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 50 DIV_E      72 LBU_3      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 51 DIV_F      e8 MUL_2      00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 52 DIVU_5     1e aFault_1   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 53 LB_6       e8 MUL_2      00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 54 SH_1       f3 aF_SW      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 55 SW_E1SWH   41 JALR_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 DIV_10     a5 MRET_3     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 57 DIV_11     53 LDAF_LH    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 58 DIV_14     b4 eFetch3    00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00002063 close to branch
 * 59 DIV_15     56 LH_4       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00002067 close to jalr
 * 5a OR_1       a8 DIV_3      00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     85 LBU_1      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       f6 WFI_1      00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e ECAL_RET   3e SLL_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 5f EBRKWFI1   e8 MUL_2      00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 60 IJ_1       10 SUB_1      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00003003 close to load
 * 61 IJT_1      89 DIV_F      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 62 DIVU_3     e0 DIVU_1     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIVU_4     26 OR_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      75 unx75      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 ECALL_1    78 DIV_4      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 67 MRET_1     c5 MRET_5     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 68 LB_2       72 LBU_3      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd    53 LDAF_LH    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c     f4 Fetch2     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    ba LHU_3      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     82 DIV_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e Fetch      d7 ECALL_3    00000001001010001000101111101010110000  Fr11  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     e5 aF_SW_2    00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 MUL_1      ffffffff (null)     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 71 MUL_3      41 JALR_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 72 StdIncPc   3a SRxI_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 73 aFault     29 XOR_1      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 74 eILL0a        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 76 LBU_2      e6 StdIncPc   00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 77 aFaulte    e6 StdIncPc   00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 78 SW_2       ce _LCSRRCI_1 00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00003063 close to branch
 * 79 aF_SW      cb QINT_2     00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00003067 close to jalr
 * 7a SLTIX_1    78 DIV_4      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     85 LBU_1      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e Fetch2     87 unx87      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 7f jFault        (use dinx) 00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 80 LBU_0      be IJ_1       00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 SLTX_1     cb QINT_2     00000010000000000000111111101100000xx0        ~rs2 to Q                                         0000400b close to ij
 * 83 CSRRW_2    4e eILL0b     00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 JAL_1      76 Fetchu     00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 86 JAL_3      86 JAL_2      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 87 NMI_2         (use dinx) 00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 88 WFI_1      56 LH_4       00110010000000000000000011001100100110 WFI    To check offset                                   00004023 close to store
 * 89 EBREAK_1   72 LBU_3      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 8a SLLI_1     3a SRxI_1     00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      40004023 close to store
 * 8b LDAF_2     72 LBU_3      00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      4e eILL0b     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e SLLI_2     fe ILLe       00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                40004033 sloppy xor     
 * 8f SW_E4      97 SW_E1SWH   00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 90 ECALL_2    86 JAL_2      00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 91 MULHU_7    c3 DIVU_4     00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 92 SRxI_1     86 JAL_2      00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 93 ECALL_6    c6 IJT_4      00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 94 SRxI_2     86 JAL_2      00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 95 SLL_1      8f ILL_3      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 96 SRx_1      d9 MULH_3     00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 97 ILL_4      c5 MRET_5     00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a JALR_1     86 JAL_2      00010010000000000000000011101100100110        Q=1                                               00000000 
 * 9b aF_SW_3       (use dinx) 00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 9c WFI_3      36 SLLI_2     00010010000000000000101011101100100110        More check offset                                 00004073 close to csr/system 
 * 9d ILL_1      58 DIV_A      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 9e ILL_2      c8 DIV_7      00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 9f QINT_2     78 DIV_4      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 CSRRW_1    d5 Fetch2u    00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * a2 LH_4       53 LDAF_LH    00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      0000500b close to ij
 * a3 aFault_2   72 LBU_3      00010000110000001110001011100x00100110        Store 5 to mcause                                 0000500f close to fence
 * a4 SRxI_0     92 LDAF_3     00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 LH_5       d0 ECALL_1    00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * a6 SB_1       66 SW_1       00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * a7 (null)     aa DIV_6      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * a8 SB_2       46 ILL_1      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00005023 close to store
 * a9 MULHU_3    86 JAL_2      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * aa EBRKWFI2   e0 DIVU_1     00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         40005023 close to store
 * ab (null)     93 SW_E2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ac _L0xac     96 SH_1       00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     eb LH_3       00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     96 SH_1       00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af (null)     dd aF_SW_1    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b0 WFI_4      d2 LB_2       00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * b1 MULH_1     c3 DIVU_4     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * b2 SB_4       6e DIV_C      00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b3 (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b4 DIV_C      b9 DIV_e      00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b5 MRET_6     c7 QINT_1     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * b6 LBU_3      93 SW_E2      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * b7 (null)     da LDAF_a     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 unalignd   ffffffff (null)     00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00005067 close to jalr
 * ba SB_5       3a SRxI_1     00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * bb (null)     d4 aFault_2   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * bc CSRRWI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd NMI_1      6e DIV_C      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * be LBU_1      45 WFI_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * bf (null)     db jFault_1   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c0 JAL_2      50 LW_1       10110000000000000100110011000x00100110        Return address to TRG                             00006003 close to load
 * c1 _LCSRRS_1  f1 aFaulte    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * c2 ILL_3      e2 MUL_1      00000010000000000000101011101100100110        Q = 1                                             0000600b close to ij
 * c3 LDAF_3     52 LH_1       00000000000000001101100111100x00001xx0        PC to mepc                                        0000600f close to fence
 * c4 ORI_0      ee eILL0a     00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 SW_E2      b5 SH_3       00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * c6 SW_E3      9e SH_4       00110010000000000000101111001100100110        Q = 3                                             00000000 
 * c7 SH_4       9f SH_5       00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * c8 SH_5       32 JAL_1      00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00006023 close to store
 * c9 ECALL_4    ca DIVU_2     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * ca MRET_3     62 DIV_8      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          40006023 close to store
 * cb DIV_3      72 LBU_3      01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      4e eILL0b     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce DIV_6      fe ILLe       00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            40006033 sloppy or      
 * cf EBREAK_2   13 condb_2    00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * d0 MRET_4     90 NMI_2      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * d1 CSRRW_3    e1 ORI_1      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * d2 CSRRW_4    09 LB_5       00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d3 eFetch3    41 JALR_1     0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * d4 SH_3       c3 DIVU_4     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d5 ECALL_5       (use dinx) 00110010000000000000101011001100100110        Q = 8                                             00000000 
 * d6 IJ_3       fe ILLe       00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * d7 DIV_e      c9 MRET_2     00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 SH_2       10 SUB_1      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00006067 close to jalr
 * da IJ_4       8b LB_6       00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * db IJT_2      c3 DIVU_4     00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * dc CSRRSI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd MRET_5     ef WFI_5      00000010000000000000000011101100010xx0        ~302                                              00000000 
 * de IJT_4      7e NMI_1      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * df QINT_1     7e NMI_1      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * e0 DIV_7      e2 MUL_1      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00007003 close to load
 * e1 MRET_2     3d SRxI_2     00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * e2 DIVU_2     f0 LBU_2      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            0000700b close to ij
 * e3 _LCSRRCI_1 3a SRxI_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 MRET_7     9b unx9b      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * e6 Fetch2u    6e DIV_C      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * e7 MULH_3     41 JALR_1     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * e8 LDAF_a     70 LHU_2      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00007023 close to store
 * e9 jFault_1   de Fetch      00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * ea aF_SW_1    4b CSRRW_2    00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      40007023 close to store
 * eb DIVU_1     a2 DIV_14     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     eb LH_3       00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee ORI_1      fe ILLe       00000010000000000000000011101100001xx0        Q = RS1                                           40007033 sloppy and     
 * ef aF_SW_2    6e DIV_C      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * f0 MUL_2      b6 ECALL_5    00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * f1 IJT_3      41 JALR_1     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * f2 MULHU_5    72 LBU_3      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * f3 LH_3       ea MULHU_5    00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f4 MULH_2     d3 aFaultd    00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * f5 WFI_2      e9 IJT_3      00010010000000000000101011101100100110        Check offset                                      00000000 
 * f6 SB_3       f5 jFault     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f7 (null)     cf MRET_7     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)     e7 aFault     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00007067 close to jalr
 * fa (null)     9c DIV_10     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     b2 CSRRW_4    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      bd IJ_4       00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       9d DIV_11     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     df eFetch     00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 2000, used ffff, inputs c5
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       68 DIV_12     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       60 MULHU_3    00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     72 LBU_3      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     9b unx9b      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       53 LDAF_LH    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     9b unx9b      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       ab EBREAK_2   00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      70 LHU_2      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    53 LDAF_LH    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    6e DIV_C      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     92 LDAF_3     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       72 LBU_3      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   5e LHU_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     72 LBU_3      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       e1 ORI_1      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    c6 IJT_4      00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      72 LBU_3      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      8b LB_6       00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     88 DIV_E      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      90 NMI_2      00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     a1 ECALL_4    00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      ab EBREAK_2   00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       6e DIV_C      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   89 DIV_F      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     6b SB_4       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    72 LBU_3      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     8f ILL_3      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    96 SH_1       00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      88 DIV_E      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    8e _LCSRRS_1  00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     9d DIV_11     00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    ee eILL0a     00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       9f SH_5       00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 DIV_4      95 SW_E3      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 47 DIV_5      b0 CSRRW_3    00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     c1 IJT_2      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    be IJ_1       00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_1      fe ILLe       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40002033 sloppy slt     
 * 4f DIV_2      72 LBU_3      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 50 DIV_E      72 LBU_3      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 51 DIV_F      df eFetch     00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 52 DIVU_5     1e aFault_1   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 53 LB_6       df eFetch     00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 54 SH_1       ef WFI_5      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 55 SW_E1SWH   41 JALR_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 DIV_10     9a ECALL_6    01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 57 DIV_11     53 LDAF_LH    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 58 DIV_14     a3 DIV_15     00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00002063 close to branch
 * 59 DIV_15     56 LH_4       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00002067 close to jalr
 * 5a OR_1       9c DIV_10     00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    96 SH_1       00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       f4 Fetch2     00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e ECAL_RET   3e SLL_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 5f EBRKWFI1   df eFetch     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 60 IJ_1       10 SUB_1      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00003003 close to load
 * 61 IJT_1      83 DIV_2      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 62 DIVU_3     d4 aFault_2   00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIVU_4     26 OR_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      75 unx75      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 ECALL_1    78 DIV_4      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 67 MRET_1     b2 CSRRW_4    00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 68 LB_2       72 LBU_3      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd    53 LDAF_LH    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c     f0 LBU_2      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    a8 DIV_3      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e Fetch      c7 QINT_1     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     da LDAF_a     00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 MUL_1      ffffffff (null)     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 71 MUL_3      41 JALR_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 72 StdIncPc   3a SRxI_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 73 aFault     29 XOR_1      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 74 eILL0a        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 76 LBU_2      dd aF_SW_1    00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 77 aFaulte    dd aF_SW_1    00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 78 SW_2       ba LHU_3      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00003063 close to branch
 * 79 aF_SW      b9 DIV_e      00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00003067 close to jalr
 * 7a SLTIX_1    78 DIV_4      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    96 SH_1       00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e Fetch2     c3 DIVU_4     00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 7f jFault        (use dinx) 00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 80 LBU_0      aa DIV_6      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 WFI_1      b9 DIV_e      00110010000000000000000011001100100110 WFI    To check offset                                   0000400b close to ij
 * 83 EBREAK_1   4e eILL0b     00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     76 Fetchu     00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 JAL_1      87 unx87      00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 87 JAL_3         (use dinx) 00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 88 SLLI_1     56 LH_4       00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00004023 close to store
 * 89 SLLI_2     72 LBU_3      00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 8a ECALL_2    3a SRxI_1     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  40004023 close to store
 * 8b MULHU_7    72 LBU_3      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      4e eILL0b     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e SRxI_1     fe ILLe       00000000000000000100101001101100001xx1        Register to shift to Q                            40004033 sloppy xor     
 * 8f SRxI_2     d3 aFaultd    00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 90 SLL_1      87 unx87      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 91 SRx_1      b1 aF_SW_3    00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 92 JALR_1     87 unx87      00010010000000000000000011101100100110        Q=1                                               00000000 
 * 93 WFI_3      b3 unxb3      00010010000000000000101011101100100110        More check offset                                 00000000 
 * 94 ILL_1      87 unx87      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 95 ILL_2      cb QINT_2     00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 96 CSRRW_1    c8 DIV_7      00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 97 LH_4       b2 CSRRW_4    00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a LH_5       87 unx87      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 9b SB_1          (use dinx) 00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 9c SB_2       36 SLLI_2     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00004073 close to csr/system 
 * 9d MULHU_3    58 DIV_A      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * 9e EBRKWFI2   b5 SH_3       00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 9f WFI_4      78 DIV_4      00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 MULH_1     c5 MRET_5     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * a2 SB_4       53 LDAF_LH    00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      0000500b close to ij
 * a3 DIV_C      72 LBU_3      00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              0000500f close to fence
 * a4 SRxI_0     8e _LCSRRS_1  00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_6     bd IJ_4       00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * a6 LBU_3      66 SW_1       00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * a7 unalignd   9e SH_4       00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * a8 SB_5       46 ILL_1      00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00005023 close to store
 * a9 NMI_1      87 unx87      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * aa LBU_1      d4 aFault_2   00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40005023 close to store
 * ab JAL_2      d1 MRET_1     10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * ac _L0xac     91 LDAF_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     e5 aF_SW_2    00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     91 LDAF_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af _LCSRRS_1  cf MRET_7     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b0 ILL_3      bf IJT_1      00000010000000000000101011101100100110        Q = 1                                             00000000 
 * b1 LDAF_3     b1 aF_SW_3    00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * b2 SW_E2      6e DIV_C      00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * b3 SW_E3         (use dinx) 00110010000000000000101111001100100110        Q = 3                                             00000000 
 * b4 SH_4       a7 EBRKWFI1   00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b5 SH_5       b4 eFetch3    00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b6 ECALL_4    d1 MRET_1     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * b7 MRET_3     ca DIVU_2     00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 DIV_3      ffffffff (null)     01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00005067 close to jalr
 * ba DIV_6      3a SRxI_1     00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * bb EBREAK_2   c2 DIVU_3     00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * bc CSRRWI_0   96 SH_1       00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd MRET_4     6e DIV_C      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * be CSRRW_3    45 WFI_3      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * bf CSRRW_4    ce _LCSRRCI_1 00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * c0 eFetch3    50 LW_1       0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00006003 close to load
 * c1 CSRRW_2    ea MULHU_5    00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * c2 SH_3       d6 eILL0c     00000010000000000000000011101000110000        Prepare get back address to use                   0000600b close to ij
 * c3 NMI_2      52 LH_1       00000000110000001111010011101000110000        mtval = 0.                                        0000600f close to fence
 * c4 ORI_0      e6 StdIncPc   00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 ECALL_5    a5 MRET_3     00110010000000000000101011001100100110        Q = 8                                             00000000 
 * c6 IJ_3       95 SW_E3      00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * c7 DIV_e      db jFault_1   00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * c8 SH_2       32 JAL_1      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00006023 close to store
 * c9 LDAF_2     b7 IJ_3       00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * ca IJ_4       62 DIV_8      00000100000010001010110111100100011xx0        Mask and use as PC                                40006023 close to store
 * cb SW_E4      72 LBU_3      00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      4e eILL0b     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce IJT_2      fe ILLe       00000000000000001100101011101000110000        Read word is to be masked with ~1u                40006033 sloppy or      
 * cf MRET_5     13 condb_2    00000010000000000000000011101100010xx0        ~302                                              00000000 
 * d0 IJT_4      8a DIVU_5     00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * d1 ECALL_6    d5 Fetch2u    00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * d2 QINT_1     09 LB_5       00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * d3 ILL_4      41 JALR_1     00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * d4 DIV_7      b1 aF_SW_3    00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d5 MRET_2        (use dinx) 00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * d6 DIVU_2     fe ILLe       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d7 _LCSRRCI_1 b6 ECALL_5    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 aF_SW_3    10 SUB_1      00010000110000001110001011000x00100000        Store 7 to mcause                                 00006067 close to jalr
 * da MRET_7     c9 MRET_2     00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * db QINT_2     b1 aF_SW_3    00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * dc CSRRSI_0   96 SH_1       00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd Fetch2u    e7 aFault     0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * de MULH_3     7e NMI_1      00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * df LDAF_a     7e NMI_1      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * e0 jFault_1   d6 eILL0c     00010000000000001110001011100x00100110        Store 1 to mcause                                 00007003 close to load
 * e1 aFault_2   3d SRxI_2     00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * e2 aF_SW_1    e8 MUL_2      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      0000700b close to ij
 * e3 (null)     3a SRxI_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 DIVU_1     d9 MULH_3     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * e6 ORI_1      6e DIV_C      00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * e7 aF_SW_2    41 JALR_1     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * e8 MUL_2      70 LHU_2      00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00007023 close to store
 * e9 (null)     d0 ECALL_1    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ea IJT_3      4b CSRRW_2    00010010000000000000110011101100100110        Construct Q = 1                                   40007023 close to store
 * eb (null)     97 SW_E1SWH   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     e5 aF_SW_2    00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee MULHU_5    fe ILLe       00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          40007033 sloppy and     
 * ef LH_3       6e DIV_C      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f0 MULH_2     a6 ECAL_RET   00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * f1 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f2 WFI_2      72 LBU_3      00010010000000000000101011101100100110        Check offset                                      00000000 
 * f3 (null)     e2 MUL_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 SB_3       c0 DIV_D      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f5 (null)     e0 DIVU_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f6 (null)     f2 SW_2       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     bb SH_2       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)     de Fetch      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00007067 close to jalr
 * fa (null)     93 SW_E2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     a2 DIV_14     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   96 SH_1       00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      a9 ILL_4      00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       94 SW_E4      00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     d2 LB_2       00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0080, used ffff, inputs c6
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       78 DIV_4      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       70 LHU_2      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     90 NMI_2      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     90 NMI_2      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     c5 MRET_5     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       59 DIV_B      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     c5 MRET_5     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       dd aF_SW_1    00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      8e _LCSRRS_1  00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     90 NMI_2      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    59 DIV_B      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       90 NMI_2      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    88 DIV_E      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     b7 IJ_3       00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       90 NMI_2      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   6a MULH_1     00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     90 NMI_2      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       66 SW_1       00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    82 DIV_1      00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      90 NMI_2      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      b0 CSRRW_3    00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     90 NMI_2      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     a8 DIV_3      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     60 MULHU_3    00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     60 MULHU_3    00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      b5 SH_3       00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     ce _LCSRRCI_1 00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     90 NMI_2      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      90 NMI_2      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      dd aF_SW_1    00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       88 DIV_E      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   a9 ILL_4      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     87 unx87      00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    90 NMI_2      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     b4 eFetch3    00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    bf IJT_1      00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      a8 DIV_3      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    b1 aF_SW_3    00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     c7 QINT_1     00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    db jFault_1   00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       c9 MRET_2     00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 CSRRW_2    be IJ_1       00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 47 NMI_2      df eFetch     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     46 ILL_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    f4 Fetch2     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e LDAF_2     fe ILLe       00110000110000001110001011000x00100110        Store 4 to mcause                                 40002033 sloppy slt     
 * 4f SW_E4      90 NMI_2      00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 50 DIV_4      90 NMI_2      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 51 DIV_5      bb SH_2       00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 52 DIV_1      1e aFault_1   00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 53 DIV_2      bb SH_2       00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 54 DIV_E      e2 MUL_1      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 55 DIV_F      41 JALR_1     00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 56 ECALL_6    c1 IJT_2      00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 57 ILL_4      59 DIV_B      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 58 DIVU_5     d0 ECALL_1    00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00002063 close to branch
 * 59 LB_6       62 DIV_8      00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00002067 close to jalr
 * 5a OR_1       c6 IJT_4      00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    bf IJT_1      00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       eb LH_3       00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e aF_SW_3    3e SLL_1      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 5f QINT_2     bb SH_2       00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 60 SH_1       10 SUB_1      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00003003 close to load
 * 61 SW_E1SWH   a7 EBRKWFI1   00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 DIV_10     a2 DIV_14     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    0000300b close to ij
 * 63 DIV_11     26 OR_1       01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      95 SW_E3      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 aFault_2   9c DIV_10     00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 67 (null)     e1 ORI_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 68 DIV_14     90 NMI_2      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00003023 close to store
 * 69 DIV_15     59 DIV_B      00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 6a ECAL_RET   e3 MUL_3      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40003023 close to store
 * 6b EBRKWFI1   d6 eILL0c     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e (null)     83 DIV_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   40003033 sloppy sltu    
 * 6f (null)     b2 CSRRW_4    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 70 IJ_1       ffffffff (null)     00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * 71 IJT_1      41 JALR_1     00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 72 DIVU_3     3a SRxI_1     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 73 DIVU_4     29 XOR_1      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 74 ECALL_1       (use dinx) 00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 75 MRET_1        (use dinx) 00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 76 (null)     b3 unxb3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 77 (null)     b3 unxb3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 78 LB_2       ef WFI_5      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003063 close to branch
 * 79 aFaultd    ee eILL0a     00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00003067 close to jalr
 * 7a SLTIX_1    9c DIV_10     00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    bf IJT_1      00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e (null)     47 ILL_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 7f (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 80 LBU_0      d9 MULH_3     00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 IJ_3       ee eILL0a     00010010000000000000110011101100100110        Construct Q = 1                                   0000400b close to ij
 * 83 DIV_e      52 LH_1       00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     96 SH_1       00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 eILL0c     a5 MRET_3     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 87 ECALL_3       (use dinx) 00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 88 Fetch      62 DIV_8      00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00004023 close to store
 * 89 eFetch     90 NMI_2      00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 8a SH_2       3a SRxI_1     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      40004023 close to store
 * 8b IJ_4       90 NMI_2      00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      52 LH_1       01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e MUL_1      fe ILLe       00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           40004033 sloppy xor     
 * 8f MUL_3      57 LH_5       00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 90 StdIncPc   a5 MRET_3     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 91 aFault     e0 DIVU_1     00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 92 IJT_2      a5 MRET_3     00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * 93 MRET_5     e5 aF_SW_2    00000010000000000000000011101100010xx0        ~302                                              00000000 
 * 94 eILL0a     a5 MRET_3     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 95 WFI_5      4f MRET_8     00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 96 LBU_2      8a DIVU_5     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 97 aFaulte    e1 ORI_1      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a IJT_4      a5 MRET_3     00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 9b QINT_1        (use dinx) 00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 9c SW_2       36 SLLI_2     00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00004073 close to csr/system 
 * 9d aF_SW      68 DIV_12     00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 9e Fetch2     e7 aFault     00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 9f jFault     9c DIV_10     00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JAL_1      f9 MULH_2     00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * a2 DIV_7      59 DIV_B      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            0000500b close to ij
 * a3 MRET_2     90 NMI_2      00010010000000000000011011001100100000        0xff+3 = 0x102                                    0000500f close to fence
 * a4 SRxI_0     b1 aF_SW_3    00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 JAL_3      f1 aFaulte    00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a6 WFI_1      74 unx74      00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * a7 EBREAK_1   c8 DIV_7      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * a8 SLLI_1     50 LW_1       00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00005023 close to store
 * a9 SLLI_2     a5 MRET_3     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * aa DIVU_2     a2 DIV_14     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            40005023 close to store
 * ab _LCSRRCI_1 56 LH_4       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * ac _L0xac     b6 ECALL_5    00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     ca DIVU_2     00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     b6 ECALL_5    00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af ECALL_2    93 SW_E2      00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * b0 MULHU_7    f5 jFault     00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * b1 SRxI_1     e0 DIVU_1     00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * b2 MRET_7     88 DIV_E      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * b3 Fetch2u       (use dinx) 0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * b4 SRxI_2     d5 Fetch2u    00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * b5 SLL_1      e6 StdIncPc   00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * b6 SRx_1      56 LH_4       00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * b7 JALR_1     8b LB_6       00010010000000000000000011101100100110        Q=1                                               00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 WFI_3      ffffffff (null)     00010010000000000000101011101100100110        More check offset                                 00005067 close to jalr
 * ba MULH_3     3a SRxI_1     00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * bb LDAF_a     f7 EBREAK_1   00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * bc CSRRWI_0   bf IJT_1      00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ILL_1      88 DIV_E      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * be ILL_2      45 WFI_3      00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * bf CSRRW_1    92 LDAF_3     00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * c0 LH_4       54 LH_2       00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00006003 close to load
 * c1 LH_5       da LDAF_a     00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * c2 jFault_1   aa DIV_6      00010000000000001110001011100x00100110        Store 1 to mcause                                 0000600b close to ij
 * c3 aF_SW_1    58 DIV_A      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      0000600f close to fence
 * c4 ORI_0      cb QINT_2     00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 SB_1       d1 MRET_1     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * c6 SB_2       be IJ_1       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * c7 MULHU_3    5f LDAF_LHU   00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * c8 EBRKWFI2   32 JAL_1      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00006023 close to store
 * c9 WFI_4      e9 IJT_3      00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * ca DIVU_1     72 LBU_3      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           40006023 close to store
 * cb ORI_1      90 NMI_2      00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      52 LH_1       01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce MULH_1     fe ILLe       00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              40006033 sloppy or      
 * cf SB_4       13 condb_2    00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * d0 DIV_C      af MRET_4     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * d1 MRET_6     a3 DIV_15     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * d2 aF_SW_2    09 LB_5       00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d3 MUL_2      41 JALR_1     00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * d4 LBU_3      e0 DIVU_1     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * d5 unalignd      (use dinx) 00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * d6 SB_5       fe ILLe       00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * d7 NMI_1      e8 MUL_2      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 LBU_1      10 SUB_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00006067 close to jalr
 * da IJT_3      4e eILL0b     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * db MULHU_5    e0 DIVU_1     00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * dc CSRRSI_0   bf IJT_1      00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd JAL_2      d2 LB_2       10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * de _LCSRRS_1  9e SH_4       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * df ILL_3      9e SH_4       00000010000000000000101011101100100110        Q = 1                                             00000000 
 * e0 LDAF_3     aa DIV_6      00000000000000001101100111100x00001xx0        PC to mepc                                        00007003 close to load
 * e1 SW_E2      3d SRxI_2     00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * e2 LH_3       d3 aFaultd    00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 0000700b close to ij
 * e3 MULH_2     3a SRxI_1     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SW_E3      5e LHU_1      00110010000000000000101111001100100110        Q = 3                                             00000000 
 * e6 SH_4       88 DIV_E      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * e7 SH_5       41 JALR_1     00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * e8 ECALL_4    8e _LCSRRS_1  00110010000000000000101011001100100110        Q = 4                                             00007023 close to store
 * e9 MRET_3     9a ECALL_6    00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * ea WFI_2      4b CSRRW_2    00010010000000000000101011101100100110        Check offset                                      40007023 close to store
 * eb SB_3       c0 DIV_D      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     ca DIVU_2     00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee DIV_3      fe ILLe       01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        40007033 sloppy and     
 * ef DIV_6      88 DIV_E      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * f0 EBREAK_2   d4 aFault_2   00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * f1 MRET_4     41 JALR_1     00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * f2 (null)     90 NMI_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f3 (null)     c3 DIVU_4     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 CSRRW_3    f6 WFI_1      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * f5 CSRRW_4    c2 DIVU_3     00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * f6 eFetch3    ea MULHU_5    0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * f7 SH_3       f0 LBU_2      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 ECALL_5    ba LHU_3      00110010000000000000101011001100100110        Q = 8                                             00007067 close to jalr
 * fa (null)     b9 DIV_e      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     cf MRET_7     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   bf IJT_1      00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      d7 ECALL_3    00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       bd IJ_4       00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     9b unx9b      00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0020, used ffff, inputs c9
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       9c DIV_10     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       8a DIVU_5     00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     ba LHU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     ba LHU_3      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     b0 CSRRW_3    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       6b SB_4       00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     b0 CSRRW_3    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       dd aF_SW_1    00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      aa DIV_6      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     ba LHU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    6b SB_4       00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     4e eILL0b     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       ba LHU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    a8 DIV_3      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     90 NMI_2      00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       ba LHU_3      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     62 DIV_8      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   88 DIV_E      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     ba LHU_3      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       61 EBRKWFI2   00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    81 unx81      00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      ba LHU_3      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      76 Fetchu     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     ba LHU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     70 LHU_2      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      52 LH_1       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     6e DIV_C      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     6e DIV_C      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    5d SB_2       00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      82 DIV_1      00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     bd IJ_4       00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     ba LHU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      ba LHU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   56 LH_4       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      dd aF_SW_1    00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       a8 DIV_3      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   72 LBU_3      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     9f SH_5       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    ba LHU_3      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     7d unx7d      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     62 DIV_8      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    a2 DIV_14     00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      70 LHU_2      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    7a SB_5       00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 CSRRW_2    1d ORI_2      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 42 aFault_1   b4 eFetch3    00110010000000000000101011001100100110        Q = 4                                             0000200b close to ij
 * 43 NMI_2      d7 ECALL_3    00000000110000001111010011101000110000        mtval = 0.                                        0000200f close to fence
 * 44 SLTI_0     56 LH_4       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 LDAF_2     b9 DIV_e      00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 46 IJ_2       96 SH_1       00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 47 SW_E4      df eFetch     00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     41 JALR_1     00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    f4 Fetch2     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      60 MULHU_3    00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   5a SB_1       00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e Fetchu     fe ILLe       00000010000000000000001111101010110000  Fr10u Read and latch instruction                        40002033 sloppy slt     
 * 4f eFetchu    ba LHU_3      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 50 OR_1       ba LHU_3      00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 51 ECALL_6    b7 IJ_3       00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 52 OR_2       1e aFault_1   00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 53 ILL_4      b7 IJ_3       00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 54 XOR_1      e1 ORI_1      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 55 aF_SW_3    42 MULHU_2    00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 56 SLTIX_1    af MRET_4     00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 57 QINT_2     6b SB_4       00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 58 DIV_4      c2 DIVU_3     00000000000000001100000011101000110000        ~abs(divisor) to yy                               00002063 close to branch
 * 59 DIV_5      78 DIV_4      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00002067 close to jalr
 * 5a MULHU_1    b2 CSRRW_4    00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 5b _L0x5b     62 DIV_8      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    a2 DIV_14     00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLTIX_2    e7 aFault     00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 5e DIV_1      3e SLL_1      00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 5f DIV_2      b7 IJ_3       00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 60 SLTX_1     10 SUB_1      00000010000000000000111111101100000xx0        ~rs2 to Q                                         00003003 close to load
 * 61 aFault_2   db jFault_1   00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 62 JAL_1      a1 ECALL_4    00010000000000001100001011101000100000        Target adr to yy                                  0000300b close to ij
 * 63 (null)     26 OR_1       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000300f close to fence
 * 64 SLTIU_0    56 LH_4       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 (null)     bf IJT_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 66 JAL_3      ca DIVU_2     00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 67 (null)     e2 MUL_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 68 DIV_E      ba LHU_3      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003023 close to store
 * 69 DIV_F      6b SB_4       00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 6a DIVU_5     e3 MUL_3      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               40003023 close to store
 * 6b LB_6       d4 aFault_2   00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 6c SLTU_0     60 MULHU_3    00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    5a SB_1       00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e SH_1       83 DIV_2      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        40003033 sloppy sltu    
 * 6f SW_E1SWH   b1 aF_SW_3    00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 70 SLLI_1     ffffffff (null)     00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 71 (null)     42 MULHU_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 72 SLLI_2     3a SRxI_1     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 73 (null)     29 XOR_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 74 ECALL_2       (use dinx) 00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 75 (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 76 MULHU_7    b3 unxb3      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 77 (null)     b3 unxb3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 78 DIV_10     ef WFI_5      01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00003063 close to branch
 * 79 DIV_11     ee eILL0a     01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00003067 close to jalr
 * 7a SRxI_1     ca DIVU_2     00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 7b _L0x7b     62 DIV_8      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    a2 DIV_14     00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SRxI_2        (use dinx) 00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 7e DIV_14     43 MULHU_4    00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00000000 
 * 7f DIV_15        (use dinx) 00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 80 LBU_0      d9 MULH_3     00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 IJ_3          (use dinx) 00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 82 SLL_1      ee eILL0a     00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              0000400b close to ij
 * 83 DIV_e      5e LHU_1      00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SH_2       c8 DIV_7      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 86 SRx_1      66 SW_1       00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 87 IJ_4          (use dinx) 00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 88 ECAL_RET   78 DIV_4      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00004023 close to store
 * 89 EBRKWFI1   ba LHU_3      00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 8a IJ_1       3a SRxI_1     00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   40004023 close to store
 * 8b IJT_1      ba LHU_3      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 8c XOR_0      54 LH_2       00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      5e LHU_1      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e DIVU_3     fe ILLe       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           40004033 sloppy xor     
 * 8f DIVU_4     53 LDAF_LH    01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 90 JALR_1     66 SW_1       00010010000000000000000011101100100110        Q=1                                               00000000 
 * 91 IJT_2      e0 DIVU_1     00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * 92 WFI_3      66 SW_1       00010010000000000000101011101100100110        More check offset                                 00000000 
 * 93 MRET_5     e6 StdIncPc   00000010000000000000000011101100010xx0        ~302                                              00000000 
 * 94 ILL_1      66 SW_1       00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 95 IJT_4      47 ILL_2      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 96 ILL_2      85 LBU_1      00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 97 QINT_1     e2 MUL_1      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a ECALL_1    66 SW_1       00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 9b MRET_1        (use dinx) 00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 9c LB_2       36 SLLI_2     00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00004073 close to csr/system 
 * 9d aFaultd    7e NMI_1      00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 9e eILL0c     e9 IJT_3      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 9f ECALL_3    ca DIVU_2     00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 DIV_7      fb SB_3       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * a2 CSRRW_1    6b SB_4       00010010000000000000000011101100100110        Construct PC storage adr                          0000500b close to ij
 * a3 MRET_2     ba LHU_3      00010010000000000000011011001100100000        0xff+3 = 0x102                                    0000500f close to fence
 * a4 SRxI_0     7a SB_5       00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 DIVU_2     f2 SW_2       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * a6 LH_4       9a ECALL_6    00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * a7 _LCSRRCI_1 b6 ECALL_5    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * a8 Fetch      58 DIV_A      00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00005023 close to store
 * a9 eFetch     66 SW_1       00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * aa MUL_1      a1 ECALL_4    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           40005023 close to store
 * ab MUL_3      51 LDAF_LW    00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * ac _L0xac     86 JAL_2      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     c5 MRET_5     00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     86 JAL_2      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af LH_5       93 SW_E2      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * b0 SB_1       f6 WFI_1      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * b1 MRET_7     e0 DIVU_1     00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * b2 SB_2       a8 DIV_3      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * b3 Fetch2u       (use dinx) 0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * b4 MULHU_3    d2 LB_2       00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * b5 MULH_3     e8 MUL_2      00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * b6 EBRKWFI2   51 LDAF_LW    00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * b7 LDAF_a     87 unx87      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 WFI_4      ffffffff (null)     00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00005067 close to jalr
 * ba StdIncPc   3a SRxI_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * bb aFault     fa WFI_2      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * bc CSRRWI_0   a2 DIV_14     00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd MULH_1     a8 DIV_3      00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * be eILL0a     46 ILL_1      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bf WFI_5      91 LDAF_2     00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * c0 SB_4       68 DIV_12     00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00006003 close to load
 * c1 jFault_1   d5 Fetch2u    00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * c2 DIV_C      a5 MRET_3     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              0000600b close to ij
 * c3 aF_SW_1    6a MULH_1     00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      0000600f close to fence
 * c4 ORI_0      c7 QINT_1     00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 DIVU_1     c6 IJT_4      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * c6 MRET_6     96 SH_1       00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * c7 ORI_1      57 LH_5       00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * c8 LBU_2      32 JAL_1      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00006023 close to store
 * c9 aFaulte    eb LH_3       00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * ca SW_2       8e _LCSRRS_1  00000010000000000000001011x01000xxxxx0        Prepare read PC                                   40006023 close to store
 * cb aF_SW      ba LHU_3      00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * cc OR_0       50 LW_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      5e LHU_1      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce Fetch2     fe ILLe       00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     40006033 sloppy or      
 * cf jFault     13 condb_2    00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * d0 LBU_3      74 unx74      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * d1 aF_SW_2    a3 DIV_15     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d2 unalignd   09 LB_5       00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * d3 MUL_2      42 MULHU_2    00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * d4 SB_5       e0 DIVU_1     00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * d5 IJT_3         (use dinx) 00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * d6 NMI_1      fe ILLe       00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * d7 MULHU_5    ea MULHU_5    00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 LBU_1      10 SUB_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00006067 close to jalr
 * da WFI_1      45 WFI_3      00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * db EBREAK_1   e0 DIVU_1     00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * dc CSRRSI_0   a2 DIV_14     00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd JAL_2      d1 MRET_1     10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * de _LCSRRS_1  ce _LCSRRCI_1 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * df ILL_3      ce _LCSRRCI_1 00000010000000000000101011101100100110        Q = 1                                             00000000 
 * e0 LDAF_3     a5 MRET_3     00000000000000001101100111100x00001xx0        PC to mepc                                        00007003 close to load
 * e1 LH_3       3d SRxI_2     00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * e2 SW_E2      d3 aFaultd    00000000000000001101101111101000001xx0        Store address that faulted                        0000700b close to ij
 * e3 MULH_2     3a SRxI_1     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 WFI_2      55 aFaultb    00010010000000000000101011101100100110        Check offset                                      00000000 
 * e6 SW_E3      a8 DIV_3      00110010000000000000101111001100100110        Q = 3                                             00000000 
 * e7 SB_3       42 MULHU_2    00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e8 SH_4       aa DIV_6      00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00007023 close to store
 * e9 SH_5       95 SW_E3      00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * ea ECALL_4    4b CSRRW_2    00110010000000000000101011001100100110        Q = 4                                             40007023 close to store
 * eb MRET_3     a6 ECAL_RET   00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     c5 MRET_5     00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee DIV_3      fe ILLe       01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        40007033 sloppy and     
 * ef DIV_6      a8 DIV_3      00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * f0 EBREAK_2   d0 ECALL_1    00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * f1 (null)     42 MULHU_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f2 MRET_4     ba LHU_3      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * f3 (null)     c3 DIVU_4     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 CSRRW_3    f9 MULH_2     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * f5 (null)     c1 IJT_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f6 CSRRW_4    e5 aF_SW_2    00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * f7 (null)     f0 LBU_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 eFetch3    b5 SH_3       0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00007067 close to jalr
 * fa SH_3       92 LDAF_3     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fb ECALL_5    c0 DIV_D      00110010000000000000101011001100100110        Q = 8                                             00000000 
 * fc CSRRCI_0   a2 DIV_14     00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      d6 eILL0c     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       94 SW_E4      00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     97 SW_E1SWH   00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0020, used ffff, inputs ca
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       7e NMI_1      00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       70 LHU_2      00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     90 NMI_2      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     90 NMI_2      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     c5 MRET_5     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       5f LDAF_LHU   00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     c5 MRET_5     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       dd aF_SW_1    00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      8e _LCSRRS_1  00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     90 NMI_2      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    5f LDAF_LHU   00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     4e eILL0b     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       90 NMI_2      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    8a DIVU_5     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     ba LHU_3      00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       90 NMI_2      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   6e DIV_C      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     90 NMI_2      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       62 DIV_8      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    82 DIV_1      00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      90 NMI_2      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      b0 CSRRW_3    00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     90 NMI_2      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     aa DIV_6      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     60 MULHU_3    00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     60 MULHU_3    00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      b5 SH_3       00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     ce _LCSRRCI_1 00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     90 NMI_2      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      90 NMI_2      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      dd aF_SW_1    00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       8a DIVU_5     00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   ab EBREAK_2   00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     89 DIV_F      00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    90 NMI_2      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     b4 eFetch3    00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    bf IJT_1      00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      aa DIV_6      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    b1 aF_SW_3    00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 CSRRW_2    c9 MRET_2     00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    0000200b close to ij
 * 43 NMI_2      d7 ECALL_3    00000000110000001111010011101000110000        mtval = 0.                                        0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       cb QINT_2     00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 LDAF_2     be IJ_1       00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 47 SW_E4      df eFetch     00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     42 MULHU_2    00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    f4 Fetch2     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e Fetchu     fe ILLe       00000010000000000000001111101010110000  Fr10u Read and latch instruction                        40002033 sloppy slt     
 * 4f eFetchu    90 NMI_2      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 50 DIV_4      90 NMI_2      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 51 DIV_5      b7 IJ_3       00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 52 ECALL_6    1e aFault_1   00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 53 ILL_4      b7 IJ_3       00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 54 DIV_1      e2 MUL_1      00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  00000000 
 * 55 DIV_2      41 JALR_1     00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 56 aF_SW_3    c1 IJT_2      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 57 QINT_2     5f LDAF_LHU   00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 58 DIV_E      d0 ECALL_1    01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00002063 close to branch
 * 59 DIV_F      68 DIV_12     00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00002067 close to jalr
 * 5a OR_1       c8 DIV_7      00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    bf IJT_1      00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       e7 aFault     00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIVU_5     3e SLL_1      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 5f LB_6       b7 IJ_3       00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 60 SH_1       10 SUB_1      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00003003 close to load
 * 61 SW_E1SWH   a9 ILL_4      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 aFault_2   a2 DIV_14     00010000110000001110001011100x00100110        Store 5 to mcause                                 0000300b close to ij
 * 63 (null)     26 OR_1       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      95 SW_E3      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 (null)     9c DIV_10     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 67 (null)     e1 ORI_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 68 DIV_10     90 NMI_2      01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00003023 close to store
 * 69 DIV_11     5f LDAF_LHU   01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 6a DIV_14     e3 MUL_3      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 40003023 close to store
 * 6b DIV_15     d9 MULH_3     00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e ECAL_RET   83 DIV_2      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40003033 sloppy sltu    
 * 6f EBRKWFI1   b2 CSRRW_4    00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 70 IJ_1       ffffffff (null)     00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00000000 
 * 71 IJT_1      41 JALR_1     00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 72 (null)     3a SRxI_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 73 (null)     29 XOR_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 74 DIVU_3        (use dinx) 00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 75 DIVU_4        (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 76 (null)     b3 unxb3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 77 (null)     b3 unxb3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 78 ECALL_1    ef WFI_5      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00003063 close to branch
 * 79 MRET_1     ee eILL0a     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00003067 close to jalr
 * 7a SLTIX_1    9c DIV_10     00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    bf IJT_1      00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e LB_2       43 MULHU_4    00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 7f aFaultd       (use dinx) 00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 80 LBU_0      db jFault_1   00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 IJ_3       ee eILL0a     00010010000000000000110011101100100110        Construct Q = 1                                   0000400b close to ij
 * 83 DIV_e      54 LH_2       00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     9a ECALL_6    00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 SH_2       a5 MRET_3     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 87 IJ_4          (use dinx) 00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 88 eILL0c     68 DIV_12     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00004023 close to store
 * 89 ECALL_3    90 NMI_2      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 8a Fetch      3a SRxI_1     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        40004023 close to store
 * 8b eFetch     90 NMI_2      00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      54 LH_2       01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e MUL_1      fe ILLe       00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           40004033 sloppy xor     
 * 8f MUL_3      53 LDAF_LH    00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 90 StdIncPc   a5 MRET_3     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 91 aFault     e0 DIVU_1     00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 92 IJT_2      a5 MRET_3     00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * 93 MRET_5     e5 aF_SW_2    00000010000000000000000011101100010xx0        ~302                                              00000000 
 * 94 eILL0a     a5 MRET_3     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 95 WFI_5      47 ILL_2      00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 96 IJT_4      86 JAL_2      00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 97 QINT_1     e1 ORI_1      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a LBU_2      a5 MRET_3     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 9b aFaulte       (use dinx) 00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 9c SW_2       36 SLLI_2     00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00004073 close to csr/system 
 * 9d aF_SW      6a MULH_1     00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 9e Fetch2     e9 IJT_3      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 9f jFault     9c DIV_10     00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JAL_1      fb SB_3       00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * a2 DIV_7      5f LDAF_LHU   00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            0000500b close to ij
 * a3 MRET_2     90 NMI_2      00010010000000000000011011001100100000        0xff+3 = 0x102                                    0000500f close to fence
 * a4 SRxI_0     b1 aF_SW_3    00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 JAL_3      f1 aFaulte    00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a6 DIVU_2     78 DIV_4      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * a7 _LCSRRCI_1 ca DIVU_2     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * a8 WFI_1      50 LW_1       00110010000000000000000011001100100110 WFI    To check offset                                   00005023 close to store
 * a9 EBREAK_1   a5 MRET_3     00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * aa SLLI_1     a2 DIV_14     00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      40005023 close to store
 * ab SLLI_2     52 LH_1       00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * ac _L0xac     b9 DIV_e      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     c6 IJT_4      00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     b9 DIV_e      00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af ECALL_2    93 SW_E2      00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * b0 MULHU_7    f5 jFault     00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * b1 SRxI_1     e0 DIVU_1     00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * b2 MRET_7     8a DIVU_5     00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * b3 Fetch2u       (use dinx) 0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * b4 SRxI_2     d5 Fetch2u    00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * b5 SLL_1      e8 MUL_2      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * b6 MULH_3     52 LH_1       00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * b7 LDAF_a     87 unx87      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SRx_1      ffffffff (null)     00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00005067 close to jalr
 * ba JALR_1     3a SRxI_1     00010010000000000000000011101100100110        Q=1                                               00000000 
 * bb WFI_3      fa WFI_2      00010010000000000000101011101100100110        More check offset                                 00000000 
 * bc CSRRWI_0   bf IJT_1      00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ILL_1      8a DIVU_5     00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * be ILL_2      45 WFI_3      00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * bf CSRRW_1    92 LDAF_3     00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * c0 LH_4       58 DIV_A      00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00006003 close to load
 * c1 LH_5       d6 eILL0c     00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * c2 jFault_1   a6 ECAL_RET   00010000000000001110001011100x00100110        Store 1 to mcause                                 0000600b close to ij
 * c3 aF_SW_1    5e LHU_1      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      0000600f close to fence
 * c4 ORI_0      c7 QINT_1     00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 SB_1       d1 MRET_1     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * c6 DIVU_1     be IJ_1       00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * c7 ORI_1      57 LH_5       00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * c8 SB_2       32 JAL_1      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00006023 close to store
 * c9 MULHU_3    eb LH_3       00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * ca EBRKWFI2   74 unx74      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         40006023 close to store
 * cb WFI_4      90 NMI_2      00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      54 LH_2       01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce MULH_1     fe ILLe       00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              40006033 sloppy or      
 * cf SB_4       13 condb_2    00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * d0 DIV_C      af MRET_4     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * d1 MRET_6     a3 DIV_15     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * d2 aF_SW_2    09 LB_5       00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d3 MUL_2      41 JALR_1     00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * d4 LBU_3      e0 DIVU_1     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * d5 unalignd      (use dinx) 00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * d6 IJT_3      fe ILLe       00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * d7 MULHU_5    ea MULHU_5    00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 SB_5       10 SUB_1      00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00006067 close to jalr
 * da NMI_1      46 ILL_1      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * db LBU_1      e0 DIVU_1     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * dc CSRRSI_0   bf IJT_1      00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd JAL_2      d2 LB_2       10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * de _LCSRRS_1  9e SH_4       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * df ILL_3      9e SH_4       00000010000000000000101011101100100110        Q = 1                                             00000000 
 * e0 LDAF_3     a6 ECAL_RET   00000000000000001101100111100x00001xx0        PC to mepc                                        00007003 close to load
 * e1 SW_E2      3d SRxI_2     00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * e2 LH_3       d3 aFaultd    00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 0000700b close to ij
 * e3 MULH_2     3a SRxI_1     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SW_E3      56 LH_4       00110010000000000000101111001100100110        Q = 3                                             00000000 
 * e6 WFI_2      8a DIVU_5     00010010000000000000101011101100100110        Check offset                                      00000000 
 * e7 SB_3       41 JALR_1     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e8 SH_4       8e _LCSRRS_1  00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00007023 close to store
 * e9 SH_5       96 SH_1       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * ea ECALL_4    4b CSRRW_2    00110010000000000000101011001100100110        Q = 4                                             40007023 close to store
 * eb MRET_3     c0 DIV_D      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     c6 IJT_4      00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee DIV_3      fe ILLe       01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        40007033 sloppy and     
 * ef DIV_6      8a DIVU_5     00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * f0 EBREAK_2   d4 aFault_2   00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * f1 MRET_4     41 JALR_1     00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * f2 (null)     90 NMI_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f3 (null)     c3 DIVU_4     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 CSRRW_3    f9 MULH_2     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * f5 CSRRW_4    c2 DIVU_3     00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * f6 (null)     e6 StdIncPc   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     f0 LBU_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 eFetch3    b6 ECALL_5    0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00007067 close to jalr
 * fa SH_3       bb SH_2       00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fb ECALL_5    cf MRET_7     00110010000000000000101011001100100110        Q = 8                                             00000000 
 * fc CSRRCI_0   bf IJT_1      00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      da LDAF_a     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       bd IJ_4       00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     97 SW_E1SWH   00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 1000, used ffff, inputs cc
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       68 DIV_12     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       60 MULHU_3    00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     72 LBU_3      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     9b unx9b      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       53 LDAF_LH    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     9b unx9b      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       ab EBREAK_2   00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      70 LHU_2      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    53 LDAF_LH    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    6e DIV_C      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     92 LDAF_3     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       72 LBU_3      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   5e LHU_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     72 LBU_3      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       e0 DIVU_1     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    c8 DIV_7      00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      72 LBU_3      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      8b LB_6       00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     88 DIV_E      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      90 NMI_2      00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     a1 ECALL_4    00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      ab EBREAK_2   00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       6e DIV_C      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   89 DIV_F      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     6b SB_4       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    72 LBU_3      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     8f ILL_3      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    96 SH_1       00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      88 DIV_E      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    8e _LCSRRS_1  00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     9d DIV_11     00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    ee eILL0a     00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       9f SH_5       00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 DIV_4      95 SW_E3      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 47 DIV_5      b0 CSRRW_3    00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     c0 DIV_D      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    be IJ_1       00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_1      fe ILLe       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40002033 sloppy slt     
 * 4f DIV_2      72 LBU_3      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 50 DIV_E      72 LBU_3      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 51 DIV_F      df eFetch     00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 52 DIVU_5     1e aFault_1   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 53 LB_6       df eFetch     00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 54 SH_1       ef WFI_5      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 55 SW_E1SWH   41 JALR_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 DIV_10     9a ECALL_6    01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 57 DIV_11     53 LDAF_LH    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 58 DIV_14     a3 DIV_15     00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00002063 close to branch
 * 59 DIV_15     56 LH_4       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00002067 close to jalr
 * 5a OR_1       9c DIV_10     00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    96 SH_1       00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       f6 WFI_1      00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e ECAL_RET   3e SLL_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 5f EBRKWFI1   df eFetch     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 60 IJ_1       10 SUB_1      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00003003 close to load
 * 61 IJT_1      83 DIV_2      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 62 DIVU_3     d6 eILL0c     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIVU_4     26 OR_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      75 unx75      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 ECALL_1    78 DIV_4      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 67 MRET_1     b2 CSRRW_4    00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 68 LB_2       72 LBU_3      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd    53 LDAF_LH    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c     f4 Fetch2     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    a8 DIV_3      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e Fetch      c9 MRET_2     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     db jFault_1   00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 MUL_1      ffffffff (null)     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 71 MUL_3      41 JALR_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 72 StdIncPc   3a SRxI_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 73 aFault     29 XOR_1      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 74 eILL0a        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 76 LBU_2      dd aF_SW_1    00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 77 aFaulte    dd aF_SW_1    00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 78 SW_2       ba LHU_3      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00003063 close to branch
 * 79 aF_SW      b9 DIV_e      00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00003067 close to jalr
 * 7a SLTIX_1    78 DIV_4      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    96 SH_1       00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e Fetch2     c1 IJT_2      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 7f jFault        (use dinx) 00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 80 LBU_0      aa DIV_6      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 WFI_1      b9 DIV_e      00110010000000000000000011001100100110 WFI    To check offset                                   0000400b close to ij
 * 83 EBREAK_1   4e eILL0b     00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     76 Fetchu     00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 JAL_1      87 unx87      00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 87 JAL_3         (use dinx) 00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 88 SLLI_1     56 LH_4       00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00004023 close to store
 * 89 SLLI_2     72 LBU_3      00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 8a ECALL_2    3a SRxI_1     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  40004023 close to store
 * 8b MULHU_7    72 LBU_3      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      4e eILL0b     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e SRxI_1     fe ILLe       00000000000000000100101001101100001xx1        Register to shift to Q                            40004033 sloppy xor     
 * 8f SRxI_2     d1 MRET_1     00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 90 SLL_1      87 unx87      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 91 SRx_1      b1 aF_SW_3    00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 92 JALR_1     87 unx87      00010010000000000000000011101100100110        Q=1                                               00000000 
 * 93 WFI_3      b3 unxb3      00010010000000000000101011101100100110        More check offset                                 00000000 
 * 94 ILL_1      87 unx87      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 95 ILL_2      c3 DIVU_4     00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 96 CSRRW_1    ca DIVU_2     00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 97 LH_4       b2 CSRRW_4    00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a LH_5       87 unx87      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 9b SB_1          (use dinx) 00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 9c SB_2       36 SLLI_2     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00004073 close to csr/system 
 * 9d MULHU_3    58 DIV_A      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * 9e EBRKWFI2   b5 SH_3       00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 9f WFI_4      78 DIV_4      00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 MULH_1     c7 QINT_1     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * a2 SB_4       53 LDAF_LH    00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      0000500b close to ij
 * a3 DIV_C      72 LBU_3      00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              0000500f close to fence
 * a4 SRxI_0     8e _LCSRRS_1  00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_6     bd IJ_4       00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * a6 LBU_3      66 SW_1       00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * a7 unalignd   9e SH_4       00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * a8 SB_5       46 ILL_1      00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00005023 close to store
 * a9 NMI_1      87 unx87      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * aa LBU_1      d6 eILL0c     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40005023 close to store
 * ab JAL_2      d0 ECALL_1    10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * ac _L0xac     91 LDAF_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     e7 aFault     00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     91 LDAF_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af _LCSRRS_1  cf MRET_7     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b0 ILL_3      bf IJT_1      00000010000000000000101011101100100110        Q = 1                                             00000000 
 * b1 LDAF_3     b1 aF_SW_3    00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * b2 SW_E2      6e DIV_C      00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * b3 SW_E3         (use dinx) 00110010000000000000101111001100100110        Q = 3                                             00000000 
 * b4 SH_4       a7 EBRKWFI1   00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b5 SH_5       b4 eFetch3    00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b6 ECALL_4    d0 ECALL_1    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * b7 MRET_3     cb QINT_2     00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 DIV_3      ffffffff (null)     01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00005067 close to jalr
 * ba DIV_6      3a SRxI_1     00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * bb EBREAK_2   c6 IJT_4      00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * bc CSRRWI_0   96 SH_1       00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd MRET_4     6e DIV_C      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * be CSRRW_3    45 WFI_3      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * bf CSRRW_4    ce _LCSRRCI_1 00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * c0 CSRRW_2    50 LW_1       00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00006003 close to load
 * c1 NMI_2      eb LH_3       00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * c2 LDAF_2     d9 MULH_3     00110000110000001110001011000x00100110        Store 4 to mcause                                 0000600b close to ij
 * c3 SW_E4      52 LH_1       00000000110000001110100111100x00101000        Store 6 to mcause                                 0000600f close to fence
 * c4 ORI_0      e8 MUL_2      00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 eFetch3    a5 MRET_3     0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * c6 SH_3       95 SW_E3      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * c7 ECALL_5    d3 aFaultd    00110010000000000000101011001100100110        Q = 8                                             00000000 
 * c8 IJ_3       32 JAL_1      00010010000000000000110011101100100110        Construct Q = 1                                   00006023 close to store
 * c9 DIV_e      b7 IJ_3       00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * ca SH_2       62 DIV_8      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      40006023 close to store
 * cb IJ_4       72 LBU_3      00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      4e eILL0b     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce IJT_2      fe ILLe       00000000000000001100101011101000110000        Read word is to be masked with ~1u                40006033 sloppy or      
 * cf MRET_5     13 condb_2    00000010000000000000000011101100010xx0        ~302                                              00000000 
 * d0 ECALL_6    8a DIVU_5     00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * d1 ILL_4      d7 ECALL_3    00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * d2 aF_SW_3    09 LB_5       00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * d3 QINT_2     41 JALR_1     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * d4 IJT_4      b1 aF_SW_3    00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * d5 QINT_1        (use dinx) 00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * d6 DIV_7      fe ILLe       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d7 MRET_2     b6 ECALL_5    00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 DIVU_2     10 SUB_1      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00006067 close to jalr
 * da _LCSRRCI_1 c2 DIVU_3     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * db MRET_7     b1 aF_SW_3    00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * dc CSRRSI_0   96 SH_1       00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd Fetch2u    e9 IJT_3      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * de MULH_3     7e NMI_1      00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * df LDAF_a     7e NMI_1      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * e0 aFault_2   d9 MULH_3     00010000110000001110001011100x00100110        Store 5 to mcause                                 00007003 close to load
 * e1 (null)     3d SRxI_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e2 (null)     ea MULHU_5    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700b close to ij
 * e3 (null)     3a SRxI_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 jFault_1   d2 LB_2       00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * e6 aF_SW_1    6e DIV_C      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * e7 DIVU_1     41 JALR_1     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * e8 ORI_1      70 LHU_2      00000010000000000000000011101100001xx0        Q = RS1                                           00007023 close to store
 * e9 aF_SW_2    d4 aFault_2   00110010000000000000101011001100100110        Q = 4                                             00000000 
 * ea MUL_2      4b CSRRW_2    00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  40007023 close to store
 * eb IJT_3      97 SW_E1SWH   00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     e7 aFault     00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee MULHU_5    fe ILLe       00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          40007033 sloppy and     
 * ef LH_3       6e DIV_C      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f0 (null)     a6 ECAL_RET   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f1 (null)     41 JALR_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f2 (null)     72 LBU_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f3 (null)     e6 StdIncPc   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f4 MULH_2     c5 MRET_5     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * f5 WFI_2      e5 aF_SW_2    00010010000000000000101011101100100110        Check offset                                      00000000 
 * f6 SB_3       f5 jFault     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f7 (null)     bb SH_2       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)     de Fetch      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00007067 close to jalr
 * fa (null)     93 SW_E2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     a2 DIV_14     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   96 SH_1       00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      a9 ILL_4      00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       94 SW_E4      00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     d5 Fetch2u    00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0800, used ffff, inputs d2
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       68 DIV_12     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       60 MULHU_3    00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     72 LBU_3      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     a5 MRET_3     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       53 LDAF_LH    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     a5 MRET_3     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       c0 DIV_D      00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      70 LHU_2      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    53 LDAF_LH    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    6e DIV_C      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     94 SW_E4      00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       72 LBU_3      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   5e LHU_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     72 LBU_3      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       b2 CSRRW_4    00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    e0 DIVU_1     00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      72 LBU_3      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      8b LB_6       00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     88 DIV_E      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      90 NMI_2      00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     aa DIV_6      00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      c0 DIV_D      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       6e DIV_C      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   89 DIV_F      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     6b SB_4       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    72 LBU_3      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     8f ILL_3      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      88 DIV_E      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    8e _LCSRRS_1  00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     a7 EBRKWFI1   00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    cf MRET_7     00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       a9 ILL_4      00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 DIV_4      9d DIV_11     00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 47 DIV_5      c5 MRET_5     00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     92 LDAF_3     00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    da LDAF_a     00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_1      fe ILLe       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40002033 sloppy slt     
 * 4f DIV_2      72 LBU_3      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 50 DIV_E      72 LBU_3      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 51 DIV_F      fb SB_3       00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 52 DIVU_5     1e aFault_1   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 53 LB_6       fb SB_3       00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 54 SH_1       e2 MUL_1      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 55 SW_E1SWH   41 JALR_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 DIV_10     a3 DIV_15     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 57 DIV_11     53 LDAF_LH    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 58 DIV_14     af MRET_4     00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00002063 close to branch
 * 59 DIV_15     56 LH_4       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00002067 close to jalr
 * 5a OR_1       a6 ECAL_RET   00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       e7 aFault     00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e ECAL_RET   3e SLL_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 5f EBRKWFI1   fb SB_3       00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 60 IJ_1       10 SUB_1      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00003003 close to load
 * 61 IJT_1      83 DIV_2      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 62 DIVU_3     f3 aF_SW      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIVU_4     26 OR_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      75 unx75      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 ECALL_1    78 DIV_4      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 67 MRET_1     c9 MRET_2     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 68 LB_2       72 LBU_3      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd    53 LDAF_LH    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c     e3 MUL_3      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    b5 SH_3       00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e Fetch      e1 ORI_1      00000001001010001000101111101010110000  Fr11  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     f7 EBREAK_1   00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 MUL_1      ffffffff (null)     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 71 MUL_3      41 JALR_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 72 StdIncPc   3a SRxI_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 73 aFault     29 XOR_1      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 74 eILL0a        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 76 LBU_2      f9 MULH_2     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 77 aFaulte    f9 MULH_2     00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 78 SW_2       d6 eILL0c     00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00003063 close to branch
 * 79 aF_SW      d5 Fetch2u    00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00003067 close to jalr
 * 7a SLTIX_1    78 DIV_4      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    a1 ECALL_4    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e Fetch2     93 SW_E2      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 7f jFault        (use dinx) 00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 80 LBU_0      bd IJ_4       00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 WFI_1      d5 Fetch2u    00110010000000000000000011001100100110 WFI    To check offset                                   0000400b close to ij
 * 83 EBREAK_1   4e eILL0b     00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     76 Fetchu     00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 JAL_1      87 unx87      00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 87 JAL_3         (use dinx) 00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 88 SLLI_1     56 LH_4       00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00004023 close to store
 * 89 SLLI_2     72 LBU_3      00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 8a ECALL_2    3a SRxI_1     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  40004023 close to store
 * 8b MULHU_7    72 LBU_3      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      4e eILL0b     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e SRxI_1     fe ILLe       00000000000000000100101001101100001xx1        Register to shift to Q                            40004033 sloppy xor     
 * 8f SRxI_2     9b unx9b      00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 90 SLL_1      87 unx87      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 91 SRx_1      c8 DIV_7      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 92 CSRRW_2    87 unx87      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 93 NMI_2      d0 ECALL_1    00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 94 JALR_1     87 unx87      00010010000000000000000011101100100110        Q=1                                               00000000 
 * 95 WFI_3      97 SW_E1SWH   00010010000000000000101011101100100110        More check offset                                 00000000 
 * 96 LDAF_2     e5 aF_SW_2    00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 97 SW_E4      c9 MRET_2     00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a ECALL_6    87 unx87      00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 9b ILL_4         (use dinx) 00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 9c ILL_1      36 SLLI_2     00000000000000001101101011100x00001xx0        Store PC to mepc                                  00004073 close to csr/system 
 * 9d ILL_2      58 DIV_A      00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 9e aF_SW_3    d2 LB_2       00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 9f QINT_2     78 DIV_4      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 CSRRW_1    df eFetch     00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * a2 LH_4       53 LDAF_LH    00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      0000500b close to ij
 * a3 LH_5       72 LBU_3      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               0000500f close to fence
 * a4 SRxI_0     8e _LCSRRS_1  00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SB_1       d9 MULH_3     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * a6 SB_2       66 SW_1       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * a7 MULHU_3    a8 DIV_3      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * a8 EBRKWFI2   46 ILL_1      00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00005023 close to store
 * a9 WFI_4      87 unx87      00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * aa MULH_1     f3 aF_SW      00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              40005023 close to store
 * ab SB_4       9a ECALL_6    00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * ac _L0xac     91 LDAF_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     c6 IJT_4      00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     91 LDAF_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af DIV_C      f0 LBU_2      00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b0 MRET_6     db jFault_1   00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * b1 LBU_3      c8 DIV_7      00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * b2 aFault_2   6e DIV_C      00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * b3 (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b4 unalignd   b4 eFetch3    00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * b5 SB_5       d1 MRET_1     00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b6 (null)     9a ECALL_6    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b7 (null)     e8 MUL_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 NMI_1      ffffffff (null)     00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00005067 close to jalr
 * ba (null)     3a SRxI_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * bb (null)     de Fetch      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * bc CSRRWI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd LBU_1      6e DIV_C      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * be (null)     45 WFI_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * bf (null)     e9 IJT_3      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * c0 JAL_2      50 LW_1       10110000000000000100110011000x00100110        Return address to TRG                             00006003 close to load
 * c1 _LCSRRS_1  ce _LCSRRCI_1 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * c2 jFault_1   f5 jFault     00010000000000001110001011100x00100110        Store 1 to mcause                                 0000600b close to ij
 * c3 aF_SW_1    52 LH_1       00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      0000600f close to fence
 * c4 ORI_0      c7 QINT_1     00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 ILL_3      b0 CSRRW_3    00000010000000000000101011101100100110        Q = 1                                             00000000 
 * c6 DIVU_1     9d DIV_11     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * c7 ORI_1      9f SH_5       00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * c8 LDAF_3     32 JAL_1      00000000000000001101100111100x00001xx0        PC to mepc                                        00006023 close to store
 * c9 SW_E2      d4 aFault_2   00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * ca aF_SW_2    62 DIV_8      00110010000000000000101011001100100110        Q = 4                                             40006023 close to store
 * cb MUL_2      72 LBU_3      00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      4e eILL0b     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce IJT_3      fe ILLe       00010010000000000000110011101100100110        Construct Q = 1                                   40006033 sloppy or      
 * cf MULHU_5    13 condb_2    00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * d0 SW_E3      8a DIVU_5     00110010000000000000101111001100100110        Q = 3                                             00000000 
 * d1 SH_4       f4 Fetch2     00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * d2 SH_5       09 LB_5       00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * d3 ECALL_4    41 JALR_1     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d4 MRET_3     c8 DIV_7      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * d5 DIV_3         (use dinx) 01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * d6 DIV_6      fe ILLe       00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * d7 EBREAK_2   d3 aFaultd    00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MRET_4     10 SUB_1      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00006067 close to jalr
 * da CSRRW_3    96 SH_1       00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * db CSRRW_4    c8 DIV_7      00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * dc CSRRSI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd eFetch3    ca DIVU_2     0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * de SH_3       7e NMI_1      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * df ECALL_5    7e NMI_1      00110010000000000000101011001100100110        Q = 8                                             00000000 
 * e0 IJ_3       f5 jFault     00010010000000000000110011101100100110        Construct Q = 1                                   00007003 close to load
 * e1 DIV_e      3d SRxI_2     00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * e2 LH_3       cb QINT_2     00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 0000700b close to ij
 * e3 MULH_2     3a SRxI_1     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SH_2       9e SH_4       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * e6 WFI_2      6e DIV_C      00010010000000000000101011101100100110        Check offset                                      00000000 
 * e7 SB_3       41 JALR_1     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e8 IJ_4       70 LHU_2      00000100000010001010110111100100011xx0        Mask and use as PC                                00007023 close to store
 * e9 IJT_2      f1 aFaulte    00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * ea (null)     4b CSRRW_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   40007023 close to store
 * eb (null)     a2 DIV_14     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     c6 IJT_4      00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee (null)     fe ILLe       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   40007033 sloppy and     
 * ef (null)     6e DIV_C      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f0 MRET_5     b1 aF_SW_3    00000010000000000000000011101100010xx0        ~302                                              00000000 
 * f1 IJT_4      41 JALR_1     00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * f2 QINT_1     72 LBU_3      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * f3 DIV_7      c3 DIVU_4     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f4 MRET_2     dd aF_SW_1    00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * f5 DIVU_2     c2 DIVU_3     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f6 _LCSRRCI_1 e6 StdIncPc   00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f7 MRET_7     d7 ECALL_3    00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 Fetch2u    fa WFI_2      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00007067 close to jalr
 * fa MULH_3     95 SW_E3      00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * fb LDAF_a     ab EBREAK_2   00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * fc CSRRCI_0   a1 ECALL_4    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      b9 DIV_e      00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       9c DIV_10     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     f2 SW_2       00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 1000, used ffff, inputs d4
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       68 DIV_12     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       60 MULHU_3    00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     72 LBU_3      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     9b unx9b      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       53 LDAF_LH    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     9b unx9b      00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       ab EBREAK_2   00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      70 LHU_2      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    53 LDAF_LH    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    6e DIV_C      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     92 LDAF_3     00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       72 LBU_3      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   5e LHU_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     72 LBU_3      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       e0 DIVU_1     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    ce _LCSRRCI_1 00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      72 LBU_3      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      8b LB_6       00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     88 DIV_E      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      90 NMI_2      00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     a1 ECALL_4    00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      ab EBREAK_2   00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       6e DIV_C      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   89 DIV_F      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     6b SB_4       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    72 LBU_3      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     8f ILL_3      00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    96 SH_1       00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      88 DIV_E      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    8e _LCSRRS_1  00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     9d DIV_11     00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    f2 SW_2       00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       9f SH_5       00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 DIV_4      95 SW_E3      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 47 DIV_5      b0 CSRRW_3    00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     c0 DIV_D      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    be IJ_1       00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_1      fe ILLe       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40002033 sloppy slt     
 * 4f DIV_2      72 LBU_3      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 50 DIV_E      72 LBU_3      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 51 DIV_F      df eFetch     00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 52 DIVU_5     1e aFault_1   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 53 LB_6       df eFetch     00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 54 SH_1       f3 aF_SW      00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 55 SW_E1SWH   41 JALR_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 DIV_10     9a ECALL_6    01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 57 DIV_11     53 LDAF_LH    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 58 DIV_14     a3 DIV_15     00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00002063 close to branch
 * 59 DIV_15     56 LH_4       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00002067 close to jalr
 * 5a OR_1       9c DIV_10     00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    96 SH_1       00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       f6 WFI_1      00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e ECAL_RET   3e SLL_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 5f EBRKWFI1   df eFetch     00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 60 IJ_1       10 SUB_1      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00003003 close to load
 * 61 IJT_1      83 DIV_2      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 62 DIVU_3     d6 eILL0c     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIVU_4     26 OR_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      75 unx75      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 ECALL_1    78 DIV_4      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 67 MRET_1     b2 CSRRW_4    00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 68 LB_2       72 LBU_3      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd    53 LDAF_LH    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c     f4 Fetch2     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    a8 DIV_3      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e Fetch      cf MRET_7     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     db jFault_1   00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 MUL_1      ffffffff (null)     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 71 MUL_3      41 JALR_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 72 StdIncPc   3a SRxI_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 73 aFault     29 XOR_1      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 74 eILL0a        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 76 LBU_2      dd aF_SW_1    00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 77 aFaulte    dd aF_SW_1    00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 78 SW_2       ba LHU_3      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00003063 close to branch
 * 79 aF_SW      b9 DIV_e      00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00003067 close to jalr
 * 7a SLTIX_1    78 DIV_4      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     86 JAL_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    96 SH_1       00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e Fetch2     c1 IJT_2      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 7f jFault        (use dinx) 00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 80 LBU_0      aa DIV_6      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 WFI_1      b9 DIV_e      00110010000000000000000011001100100110 WFI    To check offset                                   0000400b close to ij
 * 83 EBREAK_1   4e eILL0b     00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     76 Fetchu     00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 JAL_1      87 unx87      00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 87 JAL_3         (use dinx) 00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 88 SLLI_1     56 LH_4       00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00004023 close to store
 * 89 SLLI_2     72 LBU_3      00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 8a ECALL_2    3a SRxI_1     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  40004023 close to store
 * 8b MULHU_7    72 LBU_3      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      4e eILL0b     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e SRxI_1     fe ILLe       00000000000000000100101001101100001xx1        Register to shift to Q                            40004033 sloppy xor     
 * 8f SRxI_2     c9 MRET_2     00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 90 SLL_1      87 unx87      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 91 SRx_1      b1 aF_SW_3    00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 92 JALR_1     87 unx87      00010010000000000000000011101100100110        Q=1                                               00000000 
 * 93 WFI_3      b3 unxb3      00010010000000000000101011101100100110        More check offset                                 00000000 
 * 94 ILL_1      87 unx87      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 95 ILL_2      c3 DIVU_4     00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 96 CSRRW_1    d0 ECALL_1    00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 97 LH_4       b2 CSRRW_4    00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a LH_5       87 unx87      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 9b SB_1          (use dinx) 00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 9c SB_2       36 SLLI_2     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00004073 close to csr/system 
 * 9d MULHU_3    58 DIV_A      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * 9e EBRKWFI2   b5 SH_3       00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 9f WFI_4      78 DIV_4      00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 MULH_1     c7 QINT_1     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * a2 SB_4       53 LDAF_LH    00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      0000500b close to ij
 * a3 DIV_C      72 LBU_3      00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              0000500f close to fence
 * a4 SRxI_0     8e _LCSRRS_1  00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_6     bd IJ_4       00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * a6 LBU_3      66 SW_1       00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * a7 unalignd   9e SH_4       00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * a8 SB_5       46 ILL_1      00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00005023 close to store
 * a9 NMI_1      87 unx87      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * aa LBU_1      d6 eILL0c     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40005023 close to store
 * ab JAL_2      c8 DIV_7      10110000000000000100110011000x00100110        Return address to TRG                             00000000 
 * ac _L0xac     91 LDAF_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     e7 aFault     00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     91 LDAF_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af _LCSRRS_1  d3 aFaultd    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b0 ILL_3      bf IJT_1      00000010000000000000101011101100100110        Q = 1                                             00000000 
 * b1 LDAF_3     b1 aF_SW_3    00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * b2 SW_E2      6e DIV_C      00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * b3 SW_E3         (use dinx) 00110010000000000000101111001100100110        Q = 3                                             00000000 
 * b4 SH_4       a7 EBRKWFI1   00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b5 SH_5       b4 eFetch3    00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b6 ECALL_4    c8 DIV_7      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * b7 MRET_3     d1 MRET_1     00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 DIV_3      ffffffff (null)     01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00005067 close to jalr
 * ba DIV_6      3a SRxI_1     00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * bb EBREAK_2   c6 IJT_4      00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * bc CSRRWI_0   96 SH_1       00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd MRET_4     6e DIV_C      00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * be CSRRW_3    45 WFI_3      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * bf CSRRW_4    d2 LB_2       00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * c0 CSRRW_2    50 LW_1       00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00006003 close to load
 * c1 NMI_2      f1 aFaulte    00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * c2 LDAF_2     d9 MULH_3     00110000110000001110001011000x00100110        Store 4 to mcause                                 0000600b close to ij
 * c3 SW_E4      52 LH_1       00000000110000001110100111100x00101000        Store 6 to mcause                                 0000600f close to fence
 * c4 ORI_0      ee eILL0a     00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 eFetch3    a5 MRET_3     0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * c6 SH_3       95 SW_E3      00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * c7 ECALL_5    cb QINT_2     00110010000000000000101011001100100110        Q = 8                                             00000000 
 * c8 ECALL_6    32 JAL_1      00010000110000001110100111000x00100000        mcause = 11                                       00006023 close to store
 * c9 ILL_4      b7 IJ_3       00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * ca aF_SW_3    62 DIV_8      00010000110000001110001011000x00100000        Store 7 to mcause                                 40006023 close to store
 * cb QINT_2     72 LBU_3      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      4e eILL0b     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce IJ_3       fe ILLe       00010010000000000000110011101100100110        Construct Q = 1                                   40006033 sloppy or      
 * cf DIV_e      13 condb_2    00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * d0 SH_2       8a DIVU_5     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d1 IJ_4       d7 ECALL_3    00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * d2 IJT_2      09 LB_5       00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * d3 MRET_5     41 JALR_1     00000010000000000000000011101100010xx0        ~302                                              00000000 
 * d4 IJT_4      b1 aF_SW_3    00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * d5 QINT_1        (use dinx) 00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * d6 DIV_7      fe ILLe       00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * d7 MRET_2     b6 ECALL_5    00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 DIVU_2     10 SUB_1      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00006067 close to jalr
 * da _LCSRRCI_1 c2 DIVU_3     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * db MRET_7     b1 aF_SW_3    00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * dc CSRRSI_0   96 SH_1       00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd Fetch2u    ef WFI_5      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * de MULH_3     7e NMI_1      00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * df LDAF_a     7e NMI_1      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * e0 aFault_2   d9 MULH_3     00010000110000001110001011100x00100110        Store 5 to mcause                                 00007003 close to load
 * e1 (null)     3d SRxI_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e2 (null)     f0 LBU_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700b close to ij
 * e3 (null)     3a SRxI_1     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 jFault_1   ca DIVU_2     00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * e6 aF_SW_1    6e DIV_C      00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * e7 DIVU_1     41 JALR_1     00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * e8 (null)     70 LHU_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00007023 close to store
 * e9 (null)     d4 aFault_2   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ea (null)     4b CSRRW_2    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   40007023 close to store
 * eb (null)     97 SW_E1SWH   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     e7 aFault     00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee ORI_1      fe ILLe       00000010000000000000000011101100001xx0        Q = RS1                                           40007033 sloppy and     
 * ef aF_SW_2    6e DIV_C      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * f0 MUL_2      a6 ECAL_RET   00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * f1 IJT_3      41 JALR_1     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * f2 MULHU_5    72 LBU_3      00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * f3 LH_3       e6 StdIncPc   00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f4 MULH_2     c5 MRET_5     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * f5 WFI_2      e5 aF_SW_2    00010010000000000000101011101100100110        Check offset                                      00000000 
 * f6 SB_3       f5 jFault     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f7 (null)     bb SH_2       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)     de Fetch      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00007067 close to jalr
 * fa (null)     93 SW_E2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fb (null)     a2 DIV_14     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * fc CSRRCI_0   96 SH_1       00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      a9 ILL_4      00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       94 SW_E4      00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     d5 Fetch2u    00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0004, used ffff, inputs d8
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       9e SH_4       00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       8e _LCSRRS_1  00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     aa DIV_6      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     aa DIV_6      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     df eFetch     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       7f unx7f      00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     df eFetch     00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       f9 MULH_2     00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      a8 DIV_3      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     aa DIV_6      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 CSRRW_2    7f unx7f      00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 11 NMI_2      3a SRxI_1     00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 12 LDAF_2     68 DIV_12     00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 13 SW_E4      2e MULHU_1    00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 14 ECALL_6    39 MULHU_7    00010000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 15 ILL_4      06 LB_3       00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 16 aF_SW_3    aa DIV_6      00010000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 17 QINT_2     a6 ECAL_RET   00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     ce _LCSRRCI_1 00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       aa DIV_6      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   8a DIVU_5     00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     aa DIV_6      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e MULHU_2    30 SLTIX_2    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 1f MULHU_4    90 NMI_2      00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 20 LH_0       42 MULHU_2    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      aa DIV_6      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      c5 MRET_5     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     aa DIV_6      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     af MRET_4     00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 eILL0b     5d SB_2       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     3d SRxI_2     00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     82 DIV_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     82 DIV_1      00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      ca DIVU_2     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     e5 aF_SW_2    00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    1e aFault_1   00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     aa DIV_6      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 aFault_2   aa DIV_6      00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 31 (null)     7a SB_5       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 32 (null)     f9 MULH_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 33 (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 34 (null)     a6 ECAL_RET   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 35 (null)     b9 DIV_e      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 36 (null)     03 _L0x03     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 37 (null)     a3 DIV_15     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    aa DIV_6      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     c9 MRET_2     00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    db jFault_1   00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LW_1       af MRET_4     00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    c8 DIV_7      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 LH_1       e1 ORI_1      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH    d7 ECALL_3    00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       e3 MUL_3      00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 LH_2       da LDAF_a     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    fb SB_3       00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     10 SUB_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     60 MULHU_3    00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    73 unalignd   00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_A      fe ILLe       00110010000000000000101111101100001xx1        Transfer rM to rDee                               40002033 sloppy slt     
 * 4f DIV_B      aa DIV_6      00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 50 LDAF_3     aa DIV_6      00000000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 51 SW_E2      b7 IJ_3       00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 52 SW_E3      46 ILL_1      00110010000000000000101111001100100110        Q = 3                                             00000000 
 * 53 SH_4       b7 IJ_3       00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 54 SH_5       f0 LBU_2      00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 55 ECALL_4    41 JALR_1     00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 56 MRET_3     de Fetch      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * 57 DIV_3      7f unx7f      01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * 58 LHU_1      e7 aFault     00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00002063 close to branch
 * 59 LDAF_LHU   86 JAL_2      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00002067 close to jalr
 * 5a OR_1       e0 DIVU_1     00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    db jFault_1   00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       f3 aF_SW      00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e DIV_8      66 SW_1       00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 5f DIV_9      b7 IJ_3       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 60 SW_1       1e aFault_1   00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00003003 close to load
 * 61 SW_E1SWE   c7 QINT_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 DIV_12     b0 CSRRW_3    00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              0000300b close to ij
 * 63 DIV_13     4e eILL0b     00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      bb SH_2       00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 LHU_2      c0 DIV_D      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 67 aFaultc    51 LDAF_LW    00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 68 Fetchu     aa DIV_6      00000010000000000000001111101010110000  Fr10u Read and latch instruction                        00003023 close to store
 * 69 eFetchu    7f unx7f      00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 6a DIV_4      f1 aFaulte    00000000000000001100000011101000110000        ~abs(divisor) to yy                               40003023 close to store
 * 6b DIV_5      eb LH_3       00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_1      91 LDAF_2     00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40003033 sloppy sltu    
 * 6f DIV_2      b4 eFetch3    00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 70 DIV_6      ffffffff (null)     00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00000000 
 * 71 EBREAK_2   41 JALR_1     00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * 72 MRET_4     3a SRxI_1     00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * 73 CSRRW_3    29 XOR_1      00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * 74 CSRRW_4       (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * 75 eFetch3       (use dinx) 0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * 76 SH_3       b5 SH_3       00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * 77 ECALL_5    b5 SH_3       00110010000000000000101011001100100110        Q = 8                                             00000000 
 * 78 DIV_E      70 LHU_2      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00003063 close to branch
 * 79 DIV_F      57 LH_5       00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00003067 close to jalr
 * 7a SLTIX_1    c0 DIV_D      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     a1 ECALL_4    00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    db jFault_1   00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e DIVU_5     11 AND_1      00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 7f LB_6          (use dinx) 00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 80 LBU_0      ef WFI_5      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 SH_1       57 LH_5       00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        0000400b close to ij
 * 83 SW_E1SWH   6e DIV_C      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     be IJ_1       00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 DIV_10     a5 MRET_3     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 87 DIV_11        (use dinx) 01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 88 DIV_14     86 JAL_2      00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00004023 close to store
 * 89 DIV_15     aa DIV_6      00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00000000 
 * 8a ECAL_RET   3a SRxI_1     00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40004023 close to store
 * 8b EBRKWFI1   aa DIV_6      00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      6e DIV_C      01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e IJ_1       fe ILLe       00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   40004033 sloppy xor     
 * 8f IJT_1      15 condb_4    00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 90 IJ_3       a5 MRET_3     00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * 91 DIV_e      50 LW_1       00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00000000 
 * 92 SH_2       a5 MRET_3     00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 93 IJ_4       52 LH_1       00000100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 94 IJT_2      a5 MRET_3     00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * 95 MRET_5     13 condb_2    00000010000000000000000011101100010xx0        ~302                                              00000000 
 * 96 IJT_4      92 LDAF_3     00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 97 QINT_1     51 LDAF_LW    00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a DIVU_3     a5 MRET_3     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 9b DIVU_4        (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 9c ECALL_1    62 DIV_8      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00004073 close to csr/system 
 * 9d MRET_1     88 DIV_E      00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 9e LB_2       54 LH_2       00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 9f aFaultd    c0 DIV_D      00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * a0 LHU_0      58 DIV_A      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JAL_1      77 eFetchu    00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * a2 eILL0c     7f unx7f      00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000500b close to ij
 * a3 ECALL_3    aa DIV_6      00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    0000500f close to fence
 * a4 SRxI_0     c8 DIV_7      00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 JAL_3      72 LBU_3      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * a6 Fetch      9c DIV_10     00000001001010001000101111101010110000  Fr11  Read and latch instruction                        00000000 
 * a7 eFetch     e2 MUL_1      00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * a8 MUL_1      6a MULH_1     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00005023 close to store
 * a9 MUL_3      a5 MRET_3     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * aa StdIncPc   b0 CSRRW_3    10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    40005023 close to store
 * ab aFault     14 condb_3    00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * ac _L0xac     cb QINT_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     d2 LB_2       00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     cb QINT_2     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SLLI_1     95 SW_E3      00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * b0 DIV_7      74 unx74      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * b1 MRET_2     50 LW_1       00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * b2 DIVU_2     a6 ECAL_RET   00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * b3 _LCSRRCI_1    (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b4 MRET_7     ea MULHU_5    00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * b5 Fetch2u    53 LDAF_LH    0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * b6 MULH_3     14 condb_3    00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * b7 LDAF_a     93 SW_E2      00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SLLI_2     ffffffff (null)     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00005067 close to jalr
 * ba eILL0a     3a SRxI_1     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bb WFI_5      76 Fetchu     00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * bc CSRRWI_0   db jFault_1   00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ECALL_2    a6 ECAL_RET   00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * be LBU_2      45 WFI_3      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * bf aFaulte    94 SW_E4      00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * c0 SW_2       78 DIV_4      00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00006003 close to load
 * c1 aF_SW      d6 eILL0c     00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * c2 Fetch2     b2 CSRRW_4    00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     0000600b close to ij
 * c3 jFault     7e NMI_1      00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000600f close to fence
 * c4 ORI_0      d3 aFaultd    00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MULHU_7    e8 MUL_2      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * c6 WFI_1      da LDAF_a     00110010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * c7 EBREAK_1   17 condb_5t   00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * c8 SRxI_1     5e LHU_1      00000000000000000100101001101100001xx1        Register to shift to Q                            00006023 close to store
 * c9 SRxI_2     56 LH_4       00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * ca SLL_1      9a ECALL_6    00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              40006023 close to store
 * cb SRx_1      aa DIV_6      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      6e DIV_C      01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce JALR_1     fe ILLe       00010010000000000000000011101100100110        Q=1                                               40006033 sloppy or      
 * cf WFI_3      27 OR_2       00010010000000000000101011101100100110        More check offset                                 00000000 
 * d0 jFault_1   bd IJ_4       00010000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * d1 aF_SW_1    b1 aF_SW_3    00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * d2 DIVU_1     09 LB_5       00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * d3 ORI_1      41 JALR_1     00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * d4 aF_SW_2    50 LW_1       00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d5 MUL_2         (use dinx) 00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * d6 IJT_3      fe ILLe       00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * d7 MULHU_5    55 aFaultb    00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 ILL_1      1e aFault_1   00000000000000001101101011100x00001xx0        Store PC to mepc                                  00006067 close to jalr
 * da ILL_2      12 straddle   00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * db CSRRW_1    50 LW_1       00010010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * dc CSRRSI_0   db jFault_1   00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd LH_4       d4 aFault_2   00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * de LH_5       c2 DIVU_3     00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * df SB_1       c2 DIVU_3     00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * e0 SB_2       b2 CSRRW_4    00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00007003 close to load
 * e1 MULHU_3    3d SRxI_2     00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * e2 EBRKWFI2   d5 Fetch2u    00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         0000700b close to ij
 * e3 WFI_4      3a SRxI_1     00000010000000000000001011x01001xxxxx0        Prepare read PC                                   0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 MULH_1     16 condb_5    00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * e6 SB_4       a6 ECAL_RET   00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * e7 DIV_C      41 JALR_1     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * e8 MRET_6     a8 DIV_3      00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00007023 close to store
 * e9 LBU_3      96 SH_1       00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * ea unalignd   4b CSRRW_2    00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                40007023 close to store
 * eb SB_5       dd aF_SW_1    00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     d2 LB_2       00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee NMI_1      fe ILLe       00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40007033 sloppy and     
 * ef LBU_1      a6 ECAL_RET   00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * f0 LH_3       e9 IJT_3      00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f1 MULH_2     41 JALR_1     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * f2 WFI_2      aa DIV_6      00010010000000000000101011101100100110        Check offset                                      00000000 
 * f3 SB_3       d1 MRET_1     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f4 (null)     75 unx75      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f5 (null)     d0 ECALL_1    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f6 (null)     f2 SW_2       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f7 (null)     71 aFaultc    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 JAL_2      b6 ECALL_5    10110000000000000100110011000x00100110        Return address to TRG                             00007067 close to jalr
 * fa _LCSRRS_1  cf MRET_7     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * fb ILL_3      e6 StdIncPc   00000010000000000000101011101100100110        Q = 1                                             00000000 
 * fc CSRRCI_0   db jFault_1   00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      ee eILL0a     00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       d9 MULH_3     00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     97 SW_E1SWH   00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0200, used ffff, inputs e2
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       68 DIV_12     00000010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       60 MULHU_3    00010010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0               0000000b ij       
 * 03 _L0x03     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     72 LBU_3      00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00000017 auipc   
 * 06 condb_5    0b JALR_2     00000010000000000000001011x01000xxxxx0        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     00010100000010001010110111100100100000        Branch taken.                                     00000000 
 * 08 _L0x08     b0 CSRRW_3    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       53 LDAF_LH    00000010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     b0 CSRRW_3    00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       c0 DIV_D      00000010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      70 LHU_2      00100010000000000000111011x01000xxxxx0 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      21 XORI_1     00000010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 MULHU_2    53 LDAF_LH    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           00000000 
 * 11 MULHU_4    3a SRxI_1     00000010000000000000000011100100000xx0        Prepare read Rjj.                                 00000000 
 * 12 eILL0b     42 MULHU_2    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e MULHU_1    00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       39 MULHU_7    00000001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    6e DIV_C      00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     a6 ECAL_RET   00010000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       72 LBU_3      00000010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000006f jal     
 * 1c ECAL_BRK   5e LHU_1      00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     72 LBU_3      00000000000000001100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       92 LDAF_3     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    e9 IJT_3      00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      72 LBU_3      00000010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1      9d DIV_11     00000010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     72 LBU_3      00000010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     94 SW_E4      00000010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000000011x00100xxxxx0 AUIPC  q = imm20+2 or imm20+4  (copy x/2)                00001017 auipc   
 * 26 DIV_A      5d SB_2       00110010000000000000101111101100001xx1        Transfer rM to rDee                               00000000 
 * 27 DIV_B      3d SRxI_2     00000000000000001100111111101000110000        REM = Q to yy                                     00000000 
 * 28 _L0x28     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 straddle   49 CSRRW_1    10110100000010001010110111000100100110  Fr10u IncPC, OpFetch                                    00000000 
 * 2a _L0x2a     54 LH_2       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    81 unx81      00000010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      a3 DIV_15     00000010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     b5 SH_3       00000010000000000000101001101100001xx0 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e condb_3    10 SUB_1      00010010000000000000110011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     72 LBU_3      00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      72 LBU_3      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   7a SB_5       00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 DIV_8      c0 DIV_D      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           00000000 
 * 33 DIV_9         (use dinx) 01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    00000000 
 * 34 SW_1       6e DIV_C      00000000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   95 SW_E3      00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 DIV_12     03 _L0x03     00000000000000000100001011101000001xx0        RS2 > 0, RS1 >= 0, yy is true result              00000000 
 * 37 DIV_13     6b SB_4       00000010000000000000101011101100000xx0        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 38 BNE        2b SLTIX_1    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_4    72 LBU_3      00000010000000000000000011101101001xx0        Branch on condition                               00001067 close to jalr
 * 3a ANDI_1     a2 DIV_14     00000000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3b _L0x3b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000106f jal     
 * 3c CSRRW_0    aa DIV_6      00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ORI_2      03 _L0x03     00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3e LHU_2      94 SW_E4      00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    a1 ECALL_4    00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 aFault_1   1d ORI_2      00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 42 Fetchu     b2 CSRRW_4    00000010000000000000001111101010110000  Fr10u Read and latch instruction                        0000200b close to ij
 * 43 eFetchu    cf MRET_7     00000011001010000000101111101010110000  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     7a SB_5       00000010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       b4 eFetch3    00000000000000001100101011101000110000        Read word is to be masked with lsb = 0            00000000 
 * 46 DIV_4      a9 ILL_4      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00000000 
 * 47 DIV_5      c5 MRET_5     00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00000000 
 * 48 _L0x48     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XORI_1     82 DIV_1      00000000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4a _L0x4a     34 JAL_3      00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MULHU_6    e3 MUL_3      00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      00000000 
 * 4c SLT_0      85 LBU_1      00000010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   7d unx7d      00000000000000001100111001101000001xx0 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e DIV_1      fe ILLe       00000000000000001000111011101000000xx0        jj=abs(RS1). Next handle divisor                  40002033 sloppy slt     
 * 4f DIV_2      72 LBU_3      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     00000000 
 * 50 DIV_E      72 LBU_3      01100010000000000000111111x00x00xxxxx0        RS2 != 0. Check signs                             00000000 
 * 51 DIV_F      fb SB_3       00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 52 DIVU_5     1e aFault_1   00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 53 LB_6       fb SB_3       00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 54 SH_1       d2 LB_2       00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 55 SW_E1SWH   41 JALR_1     00000000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 DIV_10     af MRET_4     01100010000000000000110011101000001xx0        RS2 > 0. Branch on sign of RS1                    00000000 
 * 57 DIV_11     53 LDAF_LH    01100010000000000000110011101000001xx0        RS2 < 0. Branch on sign of RS1                    00000000 
 * 58 DIV_14     b7 IJ_3       00000010000000000000101011101100000xx0        RS2 < 0, RS1 >= 0, change sign yy                 00002063 close to branch
 * 59 DIV_15     56 LH_4       00000000000000000100001011101000001xx0        RS2 < 0, RS1 < 0, yy is true result               00002067 close to jalr
 * 5a OR_1       b1 aF_SW_3    00000000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000206f jal     
 * 5c CSRRS_0    aa DIV_6      00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       d7 ECALL_3    00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e ECAL_RET   3e SLL_1      00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 5f EBRKWFI1   fb SB_3       00010010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 60 IJ_1       10 SUB_1      00000010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~1u]                   00003003 close to load
 * 61 IJT_1      89 DIV_F      00000010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 62 DIVU_3     f3 aF_SW      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIVU_4     26 OR_1       01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    7a SB_5       00000010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      75 unx75      00000010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 ECALL_1    78 DIV_4      00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 67 MRET_1     c9 MRET_2     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 68 LB_2       72 LBU_3      00000010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd    53 LDAF_LH    00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c     d3 aFaultd    00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    bd IJ_4       00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     85 LBU_1      00000010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    7d unx7d      00000000000000001100111001101000001xx0 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e Fetch      ea MULHU_5    00000001001010001000101111101010110000  Fr11  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     f7 EBREAK_1   00000001001010001000101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 MUL_1      ffffffff (null)     00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           00000000 
 * 71 MUL_3      41 JALR_1     00110010000000000000101111x01000xxxxx1        Transfer rM to rDee                               00000000 
 * 72 StdIncPc   3a SRxI_1     10110100000010001010110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * 73 aFault     29 XOR_1      00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 74 eILL0a        (use dinx) 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 WFI_5         (use dinx) 00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 76 LBU_2      f9 MULH_2     00000010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 77 aFaulte    f9 MULH_2     00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 78 SW_2       e0 DIVU_1     00000010000000000000001011x01000xxxxx0        Prepare read PC                                   00003063 close to branch
 * 79 aF_SW      dd aF_SW_1    00000010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00003067 close to jalr
 * 7a SLTIX_1    78 DIV_4      00010010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 7b _L0x7b     90 NMI_2      00000010000000000000000011100100110000 JAL    J-imm is in q.                                    0000306f jal     
 * 7c CSRRC_0    aa DIV_6      00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d MULHU_1       (use dinx) 00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                00000000 
 * 7e Fetch2     83 DIV_2      00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 7f jFault        (use dinx) 00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 80 LBU_0      bf IJT_1      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLTIX_2       (use dinx) 00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 82 CSRRW_2    dd aF_SW_1    00000000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    0000400b close to ij
 * 83 NMI_2      4e eILL0b     00000000110000001111010011101000110000        mtval = 0.                                        0000400f close to fence
 * 84 XORI_0     49 CSRRW_1    00000010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLTX_1     76 Fetchu     00000010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 86 LDAF_2     91 LDAF_2     00110000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 87 SW_E4         (use dinx) 00000000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 88 WFI_1      56 LH_4       00110010000000000000000011001100100110 WFI    To check offset                                   00004023 close to store
 * 89 EBREAK_1   72 LBU_3      00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 8a ECALL_6    3a SRxI_1     00010000110000001110100111000x00100000        mcause = 11                                       40004023 close to store
 * 8b ILL_4      72 LBU_3      00010000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * 8c XOR_0      65 WFI_4      00000010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d DIV_0      4e eILL0b     01100010000000000000101101101100001xx0 DIV    Branch on sign dividend RS1                       00000000 
 * 8e aF_SW_3    fe ILLe       00010000110000001110001011000x00100000        Store 7 to mcause                                 40004033 sloppy xor     
 * 8f QINT_2     8b LB_6       00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 90 JAL_1      91 LDAF_2     00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 91 JAL_3      c8 DIV_7      00000100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 92 aFault_2   91 LDAF_2     00010000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 93 (null)     d0 ECALL_1    000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 94 SLLI_1     91 LDAF_2     00000000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 95 SLLI_2     87 unx87      00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 96 (null)     eb LH_3       000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 97 (null)     c9 MRET_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 98 BLT        2b SLTIX_1    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a (null)     91 LDAF_2     000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 9b (null)        (use dinx) 000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 9c ECALL_2    36 SLLI_2     00000000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00004073 close to csr/system 
 * 9d MULHU_7    58 DIV_A      00100000000000000100001011101000001xx0        Last shift.                                       00000000 
 * 9e (null)     d4 aFault_2   000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * 9f (null)     78 DIV_4      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * a0 LHU_0      30 SLTIX_2    00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SRxI_1     e8 MUL_2      00000000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * a2 SRxI_2     53 LDAF_LH    00000000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                0000500b close to ij
 * a3 SLL_1      72 LBU_3      00000010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              0000500f close to fence
 * a4 SRxI_0     a1 ECALL_4    00000010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SRx_1      e2 MUL_1      00000010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * a6 JALR_1     66 SW_1       00010010000000000000000011101100100110        Q=1                                               00000000 
 * a7 WFI_3      b3 unxb3      00010010000000000000101011101100100110        More check offset                                 00000000 
 * a8 ILL_1      46 ILL_1      00000000000000001101101011100x00001xx0        Store PC to mepc                                  00005023 close to store
 * a9 ILL_2      91 LDAF_2     00000000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * aa CSRRW_1    f3 aF_SW      00010010000000000000000011101100100110        Construct PC storage adr                          40005023 close to store
 * ab LH_4       8a DIVU_5     00000010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * ac _L0xac     a5 MRET_3     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     c6 IJT_4      00100010000000000000111001x01000xxxxx0 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     a5 MRET_3     00000010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af LH_5       f0 LBU_2      00000010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * b0 SB_1       e5 aF_SW_2    00000000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * b1 SB_2       c8 DIV_7      00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * b2 MULHU_3    6e DIV_C      00100010000000000000111111101100001xx0        Shift Q and rM. Prepare read rs1                  00000000 
 * b3 EBRKWFI2      (use dinx) 00000000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * b4 WFI_4      bb SH_2       00000010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * b5 MULH_1     d1 MRET_1     00000000000000001100101011101000000xx0        Store ~rs1 to Ryy. Prep construct 1.              00000000 
 * b6 SB_4       8a DIVU_5     00001110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b7 DIV_C      ee eILL0a     00000000000000001100111011100100001xx0        rM to yy. Q=ffffffff                              00000000 
 * b8 BGE        2b SLTIX_1    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MRET_6     ffffffff (null)     00010010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00005067 close to jalr
 * ba LBU_3      3a SRxI_1     00000010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * bb unalignd   e7 aFault     00000010000000000000001011101000110000  Fr10u Unaligned pc, prep read high hword                00000000 
 * bc CSRRWI_0   aa DIV_6      00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SB_5       6e DIV_C      00000000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * be NMI_1      45 WFI_3      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * bf LBU_1      ef WFI_5      00000010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * c0 JAL_2      50 LW_1       10110000000000000100110011000x00100110        Return address to TRG                             00006003 close to load
 * c1 _LCSRRS_1  ce _LCSRRCI_1 00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * c2 jFault_1   f5 jFault     00010000000000001110001011100x00100110        Store 1 to mcause                                 0000600b close to ij
 * c3 aF_SW_1    52 LH_1       00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      0000600f close to fence
 * c4 ORI_0      c7 QINT_1     00000000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 ILL_3      b9 DIV_e      00000010000000000000101011101100100110        Q = 1                                             00000000 
 * c6 DIVU_1     a9 ILL_4      00000000000000001100101111101000000xx0        Store inverted rs2 to yy. Prepare shift           00000000 
 * c7 ORI_1      8f ILL_3      00000010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * c8 LDAF_3     32 JAL_1      00000000000000001101100111100x00001xx0        PC to mepc                                        00006023 close to store
 * c9 SW_E2      d9 MULH_3     00000000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * ca aF_SW_2    62 DIV_8      00110010000000000000101011001100100110        Q = 4                                             40006023 close to store
 * cb MUL_2      72 LBU_3      00100010000000000000111011101100001xx0        Shift Q and rM. Prepare read rs2                  00000000 
 * cc OR_0       5a SB_1       00000010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd REM_0      4e eILL0b     01100010000000000000101101101100001xx0 REM    Branch on sign dividend RS1                       00000000 
 * ce IJT_3      fe ILLe       00010010000000000000110011101100100110        Construct Q = 1                                   40006033 sloppy or      
 * cf MULHU_5    13 condb_2    00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          00000000 
 * d0 SW_E3      9c DIV_10     00110010000000000000101111001100100110        Q = 3                                             00000000 
 * d1 SH_4       f4 Fetch2     00001110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * d2 LH_3       09 LB_5       00000010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * d3 MULH_2     41 JALR_1     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00000000 
 * d4 SH_5       c8 DIV_7      00000000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * d5 ECALL_4       (use dinx) 00110010000000000000101011001100100110        Q = 4                                             00000000 
 * d6 WFI_2      fe ILLe       00010010000000000000101011101100100110        Check offset                                      00000000 
 * d7 SB_3       d5 Fetch2u    00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d8 BLTU       2b SLTIX_1    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MRET_3     10 SUB_1      00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00006067 close to jalr
 * da (null)     86 JAL_2      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * db (null)     c8 DIV_7      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * dc CSRRSI_0   aa DIV_6      00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd DIV_3      ca DIVU_2     01100010000000000000101011101100000xx0        Branch on sign divisor RS2                        00000000 
 * de (null)     7e NMI_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * df (null)     7e NMI_1      000000x000000000000000xxxx00x00xx00xxx QINT_0                                                   00000000 
 * e0 DIV_6      f5 jFault     00100010000000000000101111x01000xxxxx0        Write M. Prepare shift                            00007003 close to load
 * e1 EBREAK_2   3d SRxI_2     00000000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * e2 MRET_4     cb QINT_2     00010010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          0000700b close to ij
 * e3 CSRRW_3    3a SRxI_1     00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     0000700f close to fence
 * e4 ANDI_0     3a SRxI_1     00000010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 CSRRW_4    8e _LCSRRS_1  00110100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * e6 eFetch3    6e DIV_C      0001000000000xx11001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * e7 SH_3       41 JALR_1     00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e8 ECALL_5    70 LHU_2      00110010000000000000101011001100100110        Q = 8                                             00007023 close to store
 * e9 IJ_3       f1 aFaulte    00010010000000000000110011101100100110        Construct Q = 1                                   00000000 
 * ea DIV_e      4b CSRRW_2    00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      40007023 close to store
 * eb SH_2       ab EBREAK_2   00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * ec AND_0      22 MULHU_6    00000010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed REMU_0     c6 IJT_4      00100010000000000000111001x01000xxxxx0 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee IJ_4       fe ILLe       00000100000010001010110111100100011xx0        Mask and use as PC                                40007033 sloppy and     
 * ef IJT_2      6e DIV_C      00000000000000001100101011101000110000        Read word is to be masked with ~1u                00000000 
 * f0 MRET_5     ba LHU_3      00000010000000000000000011101100010xx0        ~302                                              00000000 
 * f1 IJT_4      41 JALR_1     00000100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * f2 QINT_1     72 LBU_3      00000000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * f3 DIV_7      c3 DIVU_4     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f4 MRET_2     e6 StdIncPc   00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * f5 DIVU_2     c2 DIVU_3     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00000000 
 * f6 _LCSRRCI_1 d6 eILL0c     00000010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f7 MRET_7     e1 ORI_1      00000010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f8 BGEU       2b SLTIX_1    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 Fetch2u    fa WFI_2      0001000000000xx11011111111111100100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00007067 close to jalr
 * fa MULH_3     a7 EBRKWFI1   00100010000000000000111111x01000xxxxx0        rM<=RS2, Q = 0. next read RS1. Join.              00000000 
 * fb LDAF_a     b6 ECALL_5    00000010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * fc CSRRCI_0   aa DIV_6      00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      be IJ_1       00000010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       a8 DIV_3      00000010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     f2 SW_2       00000010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 
 *  36   9 531 14564 Can not simplify, can't possibly represent between 531 and 540 high values with only 4 bits index
 *  35   9 413 14682 Can not simplify, no legal mapping
 *  34   9 472 14623 Can not simplify, no legal mapping
 *  33   9 1003 14092 Can not simplify, no legal mapping
 *  32 127 236 14741 Can not simplify, no legal mapping
 *  31 127 590 14387 Can not simplify, can't represent fixed locations with any less than 7 bits of the index
 *  30   9 118 14977 Can not simplify, can't possibly represent between 118 and 127 high values with only 4 bits index
 *  29   9 5015 10080 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  28   9 4661 10434 Can not simplify, can't possibly represent between 4661 and 4670 high values with only 4 bits index
 *  27   9 2183 12912 Can not simplify, no legal mapping
 *  26   9 1888 13207 Can not simplify, no legal mapping
 *  25 835 9618 4651 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  24 835 5902 8367 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  23 1473 10327 3304 Can not simplify, no legal mapping
 *  22 1473 4485 9146 Can not simplify, can't represent fixed locations with any less than 7 bits of the index
 *  21 647 12864 1593 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  20 647 13749 708 Can not simplify, can't represent fixed locations with any less than 7 bits of the index
 *  19 2133 11389 1582 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  18   9 118 14977 Can not simplify, can't possibly represent between 118 and 127 high values with only 4 bits index
 *  17 647 11389 3068 Can not simplify, can't represent fixed locations with any less than 7 bits of the index
 *  16 1602 7377 6125 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  15   9 236 14859 Can not simplify, no legal mapping
 *  14 647 296 14161 Can not simplify, no legal mapping
 *  13 2771 7434 4899 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  12 2133 4131 8840 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  11 2133 3718 9253 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  10 7611 2419 5074 Can not simplify, no legal mapping
 *   9 7611 2360 5133 Can not simplify, no legal mapping
 *   8 647 944 13513 Can not simplify, no legal mapping
 *   7 647 7671 6786 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *   6 647 7139 7318 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *   5 647 7139 7318 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *   4 647 7671 6786 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *   3   9 6256 8839 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *   2 647 6903 7554 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *   1 647 9382 5075 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *   0   9 6243 8852 Can not simplify, can't possibly represent between 6243 and 6252 high values with only 4 bits index
 */
localparam u0_0 = 256'h30e6001000e208041886205a008b205a18091007000420e600e620be09d22001;
localparam u0_1 = 256'h30b726d438e630a6303218e62041301320de00e64816261500142676001a008b;
localparam u0_2 = 256'h30e63042086a003e2630209600212096201d00270004303500e6213900e62052;
localparam u0_3 = 256'h083a0835090330493032093d08e6301348d72803083608de00002086002b32e6;
localparam u0_4 = 256'h26e600fe082e003108b02066264b2066088f08472665102b00ea2160260b2050;
localparam u0_5 = 256'h30da097028fb30493032085d309c096e008b1857301e09eb30da095430da08e6;
localparam u0_6 = 256'h26cf08b9082e0031087a00f9008b08e6309308f240ef102b265826c850f70842;
localparam u0_7 = 256'h0000089000003049303208f226a830aab0d5b0d5000000003012101a301e09ba;
localparam u0_8 = 256'h26a900fe0882002926e6011a30e6009c0000263409f01021208200a800002085;
localparam u0_9 = 256'h08f2089f08a208680000203400fe3013309308bb269428340895083426923034;
localparam u0_A = 256'h26c5003f00e0003f089a00c826340078206130d026af303a08e6008b26b6205e;
localparam u0_B = 256'h08c1081f18de304928b5101a06c0301326bd269a309e2673000026de209226b2;
localparam u0_C = 256'h404f00fe0882002630e62cc220a52c6208cb1847106f10e1268a26ca30e94888;
localparam u0_D = 256'hb0f4b0f430e53049269200910042301330a100fe20002692301e090630c92637;
localparam u0_E = 256'h26de00fe00e000111056202226c608e2301e26de26b1101a011a21e8081d00ca;
localparam u0_F = 256'h00c70046007e3049306b264526d9301330ab26fa30db20b400dd00e6301e0972;
localparam u1_0 = 256'h10ba03b203b203bb30ba23ab017b23ab017b01bb003110ba00b2837b02fb036b;
localparam u1_1 = 256'h32ba02b310ba82f9003910ba22ba33ba2b7900b2003b033b03fb2b7103bb03fb;
localparam u1_2 = 256'h10ba23fa029b03b0003aa3ab03bba3ab003b23ba003103c800b202bb10bab36b;
localparam u1_3 = 256'h03c803c8129b31ba0039129b10ba33ba343a12db12db2b79000030ba03fb10ba;
localparam u1_4 = 256'h02bb0030339a03b20eb983bb003b83bb3eba36b802bb03fb0039029b003b837b;
localparam u1_5 = 256'h3eb902fb32db31ba003932db33fa02fb023b023b3eba029b3eb902fb3eb912fa;
localparam u1_6 = 256'h003b33b9339a03b20b3b32ba02bb10ba3cb80fb900b203fb02fb02db21ba03fb;
localparam u1_7 = 256'h0000343a000031ba00390b3902bb303a02fa00fa0000000000ba01bb3eba029b;
localparam u1_8 = 256'h02bb003002db03f210ba02f210ba03f00000133002fb03fb02bb23ba0000036b;
localparam u1_9 = 256'h0739073b033a033a00003a70003033ba3cb832db02f33a7836fa367838b03d3a;
localparam u1_A = 256'h003b03b0039203b036ba02f23a7802bb003b82f901bb03c810ba02bb02b3b36b;
localparam u1_B = 256'h02fb02fb2b7931ba32db01fb033b33ba033b02b3003a67fb00002b7138b002b3;
localparam u1_C = 256'h01b2003002db03f23d3a033b01b3033b343a377b003b23fa02fb02db32ba03bb;
localparam u1_D = 256'h22fa22fa3eba31ba38b802b203f233ba3eba00306fff38b83eba029b21ba00bb;
localparam u1_E = 256'h2b710030039203f201fb033b033b03bb3eba2b7102b303fb02f2029b003b32fa;
localparam u1_F = 256'h00b200b000b231ba003a02bb23ba33ba3cba00333eba2c7e003100b23eba029b;
localparam u2_0 = 256'h00000080088000800000040000800400008000800080040000800490008a0580;
localparam u2_1 = 256'h00000c80000000800080000004000000050200800080048000802d0200800080;
localparam u2_2 = 256'h0000080000800080048004000080040004800000008000800080008000000500;
localparam u2_3 = 256'h0080008000040000008000000800000000000004000001020000040000800000;
localparam u2_4 = 256'h0480008000000080002007810480078100000000048000800080008004800581;
localparam u2_5 = 256'h0000008a000400000080000000000c8000800080000000840000008a00000042;
localparam u2_6 = 256'h0480000000000080038000000080000000000000008000801480048000000880;
localparam u2_7 = 256'h0000000000000000008000000c80000000ca0080000000000080008000000084;
localparam u2_8 = 256'h00800080188000800c000c800000188000002c00008a00800480000000000580;
localparam u2_9 = 256'h00000380188018800000043000800000000000000c800030000000000c300030;
localparam u2_A = 256'h048000800880008000000880043018800480008104800080000000800c800500;
localparam u2_B = 256'h0082008201020000000400800080000004800c800080040000000d0204300c80;
localparam u2_C = 256'h0080008018800080003008800480088000000100008000001480048000000080;
localparam u2_D = 256'h004a004a00000000040000800880000000000080040004300000008400000480;
localparam u2_E = 256'h0d02008008800080008000800480088000002d020c8000800c80008000800000;
localparam u2_F = 256'h0080008000800000008004800400000000000c80000004000080008000000084;
