/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------
 * Automaticaly generated by ../bin/midgetv_genucode (based on ../code/ucode.h).
 * Do not edit.
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       d2 LB_2       0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       be IJ_1       0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     e6 StdIncPc   0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     e6 StdIncPc   0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 LB_3       07 LB_4       0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 07 LB_4       09 LB_5       0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 08 _L0x08     5a SB_1       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_5       8b LB_6       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 0a _L0x0a     5a SB_1       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b JALR_2     86 JAL_2      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      10 SUB_1      0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 SUB_1      8b LB_6       0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 11 AND_1      1a ANDI_1     0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 12 unx12         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 12: Not in use                                           00000000 
 * 13 condb_2    14 condb_3    0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 14 condb_3    15 condb_4    0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 15 condb_4    16 condb_5    0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 16 condb_5    de Fetch      0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 17 condb_5t   74 BrOpFet    0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 18 BEQ        13 condb_2    0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     41 JALR_1     0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a ANDI_1     e6 StdIncPc   0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 1b _L0x1b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   a6 ECAL_RET   0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d ORI_2      e6 StdIncPc   0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 1e aFault_1   d4 aFault_2   0010000000000000101011001100100110        Q = 4                                             00000000 
 * 1f IJ_2       b7 IJ_3       0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 20 LH_0       52 LH_1       0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 XORI_1     e6 StdIncPc   0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 22 unx22         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 22: Not in use                                           0000100b close to ij
 * 23 _L0x23     e6 StdIncPc   0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     35 SLLI_1     0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 OR_1       27 OR_2       0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 27 OR_2       1d ORI_2      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 28 _L0x28     96 SH_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 XOR_1      21 XORI_1     0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 2a _L0x2a     96 SH_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b SLTIX_1    30 SLTIX_2    0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 2c SLL_0      3e SLL_1      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e unx2e         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 2e: Not in use                                           40001033 sloppy sll     
 * 2f _L0x2f     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SLTIX_2    e6 StdIncPc   0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 31 SLTX_1     2b SLTIX_1    0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 32 JAL_1      86 JAL_2      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 33 JAERR_1    81 JAERR_2    0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 34 JAL_3      de Fetch      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 35 SLLI_1     36 SLLI_2     0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 36 SLLI_2     03 _L0x03     0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 37 ECALL_2    d7 ECALL_3    0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 38 BNE        13 condb_2    0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 unx39         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 39: Not in use                                           00001067 close to jalr
 * 3a SRxI_1     3d SRxI_2     0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 3b _L0x3b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    49 CSRRW_1    0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d SRxI_2     03 _L0x03     0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 3e SLL_1      35 SLLI_1     0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 3f SRx_1      3a SRxI_1     0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 40 LW_0       50 LW_1       0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 JALR_1     0b JALR_2     0010000000000000000011101100100110        Q=1                                               00000000 
 * 42 unx42         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 42: Not in use                                           0000200b close to ij
 * 43 unx43         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 43: Not in use                                           0000200f close to fence
 * 44 SLTI_0     2b SLTIX_1    0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 WFI_3      65 WFI_4      0010000000000000101011101100100110        More check offset                                 00000000 
 * 46 ILL_1      47 ILL_2      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 47 ILL_2      8f ILL_3      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 48 _L0x48     66 SW_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 CSRRW_1    4b CSRRW_2    0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 4a _L0x4a     66 SW_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b CSRRW_2    b0 CSRRW_3    0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 4c SLT_0      31 SLTX_1     0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d unx4d         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 4d: Not in use                                           00000000 
 * 4e eILL0b     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40002033 sloppy slt     
 * 4f MRET_8     e6 StdIncPc   0010000000000000101011101100100110        Prep +4                                           00000000 
 * 50 LW_1       e6 StdIncPc   0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 51 LDAF_LW    da LDAF_a     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 52 LH_1       54 LH_2       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 53 LDAF_LH    da LDAF_a     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 54 LH_2       eb LH_3       0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 55 aFaultb    1e aFault_1   0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 56 LH_4       57 LH_5       0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 57 LH_5       8b LB_6       0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 58 unx58         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 58: Not in use                                           00002063 close to branch
 * 59 unx59         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 59: Not in use                                           00002067 close to jalr
 * 5a SB_1       5d SB_2       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5b _L0x5b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    49 CSRRW_1    0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SB_2       fb SB_3       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 5e LHU_1      70 LHU_2      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 5f LDAF_LHU   da LDAF_a     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 60 unx60         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 60: Not in use                                           00003003 close to load
 * 61 EBRKWFI2   f7 EBREAK_1   0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 62 unx62         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 62: Not in use                                           0000300b close to ij
 * 63 unx63         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 63: Not in use                                           0000300f close to fence
 * 64 SLTIU_0    2b SLTIX_1    0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 WFI_4      ef WFI_5      0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 66 SW_1       f2 SW_2       0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 67 SW_E1SWE   93 SW_E2      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 68 unx68         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 68: Not in use                                           00003023 close to store
 * 69 unx69         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 69: Not in use                                           00000000 
 * 6a unx6a         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 6a: Not in use                                           40003023 close to store
 * 6b SB_4       7a SB_5       1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 6c SLTU_0     31 SLTX_1     0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d unx6d         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 6d: Not in use                                           00000000 
 * 6e unx6e         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 6e: Not in use                                           40003033 sloppy sltu    
 * 6f MRET_6     cf MRET_7     0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 70 LHU_2      ba LHU_3      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 71 aFaultc    1e aFault_1   0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 72 LBU_3      1a ANDI_1     0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 73 BAERR_1    76 BAERR_2    0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 74 BrOpFet    f4 Fetch2     0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 75 BAlignEr   73 BAERR_1    0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 76 BAERR_2    77 BAERR_3    0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 77 BAERR_3    7d BAERR_4    0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * 78 unx78         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 78: Not in use                                           00003063 close to branch
 * 79 unx79         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 79: Not in use                                           00003067 close to jalr
 * 7a SB_5       f2 SW_2       0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 7b _L0x7b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    49 CSRRW_1    0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d BAERR_4    34 JAL_3      0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 7e NMI_1      90 NMI_2      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 7f JALRE2     7d BAERR_4    0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * 80 LBU_0      85 LBU_1      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 JAERR_2    7d BAERR_4    0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 82 unx82         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 82: Not in use                                           0000400b close to ij
 * 83 unx83         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 83: Not in use                                           0000400f close to fence
 * 84 XORI_0     21 XORI_1     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 LBU_1      f0 LBU_2      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 86 JAL_2      34 JAL_3      0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 87 JALRE1     7f JALRE2     0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 88 unx88         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 88: Not in use                                           00004023 close to store
 * 89 unx89         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 89: Not in use                                           00000000 
 * 8a unx8a         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 8a: Not in use                                           40004023 close to store
 * 8b LB_6       e6 StdIncPc   0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 8c XOR_0      29 XOR_1      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d unx8d         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 8d: Not in use                                           00000000 
 * 8e _LCSRRS_1  fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40004033 sloppy xor     
 * 8f ILL_3      a9 ILL_4      0010000000000000101011101100100110        Q = 1                                             00000000 
 * 90 NMI_2      34 JAL_3      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 91 LDAF_2     92 LDAF_3     0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 92 LDAF_3     34 JAL_3      0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 93 SW_E2      95 SW_E3      0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 94 SW_E4      34 JAL_3      0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 95 SW_E3      94 SW_E4      0010000000000000101111001100100110        Q = 3                                             00000000 
 * 96 SH_1       bb SH_2       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 97 SW_E1SWH   93 SW_E2      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 98 BLT        13 condb_2    0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a ECALL_6    34 JAL_3      0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 9b unx9b         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 9b: Not in use                                           00000000 
 * 9c unx9c         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 9c: Not in use                                           00004073 close to csr/system 
 * 9d unx9d         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 9d: Not in use                                           00000000 
 * 9e SH_4       9f SH_5       1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 9f SH_5       f2 SW_2       0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * a0 LHU_0      5e LHU_1      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_4    b6 ECALL_5    0010000000000000101011001100100110        Q = 4                                             00000000 
 * a2 unxa2         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx a2: Not in use                                           0000500b close to ij
 * a3 unxa3         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx a3: Not in use                                           0000500f close to fence
 * a4 SRxI_0     3a SRxI_1     0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_3     af MRET_4     0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * a6 ECAL_RET   d0 ECALL_1    0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * a7 EBRKWFI1   61 EBRKWFI2   0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * a8 unxa8         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx a8: Not in use                                           00005023 close to store
 * a9 ILL_4      34 JAL_3      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * aa unxaa         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx aa: Not in use                                           40005023 close to store
 * ab EBREAK_2   9a ECALL_6    0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * ac _L0xac     3f SRx_1      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad unxad         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ad: Not in use                                           00000000 
 * ae _L0xae     3f SRx_1      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_4     c5 MRET_5     0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b0 CSRRW_3    b2 CSRRW_4    0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b1 aF_SW_3    92 LDAF_3     0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * b2 CSRRW_4    de Fetch      0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b3 unxb3         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx b3: Not in use                                           00000000 
 * b4 i0reserv      (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * b5 SH_3       9e SH_4       0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b6 ECALL_5    9a ECALL_6    0010000000000000101011001100100110        Q = 8                                             00000000 
 * b7 IJ_3       bd IJ_4       0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b8 BGE        13 condb_2    0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 unxb9         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx b9: Not in use                                           00005067 close to jalr
 * ba LHU_3      1a ANDI_1     0010000000000000011111101100010xx0        Invert q. Prepare read mask                       00000000 
 * bb SH_2       b5 SH_3       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * bc CSRRWI_0   49 CSRRW_1    0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd IJ_4       de Fetch      0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * be IJ_1       1f IJ_2       0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * bf IJT_1      c1 IJT_2      0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * c0 unxc0         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx c0: Not in use                                           00006003 close to load
 * c1 IJT_2      e9 IJT_3      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c2 unxc2         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx c2: Not in use                                           0000600b close to ij
 * c3 unxc3         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx c3: Not in use                                           0000600f close to fence
 * c4 ORI_0      e1 ORI_1      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_5     6f MRET_6     0010000000000000000011101100010xx0        ~302                                              00000000 
 * c6 IJT_4      47 ILL_2      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * c7 QINT_1     cb QINT_2     0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * c8 unxc8         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx c8: Not in use                                           00006023 close to store
 * c9 MRET_2     a5 MRET_3     0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * ca unxca         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ca: Not in use                                           40006023 close to store
 * cb QINT_2     e6 StdIncPc   0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * cc OR_0       26 OR_1       0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd unxcd         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx cd: Not in use                                           00000000 
 * ce _LCSRRCI_1 fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006033 sloppy or      
 * cf MRET_7     4f MRET_8     0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * d0 ECALL_1    37 ECALL_2    0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * d1 MRET_1     c9 MRET_2     0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * d2 LB_2       06 LB_3       0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * d3 aFaultd    1e aFault_1   0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * d4 aFault_2   92 LDAF_3     0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * d5 unxd5         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx d5: Not in use                                           00000000 
 * d6 eILL0c     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d7 ECALL_3    a1 ECALL_4    0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * d8 BLTU       13 condb_2    0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 unxd9         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx d9: Not in use                                           00006067 close to jalr
 * da LDAF_a     91 LDAF_2     0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * db jFault_1   92 LDAF_3     0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * dc CSRRSI_0   49 CSRRW_1    0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd aF_SW_1    e5 aF_SW_2    0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * de Fetch      f4 Fetch2     0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * df eFetch     f4 Fetch2     0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * e0 unxe0         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx e0: Not in use                                           00007003 close to load
 * e1 ORI_1      1d ORI_2      0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * e2 unxe2         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx e2: Not in use                                           0000700b close to ij
 * e3 unxe3         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx e3: Not in use                                           0000700f close to fence
 * e4 ANDI_0     1a ANDI_1     0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 aF_SW_2    b1 aF_SW_3    0010000000000000101011001100100110        Q = 4                                             00000000 
 * e6 StdIncPc   de Fetch      0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * e7 aFault     1e aFault_1   0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * e8 unxe8         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx e8: Not in use                                           00007023 close to store
 * e9 IJT_3      c6 IJT_4      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ea unxea         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ea: Not in use                                           40007023 close to store
 * eb LH_3       56 LH_4       0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * ec AND_0      11 AND_1      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed unxed         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ed: Not in use                                           00000000 
 * ee eILL0a     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40007033 sloppy and     
 * ef WFI_5      de Fetch      0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * f0 LBU_2      72 LBU_3      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * f1 aFaulte    1e aFault_1   0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * f2 SW_2       e6 StdIncPc   0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * f3 aF_SW      dd aF_SW_1    0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * f4 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f5 jFault     db jFault_1   0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * f6 WFI_1      fa WFI_2      0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * f7 EBREAK_1   ab EBREAK_2   0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * f8 BGEU       13 condb_2    0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 unxf9         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx f9: Not in use                                           00007067 close to jalr
 * fa WFI_2      45 WFI_3      0010000000000000101011101100100110        Check offset                                      00000000 
 * fb SB_3       6b SB_4       0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fc CSRRCI_0   49 CSRRW_1    0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      7e NMI_1      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       46 ILL_1      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     c7 QINT_1     0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 
 */
/* Col   x   1   0
 *  41  51   4 201 
 * Candidate function 0400, used cfff, inputs 5c
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       82 unx82      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       78 unx78      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     8a unx8a      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     8a unx8a      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     bb SH_2       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       da LDAF_a     0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     bb SH_2       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       62 unx62      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     8a unx8a      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      21 XORI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     8a unx8a      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 CSRRW_4    da LDAF_a     0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * 11 SH_3       39 unx39      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * 12 ECALL_5       (use dinx) 0010000000000000101011001100100110        Q = 8                                             00000000 
 * 13 IJ_3       2b SLTIX_1    0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 14 jFault_1   2e unx2e      0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 15 aF_SW_1    06 LB_3       0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 16 ORI_1      88 unx88      0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 17 aF_SW_2    60 unx60      0010000000000000101011001100100110        Q = 4                                             00000000 
 * 18 BEQ        29 XOR_1      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     a8 unxa8      0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       8a unx8a      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   6e unx6e      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     8a unx8a      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e JAL_1      b2 CSRRW_4    0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 1f JAERR_1    13 condb_2    0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 20 LH_0       42 unx42      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      8a unx8a      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1         (use dinx) 0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     8a unx8a      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     81 JAERR_2    0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 eILL0b     5a SB_1       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     3a SRxI_1     0010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_2    45 WFI_3      0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2a _L0x2a     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_3    6d unx6d      0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2c SLL_0      a6 ECAL_RET   0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     8a unx8a      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_4       (use dinx) 0010000000000000110011101101001xx0        Branch on condition                               40001033 sloppy sll     
 * 2f _L0x2f     8a unx8a      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SH_2       8a unx8a      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 31 IJ_4       65 WFI_4      0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 32 IJT_2      62 unx62      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * 33 MRET_5     cf MRET_7     0010000000000000000011101100010xx0        ~302                                              00000000 
 * 34 IJT_3      88 unx88      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 35 LH_3       85 LBU_1      0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 36 WFI_2      03 _L0x03     0010000000000000101011101100100110        Check offset                                      00000000 
 * 37 SB_3       87 JALRE1     0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * 38 BNE        29 XOR_1      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00001067 close to jalr
 * 3a ORI_2      a5 MRET_3     0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3b _L0x3b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    ad unxad      0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d aFault_1   03 _L0x03     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 3e LW_1       81 JAERR_2    0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    a1 ECALL_4    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 IJ_2       1d ORI_2      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 42 LH_1          (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH       (use dinx) 0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     65 WFI_4      0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 XORI_1     bf IJT_1      0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 46 LH_2       ab EBREAK_2   0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    dd aF_SW_1    0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     58 unx58      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 SB_4       af MRET_4     1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 4a _L0x4a     58 unx58      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b SH_4       fa WFI_2      1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 4c SLT_0      7a SB_5       0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d OR_1          (use dinx) 0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 4e LHU_1      fe ILLe       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40002033 sloppy slt     
 * 4f LDAF_LHU   8a unx8a      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 50 (null)     8a unx8a      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 51 (null)     b3 unxb3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 52 (null)     46 ILL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 (null)     b3 unxb3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 54 (null)     35 SLLI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 55 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 56 (null)     ba LHU_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 (null)     da LDAF_a     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 58 SW_1          (use dinx) 0000000000000011111011100100001xx0        Write d to a+k until accepted                     00002063 close to branch
 * 59 SW_E1SWE      (use dinx) 0000000000001111001011100x00110000        Store faulting address alignment to mtval         00002067 close to jalr
 * 5a OR_2       bd IJ_4       0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5b _L0x5b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    ad unxad      0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d XOR_1      37 ECALL_2    0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 5e LHU_2      5e LHU_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaultc    b3 unxb3      0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 60 BrOpFet       (use dinx) 0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00003003 close to load
 * 61 BAlignEr   a3 unxa3      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 62 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             0000300b close to ij
 * 63 JALRE1        (use dinx) 0000000000001101110011100x00001xx0  err   Store pc to mepc                                  0000300f close to fence
 * 64 SLTIU_0    65 WFI_4      0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLTIX_1    8f ILL_3      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 66 SH_1       9c unx9c      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 67 SW_E1SWH   e1 ORI_1      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 68 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00003023 close to store
 * 69 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 6a (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40003023 close to store
 * 6b (null)     c6 IJT_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 6c SLTU_0     7a SB_5       0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SLTIX_2       (use dinx) 0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 6e ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40003033 sloppy sltu    
 * 6f EBRKWFI1   b1 aF_SW_3    0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 70 (null)     ffffffff (null)     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 71 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 72 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 (null)     c3 unxc3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 74 (null)     9e SH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 75 (null)     c2 unxc2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 76 (null)     c5 MRET_5     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 (null)     c7 QINT_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 78 IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00003063 close to branch
 * 79 IJT_1         (use dinx) 0010000010000000101111101100001xx0        Exit CSR, enter trap                              00003067 close to jalr
 * 7a SLTX_1     9c unx9c      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 7b _L0x7b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    ad unxad      0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d JAL_3      7d BAERR_4    0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 7e ECALL_1    de Fetch      0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 7f MRET_1     c7 QINT_1     0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 80 LBU_0      d9 unxd9      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLLI_1     c7 QINT_1     0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 82 LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     0000400b close to ij
 * 83 aFaultd       (use dinx) 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       0000400f close to fence
 * 84 XORI_0     45 WFI_3      0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLLI_2     9a ECALL_6    0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 86 eILL0c     7d BAERR_4    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 87 ECALL_3    ce _LCSRRCI_1 0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 88 Fetch         (use dinx) 0000000000001000001111101010110000  Fr00  Read and latch instruction                        00004023 close to store
 * 89 eFetch        (use dinx) 0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 8a StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    40004023 close to store
 * 8b aFault     8a unx8a      0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 8c XOR_0      5d SB_2       0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d ECALL_2       (use dinx) 0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 8e eILL0a     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40004033 sloppy xor     
 * 8f WFI_5      ee eILL0a     0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 90 IJT_4      7d BAERR_4    0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 91 QINT_1     e0 unxe0      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 92 MRET_2     7d BAERR_4    0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * 93 QINT_2     e3 unxe3      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 94 i0reserv   7d BAERR_4    xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * 95 (null)     e2 unxe2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 96 (null)     30 SLTIX_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 (null)     e1 ORI_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 98 BLT        29 XOR_1      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a LBU_2      7d BAERR_4    0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 9b aFaulte       (use dinx) 0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 9c SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   00004073 close to csr/system 
 * 9d aF_SW         (use dinx) 0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 9e Fetch2     e6 StdIncPc   000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 9f jFault     9c unx9c      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * a0 LHU_0      4e eILL0b     0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SRxI_1     12 unx12      0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * a2 WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   0000500b close to ij
 * a3 EBREAK_1      (use dinx) 0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       0000500f close to fence
 * a4 SRxI_0     a1 ECALL_4    0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SRxI_2     f9 unxf9      0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * a6 SLL_1      7e NMI_1      0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * a7 SRx_1      be IJ_1       0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * a8 JALR_1        (use dinx) 0010000000000000000011101100100110        Q=1                                               00005023 close to store
 * a9 WFI_3      7d BAERR_4    0010000000000000101011101100100110        More check offset                                 00000000 
 * aa ILL_1         (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  40005023 close to store
 * ab ILL_2      e5 aF_SW_2    0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * ac _L0xac     a7 EBRKWFI1   0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad CSRRW_1       (use dinx) 0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * ae _L0xae     a7 EBRKWFI1   0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af CSRRW_2    33 JAERR_1    0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * b0 _LCSRRCI_1 10 SUB_1      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b1 MRET_7     e0 unxe0      0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * b2 aFault_2   88 unx88      0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * b3 LDAF_a        (use dinx) 0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * b4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b5 (null)     4b CSRRW_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b6 (null)     e5 aF_SW_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 (null)     31 SLTX_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b8 BGE        29 XOR_1      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 LH_4          (use dinx) 0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00005067 close to jalr
 * ba LH_5       39 unx39      0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * bb SB_1       11 AND_1      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * bc CSRRWI_0   ad unxad      0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SB_2       88 unx88      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * be EBRKWFI2   41 JALR_1     0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * bf WFI_4      32 JAL_1      0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * c0 MRET_6        (use dinx) 0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00006003 close to load
 * c1 LBU_3      34 JAL_3      0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * c2 BAERR_1       (use dinx) 0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             0000600b close to ij
 * c3 BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           0000600f close to fence
 * c4 ORI_0      16 condb_5    0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 BAERR_3    c0 unxc0      0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * c6 SB_5       ab EBREAK_2   0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * c7 BAERR_4    93 SW_E2      0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * c8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00006023 close to store
 * c9 (null)     ed unxed      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ca (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40006023 close to store
 * cb (null)     8a unx8a      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * cc OR_0       4d unx4d      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * ce JALRE2     fe ILLe       0000000000001111101011100x00001xx0        mtval is target                                   40006033 sloppy or      
 * cf JAERR_2    27 OR_2       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * d0 (null)     8d unx8d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 (null)     92 LDAF_3     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d4 (null)     e0 unxe0      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     e7 aFault     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       29 XOR_1      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 LBU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00006067 close to jalr
 * da LB_6       df eFetch     0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * db _LCSRRS_1  e0 unxe0      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * dc CSRRSI_0   ad unxad      0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd ILL_3      17 condb_5t   0010000000000000101011101100100110        Q = 1                                             00000000 
 * de NMI_2      9e SH_4       0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * df LDAF_2     9e SH_4       0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * e0 LDAF_3        (use dinx) 0000000000001101100111100x00001xx0        PC to mepc                                        00007003 close to load
 * e1 SW_E2      3a SRxI_1     0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * e2 SW_E4         (use dinx) 0000110000001110100111100x00101000        Store 6 to mcause                                 0000700b close to ij
 * e3 SW_E3         (use dinx) 0010000000000000101111001100100110        Q = 3                                             0000700f close to fence
 * e4 ANDI_0     39 unx39      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 ECALL_6    fb SB_3       0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * e6 SH_5       88 unx88      0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * e7 ECALL_4    3d SRxI_2     0010000000000000101011001100100110        Q = 4                                             00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     90 NMI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     b9 unxb9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      22 unx22      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed MRET_3        (use dinx) 0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * ee ILL_4      fe ILLe       0000110000001110100111100x00100110        Store 2 to mcause                                 40007033 sloppy and     
 * ef EBREAK_2   88 unx88      0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * f0 (null)     c1 IJT_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     8a unx8a      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     15 condb_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     14 condb_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     36 SLLI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     ef WFI_5      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       29 XOR_1      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 MRET_4        (use dinx) 0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00007067 close to jalr
 * fa CSRRW_3    a9 ILL_4      0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * fb aF_SW_3    49 CSRRW_1    0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * fc CSRRCI_0   ad unxad      0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      cd unxcd      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       aa unxaa      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     91 LDAF_2     0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 
 *  40  52  34 426 Can not simplify, can't represent fixed locations and pairs with any less than 5 bits of the index
 *  39 103 209 200 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  38  52   6 454 
 * Candidate function 0042, used ffff, inputs 0f
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       09 LB_5       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 (null)     68 unx68      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 02 IJ_0       5e LHU_1      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     6e unx6e      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     6e unx6e      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 LW_1       1a ANDI_1     0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 07 LDAF_LW    1d ORI_2      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 08 _L0x08     8e _LCSRRS_1  0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_1       a5 MRET_3     0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 0a _L0x0a     8e _LCSRRS_1  0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_3       52 LH_1       0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     6e unx6e      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      29 XOR_1      0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     6e unx6e      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 Fetch      a5 MRET_3     0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 11 eFetch     39 unx39      0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 12 condb_5       (use dinx) 0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 13 condb_5t   30 SLTIX_2    0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 14 JAL_1      37 ECALL_2    0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 15 JAERR_1    12 unx12      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 16 BrOpFet    10 SUB_1      0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 17 BAlignEr   16 condb_5    0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 18 BEQ        2e unx2e      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     7d BAERR_4    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_4       6e unx6e      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 1b _L0x1b     14 condb_3    0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   58 unx58      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d LB_5       6e unx6e      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1e eILL0b     d2 LB_2       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 1f MRET_8     c3 unxc3      0010000000000000101011101100100110        Prep +4                                           00000000 
 * 20 LH_0       32 JAL_1      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 22 JALR_2        (use dinx) 0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        0000100b close to ij
 * 23 _L0x23     6e unx6e      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     60 unx60      0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LW_1       4b CSRRW_2    0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LW    3a SRxI_1     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     54 LH_2       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 SUB_1      47 ILL_2      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 2a _L0x2a     54 LH_2       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b AND_1      57 LH_5       0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 2c SLL_0      77 BAERR_3    0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     6e unx6e      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_2       (use dinx) 0010000000000000111111101100000xx0        ~RS2 in Q                                         40001033 sloppy sll     
 * 2f _L0x2f     6e unx6e      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 condb_3    6e unx6e      0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 31 (null)     50 LW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 32 LH_1       52 LH_1       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 33 LDAF_LH    a2 unxa2      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 34 LH_2       10 SUB_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 35 aFaultb    65 WFI_4      0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 condb_4    6b SB_4       0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 38 BNE        2e unx2e      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00001067 close to jalr
 * 3a ORI_2      70 LHU_2      0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3b _L0x3b     14 condb_3    0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    89 unx89      0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d aFault_1   03 _L0x03     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 3e LHU_1      60 unx60      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LHU   6d unx6d      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       26 OR_1       0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 (null)     22 unx22      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 42 SW_1          (use dinx) 0000000000000011111011100100001xx0        Write d to a+k until accepted                     0000200b close to ij
 * 43 SW_E1SWE      (use dinx) 0000000000001111001011100x00110000        Store faulting address alignment to mtval         0000200f close to fence
 * 44 SLTI_0     50 LW_1       0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 IJ_2       92 LDAF_3     0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 46 (null)     88 unx88      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 47 XORI_1     a8 unxa8      0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 48 _L0x48     42 unx42      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 OR_1       8a unx8a      0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 4a _L0x4a     42 unx42      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b OR_2       bd IJ_4       0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 4c SLT_0      5a SB_1       0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d XOR_1         (use dinx) 0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 4e LHU_2      fe ILLe       0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40002033 sloppy slt     
 * 4f aFaultc    6e unx6e      0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 50 SLTIX_1    6e unx6e      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 51 (null)     d3 aFaultd    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 52 JAL_2      34 JAL_3      0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 53 JALRE1     d3 aFaultd    0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 54 SH_1       db jFault_1   0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 55 SW_E1SWH   3d SRxI_2     0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 56 (null)     8d unx8d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 SLTIX_2    a5 MRET_3     0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 58 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00002063 close to branch
 * 59 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00002067 close to jalr
 * 5a SLTX_1     8f ILL_3      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 5b _L0x5b     14 condb_3    0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    89 unx89      0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d JAL_3      de Fetch      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 5e IJ_1       4e eILL0b     0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 5f IJT_1      d3 aFaultd    0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 60 SLLI_1        (use dinx) 0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00003003 close to load
 * 61 (null)     83 unx83      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 62 ECALL_1       (use dinx) 0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 0000300b close to ij
 * 63 MRET_1        (use dinx) 0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    0000300f close to fence
 * 64 SLTIU_0    50 LW_1       0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLLI_2     73 BAERR_1    0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 66 (null)     78 unx78      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 67 ECALL_2    ad unxad      0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 68 LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd       (use dinx) 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    9c unx9c      0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     5a SB_1       0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SRxI_1        (use dinx) 0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 6e StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    40003033 sloppy sltu    
 * 6f aFault     d0 ECALL_1    0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 70 SRxI_2     ffffffff (null)     0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 71 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 72 eILL0a     39 unx39      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 73 WFI_5      9a ECALL_6    0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 74 LBU_2      7e NMI_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 75 aFaulte    97 SW_E1SWH   0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 76 (null)     9b unx9b      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 SLL_1      9d unx9d      0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 78 SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   00003063 close to branch
 * 79 aF_SW         (use dinx) 0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00003067 close to jalr
 * 7a SRx_1      78 unx78      0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 7b _L0x7b     14 condb_3    0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    89 unx89      0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d JALR_1     5d SB_2       0010000000000000000011101100100110        Q=1                                               00000000 
 * 7e Fetch2     a9 ILL_4      000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 7f jFault     9d unx9d      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 80 LBU_0      a3 unxa3      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 (null)     9d unx9d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 82 WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   0000400b close to ij
 * 83 EBREAK_1      (use dinx) 0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       0000400f close to fence
 * 84 XORI_0     47 ILL_2      0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 WFI_3      74 BrOpFet    0010000000000000101011101100100110        More check offset                                 00000000 
 * 86 (null)     5d SB_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 87 ILL_1      9f SH_5       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 88 ILL_2         (use dinx) 0000000000001111101011101000001xx0        Store 0 to mtval                                  00004023 close to store
 * 89 CSRRW_1       (use dinx) 0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 8a CSRRW_2       (use dinx) 0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    40004023 close to store
 * 8b LH_4       6e unx6e      0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 8c XOR_0      4d unx4d      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d LH_5          (use dinx) 0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 8e SB_1       fe ILLe       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        40004033 sloppy xor     
 * 8f SB_2       b9 unxb9      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 90 EBRKWFI2   5d SB_2       0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 91 (null)     ab EBREAK_2   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 92 WFI_4      5d SB_2       0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 93 SB_4       b0 CSRRW_3    1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 94 MRET_6     5d SB_2       0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 95 LBU_3      af MRET_4     0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 96 (null)     c5 MRET_5     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 BAERR_1    ad unxad      0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 98 BLT        2e unx2e      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a BAERR_2    5d SB_2       0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 9b BAERR_3       (use dinx) 0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * 9c SB_5          (use dinx) 0000000000000010110011100100001xx0        Write d to a+k until accepted                     00004073 close to csr/system 
 * 9d BAERR_4       (use dinx) 0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 9e NMI_1      b4 i0reserv   0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 9f JALRE2     78 unx78      0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * a0 LHU_0      3e SLL_1      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 (null)     c2 unxc2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a2 JAERR_2       (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  0000500b close to ij
 * a3 LBU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000500f close to fence
 * a4 SRxI_0     6d unx6d      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 LB_6       bb SH_2       0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * a6 (null)     62 unx62      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a7 _LCSRRS_1  90 NMI_2      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * a8 ILL_3         (use dinx) 0010000000000000101011101100100110        Q = 1                                             00005023 close to store
 * a9 NMI_2      5d SB_2       0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * aa LDAF_2        (use dinx) 0000110000001110001011000x00100110        Store 4 to mcause                                 40005023 close to store
 * ab LDAF_3     b2 CSRRW_4    0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * ac _L0xac     7a SB_5       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad SW_E2         (use dinx) 0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * ae _L0xae     7a SB_5       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SW_E4      c9 MRET_2     0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * b0 SW_E3      bf IJT_1      0010000000000000101111001100100110        Q = 3                                             00000000 
 * b1 (null)     ab EBREAK_2   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b2 ECALL_6    10 SUB_1      0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * b3 SH_4          (use dinx) 1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b4 SH_5          (use dinx) 0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b5 ECALL_4    b3 unxb3      0010000000000000101011001100100110        Q = 4                                             00000000 
 * b6 (null)     b2 CSRRW_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 MRET_3     c7 QINT_1     0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * b8 BGE        2e unx2e      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 ILL_4         (use dinx) 0000110000001110100111100x00100110        Store 2 to mcause                                 00005067 close to jalr
 * ba EBREAK_2   39 unx39      0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * bb MRET_4     c0 unxc0      0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * bc CSRRWI_0   89 unx89      0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd CSRRW_3    10 SUB_1      0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * be aF_SW_3    45 WFI_3      0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * bf CSRRW_4    c8 unxc8      0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * c0 SH_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   00006003 close to load
 * c1 (null)     da LDAF_a     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 ECALL_5       (use dinx) 0010000000000000101011001100100110        Q = 8                                             0000600b close to ij
 * c3 IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   0000600f close to fence
 * c4 ORI_0      d7 ECALL_3    0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 SH_2       94 SW_E4      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * c6 (null)     88 unx88      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c7 IJ_4       ce _LCSRRCI_1 0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * c8 IJT_2         (use dinx) 0000000000001100101011101000110000        Read word is to be masked with ~3u                00006023 close to store
 * c9 MRET_5     b7 IJ_3       0010000000000000000011101100010xx0        ~302                                              00000000 
 * ca IJT_4         (use dinx) 0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    40006023 close to store
 * cb QINT_1     6e unx6e      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * cc OR_0       49 CSRRW_1    0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd MRET_2        (use dinx) 0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * ce QINT_2     fe ILLe       0000110000001111010011101000110000        mtval = 0.                                        40006033 sloppy or      
 * cf _LCSRRCI_1 1f IJ_2       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d0 MRET_7     67 SW_E1SWE   0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * d1 (null)     cd unxcd      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 aFault_2   0b JALR_2     0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * d3 LDAF_a     3d SRxI_2     0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * d4 jFault_1   ab EBREAK_2   0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * d5 aF_SW_1       (use dinx) 0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 ORI_1      b5 SH_3       0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * d8 BLTU       2e unx2e      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 aF_SW_2       (use dinx) 0010000000000000101011001100100110        Q = 4                                             00006067 close to jalr
 * da IJT_3      aa unxaa      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * db LH_3       ab EBREAK_2   0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * dc CSRRSI_0   89 unx89      0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd WFI_2      d9 unxd9      0010000000000000101011101100100110        Check offset                                      00000000 
 * de SB_3       7e NMI_1      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * df i0reserv   7e NMI_1      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * e0 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007003 close to load
 * e1 (null)     3a SRxI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     39 unx39      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     be IJ_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 (null)     10 SUB_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e7 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     ca unxca      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     8b LB_6       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      2b SLTIX_1    0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007033 sloppy and     
 * ef (null)     10 SUB_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     95 SW_E3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     d5 unxd5      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     d4 aFault_2   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     dd aF_SW_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     ba LHU_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       2e unx2e      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     85 LBU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     93 SW_E2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   89 unx89      0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      9e SH_4       0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       87 JALRE1     0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     cb QINT_2     0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0402, used ffff, inputs 17
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       0b JALR_2     0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 (null)     50 LW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 02 IJ_0       46 ILL_1      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     56 LH_4       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     56 LH_4       0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    22 unx22      0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   2b SLTIX_1    0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     8d unx8d      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 (null)     a3 unxa3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 0a _L0x0a     8d unx8d      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_1       36 SLLI_2     0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      39 unx39      0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      a3 unxa3      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    53 LDAF_LH    0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 LW_1          (use dinx) 0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 13 LDAF_LW    4b CSRRW_2    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 14 eILL0b     4d unx4d      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 15 MRET_8     06 LB_3       0010000000000000101011101100100110        Prep +4                                           00000000 
 * 16 LH_1       60 unx60      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    32 JAL_1      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        45 WFI_3      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     82 unx82      0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a (null)     56 LH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   42 unx42      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d LB_3       56 LH_4       0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 1e LH_2       d0 ECALL_1    0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    c2 unxc2      0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 (null)     56 LH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 22 LB_4          (use dinx) 0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       0000100b close to ij
 * 23 _L0x23     56 LH_4       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     76 BAERR_2    0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LHU_1      6f MRET_6     0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LHU   5d SB_2       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     3e SLL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 (null)     6d unx6d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 2a _L0x2a     3e SLL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b LB_5       73 BAERR_1    0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 2c SLL_0      7e NMI_1      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e JALR_2        (use dinx) 0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        40001033 sloppy sll     
 * 2f _L0x2f     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SW_1       56 LH_4       0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 31 SW_E1SWE   71 aFaultc    0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 32 BrOpFet    36 SLLI_2     0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 33 BAlignEr   9f SH_5       0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 34 LHU_2      60 unx60      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 35 aFaultc    77 BAERR_3    0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 36 JAL_2      03 _L0x03     0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 37 JALRE1     55 aFaultb    0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 38 BNE        45 WFI_3      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 SUB_1         (use dinx) 0010000000000000111111101100000xx0        Q = ~RS2                                          00001067 close to jalr
 * 3a (null)     7d BAERR_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    87 JALRE1     0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d AND_1      03 _L0x03     0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 3e SH_1       76 BAERR_2    0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 3f SW_E1SWH   79 unx79      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 40 LW_0       12 unx12      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 (null)     2e unx2e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 42 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000200b close to ij
 * 43 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000200f close to fence
 * 44 SLTI_0     71 aFaultc    0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 condb_2    90 NMI_2      0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 46 IJ_1       86 JAL_2      0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 47 IJT_1      a6 ECAL_RET   0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 48 _L0x48     30 SLTIX_2    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 (null)     88 unx88      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 4a _L0x4a     30 SLTIX_2    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b condb_3    bb SH_2       0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 4c SLT_0      74 BrOpFet    0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d condb_4       (use dinx) 0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 4e ECALL_1    fe ILLe       0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40002033 sloppy slt     
 * 4f MRET_1     56 LH_4       0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 50 LB_2       56 LH_4       0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 51 aFaultd    d1 MRET_1     0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 52 (null)     1e aFault_1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 ANDI_1     d1 MRET_1     0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 54 eILL0c     d9 unxd9      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 55 ECALL_3    65 WFI_4      0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 56 StdIncPc   8b LB_6       0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * 57 aFault     a3 unxa3      0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 58 eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00002063 close to branch
 * 59 WFI_5         (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch                                    00002067 close to jalr
 * 5a (null)     8e _LCSRRS_1  00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    87 JALRE1     0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d ORI_2      dd aF_SW_1    0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 5e LBU_2      34 JAL_3      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaulte    d1 MRET_1     0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 60 Fetch         (use dinx) 0000000000001000001111101010110000  Fr00  Read and latch instruction                        00003003 close to load
 * 61 eFetch     6b SB_4       0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 62 SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   0000300b close to ij
 * 63 aF_SW         (use dinx) 0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     0000300f close to fence
 * 64 SLTIU_0    71 aFaultc    0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 aFault_1   59 unx59      0010000000000000101011001100100110        Q = 4                                             00000000 
 * 66 Fetch2     62 unx62      000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 67 jFault     ab EBREAK_2   0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 68 IJ_2          (use dinx) 0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00003023 close to store
 * 69 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 6a WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   40003023 close to store
 * 6b EBREAK_1   9b unx9b      0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 6c SLTU_0     74 BrOpFet    0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d XORI_1        (use dinx) 0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 6e OR_1          (use dinx) 0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              40003033 sloppy sltu    
 * 6f OR_2       cf MRET_7     0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 70 XOR_1      ffffffff (null)     0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 71 SLTIX_1    65 WFI_4      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 72 (null)     53 LDAF_LH    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 SLTIX_2    96 SH_1       0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 74 SLTX_1     66 SW_1       0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 75 JAL_3      95 SW_E3      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 76 SLLI_1     97 SW_E1SWH   0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 77 SLLI_2     9c unx9c      0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 78 ECALL_2       (use dinx) 0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00003063 close to branch
 * 79 SRxI_1        (use dinx) 0000000000000100101001101100001xx1        Register to shift to Q                            00003067 close to jalr
 * 7a (null)     62 unx62      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    87 JALRE1     0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SRxI_2     75 BAlignEr   0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 7e SLL_1      a7 EBRKWFI1   0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 7f SRx_1      9c unx9c      0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 80 LBU_0      a2 unxa2      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 (null)     9c unx9c      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 82 JALR_1        (use dinx) 0010000000000000000011101100100110        Q=1                                               0000400b close to ij
 * 83 WFI_3         (use dinx) 0010000000000000101011101100100110        More check offset                                 0000400f close to fence
 * 84 XORI_0     6d unx6d      0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 ILL_1      5e LHU_1      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 86 ILL_2      75 BAlignEr   0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 87 CSRRW_1    9e SH_4       0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 88 CSRRW_2       (use dinx) 0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00004023 close to store
 * 89 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 8a LH_4          (use dinx) 0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      40004023 close to store
 * 8b LH_5       56 LH_4       0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 8c XOR_0      70 LHU_2      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d SB_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 8e SB_2       fe ILLe       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   40004033 sloppy xor     
 * 8f EBRKWFI2   b6 ECALL_5    0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 90 WFI_4      75 BAlignEr   0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 91 SB_4       aa unxaa      1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 92 (null)     75 BAlignEr   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 MRET_6     af MRET_4     0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 94 LBU_3      75 BAlignEr   0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 95 BAERR_1    ad unxad      0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 96 BAERR_2    c3 unxc3      0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 97 BAERR_3    ab EBREAK_2   0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * 98 BLT        45 WFI_3      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a (null)     75 BAlignEr   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 9b SB_5          (use dinx) 0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 9c BAERR_4       (use dinx) 0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00004073 close to csr/system 
 * 9d NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 9e JALRE2     b3 unxb3      0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * 9f JAERR_2    62 unx62      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * a0 LHU_0      26 OR_1       0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 (null)     c0 unxc0      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a2 LBU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000500b close to ij
 * a3 LB_6          (use dinx) 0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          0000500f close to fence
 * a4 SRxI_0     79 unx79      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 _LCSRRS_1  b9 unxb9      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * a6 ILL_3      4e eILL0b     0010000000000000101011101100100110        Q = 1                                             00000000 
 * a7 NMI_2      8f ILL_3      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * a8 LDAF_2        (use dinx) 0000110000001110001011000x00100110        Store 4 to mcause                                 00005023 close to store
 * a9 (null)     75 BAlignEr   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * aa LDAF_3        (use dinx) 0000000000001101100111100x00001xx0        PC to mepc                                        40005023 close to store
 * ab SW_E2      b0 CSRRW_3    0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * ac _L0xac     7f JALRE2     0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad SW_E4         (use dinx) 0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * ae _L0xae     7f JALRE2     0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SW_E3      c7 QINT_1     0010000000000000101111001100100110        Q = 3                                             00000000 
 * b0 ECALL_6    be IJ_1       0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * b1 SH_4       aa unxaa      1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b2 (null)     60 unx60      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 SH_5          (use dinx) 0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b4 ECALL_4       (use dinx) 0010000000000000101011001100100110        Q = 4                                             00000000 
 * b5 MRET_3     b1 aF_SW_3    0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * b6 ILL_4      b0 CSRRW_3    0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * b7 EBREAK_2   c5 MRET_5     0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * b8 BGE        45 WFI_3      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MRET_4        (use dinx) 0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00005067 close to jalr
 * ba (null)     53 LDAF_LH    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * bb CSRRW_3    bf IJT_1      0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * bc CSRRWI_0   87 JALRE1     0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd aF_SW_3    60 unx60      0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * be CSRRW_4    68 unx68      0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * bf SH_3       c6 IJT_4      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * c0 ECALL_5       (use dinx) 0010000000000000101011001100100110        Q = 8                                             00006003 close to load
 * c1 (null)     d7 ECALL_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   0000600b close to ij
 * c3 SH_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      0000600f close to fence
 * c4 ORI_0      d5 unxd5      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 IJ_4       93 SW_E2      0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * c6 IJT_2      86 JAL_2      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c7 MRET_5     cd unxcd      0010000000000000000011101100010xx0        ~302                                              00000000 
 * c8 IJT_4         (use dinx) 0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00006023 close to store
 * c9 (null)     b5 SH_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ca QINT_1        (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40006023 close to store
 * cb MRET_2     56 LH_4       0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * cc OR_0       6e unx6e      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd QINT_2        (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * ce _LCSRRCI_1 fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006033 sloppy or      
 * cf MRET_7     15 condb_4    0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * d0 aFault_2   78 unx78      0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * d1 LDAF_a     cb QINT_2     0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * d2 (null)     1d ORI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 jFault_1   65 WFI_4      0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * d4 aF_SW_1    aa unxaa      0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * d5 ORI_1         (use dinx) 0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * d6 aF_SW_2    fe ILLe       0010000000000000101011001100100110        Q = 4                                             00000000 
 * d7 IJT_3      b4 i0reserv   0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * d8 BLTU       45 WFI_3      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 LH_3          (use dinx) 0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00006067 close to jalr
 * da (null)     a8 unxa8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * db WFI_2      aa unxaa      0010000000000000101011101100100110        Check offset                                      00000000 
 * dc CSRRSI_0   87 JALRE1     0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd SB_3       d6 eILL0c     0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * de i0reserv   66 SW_1       xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * df (null)     66 SW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e0 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007003 close to load
 * e1 (null)     5d SB_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     53 LDAF_LH    0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     bd IJ_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 (null)     60 unx60      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e7 (null)     65 WFI_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     c8 unxc8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     8a unx8a      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      3d SRxI_2     0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007033 sloppy and     
 * ef (null)     60 unx60      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     94 SW_E4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     65 WFI_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     56 LH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     d4 aFault_2   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     d3 aFaultd    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     db jFault_1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     b7 IJ_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       45 WFI_3      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     83 unx83      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     91 LDAF_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   87 JALRE1     0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      9d unx9d      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       85 LBU_1      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     ca unxca      0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0900, used ffff, inputs 1b
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       6a unx6a      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       66 SW_1       0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     78 unx78      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     78 unx78      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     8d unx8d      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       a5 MRET_3     0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     8d unx8d      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       5e LHU_1      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      21 XORI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 LW_1       a5 MRET_3     0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 11 LDAF_LW    32 JAL_1      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 12 Fetch         (use dinx) 0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 13 eFetch     2b SLTIX_1    0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 14 BrOpFet    2e unx2e      0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 15 BAlignEr   06 LB_3       0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 16 Fetch      16 condb_5    0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 17 eFetch     14 condb_3    0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 18 BEQ        29 XOR_1      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     71 aFaultc    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       78 unx78      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   62 unx62      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     78 unx78      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e JAL_1      d1 MRET_1     0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 1f JAERR_1    c3 unxc3      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 20 LH_0       3e SLL_1      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      78 unx78      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1         (use dinx) 0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     78 unx78      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     52 LH_1       0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 eILL0b     41 JALR_1     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     35 SLLI_1     0010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     60 unx60      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_2    3a SRxI_1     0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2a _L0x2a     60 unx60      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_3    4b CSRRW_2    0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2c SLL_0      65 WFI_4      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_4       (use dinx) 0010000000000000110011101101001xx0        Branch on condition                               40001033 sloppy sll     
 * 2f _L0x2f     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LW_1       78 unx78      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LW    49 CSRRW_1    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 ANDI_1     5e LHU_1      0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 33 (null)     a2 unxa2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 34 (null)     16 condb_5    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 35 ORI_2      55 aFaultb    0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 36 aFault_1   03 _L0x03     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 37 (null)     6f MRET_6     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 38 BNE        29 XOR_1      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 IJ_2          (use dinx) 0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00001067 close to jalr
 * 3a XORI_1     5d SB_2       0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 3b _L0x3b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    7a SB_5       0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d OR_1       03 _L0x03     0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 3e LH_1       52 LH_1       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LH    5a SB_1       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       30 SLTIX_2    0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 OR_2       1d ORI_2      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 42 LH_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     0000200b close to ij
 * 43 aFaultb       (use dinx) 0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       0000200f close to fence
 * 44 SLTI_0     49 CSRRW_1    0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 XOR_1      91 LDAF_2     0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 46 LHU_1      76 BAERR_2    0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 47 LDAF_LHU   a7 EBRKWFI1   0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 48 _L0x48     4e eILL0b     1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 SLTIX_1    7d BAERR_4    0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 4a _L0x4a     4e eILL0b     1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b SLTIX_2    be IJ_1       0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 4c SLT_0      4d unx4d      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d SLTX_1        (use dinx) 0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 4e SW_1       fe ILLe       0000000000000011111011100100001xx0        Write d to a+k until accepted                     40002033 sloppy slt     
 * 4f SW_E1SWE   78 unx78      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 50 (null)     78 unx78      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 51 JAL_3      d2 LB_2       0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 52 SLLI_1     42 unx42      0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 53 (null)     d2 LB_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 54 (null)     dd aF_SW_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 55 SLLI_2     36 SLLI_2     0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 56 ECALL_2    85 LBU_1      0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 57 (null)     a5 MRET_3     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 58 LHU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00002063 close to branch
 * 59 aFaultc       (use dinx) 0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00002067 close to jalr
 * 5a SRxI_1     8e _LCSRRS_1  0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 5b _L0x5b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    7a SB_5       0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SRxI_2     df eFetch     0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 5e JAL_2      58 unx58      0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 5f JALRE1     d2 LB_2       0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 60 SH_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00003003 close to load
 * 61 SW_E1SWH   8b LB_6       0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000300b close to ij
 * 63 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000300f close to fence
 * 64 SLTIU_0    49 CSRRW_1    0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLL_1      7f JALRE2     0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 66 IJ_1       86 JAL_2      0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 67 IJT_1      ab EBREAK_2   0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 68 ECALL_1       (use dinx) 0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00003023 close to store
 * 69 MRET_1        (use dinx) 0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 6a LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     40003023 close to store
 * 6b aFaultd    9d unx9d      0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6c SLTU_0     4d unx4d      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SRx_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 6e eILL0c        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003033 sloppy sltu    
 * 6f ECALL_3    cf MRET_7     0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 70 (null)     ffffffff (null)     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 71 JALR_1     36 SLLI_2     0010000000000000000011101100100110        Q=1                                               00000000 
 * 72 WFI_3      32 JAL_1      0010000000000000101011101100100110        More check offset                                 00000000 
 * 73 (null)     9b unx9b      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 74 (null)     88 unx88      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 75 ILL_1      9a ECALL_6    0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 76 ILL_2      9c unx9c      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 77 (null)     9e SH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 78 StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00003063 close to branch
 * 79 aFault        (use dinx) 0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00003067 close to jalr
 * 7a CSRRW_1    86 JAL_2      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 7b _L0x7b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    7a SB_5       0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d CSRRW_2    51 LDAF_LW    0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 7e eILL0a     a8 unxa8      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 7f WFI_5      9e SH_4       0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 80 LBU_0      a3 unxa3      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 LH_4       9e SH_4       0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 82 LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     0000400b close to ij
 * 83 aFaulte       (use dinx) 0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      0000400f close to fence
 * 84 XORI_0     3a SRxI_1     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 LH_5       82 unx82      0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 86 SW_2       51 LDAF_LW    0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 87 aF_SW      a1 ECALL_4    0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 88 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00004023 close to store
 * 89 jFault        (use dinx) 0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 8a WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   40004023 close to store
 * 8b EBREAK_1   78 unx78      0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 8c XOR_0      45 WFI_3      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d SB_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 8e SB_2       fe ILLe       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   40004033 sloppy xor     
 * 8f EBRKWFI2   ba LHU_3      0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 90 (null)     51 LDAF_LW    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 91 WFI_4      aa unxaa      0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 92 SB_4       51 LDAF_LW    1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 93 (null)     af MRET_4     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 94 (null)     51 LDAF_LW    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 95 MRET_6     ad unxad      0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 96 LBU_3      c5 MRET_5     0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 97 (null)     ab EBREAK_2   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 98 BLT        29 XOR_1      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a BAERR_1    51 LDAF_LW    0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 9b BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 9c BAERR_3       (use dinx) 0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00004073 close to csr/system 
 * 9d SB_5          (use dinx) 0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 9e BAERR_4    b5 SH_3       0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 9f NMI_1      86 JAL_2      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * a0 LHU_0      46 ILL_1      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JALRE2     c2 unxc2      0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * a2 JAERR_2       (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  0000500b close to ij
 * a3 LBU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000500f close to fence
 * a4 SRxI_0     5a SB_1       0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 LB_6       bd IJ_4       0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * a6 _LCSRRS_1  68 unx68      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * a7 ILL_3      8f ILL_3      0010000000000000101011101100100110        Q = 1                                             00000000 
 * a8 NMI_2         (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        00005023 close to store
 * a9 LDAF_2     51 LDAF_LW    0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * aa LDAF_3        (use dinx) 0000000000001101100111100x00001xx0        PC to mepc                                        40005023 close to store
 * ab SW_E2      b1 aF_SW_3    0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * ac _L0xac     6d unx6d      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad SW_E4         (use dinx) 0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * ae _L0xae     6d unx6d      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SW_E3      c8 unxc8      0010000000000000101111001100100110        Q = 3                                             00000000 
 * b0 (null)     c0 unxc0      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b1 ECALL_6    aa unxaa      0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * b2 SH_4       16 condb_5    1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b5 SH_5       b2 CSRRW_4    0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b6 ECALL_4    b1 aF_SW_3    0010000000000000101011001100100110        Q = 4                                             00000000 
 * b7 (null)     c6 IJT_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b8 BGE        29 XOR_1      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MRET_3        (use dinx) 0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00005067 close to jalr
 * ba ILL_4      32 JAL_1      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * bb EBREAK_2   c1 IJT_2      0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * bc CSRRWI_0   7a SB_5       0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd MRET_4     16 condb_5    0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * be CSRRW_3    39 unx39      0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * bf aF_SW_3    c7 QINT_1     0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * c0 CSRRW_4       (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00006003 close to load
 * c1 SH_3       db jFault_1   0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * c2 ECALL_5       (use dinx) 0010000000000000101011001100100110        Q = 8                                             0000600b close to ij
 * c3 IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   0000600f close to fence
 * c4 ORI_0      d9 unxd9      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 SH_2       95 SW_E3      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * c6 IJ_4       76 BAERR_2    0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * c7 IJT_2      cd unxcd      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c8 MRET_5        (use dinx) 0010000000000000000011101100010xx0        ~302                                              00006023 close to store
 * c9 IJT_4      b9 unxb9      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * ca QINT_1        (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40006023 close to store
 * cb MRET_2     78 unx78      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * cc OR_0       3d SRxI_2     0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd QINT_2        (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * ce _LCSRRCI_1 fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006033 sloppy or      
 * cf MRET_7     27 OR_2       0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * d0 (null)     56 LH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 aFault_2   cb QINT_2     0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * d2 LDAF_a     09 LB_5       0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * d3 (null)     36 SLLI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d4 (null)     aa unxaa      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 jFault_1      (use dinx) 0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * d6 aF_SW_1    fe ILLe       0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * d7 (null)     b6 ECALL_5    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       29 XOR_1      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 ORI_1         (use dinx) 0010000000000000000011101100001xx0        Q = RS1                                           00006067 close to jalr
 * da aF_SW_2    a9 ILL_4      0010000000000000101011001100100110        Q = 4                                             00000000 
 * db IJT_3      aa unxaa      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * dc CSRRSI_0   7a SB_5       0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd LH_3       da LDAF_a     0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * de WFI_2      88 unx88      0010000000000000101011101100100110        Check offset                                      00000000 
 * df SB_3       88 unx88      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e0 i0reserv      (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00007003 close to load
 * e1 (null)     35 SLLI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     32 JAL_1      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     bf IJT_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 (null)     16 condb_5    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e7 (null)     36 SLLI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     c9 MRET_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     81 JAERR_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      22 unx22      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007033 sloppy and     
 * ef (null)     16 condb_5    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     96 SH_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     36 SLLI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     78 unx78      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     d6 eILL0c     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     d5 unxd5      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     de Fetch      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     bb SH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       29 XOR_1      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     72 LBU_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     92 LDAF_3     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   7a SB_5       0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      9f SH_5       0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       75 BAlignEr   0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     ca unxca      0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0120, used f7ff, inputs 1d
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       78 unx78      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       66 SW_1       0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     82 unx82      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     82 unx82      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    1d ORI_2      0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   21 XORI_1     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     a8 unxa8      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 (null)     c5 MRET_5     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 0a _L0x0a     a8 unxa8      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b (null)     5e LHU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     82 unx82      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      2e unx2e      0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     82 unx82      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 LW_1       c5 MRET_5     0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 11 LDAF_LW    41 JALR_1     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 12 BrOpFet       (use dinx) 0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 13 BAlignEr   3a SRxI_1     0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 14 aFault_2   3d SRxI_2     0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 15 (null)     06 LB_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 16 LDAF_a     68 unx68      0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * 17 (null)     12 unx12      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 18 BEQ        39 unx39      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     91 LDAF_2     0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_3       82 unx82      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 1b _L0x1b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   62 unx62      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d LB_4       82 unx82      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 1e JAL_1      14 condb_3    0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 1f JAERR_1    e7 aFault     0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 20 LH_0       3e SLL_1      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 LB_5       82 unx82      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 22 JALR_2        (use dinx) 0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        0000100b close to ij
 * 23 _L0x23     82 unx82      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     7a SB_5       0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 eILL0b     5d SB_2       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     45 WFI_3      0010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     60 unx60      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 (null)     53 LDAF_LH    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 2a _L0x2a     60 unx60      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b (null)     6d unx6d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 2c SLL_0      8a unx8a      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     82 unx82      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e SUB_1         (use dinx) 0010000000000000111111101100000xx0        Q = ~RS2                                          40001033 sloppy sll     
 * 2f _L0x2f     82 unx82      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LW_1       82 unx82      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LW    6a unx6a      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 (null)     5e LHU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 AND_1      c2 unxc2      0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 34 jFault_1   68 unx68      0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 35 (null)     7d BAERR_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 36 aF_SW_1    03 _L0x03     0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 37 (null)     7f JALRE2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 38 BNE        39 unx39      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_2       (use dinx) 0010000000000000111111101100000xx0        ~RS2 in Q                                         00001067 close to jalr
 * 3a condb_3    88 unx88      0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 3b _L0x3b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    a3 unxa3      0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d condb_4    03 _L0x03     0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 3e LH_1       7a SB_5       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LH    85 LBU_1      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       30 SLTIX_2    0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 ANDI_1     22 unx22      0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 42 LH_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     0000200b close to ij
 * 43 aFaultb       (use dinx) 0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       0000200f close to fence
 * 44 SLTI_0     6a unx6a      0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 ORI_2      af MRET_4     0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 46 LHU_1      a2 unxa2      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 47 LDAF_LHU   c7 QINT_1     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 48 _L0x48     4e eILL0b     1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 (null)     a5 MRET_3     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 4a _L0x4a     4e eILL0b     1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b (null)     e1 ORI_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 4c SLT_0      71 aFaultc    0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d aFault_1      (use dinx) 0010000000000000101011001100100110        Q = 4                                             00000000 
 * 4e SW_1       fe ILLe       0000000000000011111011100100001xx0        Write d to a+k until accepted                     40002033 sloppy slt     
 * 4f SW_E1SWE   82 unx82      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 50 (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 51 IJ_2       16 condb_5    0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 52 (null)     42 unx42      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 XORI_1     16 condb_5    0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 54 ORI_1      76 BAERR_2    0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 55 (null)     4d unx4d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 56 aF_SW_2    a7 EBRKWFI1   0010000000000000101011001100100110        Q = 4                                             00000000 
 * 57 (null)     c5 MRET_5     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 58 LHU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00002063 close to branch
 * 59 aFaultc       (use dinx) 0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00002067 close to jalr
 * 5a OR_1       aa unxaa      0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    a3 unxa3      0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       96 SH_1       0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e JAL_2      58 unx58      0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 5f JALRE1     16 condb_5    0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 60 SH_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00003003 close to load
 * 61 SW_E1SWH   9f SH_5       0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000300b close to ij
 * 63 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000300f close to fence
 * 64 SLTIU_0    6a unx6a      0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      87 JALRE1     0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 IJ_1       9a ECALL_6    0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 67 IJT_1      ce _LCSRRCI_1 0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 68 Fetch         (use dinx) 0000000000001000001111101010110000  Fr00  Read and latch instruction                        00003023 close to store
 * 69 eFetch        (use dinx) 0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 6a SLTIX_1       (use dinx) 0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             40003023 close to store
 * 6b (null)     be IJ_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 6c SLTU_0     71 aFaultc    0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SLTIX_2       (use dinx) 0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 6e ECALL_1       (use dinx) 0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40003033 sloppy sltu    
 * 6f MRET_1     fb SB_3       0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 70 (null)     ffffffff (null)     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 71 SLTX_1     4d unx4d      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 72 (null)     41 JALR_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 JAL_3      bb SH_2       0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 74 IJT_3      9c unx9c      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 75 (null)     ba LHU_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 76 LH_3       bd IJ_4       0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 77 (null)     bf IJT_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 78 LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003063 close to branch
 * 79 aFaultd       (use dinx) 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00003067 close to jalr
 * 7a SLLI_1     9a ECALL_6    0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 7b _L0x7b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    a3 unxa3      0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SLLI_2     73 BAERR_1    0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 7e eILL0c     c8 unxc8      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 7f ECALL_3    bf IJT_1      0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 80 LBU_0      c3 unxc3      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 ECALL_2    bf IJT_1      0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 82 StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    0000400b close to ij
 * 83 aFault        (use dinx) 0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          0000400f close to fence
 * 84 XORI_0     53 LDAF_LH    0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SRxI_1     8e _LCSRRS_1  0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 86 eILL0a     73 BAERR_1    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 87 WFI_5      c1 IJT_2      0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 88 SRxI_2        (use dinx) 0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00004023 close to store
 * 89 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 8a SLL_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              40004023 close to store
 * 8b (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 8c XOR_0      65 WFI_4      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d SRx_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 8e LBU_2      fe ILLe       0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40004033 sloppy xor     
 * 8f aFaulte    de Fetch      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 90 (null)     73 BAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 91 JALR_1     cd unxcd      0010000000000000000011101100100110        Q=1                                               00000000 
 * 92 (null)     73 BAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 WFI_3      d1 MRET_1     0010000000000000101011101100100110        More check offset                                 00000000 
 * 94 WFI_2      73 BAERR_1    0010000000000000101011101100100110        Check offset                                      00000000 
 * 95 (null)     cf MRET_7     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 96 SB_3       e8 unxe8      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * 97 (null)     ce _LCSRRCI_1 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 98 BLT        39 unx39      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a SW_2       73 BAERR_1    0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 9b aF_SW         (use dinx) 0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 9c Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00004073 close to csr/system 
 * 9d jFault        (use dinx) 0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 9e WFI_1      da LDAF_a     0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 9f EBREAK_1   9a ECALL_6    0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * a0 LHU_0      46 ILL_1      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ILL_1      e6 StdIncPc   0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * a2 ILL_2         (use dinx) 0000000000001111101011101000001xx0        Store 0 to mtval                                  0000500b close to ij
 * a3 CSRRW_1       (use dinx) 0010000000000000000011101100100110        Construct PC storage adr                          0000500f close to fence
 * a4 SRxI_0     85 LBU_1      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 CSRRW_2    e0 unxe0      0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * a6 LH_4       6e unx6e      0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * a7 LH_5       ad unxad      0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * a8 SB_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00005023 close to store
 * a9 (null)     73 BAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * aa SB_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   40005023 close to store
 * ab (null)     d3 aFaultd    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ac _L0xac     8d unx8d      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad EBRKWFI2      (use dinx) 0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * ae _L0xae     8d unx8d      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af WFI_4      ee eILL0a     0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * b0 (null)     e3 unxe3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b1 SB_4       cd unxcd      1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b2 (null)     68 unx68      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 MRET_6        (use dinx) 0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * b4 i0reserv      (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * b5 (null)     d9 unxd9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b6 (null)     d3 aFaultd    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 (null)     ea unxea      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b8 BGE        39 unx39      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 LBU_3         (use dinx) 0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00005067 close to jalr
 * ba BAERR_1    41 JALR_1     0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * bb BAERR_2    e5 aF_SW_2    0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * bc CSRRWI_0   a3 unxa3      0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd BAERR_3    68 unx68      0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * be SB_5       51 LDAF_LW    0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * bf BAERR_4    ed unxed      0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * c0 NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00006003 close to load
 * c1 JALRE2     74 BrOpFet    0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * c2 JAERR_2       (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  0000600b close to ij
 * c3 LBU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000600f close to fence
 * c4 ORI_0      54 LH_2       0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 LB_6       b3 unxb3      0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * c6 _LCSRRS_1  a2 unxa2      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * c7 ILL_3      f9 unxf9      0010000000000000101011101100100110        Q = 1                                             00000000 
 * c8 NMI_2         (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        00006023 close to store
 * c9 (null)     dd aF_SW_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ca LDAF_2        (use dinx) 0000110000001110001011000x00100110        Store 4 to mcause                                 40006023 close to store
 * cb (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * cc OR_0       5a SB_1       0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd LDAF_3        (use dinx) 0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * ce SW_E2      fe ILLe       0000000000001101101111101000001xx0        Store address that faulted                        40006033 sloppy or      
 * cf SW_E4      27 OR_2       0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * d0 (null)     81 JAERR_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 SW_E3      f3 aF_SW      0010000000000000101111001100100110        Q = 3                                             00000000 
 * d2 (null)     1a ANDI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 ECALL_6    4d unx4d      0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * d4 (null)     cd unxcd      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     db jFault_1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       39 unx39      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 SH_4          (use dinx) 1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00006067 close to jalr
 * da SH_5       ca unxca      0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * db ECALL_4    cd unxcd      0010000000000000101011001100100110        Q = 4                                             00000000 
 * dc CSRRSI_0   a3 unxa3      0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd MRET_3     56 LH_4       0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * de ILL_4      9c unx9c      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * df EBREAK_2   9c unx9c      0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * e0 MRET_4        (use dinx) 0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00007003 close to load
 * e1 CSRRW_3    45 WFI_3      0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * e2 aF_SW_3       (use dinx) 0000110000001110001011000x00100000        Store 7 to mcause                                 0000700b close to ij
 * e3 CSRRW_4       (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      0000700f close to fence
 * e4 ANDI_0     41 JALR_1     0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SH_3       e2 unxe2      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e6 ECALL_5    68 unx68      0010000000000000101011001100100110        Q = 8                                             00000000 
 * e7 IJ_3       4d unx4d      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * e8 SH_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00007023 close to store
 * e9 (null)     ef WFI_5      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea IJ_4          (use dinx) 0100000010001010110111100100011xx0        Mask and use as PC                                40007023 close to store
 * eb (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      33 JAERR_1    0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed IJT_2         (use dinx) 0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * ee MRET_5     fe ILLe       0010000000000000000011101100010xx0        ~302                                              40007033 sloppy and     
 * ef IJT_4      68 unx68      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * f0 (null)     b9 unxb9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 QINT_1     4d unx4d      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * f2 (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 MRET_2     36 SLLI_2     0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     34 JAL_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     94 SW_E4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     df eFetch     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       39 unx39      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 QINT_2        (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        00007067 close to jalr
 * fa _LCSRRCI_1 93 SW_E2      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * fb MRET_7     b1 aF_SW_3    0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * fc CSRRCI_0   a3 unxa3      0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      c0 unxc0      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       a1 ECALL_4    0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     f1 aFaulte    0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 2010, used ffff, inputs 39
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       6a unx6a      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       66 SW_1       0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     78 unx78      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     78 unx78      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   17 condb_5t   0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     8d unx8d      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       a5 MRET_3     0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     8d unx8d      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       5e LHU_1      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      1d ORI_2      0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 LW_1       a5 MRET_3     0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 11 LDAF_LW    2e unx2e      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 12 BrOpFet       (use dinx) 0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 13 BAlignEr   29 XOR_1      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 14 LW_1       2b SLTIX_1    0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 (null)     32 JAL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 17 LB_5       12 unx12      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 18 BEQ        22 unx22      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     70 LHU_2      0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a JALR_2     78 unx78      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1b _L0x1b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   62 unx62      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d SUB_1      78 unx78      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 1e JAL_1      d1 MRET_1     0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 1f JAERR_1    c3 unxc3      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 20 LH_0       3e SLL_1      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 AND_1      78 unx78      0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 22 condb_2       (use dinx) 0010000000000000111111101100000xx0        ~RS2 in Q                                         0000100b close to ij
 * 23 _L0x23     78 unx78      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     53 LDAF_LH    0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 eILL0b     41 JALR_1     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     34 JAL_3      0010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     60 unx60      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_3    3a SRxI_1     0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2a _L0x2a     60 unx60      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_4    4b CSRRW_2    0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 2c SLL_0      65 WFI_4      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 Fetch      78 unx78      0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 31 eFetch     49 CSRRW_1    0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 32 Fetch      5e LHU_1      0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 33 eFetch     a2 unxa2      0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 34 ORI_2      32 JAL_1      0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 35 (null)     55 aFaultb    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 36 aFault_1   03 _L0x03     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 37 (null)     6f MRET_6     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 38 BNE        22 unx22      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 IJ_2          (use dinx) 0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00001067 close to jalr
 * 3a XORI_1     5d SB_2       0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 3b _L0x3b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    7a SB_5       0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d OR_1       03 _L0x03     0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 3e LH_1       53 LDAF_LH    0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LH    5a SB_1       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       14 condb_3    0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 OR_2       1a ANDI_1     0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 42 LH_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     0000200b close to ij
 * 43 aFaultb       (use dinx) 0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       0000200f close to fence
 * 44 SLTI_0     49 CSRRW_1    0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 XOR_1      91 LDAF_2     0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 46 LHU_1      76 BAERR_2    0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 47 LDAF_LHU   a7 EBRKWFI1   0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 48 _L0x48     4e eILL0b     1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 SLTIX_1    7d BAERR_4    0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 4a _L0x4a     4e eILL0b     1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b SLTIX_2    be IJ_1       0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 4c SLT_0      4d unx4d      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d SLTX_1        (use dinx) 0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 4e SW_1       fe ILLe       0000000000000011111011100100001xx0        Write d to a+k until accepted                     40002033 sloppy slt     
 * 4f SW_E1SWE   78 unx78      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 50 (null)     78 unx78      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 51 JAL_3      d3 aFaultd    0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 52 (null)     42 unx42      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 SLLI_1     d3 aFaultd    0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 54 (null)     dd aF_SW_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 55 SLLI_2     36 SLLI_2     0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 56 (null)     85 LBU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 ECALL_2    a5 MRET_3     0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 58 LHU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00002063 close to branch
 * 59 aFaultc       (use dinx) 0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00002067 close to jalr
 * 5a SRxI_1     8e _LCSRRS_1  0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 5b _L0x5b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    7a SB_5       0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SRxI_2     df eFetch     0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 5e JAL_2      58 unx58      0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 5f JALRE1     d3 aFaultd    0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 60 SH_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00003003 close to load
 * 61 SW_E1SWH   8b LB_6       0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000300b close to ij
 * 63 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000300f close to fence
 * 64 SLTIU_0    49 CSRRW_1    0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLL_1      7f JALRE2     0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 66 IJ_1       86 JAL_2      0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 67 IJT_1      ab EBREAK_2   0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 68 ECALL_1       (use dinx) 0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00003023 close to store
 * 69 MRET_1        (use dinx) 0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 6a LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     40003023 close to store
 * 6b aFaultd    9d unx9d      0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6c SLTU_0     4d unx4d      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SRx_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 6e eILL0c        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003033 sloppy sltu    
 * 6f ECALL_3    cf MRET_7     0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 70 JALR_1     ffffffff (null)     0010000000000000000011101100100110        Q=1                                               00000000 
 * 71 (null)     36 SLLI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 72 WFI_3      2e unx2e      0010000000000000101011101100100110        More check offset                                 00000000 
 * 73 (null)     9b unx9b      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 74 ILL_1      88 unx88      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 75 (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 76 ILL_2      9c unx9c      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 77 (null)     9e SH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 78 StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00003063 close to branch
 * 79 aFault        (use dinx) 0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00003067 close to jalr
 * 7a CSRRW_1    86 JAL_2      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 7b _L0x7b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    7a SB_5       0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d CSRRW_2    51 LDAF_LW    0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 7e eILL0a     a8 unxa8      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 7f WFI_5      9e SH_4       0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 80 LBU_0      a3 unxa3      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 LH_4       9e SH_4       0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 82 LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     0000400b close to ij
 * 83 aFaulte       (use dinx) 0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      0000400f close to fence
 * 84 XORI_0     3a SRxI_1     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 LH_5       82 unx82      0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 86 SW_2       51 LDAF_LW    0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 87 aF_SW      a1 ECALL_4    0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 88 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00004023 close to store
 * 89 jFault        (use dinx) 0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 8a WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   40004023 close to store
 * 8b EBREAK_1   78 unx78      0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 8c XOR_0      45 WFI_3      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d SB_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 8e SB_2       fe ILLe       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   40004033 sloppy xor     
 * 8f EBRKWFI2   ba LHU_3      0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 90 (null)     51 LDAF_LW    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 91 WFI_4      aa unxaa      0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 92 (null)     51 LDAF_LW    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 SB_4       af MRET_4     1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 94 (null)     51 LDAF_LW    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 95 MRET_6     ad unxad      0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 96 (null)     c5 MRET_5     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 LBU_3      ab EBREAK_2   0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 98 BLT        22 unx22      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a BAERR_1    51 LDAF_LW    0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 9b BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 9c BAERR_3       (use dinx) 0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00004073 close to csr/system 
 * 9d SB_5          (use dinx) 0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 9e BAERR_4    b4 i0reserv   0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 9f NMI_1      86 JAL_2      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * a0 LHU_0      46 ILL_1      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 JALRE2     c2 unxc2      0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * a2 JAERR_2       (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  0000500b close to ij
 * a3 LBU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000500f close to fence
 * a4 SRxI_0     5a SB_1       0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 LB_6       bd IJ_4       0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * a6 _LCSRRS_1  68 unx68      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * a7 ILL_3      8f ILL_3      0010000000000000101011101100100110        Q = 1                                             00000000 
 * a8 NMI_2         (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        00005023 close to store
 * a9 LDAF_2     51 LDAF_LW    0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * aa LDAF_3        (use dinx) 0000000000001101100111100x00001xx0        PC to mepc                                        40005023 close to store
 * ab SW_E2      b0 CSRRW_3    0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * ac _L0xac     6d unx6d      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad SW_E4         (use dinx) 0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * ae _L0xae     6d unx6d      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SW_E3      c8 unxc8      0010000000000000101111001100100110        Q = 3                                             00000000 
 * b0 ECALL_6    c0 unxc0      0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * b1 (null)     aa unxaa      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b2 SH_4       32 JAL_1      1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b4 SH_5          (use dinx) 0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b5 (null)     b2 CSRRW_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b6 ECALL_4    b0 CSRRW_3    0010000000000000101011001100100110        Q = 4                                             00000000 
 * b7 (null)     c6 IJT_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b8 BGE        22 unx22      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MRET_3        (use dinx) 0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00005067 close to jalr
 * ba ILL_4      2e unx2e      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * bb EBREAK_2   c1 IJT_2      0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * bc CSRRWI_0   7a SB_5       0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd MRET_4     32 JAL_1      0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * be CSRRW_3    39 unx39      0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * bf aF_SW_3    c7 QINT_1     0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * c0 CSRRW_4       (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00006003 close to load
 * c1 SH_3       db jFault_1   0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * c2 ECALL_5       (use dinx) 0010000000000000101011001100100110        Q = 8                                             0000600b close to ij
 * c3 IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   0000600f close to fence
 * c4 ORI_0      d9 unxd9      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 SH_2       95 SW_E3      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * c6 IJ_4       76 BAERR_2    0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * c7 IJT_2      cd unxcd      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c8 MRET_5        (use dinx) 0010000000000000000011101100010xx0        ~302                                              00006023 close to store
 * c9 IJT_4      b9 unxb9      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * ca QINT_1        (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40006023 close to store
 * cb MRET_2     78 unx78      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * cc OR_0       3d SRxI_2     0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd QINT_2        (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * ce _LCSRRCI_1 fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006033 sloppy or      
 * cf MRET_7     27 OR_2       0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * d0 (null)     57 LH_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 aFault_2   cb QINT_2     0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 LDAF_a     36 SLLI_2     0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * d4 (null)     aa unxaa      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 jFault_1      (use dinx) 0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 aF_SW_1    b6 ECALL_5    0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * d8 BLTU       22 unx22      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 ORI_1         (use dinx) 0010000000000000000011101100001xx0        Q = RS1                                           00006067 close to jalr
 * da aF_SW_2    a9 ILL_4      0010000000000000101011001100100110        Q = 4                                             00000000 
 * db IJT_3      aa unxaa      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * dc CSRRSI_0   7a SB_5       0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd LH_3       da LDAF_a     0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * de WFI_2      88 unx88      0010000000000000101011101100100110        Check offset                                      00000000 
 * df SB_3       88 unx88      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e0 i0reserv      (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00007003 close to load
 * e1 (null)     34 JAL_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     2e unx2e      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     bf IJT_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 (null)     32 JAL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e7 (null)     36 SLLI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     c9 MRET_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     81 JAERR_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      21 XORI_1     0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007033 sloppy and     
 * ef (null)     32 JAL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     97 SW_E1SWH   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     36 SLLI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     78 unx78      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     d7 ECALL_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     d5 unxd5      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     de Fetch      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     bb SH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       22 unx22      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     72 LBU_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     93 SW_E2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   7a SB_5       0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      9f SH_5       0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       74 BrOpFet    0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     ca unxca      0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0600, used ffff, inputs 4b
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       58 unx58      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       3e SLL_1      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     68 unx68      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     68 unx68      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     8b LB_6       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       9e SH_4       0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     8b LB_6       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       32 JAL_1      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     68 unx68      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      21 XORI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     68 unx68      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      9e SH_4       0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    39 unx39      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 eILL0b        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2b SLTIX_1    0010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LH_1       2e unx2e      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LH    06 LB_3       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_2       50 LW_1       0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 17 aFaultb    46 ILL_1      0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 18 BEQ        29 XOR_1      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     7d BAERR_4    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       68 unx68      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   36 SLLI_2     0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     68 unx68      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LHU_1      ca unxca      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 1f LDAF_LHU   b9 unxb9      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 20 LH_0       14 condb_3    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      68 unx68      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1         (use dinx) 0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     68 unx68      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     67 SW_E1SWE   0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 SW_1       54 LH_2       0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 27 SW_E1SWE   3a SRxI_1     0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 28 _L0x28     34 JAL_3      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_2    4b CSRRW_2    0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2a _L0x2a     34 JAL_3      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_3    5d SB_2       0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2c SLL_0      77 BAERR_3    0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     68 unx68      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_4       (use dinx) 0010000000000000110011101101001xx0        Branch on condition                               40001033 sloppy sll     
 * 2f _L0x2f     68 unx68      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_2      68 unx68      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 31 aFaultc    5a SB_1       0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 32 JAL_2      32 JAL_1      0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 33 JALRE1     9c unx9c      0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 34 SH_1       50 LW_1       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 35 SW_E1SWH   6d unx6d      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 ECAL_RET   03 _L0x03     0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 37 EBRKWFI1   5f LDAF_LHU   0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 38 BNE        29 XOR_1      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00001067 close to jalr
 * 3a ORI_2      74 BrOpFet    0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    87 JALRE1     0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d aFault_1   03 _L0x03     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 3e IJ_1       67 SW_E1SWE   0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 3f IJT_1      73 BAERR_1    0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 40 LW_0       52 LH_1       0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 (null)     1d ORI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 42 LW_1          (use dinx) 0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LW       (use dinx) 0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     5a SB_1       0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 (null)     8f ILL_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 46 BrOpFet    86 JAL_2      0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 47 BAlignEr   a1 ECALL_4    0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 48 _L0x48     26 OR_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 IJ_2       88 unx88      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 4a _L0x4a     26 OR_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b XORI_1     b3 unxb3      0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4c SLT_0      60 unx60      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d OR_1          (use dinx) 0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 4e ECALL_1    fe ILLe       0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40002033 sloppy slt     
 * 4f MRET_1     68 unx68      0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 50 Fetch      68 unx68      0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 51 eFetch     cb QINT_2     0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 52 LW_1       16 condb_5    0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 53 LDAF_LW    cb QINT_2     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 54 OR_2       d4 aFault_2   0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 55 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 56 (null)     8a unx8a      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 XOR_1      9e SH_4       0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 58 LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00002063 close to branch
 * 59 aFaultd       (use dinx) 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00002067 close to jalr
 * 5a SLTIX_1    8d unx8d      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    87 JALRE1     0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLTIX_2    d9 unxd9      0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 5e eILL0c     30 SLTIX_2    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 5f ECALL_3    cb QINT_2     0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 60 SLTX_1        (use dinx) 0010000000000000111111101100000xx0        ~rs2 to Q                                         00003003 close to load
 * 61 (null)     83 unx83      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 62 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000300b close to ij
 * 63 JAL_3         (use dinx) 0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                0000300f close to fence
 * 64 SLTIU_0    5a SB_1       0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 (null)     6b SB_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 66 (null)     78 unx78      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 67 SLLI_1     a6 ECAL_RET   0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 68 StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00003023 close to store
 * 69 aFault        (use dinx) 0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 6a eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b WFI_5      96 SH_1       0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 6c SLTU_0     60 unx60      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SLLI_2        (use dinx) 0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 6e LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40003033 sloppy sltu    
 * 6f aFaulte    c9 MRET_2     0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 70 ECALL_2    ffffffff (null)     0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 71 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 72 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 SRxI_1     94 SW_E4      0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 74 SRxI_2     7e NMI_1      0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 75 (null)     93 SW_E2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 76 (null)     95 SW_E3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 SLL_1      97 SW_E1SWH   0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 78 SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   00003063 close to branch
 * 79 aF_SW         (use dinx) 0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00003067 close to jalr
 * 7a SRx_1      78 unx78      0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    87 JALRE1     0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d JALR_1     63 unx63      0010000000000000000011101100100110        Q=1                                               00000000 
 * 7e Fetch2     a2 unxa2      000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 7f jFault     97 SW_E1SWH   0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 80 LBU_0      9d unx9d      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 WFI_3      97 SW_E1SWH   0010000000000000101011101100100110        More check offset                                 00000000 
 * 82 WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   0000400b close to ij
 * 83 EBREAK_1      (use dinx) 0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       0000400f close to fence
 * 84 XORI_0     4b CSRRW_2    0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 ILL_1      6e unx6e      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 86 ILL_2      63 unx63      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 87 CSRRW_1    9b unx9b      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 88 CSRRW_2       (use dinx) 0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00004023 close to store
 * 89 LH_4          (use dinx) 0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 8a LH_5          (use dinx) 0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               40004023 close to store
 * 8b SB_1       68 unx68      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 8c XOR_0      57 LH_5       0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d SB_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 8e EBRKWFI2   fe ILLe       0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         40004033 sloppy xor     
 * 8f WFI_4      b0 CSRRW_3    0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 90 SB_4       63 unx63      1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 91 MRET_6     a5 MRET_3     0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 92 LBU_3      63 unx63      0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 93 BAERR_1    a8 unxa8      0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 94 BAERR_2    63 unx63      0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 95 BAERR_3    a7 EBRKWFI1   0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * 96 SB_5       ba LHU_3      0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 97 BAERR_4    a6 ECAL_RET   0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 98 BLT        29 XOR_1      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a NMI_1      63 unx63      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 9b JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * 9c JAERR_2       (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  00004073 close to csr/system 
 * 9d LBU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 9e LB_6       ab EBREAK_2   0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 9f _LCSRRS_1  78 unx78      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * a0 LHU_0      1e aFault_1   0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ILL_3      b7 IJ_3       0010000000000000101011101100100110        Q = 1                                             00000000 
 * a2 NMI_2         (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        0000500b close to ij
 * a3 LDAF_2        (use dinx) 0000110000001110001011000x00100110        Store 4 to mcause                                 0000500f close to fence
 * a4 SRxI_0     73 BAERR_1    0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 LDAF_3     b2 CSRRW_4    0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * a6 SW_E2      4e eILL0b     0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * a7 SW_E4      8e _LCSRRS_1  0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * a8 SW_E3         (use dinx) 0010000000000000101111001100100110        Q = 3                                             00005023 close to store
 * a9 ECALL_6    63 unx63      0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * aa SH_4          (use dinx) 1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      40005023 close to store
 * ab SH_5       a9 ILL_4      0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * ac _L0xac     7a SB_5       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad ECALL_4       (use dinx) 0010000000000000101011001100100110        Q = 4                                             00000000 
 * ae _L0xae     7a SB_5       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_3     be IJ_1       0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * b0 ILL_4      b5 SH_3       0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * b1 EBREAK_2   a5 MRET_3     0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * b2 MRET_4     50 LW_1       0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b3 CSRRW_3       (use dinx) 0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b4 aF_SW_3       (use dinx) 0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * b5 CSRRW_4    aa unxaa      0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b6 SH_3       a9 ILL_4      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b7 ECALL_5    bb SH_2       0010000000000000101011001100100110        Q = 8                                             00000000 
 * b8 BGE        29 XOR_1      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00005067 close to jalr
 * ba SH_2       39 unx39      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * bb IJ_4       b6 ECALL_5    0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * bc CSRRWI_0   87 JALRE1     0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd IJT_2      50 LW_1       0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * be MRET_5     49 CSRRW_1    0010000000000000000011101100010xx0        ~302                                              00000000 
 * bf IJT_4      bd IJ_4       0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * c0 QINT_1        (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00006003 close to load
 * c1 (null)     d3 aFaultd    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600b close to ij
 * c3 MRET_2        (use dinx) 0010000000000000011011001100100000        0xff+3 = 0x102                                    0000600f close to fence
 * c4 ORI_0      cf MRET_7     0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     91 LDAF_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c6 (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c7 QINT_2     c7 QINT_1     0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * c8 _LCSRRCI_1    (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00006023 close to store
 * c9 MRET_7     af MRET_4     0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * ca aFault_2      (use dinx) 0000110000001110001011100x00100110        Store 5 to mcause                                 40006023 close to store
 * cb LDAF_a     68 unx68      0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * cc OR_0       4d unx4d      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd jFault_1      (use dinx) 0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * ce aF_SW_1    fe ILLe       0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      40006033 sloppy or      
 * cf ORI_1      13 condb_2    0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * d0 aF_SW_2    70 LHU_2      0010000000000000101011001100100110        Q = 4                                             00000000 
 * d1 (null)     c3 unxc3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 IJT_3      3d SRxI_2     0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * d4 LH_3       a5 MRET_3     0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 WFI_2      ad unxad      0010000000000000101011101100100110        Check offset                                      00000000 
 * d8 BLTU       29 XOR_1      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 SB_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   00006067 close to jalr
 * da i0reserv   a3 unxa3      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * db (null)     a5 MRET_3     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * dc CSRRSI_0   87 JALRE1     0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd (null)     d0 ECALL_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * de (null)     7e NMI_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * df (null)     7e NMI_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e0 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007003 close to load
 * e1 (null)     3a SRxI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     39 unx39      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     b4 i0reserv   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 (null)     50 LW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e7 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     bf IJT_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     89 unx89      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      22 unx22      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007033 sloppy and     
 * ef (null)     50 LW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     92 LDAF_3     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     68 unx68      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     ce _LCSRRCI_1 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     cd unxcd      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     d7 ECALL_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     b1 aF_SW_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       29 XOR_1      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     81 JAERR_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     90 NMI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   87 JALRE1     0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      9a ECALL_6    0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       85 LBU_1      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     c0 unxc0      0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0840, used fdff, inputs 53
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       72 LBU_3      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       5e LHU_1      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     76 BAERR_2    0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     76 BAERR_2    0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   1d ORI_2      0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     94 SW_E4      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       ab EBREAK_2   0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     94 SW_E4      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       54 LH_2       0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     76 BAERR_2    0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      21 XORI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     76 BAERR_2    0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      ab EBREAK_2   0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    33 JAERR_1    0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 LW_1          (use dinx) 0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 13 LDAF_LW    2b SLTIX_1    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 14 eILL0b     2e unx2e      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 15 MRET_8     06 LB_3       0010000000000000101011101100100110        Prep +4                                           00000000 
 * 16 BrOpFet    42 unx42      0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 17 BAlignEr   16 condb_5    0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 18 BEQ        29 XOR_1      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     8a unx8a      0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a (null)     76 BAERR_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   58 unx58      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d LB_5       76 BAERR_2    0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1e (null)     e0 unxe0      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 1f JALR_2     d3 aFaultd    0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 20 LH_0       26 OR_1       0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      76 BAERR_2    0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1         (use dinx) 0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     76 BAERR_2    0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     68 unx68      0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LH_1       4e eILL0b     0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LH    37 ECALL_2    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     56 LH_4       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_2    3f SRx_1      0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2a _L0x2a     56 LH_4       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_3    60 unx60      0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2c SLL_0      81 JAERR_2    0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     76 BAERR_2    0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_4       (use dinx) 0010000000000000110011101101001xx0        Branch on condition                               40001033 sloppy sll     
 * 2f _L0x2f     76 BAERR_2    0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_2       76 BAERR_2    0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 31 aFaultb    5d SB_2       0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 32 (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 ANDI_1     a9 ILL_4      0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 34 LHU_1      42 unx42      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 35 LDAF_LHU   6a unx6a      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 ORI_2      75 BAlignEr   0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 38 BNE        29 XOR_1      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 aFault_1      (use dinx) 0010000000000000101011001100100110        Q = 4                                             00001067 close to jalr
 * 3a (null)     7d BAERR_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    8f ILL_3      0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d IJ_2       03 _L0x03     0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 3e (null)     68 unx68      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 3f XORI_1     7a SB_5       0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 40 LW_0       12 unx12      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 (null)     1f IJ_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 42 Fetch         (use dinx) 0000000000001000001111101010110000  Fr00  Read and latch instruction                        0000200b close to ij
 * 43 eFetch        (use dinx) 0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     5d SB_2       0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 (null)     9b unx9b      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 46 OR_1       8e _LCSRRS_1  0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 47 (null)     af MRET_4     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 48 _L0x48     50 LW_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 (null)     90 NMI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 4a _L0x4a     50 LW_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b (null)     ca unxca      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 4c SLT_0      62 unx62      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 4e OR_2       fe ILLe       0010000000000000000011101100100000        Q = rs2                                           40002033 sloppy slt     
 * 4f (null)     76 BAERR_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 50 SW_1       76 BAERR_2    0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 51 SW_E1SWE   e2 unxe2      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 52 LHU_2      30 SLTIX_2    0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 53 aFaultc    e2 unxe2      0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 54 JAL_2      f1 aFaulte    0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 55 JALRE1     39 unx39      0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 56 SH_1       93 SW_E2      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 57 SW_E1SWH   ab EBREAK_2   0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 58 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00002063 close to branch
 * 59 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00002067 close to jalr
 * 5a XOR_1      95 SW_E3      0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    8f ILL_3      0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLTIX_1    f3 aF_SW      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 5e IJ_1       52 LH_1       0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 5f IJT_1      e2 unxe2      0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 60 SLTIX_2       (use dinx) 0000000000000100001011101000110010        Registered ALU flag to rd                         00003003 close to load
 * 61 (null)     89 unx89      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 62 SLTX_1        (use dinx) 0010000000000000111111101100000xx0        ~rs2 to Q                                         0000300b close to ij
 * 63 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000300f close to fence
 * 64 SLTIU_0    5d SB_2       0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 (null)     79 unx79      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 66 JAL_3      82 unx82      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 67 (null)     b4 i0reserv   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 68 SLLI_1        (use dinx) 0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00003023 close to store
 * 69 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 6a SLLI_2        (use dinx) 0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                40003023 close to store
 * 6b (null)     a5 MRET_3     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 6c SLTU_0     62 unx62      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 6e ECALL_2       (use dinx) 0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  40003033 sloppy sltu    
 * 6f (null)     df eFetch     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 70 ECALL_1    ffffffff (null)     0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 71 MRET_1     39 unx39      0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 72 LB_2       33 JAERR_1    0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 73 aFaultd    a2 unxa2      0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 74 eILL0c     86 JAL_2      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 ECALL_3    a1 ECALL_4    0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 76 StdIncPc   a3 unxa3      0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * 77 aFault     a6 ECAL_RET   0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 78 eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00003063 close to branch
 * 79 WFI_5         (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch                                    00003067 close to jalr
 * 7a SRxI_1     82 unx82      0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    8f ILL_3      0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SRxI_2     66 SW_1       0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 7e LBU_2      b0 CSRRW_3    0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 7f aFaulte    a6 ECAL_RET   0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 80 LBU_0      aa unxaa      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SLL_1      a6 ECAL_RET   0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 82 SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   0000400b close to ij
 * 83 aF_SW         (use dinx) 0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     0000400f close to fence
 * 84 XORI_0     3f SRx_1      0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SRx_1      7e NMI_1      0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 86 Fetch2     66 SW_1       000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 87 jFault     a8 unxa8      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 88 WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   00004023 close to store
 * 89 EBREAK_1      (use dinx) 0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 8a JALR_1        (use dinx) 0010000000000000000011101100100110        Q=1                                               40004023 close to store
 * 8b WFI_3      76 BAERR_2    0010000000000000101011101100100110        More check offset                                 00000000 
 * 8c XOR_0      5a SB_1       0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d ILL_1         (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 8e ILL_2      fe ILLe       0000000000001111101011101000001xx0        Store 0 to mtval                                  40004033 sloppy xor     
 * 8f CSRRW_1    c2 unxc2      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 90 CSRRW_2    66 SW_1       0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 91 LH_4       b3 unxb3      0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 92 (null)     66 SW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 LH_5       b7 IJ_3       0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 94 SB_1       66 SW_1       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 95 SB_2       b5 SH_3       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 96 (null)     d4 aFault_2   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 EBRKWFI2   b4 i0reserv   0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 98 BLT        29 XOR_1      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a (null)     66 SW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 9b WFI_4         (use dinx) 0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 9c SB_4          (use dinx) 1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00004073 close to csr/system 
 * 9d MRET_6        (use dinx) 0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 9e (null)     bd IJ_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 9f LBU_3      82 unx82      0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * a0 LHU_0      34 JAL_3      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 BAERR_1    d2 LB_2       0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * a2 BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           0000500b close to ij
 * a3 BAERR_3       (use dinx) 0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       0000500f close to fence
 * a4 SRxI_0     7a SB_5       0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SB_5       c8 unxc8      0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * a6 BAERR_4    70 LHU_2      0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * a7 NMI_1      97 SW_E1SWH   0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * a8 JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   00005023 close to store
 * a9 JAERR_2    66 SW_1       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * aa LBU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40005023 close to store
 * ab LB_6       b9 unxb9      0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * ac _L0xac     85 LBU_1      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad _LCSRRS_1     (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * ae _L0xae     85 LBU_1      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af ILL_3      d7 ECALL_3    0010000000000000101011101100100110        Q = 1                                             00000000 
 * b0 NMI_2      d0 ECALL_1    0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * b1 LDAF_2     b3 unxb3      0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * b2 (null)     42 unx42      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 LDAF_3        (use dinx) 0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * b4 SW_E2         (use dinx) 0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * b5 SW_E4      bb SH_2       0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * b6 (null)     b9 unxb9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 SW_E3      d5 unxd5      0010000000000000101111001100100110        Q = 3                                             00000000 
 * b8 BGE        29 XOR_1      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 ECALL_6       (use dinx) 0000110000001110100111000x00100000        mcause = 11                                       00005067 close to jalr
 * ba (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * bb SH_4       d1 MRET_1     1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * bc CSRRWI_0   8f ILL_3      0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SH_5       42 unx42      0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * be (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * bf ECALL_4    d6 eILL0c     0010000000000000101011001100100110        Q = 4                                             00000000 
 * c0 MRET_3        (use dinx) 0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00006003 close to load
 * c1 (null)     f0 LBU_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 ILL_4         (use dinx) 0000110000001110100111100x00100110        Store 2 to mcause                                 0000600b close to ij
 * c3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600f close to fence
 * c4 ORI_0      ea unxea      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     9d unx9d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c6 EBREAK_2   8e _LCSRRS_1  0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * c7 (null)     dd aF_SW_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c8 MRET_4        (use dinx) 0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00006023 close to store
 * c9 (null)     c0 unxc0      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ca CSRRW_3       (use dinx) 0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     40006023 close to store
 * cb (null)     76 BAERR_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * cc OR_0       46 ILL_1      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ce aF_SW_3    fe ILLe       0000110000001110001011000x00100000        Store 7 to mcause                                 40006033 sloppy or      
 * cf (null)     15 condb_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d0 CSRRW_4    6e unx6e      0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d1 SH_3       db jFault_1   0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d2 ECALL_5    09 LB_5       0010000000000000101011001100100110        Q = 8                                             00000000 
 * d3 IJ_3       39 unx39      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * d4 SH_2       b3 unxb3      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d5 IJ_4          (use dinx) 0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * d6 IJT_2      fe ILLe       0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * d7 MRET_5     bf IJT_1      0010000000000000000011101100010xx0        ~302                                              00000000 
 * d8 BLTU       29 XOR_1      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 IJT_4         (use dinx) 0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00006067 close to jalr
 * da QINT_1     b1 aF_SW_3    0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * db MRET_2     b3 unxb3      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * dc CSRRSI_0   8f ILL_3      0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd QINT_2     ee eILL0a     0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * de _LCSRRCI_1 86 JAL_2      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * df MRET_7     86 JAL_2      0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * e0 aFault_2      (use dinx) 0000110000001110001011100x00100110        Store 5 to mcause                                 00007003 close to load
 * e1 (null)     37 ECALL_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 LDAF_a        (use dinx) 0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     33 JAERR_1    0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     ce _LCSRRCI_1 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 jFault_1   42 unx42      0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * e7 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 aF_SW_1       (use dinx) 0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00007023 close to store
 * e9 (null)     d9 unxd9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea ORI_1         (use dinx) 0010000000000000000011101100001xx0        Q = RS1                                           40007023 close to store
 * eb (null)     91 LDAF_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      22 unx22      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee aF_SW_2    fe ILLe       0010000000000000101011001100100110        Q = 4                                             40007033 sloppy and     
 * ef (null)     42 unx42      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 IJT_3      9f SH_5       0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * f1 LH_3       39 unx39      0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f2 WFI_2      76 BAERR_2    0010000000000000101011101100100110        Check offset                                      00000000 
 * f3 SB_3       e8 unxe8      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f4 i0reserv      (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * f5 (null)     e6 StdIncPc   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     f2 SW_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     c6 IJT_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       29 XOR_1      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     8b LB_6       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     9c unx9c      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   8f ILL_3      0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      a7 EBRKWFI1   0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       8d unx8d      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     da LDAF_a     0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0210, used dfff, inputs 59
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       9a ECALL_6    0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       8a unx8a      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     9e SH_4       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     9e SH_4       0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   17 condb_5t   0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     a1 ECALL_4    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       ca unxca      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     a1 ECALL_4    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       82 unx82      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     9e SH_4       0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      1d ORI_2      0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     9e SH_4       0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 LW_1       ca unxca      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 11 LDAF_LW    2e unx2e      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 12 BrOpFet       (use dinx) 0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 13 BAlignEr   29 XOR_1      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 14 LW_1       2b SLTIX_1    0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 (null)     42 unx42      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 17 LB_5       12 unx12      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 18 BEQ        22 unx22      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     7d BAERR_4    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a JALR_2     9e SH_4       0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1b _L0x1b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   88 unx88      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d SUB_1      9e SH_4       0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 1e JAL_1      50 LW_1       0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 1f JAERR_1    6b SB_4       0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 20 LH_0       3e SLL_1      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 AND_1      9e SH_4       0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 22 condb_2       (use dinx) 0010000000000000111111101100000xx0        ~RS2 in Q                                         0000100b close to ij
 * 23 _L0x23     9e SH_4       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     60 unx60      0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 eILL0b     3a SRxI_1     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     31 SLTX_1     0010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     86 JAL_2      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_3    37 ECALL_2    0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2a _L0x2a     86 JAL_2      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_4    4e eILL0b     0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 2c SLL_0      6e unx6e      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     9e SH_4       0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     9e SH_4       0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 (null)     9e SH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 31 ORI_2      46 ILL_1      0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 32 (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 aFault_1   c6 IJT_4      0010000000000000101011001100100110        Q = 4                                             00000000 
 * 34 (null)     42 unx42      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 35 IJ_2       62 unx62      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 XORI_1     9d unx9d      0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 38 BNE        22 unx22      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 OR_1          (use dinx) 0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00001067 close to jalr
 * 3a OR_2       6a unx6a      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 3b _L0x3b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    91 LDAF_2     0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d XOR_1      03 _L0x03     0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 3e LH_1       60 unx60      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LH    68 unx68      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       14 condb_3    0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 (null)     1a ANDI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 42 Fetch         (use dinx) 0000000000001000001111101010110000  Fr00  Read and latch instruction                        0000200b close to ij
 * 43 eFetch        (use dinx) 0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     46 ILL_1      0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 (null)     af MRET_4     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 46 SLTIX_1    8d unx8d      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 47 (null)     d9 unxd9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 48 _L0x48     78 unx78      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 CSRRW_3    93 SW_E2      0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * 4a _L0x4a     78 unx78      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b aF_SW_3    49 CSRRW_1    0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 4c SLT_0      5a SB_1       0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d CSRRW_4       (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * 4e SLTIX_2    fe ILLe       0000000000000100001011101000110010        Registered ALU flag to rd                         40002033 sloppy slt     
 * 4f SH_3       9e SH_4       0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * 50 aFault_2   9e SH_4       0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 51 (null)     52 LH_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 52 LDAF_a     58 unx58      0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * 53 (null)     52 LH_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 54 jFault_1   76 BAERR_2    0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 55 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 56 aF_SW_1    97 SW_E1SWH   0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 57 (null)     ca unxca      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 58 LH_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00002063 close to branch
 * 59 aFaultb       (use dinx) 0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00002067 close to jalr
 * 5a SLTX_1     a5 MRET_3     0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 5b _L0x5b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    91 LDAF_2     0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d JAL_3      d2 LB_2       0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 5e LHU_1      7e NMI_1      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 5f LDAF_LHU   52 LH_1       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 60 SLLI_1        (use dinx) 0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00003003 close to load
 * 61 (null)     bb SH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 62 SLLI_2        (use dinx) 0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                0000300b close to ij
 * 63 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000300f close to fence
 * 64 SLTIU_0    46 ILL_1      0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 (null)     a3 unxa3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 66 ECALL_2    a8 unxa8      0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 67 (null)     de Fetch      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 68 SRxI_1        (use dinx) 0000000000000100101001101100001xx1        Register to shift to Q                            00003023 close to store
 * 69 ECALL_5       (use dinx) 0010000000000000101011001100100110        Q = 8                                             00000000 
 * 6a SRxI_2        (use dinx) 0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                40003023 close to store
 * 6b IJ_3       be IJ_1       0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 6c SLTU_0     5a SB_1       0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SH_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 6e SLL_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              40003033 sloppy sltu    
 * 6f IJ_4       ef WFI_5      0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 70 ORI_1      ffffffff (null)     0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 71 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 72 aF_SW_2    2e unx2e      0010000000000000101011001100100110        Q = 4                                             00000000 
 * 73 (null)     b9 unxb9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 74 IJT_3      aa unxaa      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 75 (null)     b7 IJ_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 76 LH_3       bd IJ_4       0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 77 (null)     bf IJT_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 78 SW_1          (use dinx) 0000000000000011111011100100001xx0        Write d to a+k until accepted                     00003063 close to branch
 * 79 SW_E1SWE      (use dinx) 0000000000001111001011100x00110000        Store faulting address alignment to mtval         00003067 close to jalr
 * 7a SRx_1      a8 unxa8      0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 7b _L0x7b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    91 LDAF_2     0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d JALR_1     5d SB_2       0010000000000000000011101100100110        Q=1                                               00000000 
 * 7e LHU_2      da LDAF_a     0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 7f aFaultc    bf IJT_1      0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 80 LBU_0      c8 unxc8      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 WFI_3      bf IJT_1      0010000000000000101011101100100110        More check offset                                 00000000 
 * 82 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             0000400b close to ij
 * 83 JALRE1        (use dinx) 0000000000001101110011100x00001xx0  err   Store pc to mepc                                  0000400f close to fence
 * 84 XORI_0     37 ECALL_2    0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 ILL_1      a6 ECAL_RET   0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 86 SH_1       5d SB_2       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 87 SW_E1SWH   c2 unxc2      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 88 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00004023 close to store
 * 89 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 8a IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   40004023 close to store
 * 8b IJT_1      9e SH_4       0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 8c XOR_0      3d SRxI_2     0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d ILL_2         (use dinx) 0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 8e ECALL_1    fe ILLe       0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40004033 sloppy xor     
 * 8f MRET_1     f9 unxf9      0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 90 (null)     5d SB_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 91 CSRRW_1    dd aF_SW_1    0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 92 (null)     5d SB_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 CSRRW_2    e0 unxe0      0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 94 (null)     5d SB_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 95 LH_4       df eFetch     0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 96 (null)     6d unx6d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 LH_5       de Fetch      0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 98 BLT        22 unx22      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a LB_2       5d SB_2       0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 9b aFaultd       (use dinx) 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 9c eILL0c        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00004073 close to csr/system 
 * 9d ECALL_3       (use dinx) 0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 9e StdIncPc   e8 unxe8      0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * 9f aFault     a8 unxa8      0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * a0 LHU_0      5e LHU_1      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SB_1       69 unx69      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * a2 eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000500b close to ij
 * a3 WFI_5         (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch                                    0000500f close to fence
 * a4 SRxI_0     68 unx68      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SB_2       fb SB_3       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * a6 LBU_2      8e _LCSRRS_1  0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * a7 aFaulte    ad unxad      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * a8 SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   00005023 close to store
 * a9 aF_SW      5d SB_2       0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * aa Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     40005023 close to store
 * ab jFault     e2 unxe2      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * ac _L0xac     7a SB_5       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad EBRKWFI2      (use dinx) 0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * ae _L0xae     7a SB_5       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af WFI_4      cb QINT_2     0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * b0 (null)     4d unx4d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b1 SB_4       dd aF_SW_1    1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b2 (null)     42 unx42      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 MRET_6        (use dinx) 0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * b4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b5 LBU_3      e6 StdIncPc   0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * b6 (null)     e2 unxe2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 BAERR_1    6f MRET_6     0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * b8 BGE        22 unx22      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00005067 close to jalr
 * ba WFI_1      2e unx2e      0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * bb EBREAK_1   4f MRET_8     0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * bc CSRRWI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd BAERR_3    42 unx42      0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * be SB_5       35 SLLI_1     0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * bf BAERR_4    c9 MRET_2     0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * c0 NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00006003 close to load
 * c1 (null)     74 BrOpFet    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   0000600b close to ij
 * c3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600f close to fence
 * c4 ORI_0      70 LHU_2      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     b3 unxb3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c6 JAERR_2    8d unx8d      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * c7 (null)     eb LH_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c8 LBU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00006023 close to store
 * c9 IJT_2      ee eILL0a     0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * ca LB_6          (use dinx) 0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          40006023 close to store
 * cb MRET_5     9e SH_4       0010000000000000000011101100010xx0        ~302                                              00000000 
 * cc OR_0       39 unx39      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd IJT_4         (use dinx) 0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * ce _LCSRRS_1  fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006033 sloppy or      
 * cf QINT_1     27 OR_2       0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * d0 WFI_2      66 SW_1       0010000000000000101011101100100110        Check offset                                      00000000 
 * d1 (null)     e9 IJT_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 SB_3       09 LB_5       0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d3 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d4 i0reserv   dd aF_SW_1    xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     ea unxea      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       22 unx22      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 ILL_3         (use dinx) 0010000000000000101011101100100110        Q = 1                                             00006067 close to jalr
 * da NMI_2      db jFault_1   0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * db LDAF_2     dd aF_SW_1    0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * dc CSRRSI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd LDAF_3     72 LBU_3      0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * de SW_E2      aa unxaa      0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * df SW_E4      aa unxaa      0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * e0 SW_E3         (use dinx) 0010000000000000101111001100100110        Q = 3                                             00007003 close to load
 * e1 (null)     31 SLTX_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 ECALL_6       (use dinx) 0000110000001110100111000x00100000        mcause = 11                                       0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     2e unx2e      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     4b CSRRW_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 SH_4       42 unx42      1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * e7 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 SH_5          (use dinx) 0000000000000001110011100100001xx0        Write d to a+k until accepted                     00007023 close to store
 * e9 MRET_2     cd unxcd      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * ea ECALL_4       (use dinx) 0010000000000000101011001100100110        Q = 4                                             40007023 close to store
 * eb QINT_2     95 SW_E3      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * ec AND_0      21 XORI_1     0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed _LCSRRCI_1    (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * ee MRET_3     fe ILLe       0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          40007033 sloppy and     
 * ef MRET_7     42 unx42      0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f0 (null)     b5 SH_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     9e SH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     56 LH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     d0 ECALL_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     fa WFI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       22 unx22      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 ILL_4         (use dinx) 0000110000001110100111100x00100110        Store 2 to mcause                                 00007067 close to jalr
 * fa EBREAK_2   81 JAERR_2    0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * fb MRET_4     b1 aF_SW_3    0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * fc CSRRCI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      c0 unxc0      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       85 LBU_1      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     cf MRET_7     0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0600, used ffff, inputs 8b
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       46 ILL_1      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       3e SLL_1      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     50 LW_1       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     50 LW_1       0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     73 BAERR_1    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       8e _LCSRRS_1  0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     73 BAERR_1    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       32 JAL_1      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     50 LW_1       0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      21 XORI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     50 LW_1       0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      8e _LCSRRS_1  0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    39 unx39      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 eILL0b        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2b SLTIX_1    0010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LH_1       2e unx2e      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LH    06 LB_3       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_2       90 NMI_2      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 17 aFaultb    86 JAL_2      0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 18 BEQ        29 XOR_1      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     6a unx6a      0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       50 LW_1       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   36 SLLI_2     0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     50 LW_1       0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LHU_1      ca unxca      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 1f LDAF_LHU   b9 unxb9      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 20 LH_0       14 condb_3    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      50 LW_1       0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1         (use dinx) 0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     50 LW_1       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     62 unx62      0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 SW_1       4b CSRRW_2    0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 27 SW_E1SWE   3a SRxI_1     0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 28 _L0x28     34 JAL_3      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_2    45 WFI_3      0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2a _L0x2a     34 JAL_3      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_3    5d SB_2       0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2c SLL_0      68 unx68      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     50 LW_1       0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_4       (use dinx) 0010000000000000110011101101001xx0        Branch on condition                               40001033 sloppy sll     
 * 2f _L0x2f     50 LW_1       0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_2      50 LW_1       0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 31 aFaultc    5a SB_1       0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 32 JAL_2      32 JAL_1      0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 33 JALRE1     8b LB_6       0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 34 SH_1       90 NMI_2      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 35 SW_E1SWH   63 unx63      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 ECAL_RET   03 _L0x03     0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 37 EBRKWFI1   4f MRET_8     0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 38 BNE        29 XOR_1      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00001067 close to jalr
 * 3a ORI_2      67 SW_E1SWE   0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    6f MRET_6     0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d aFault_1   03 _L0x03     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 3e IJ_1       62 unx62      0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 3f IJT_1      66 SW_1       0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 40 LW_0       92 LDAF_3     0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 IJ_2       1d ORI_2      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 42 ECALL_1       (use dinx) 0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 0000200b close to ij
 * 43 MRET_1        (use dinx) 0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    0000200f close to fence
 * 44 SLTI_0     5a SB_1       0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 XORI_1     76 BAERR_2    0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 46 LB_2       6e unx6e      0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 47 aFaultd    94 SW_E4      0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     26 OR_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 OR_1       70 LHU_2      0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 4a _L0x4a     26 OR_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b OR_2       af MRET_4     0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 4c SLT_0      60 unx60      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d XOR_1         (use dinx) 0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 4e eILL0c     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40002033 sloppy slt     
 * 4f ECALL_3    50 LW_1       0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 50 StdIncPc   50 LW_1       0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * 51 aFault     cb QINT_2     0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 52 eILL0a     16 condb_5    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 53 WFI_5      cb QINT_2     0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 54 LBU_2      d4 aFault_2   0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 55 aFaulte    3d SRxI_2     0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 56 SW_2       72 LBU_3      0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 57 aF_SW      8e _LCSRRS_1  0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 58 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00002063 close to branch
 * 59 jFault        (use dinx) 0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00002067 close to jalr
 * 5a SLTIX_1    74 BrOpFet    0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    6f MRET_6     0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLTIX_2    d9 unxd9      0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 5e WFI_1      30 SLTIX_2    0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 5f EBREAK_1   cb QINT_2     0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 60 SLTX_1        (use dinx) 0010000000000000111111101100000xx0        ~rs2 to Q                                         00003003 close to load
 * 61 JAL_3      5f LDAF_LHU   0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 62 SLLI_1        (use dinx) 0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      0000300b close to ij
 * 63 SLLI_2        (use dinx) 0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                0000300f close to fence
 * 64 SLTIU_0    5a SB_1       0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 ECALL_2    53 LDAF_LH    0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 66 SRxI_1     56 LH_4       0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 67 SRxI_2     9c unx9c      0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 68 SLL_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00003023 close to store
 * 69 SRx_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 6a JALR_1        (use dinx) 0010000000000000000011101100100110        Q=1                                               40003023 close to store
 * 6b WFI_3      7f JALRE2     0010000000000000101011101100100110        More check offset                                 00000000 
 * 6c SLTU_0     60 unx60      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d ILL_1         (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 6e ILL_2         (use dinx) 0000000000001111101011101000001xx0        Store 0 to mtval                                  40003033 sloppy sltu    
 * 6f CSRRW_1    c9 MRET_2     0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 70 CSRRW_2    ffffffff (null)     0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 71 LH_4       3d SRxI_2     0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 72 LH_5       39 unx39      0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 73 SB_1       7d BAERR_4    0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 74 SB_2       58 unx58      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 75 EBRKWFI2   7a SB_5       0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 76 WFI_4      7e NMI_1      0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 77 SB_4       88 unx88      1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 78 MRET_6        (use dinx) 0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00003063 close to branch
 * 79 LBU_3         (use dinx) 0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00003067 close to jalr
 * 7a BAERR_1    56 LH_4       0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    6f MRET_6     0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d BAERR_2    61 EBRKWFI2   0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 7e BAERR_3    97 SW_E1SWH   0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * 7f SB_5       88 unx88      0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 80 LBU_0      8d unx8d      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 (null)     88 unx88      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 82 LW_1          (use dinx) 0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 0000400b close to ij
 * 83 LDAF_LW       (use dinx) 0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000400f close to fence
 * 84 XORI_0     45 WFI_3      0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 86 BrOpFet    61 EBRKWFI2   0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 87 BAlignEr   8a unx8a      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 88 BAERR_4       (use dinx) 0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00004023 close to store
 * 89 NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 8a JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   40004023 close to store
 * 8b JAERR_2    50 LW_1       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 8c XOR_0      4d unx4d      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d LBU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 8e LB_6       fe ILLe       0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          40004033 sloppy xor     
 * 8f _LCSRRS_1  aa unxaa      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 90 Fetch      61 EBRKWFI2   0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 91 eFetch     9b unx9b      0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 92 LW_1       61 EBRKWFI2   0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 93 LDAF_LW    9e SH_4       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 94 ILL_3      61 EBRKWFI2   0010000000000000101011101100100110        Q = 1                                             00000000 
 * 95 (null)     9d unx9d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 96 (null)     ba LHU_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 NMI_2      9c unx9c      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 98 BLT        29 XOR_1      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a LDAF_2     61 EBRKWFI2   0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 9b LDAF_3        (use dinx) 0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 9c SW_E2         (use dinx) 0000000000001101101111101000001xx0        Store address that faulted                        00004073 close to csr/system 
 * 9d SW_E4         (use dinx) 0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 9e SW_E3      a7 EBRKWFI1   0010000000000000101111001100100110        Q = 3                                             00000000 
 * 9f ECALL_6    56 LH_4       0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * a0 LHU_0      1e aFault_1   0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 (null)     b7 IJ_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000500b close to ij
 * a3 SH_4          (use dinx) 1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      0000500f close to fence
 * a4 SRxI_0     66 SW_1       0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 (null)     ad unxad      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a6 (null)     42 unx42      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a7 SH_5       75 BAlignEr   0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * a8 ECALL_4       (use dinx) 0010000000000000101011001100100110        Q = 4                                             00005023 close to store
 * a9 MRET_3     61 EBRKWFI2   0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * aa ILL_4         (use dinx) 0000110000001110100111100x00100110        Store 2 to mcause                                 40005023 close to store
 * ab EBREAK_2   9f SH_5       0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * ac _L0xac     69 unx69      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad MRET_4        (use dinx) 0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * ae _L0xae     69 unx69      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af CSRRW_3    be IJ_1       0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b0 aF_SW_3    b3 unxb3      0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * b1 (null)     9b unx9b      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b2 (null)     90 NMI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 CSRRW_4       (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b4 SH_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b5 (null)     a3 unxa3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b6 (null)     9f SH_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 ECALL_5    bb SH_2       0010000000000000101011001100100110        Q = 8                                             00000000 
 * b8 BGE        29 XOR_1      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00005067 close to jalr
 * ba SH_2       39 unx39      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * bb IJ_4       b4 i0reserv   0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * bc CSRRWI_0   6f MRET_6     0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd IJT_2      90 NMI_2      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * be MRET_5     41 JALR_1     0010000000000000000011101100010xx0        ~302                                              00000000 
 * bf IJT_4      bd IJ_4       0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * c0 QINT_1        (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00006003 close to load
 * c1 (null)     d3 aFaultd    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600b close to ij
 * c3 MRET_2        (use dinx) 0010000000000000011011001100100000        0xff+3 = 0x102                                    0000600f close to fence
 * c4 ORI_0      cf MRET_7     0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     78 unx78      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c6 (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c7 QINT_2     c7 QINT_1     0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * c8 _LCSRRCI_1    (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00006023 close to store
 * c9 MRET_7     a9 ILL_4      0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * ca aFault_2      (use dinx) 0000110000001110001011100x00100110        Store 5 to mcause                                 40006023 close to store
 * cb LDAF_a     50 LW_1       0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * cc OR_0       49 CSRRW_1    0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd jFault_1      (use dinx) 0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * ce aF_SW_1    fe ILLe       0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      40006033 sloppy or      
 * cf ORI_1      13 condb_2    0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * d0 aF_SW_2    65 WFI_4      0010000000000000101011001100100110        Q = 4                                             00000000 
 * d1 (null)     c3 unxc3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 IJT_3      3d SRxI_2     0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * d4 LH_3       9b unx9b      0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 WFI_2      a8 unxa8      0010000000000000101011101100100110        Check offset                                      00000000 
 * d8 BLTU       29 XOR_1      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 SB_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   00006067 close to jalr
 * da i0reserv   9a ECALL_6    xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * db (null)     9b unx9b      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * dc CSRRSI_0   6f MRET_6     0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd (null)     d0 ECALL_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * de (null)     58 unx58      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * df (null)     58 unx58      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e0 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007003 close to load
 * e1 (null)     3a SRxI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     39 unx39      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     b0 CSRRW_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 (null)     90 NMI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e7 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     bf IJT_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     71 aFaultc    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      22 unx22      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007033 sloppy and     
 * ef (null)     90 NMI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     79 unx79      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     50 LW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     ce _LCSRRCI_1 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     cd unxcd      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     d7 ECALL_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     ab EBREAK_2   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       29 XOR_1      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     6b SB_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     77 BAERR_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   6f MRET_6     0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      89 unx89      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       6d unx6d      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     c0 unxc0      0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0840, used fdff, inputs 93
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       62 unx62      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       58 unx58      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     68 unx68      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     68 unx68      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   1d ORI_2      0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     93 SW_E2      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       b1 aF_SW_3    0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     93 SW_E2      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       4e eILL0b     0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     68 unx68      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      21 XORI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     68 unx68      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      b1 aF_SW_3    0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    33 JAERR_1    0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 LW_1          (use dinx) 0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 13 LDAF_LW    2b SLTIX_1    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 14 eILL0b     2e unx2e      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 15 MRET_8     06 LB_3       0010000000000000101011101100100110        Prep +4                                           00000000 
 * 16 BrOpFet    82 unx82      0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 17 BAlignEr   16 condb_5    0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 18 BEQ        29 XOR_1      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     7f JALRE2     0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a (null)     68 unx68      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   54 LH_2       0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d LB_5       68 unx68      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1e (null)     e0 unxe0      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 1f JALR_2     d3 aFaultd    0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 20 LH_0       26 OR_1       0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      68 unx68      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1         (use dinx) 0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     68 unx68      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     5d SB_2       0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LH_1       45 WFI_3      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LH    37 ECALL_2    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     50 LW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_2    3f SRx_1      0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2a _L0x2a     50 LW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_3    4d unx4d      0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2c SLL_0      77 BAERR_3    0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     68 unx68      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_4       (use dinx) 0010000000000000110011101101001xx0        Branch on condition                               40001033 sloppy sll     
 * 2f _L0x2f     68 unx68      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_2       68 unx68      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 31 aFaultb    4b CSRRW_2    0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 32 (null)     4e eILL0b     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 ANDI_1     aa unxaa      0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 34 LHU_1      82 unx82      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 35 LDAF_LHU   5f LDAF_LHU   0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 ORI_2      67 SW_E1SWE   0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 38 BNE        29 XOR_1      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 aFault_1      (use dinx) 0010000000000000101011001100100110        Q = 4                                             00001067 close to jalr
 * 3a (null)     73 BAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    8e _LCSRRS_1  0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d IJ_2       03 _L0x03     0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 3e (null)     5d SB_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 3f XORI_1     6d unx6d      0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 40 LW_0       12 unx12      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 OR_1       1f IJ_2       0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 42 SW_1          (use dinx) 0000000000000011111011100100001xx0        Write d to a+k until accepted                     0000200b close to ij
 * 43 SW_E1SWE      (use dinx) 0000000000001111001011100x00110000        Store faulting address alignment to mtval         0000200f close to fence
 * 44 SLTI_0     4b CSRRW_2    0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 OR_2       96 SH_1       0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 46 LHU_2      8a unx8a      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultc    b3 unxb3      0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 48 _L0x48     42 unx42      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XOR_1      90 NMI_2      0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 4a _L0x4a     42 unx42      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b SLTIX_1    ca unxca      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 4c SLT_0      53 LDAF_LH    0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d SLTIX_2       (use dinx) 0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 4e JAL_2      fe ILLe       0000000000000100110011000x00100110        Return address to TRG                             40002033 sloppy slt     
 * 4f JALRE1     68 unx68      0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 50 SH_1       68 unx68      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 51 SW_E1SWH   e2 unxe2      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 52 (null)     30 SLTIX_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 SLTX_1     e2 unxe2      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 54 ECAL_RET   f1 aFaulte    0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 55 EBRKWFI1   39 unx39      0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 56 (null)     92 LDAF_3     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 JAL_3      b1 aF_SW_3    0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 58 IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00002063 close to branch
 * 59 IJT_1         (use dinx) 0010000010000000101111101100001xx0        Exit CSR, enter trap                              00002067 close to jalr
 * 5a (null)     94 SW_E4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    8e _LCSRRS_1  0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLLI_1     f3 aF_SW      0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 5e (null)     46 ILL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 5f SLLI_2     e2 unxe2      0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 60 ECALL_1       (use dinx) 0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00003003 close to load
 * 61 MRET_1     79 unx79      0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 62 LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     0000300b close to ij
 * 63 aFaultd       (use dinx) 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       0000300f close to fence
 * 64 SLTIU_0    4b CSRRW_2    0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 ECALL_2    6b SB_4       0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 66 eILL0c     70 LHU_2      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 67 ECALL_3    b7 IJ_3       0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 68 StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00003023 close to store
 * 69 aFault        (use dinx) 0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 6a eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b WFI_5      9f SH_5       0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 6c SLTU_0     53 LDAF_LH    0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SRxI_1        (use dinx) 0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 6e LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40003033 sloppy sltu    
 * 6f aFaulte    df eFetch     0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 70 SW_2       ffffffff (null)     0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 71 aF_SW      39 unx39      0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 72 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 SRxI_2     9d unx9d      0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 74 Fetch2     74 BrOpFet    000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 75 jFault     9c unx9c      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 76 (null)     9e SH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 SLL_1      a2 unxa2      0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 78 WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   00003063 close to branch
 * 79 EBREAK_1      (use dinx) 0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00003067 close to jalr
 * 7a (null)     70 LHU_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    8e _LCSRRS_1  0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SRx_1      57 LH_5       0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 7e (null)     b4 i0reserv   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 7f JALR_1     a2 unxa2      0010000000000000000011101100100110        Q=1                                               00000000 
 * 80 LBU_0      b0 CSRRW_3    0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 (null)     a2 unxa2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 82 Fetch         (use dinx) 0000000000001000001111101010110000  Fr00  Read and latch instruction                        0000400b close to ij
 * 83 eFetch        (use dinx) 0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             0000400f close to fence
 * 84 XORI_0     3f SRx_1      0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 86 WFI_3      57 LH_5       0010000000000000101011101100100110        More check offset                                 00000000 
 * 87 (null)     a8 unxa8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 88 ILL_1         (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  00004023 close to store
 * 89 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 8a ILL_2         (use dinx) 0000000000001111101011101000001xx0        Store 0 to mtval                                  40004023 close to store
 * 8b (null)     68 unx68      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 8c XOR_0      49 CSRRW_1    0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 8e CSRRW_1    fe ILLe       0010000000000000000011101100100110        Construct PC storage adr                          40004033 sloppy xor     
 * 8f (null)     c2 unxc2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 90 CSRRW_2    57 LH_5       0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 91 LH_4       b6 ECALL_5    0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 92 LH_5       57 LH_5       0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 93 SB_1       ba LHU_3      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 94 SB_2       57 LH_5       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 95 EBRKWFI2   b9 unxb9      0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 96 WFI_4      d4 aFault_2   0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 97 SB_4       b7 IJ_3       1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 98 BLT        29 XOR_1      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a MRET_6     57 LH_5       0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 9b LBU_3         (use dinx) 0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 9c BAERR_1       (use dinx) 0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00004073 close to csr/system 
 * 9d BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 9e BAERR_3    be IJ_1       0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * 9f SB_5       70 LHU_2      0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * a0 LHU_0      34 JAL_3      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 (null)     d2 LB_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a2 BAERR_4       (use dinx) 0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       0000500b close to ij
 * a3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000500f close to fence
 * a4 SRxI_0     6d unx6d      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 (null)     c8 unxc8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a6 NMI_1      60 unx60      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * a7 (null)     95 SW_E3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a8 JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   00005023 close to store
 * a9 (null)     57 LH_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * aa JAERR_2       (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  40005023 close to store
 * ab (null)     bb SH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ac _L0xac     7d BAERR_4    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ae _L0xae     7d BAERR_4    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af (null)     d7 ECALL_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b0 LBU_1      d0 ECALL_1    0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * b1 LB_6       b6 ECALL_5    0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * b2 _LCSRRS_1  82 unx82      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b3 ILL_3         (use dinx) 0010000000000000101011101100100110        Q = 1                                             00000000 
 * b4 NMI_2         (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * b5 LDAF_2     bd IJ_4       0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * b6 LDAF_3     bb SH_2       0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * b7 SW_E2      d5 unxd5      0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * b8 BGE        29 XOR_1      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SW_E4         (use dinx) 0000110000001110100111100x00101000        Store 6 to mcause                                 00005067 close to jalr
 * ba SW_E3      33 JAERR_1    0010000000000000101111001100100110        Q = 3                                             00000000 
 * bb ECALL_6    d1 MRET_1     0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * bc CSRRWI_0   8e _LCSRRS_1  0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SH_4       82 unx82      1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * be SH_5       3d SRxI_2     0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * bf ECALL_4    d6 eILL0c     0010000000000000101011001100100110        Q = 4                                             00000000 
 * c0 MRET_3        (use dinx) 0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00006003 close to load
 * c1 (null)     f0 LBU_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 ILL_4         (use dinx) 0000110000001110100111100x00100110        Store 2 to mcause                                 0000600b close to ij
 * c3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600f close to fence
 * c4 ORI_0      ea unxea      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c6 EBREAK_2   8a unx8a      0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * c7 (null)     dd aF_SW_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c8 MRET_4        (use dinx) 0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00006023 close to store
 * c9 (null)     c0 unxc0      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ca CSRRW_3       (use dinx) 0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     40006023 close to store
 * cb (null)     68 unx68      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * cc OR_0       41 JALR_1     0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ce aF_SW_3    fe ILLe       0000110000001110001011000x00100000        Store 7 to mcause                                 40006033 sloppy or      
 * cf (null)     15 condb_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d0 CSRRW_4    65 WFI_4      0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d1 SH_3       db jFault_1   0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d2 ECALL_5    09 LB_5       0010000000000000101011001100100110        Q = 8                                             00000000 
 * d3 IJ_3       39 unx39      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * d4 SH_2       b6 ECALL_5    0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d5 IJ_4          (use dinx) 0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * d6 IJT_2      fe ILLe       0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * d7 MRET_5     bf IJT_1      0010000000000000000011101100010xx0        ~302                                              00000000 
 * d8 BLTU       29 XOR_1      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 IJT_4         (use dinx) 0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00006067 close to jalr
 * da QINT_1     b5 SH_3       0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * db MRET_2     b6 ECALL_5    0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * dc CSRRSI_0   8e _LCSRRS_1  0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd QINT_2     ee eILL0a     0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * de _LCSRRCI_1 74 BrOpFet    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * df MRET_7     74 BrOpFet    0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * e0 aFault_2      (use dinx) 0000110000001110001011100x00100110        Store 5 to mcause                                 00007003 close to load
 * e1 (null)     37 ECALL_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 LDAF_a        (use dinx) 0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     33 JAERR_1    0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     ce _LCSRRCI_1 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 jFault_1   82 unx82      0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * e7 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 aF_SW_1       (use dinx) 0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00007023 close to store
 * e9 (null)     d9 unxd9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea ORI_1         (use dinx) 0010000000000000000011101100001xx0        Q = RS1                                           40007023 close to store
 * eb (null)     91 LDAF_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      22 unx22      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee aF_SW_2    fe ILLe       0010000000000000101011001100100110        Q = 4                                             40007033 sloppy and     
 * ef (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 IJT_3      9b unx9b      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * f1 LH_3       39 unx39      0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f2 WFI_2      68 unx68      0010000000000000101011101100100110        Check offset                                      00000000 
 * f3 SB_3       e8 unxe8      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f4 i0reserv      (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * f5 (null)     e6 StdIncPc   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     f2 SW_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     c6 IJT_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       29 XOR_1      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     97 SW_E1SWH   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   8e _LCSRRS_1  0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      a6 ECAL_RET   0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       88 unx88      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     da LDAF_a     0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0210, used dfff, inputs 99
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       6a unx6a      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       66 SW_1       0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     78 unx78      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     78 unx78      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   17 condb_5t   0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     86 JAL_2      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       ca unxca      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     86 JAL_2      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       5e LHU_1      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      1d ORI_2      0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 LW_1       ca unxca      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 11 LDAF_LW    2e unx2e      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 12 BrOpFet       (use dinx) 0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 13 BAlignEr   29 XOR_1      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 14 LW_1       2b SLTIX_1    0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 17 LB_5       12 unx12      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 18 BEQ        22 unx22      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     65 WFI_4      0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a JALR_2     78 unx78      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1b _L0x1b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   62 unx62      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d SUB_1      78 unx78      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 1e JAL_1      90 NMI_2      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 1f JAERR_1    ab EBREAK_2   0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 20 LH_0       3e SLL_1      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 AND_1      78 unx78      0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 22 condb_2       (use dinx) 0010000000000000111111101100000xx0        ~RS2 in Q                                         0000100b close to ij
 * 23 _L0x23     78 unx78      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     4d unx4d      0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 eILL0b     3a SRxI_1     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     31 SLTX_1     0010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     60 unx60      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_3    37 ECALL_2    0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2a _L0x2a     60 unx60      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_4    45 WFI_3      0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 2c SLL_0      5a SB_1       0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 (null)     78 unx78      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 31 ORI_2      41 JALR_1     0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 32 (null)     5e LHU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 aFault_1   c6 IJT_4      0010000000000000101011001100100110        Q = 4                                             00000000 
 * 34 (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 35 IJ_2       51 LDAF_LW    0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 XORI_1     6f MRET_6     0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 38 BNE        22 unx22      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 OR_1          (use dinx) 0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00001067 close to jalr
 * 3a OR_2       57 LH_5       0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 3b _L0x3b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    75 BAlignEr   0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d XOR_1      03 _L0x03     0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 3e LH_1       4d unx4d      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LH    55 aFaultb    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       14 condb_3    0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 SLTIX_1    1a ANDI_1     0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 42 LH_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     0000200b close to ij
 * 43 aFaultb       (use dinx) 0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       0000200f close to fence
 * 44 SLTI_0     41 JALR_1     0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 SLTIX_2    8e _LCSRRS_1  0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 46 LHU_1      73 BAERR_1    0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 47 LDAF_LHU   d9 unxd9      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 48 _L0x48     4e eILL0b     1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 SLTX_1     77 BAERR_3    0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 4a _L0x4a     4e eILL0b     1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b JAL_3      89 unx89      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 4c SLT_0      49 CSRRW_1    0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d SLLI_1        (use dinx) 0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 4e SW_1       fe ILLe       0000000000000011111011100100001xx0        Write d to a+k until accepted                     40002033 sloppy slt     
 * 4f SW_E1SWE   78 unx78      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 50 (null)     78 unx78      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 51 SLLI_2     92 LDAF_3     0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 52 (null)     42 unx42      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 ECALL_2    92 LDAF_3     0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 54 (null)     b6 ECALL_5    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 55 SRxI_1     33 JAERR_1    0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 56 (null)     7d BAERR_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 SRxI_2     ca unxca      0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 58 LHU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00002063 close to branch
 * 59 aFaultc       (use dinx) 0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00002067 close to jalr
 * 5a SLL_1      88 unx88      0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 5b _L0x5b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    75 BAlignEr   0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SRx_1      d2 LB_2       0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 5e JAL_2      58 unx58      0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 5f JALRE1     92 LDAF_3     0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 60 SH_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00003003 close to load
 * 61 SW_E1SWH   bb SH_2       0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 62 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000300b close to ij
 * 63 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000300f close to fence
 * 64 SLTIU_0    41 JALR_1     0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 JALR_1     7f JALRE2     0010000000000000000011101100100110        Q=1                                               00000000 
 * 66 IJ_1       9c unx9c      0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 67 IJT_1      de Fetch      0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 68 ECALL_1       (use dinx) 0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00003023 close to store
 * 69 MRET_1        (use dinx) 0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 6a LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     40003023 close to store
 * 6b aFaultd    be IJ_1       0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6c SLTU_0     49 CSRRW_1    0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d WFI_3         (use dinx) 0010000000000000101011101100100110        More check offset                                 00000000 
 * 6e eILL0c        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003033 sloppy sltu    
 * 6f ECALL_3    ef WFI_5      0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 70 (null)     ffffffff (null)     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 71 ILL_1      33 JAERR_1    0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 72 (null)     2e unx2e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 ILL_2      b9 unxb9      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 74 (null)     9e SH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 75 CSRRW_1    aa unxaa      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 76 (null)     bd IJ_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 CSRRW_2    bf IJT_1      0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 78 StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00003063 close to branch
 * 79 aFault        (use dinx) 0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00003067 close to jalr
 * 7a LH_4       9c unx9c      0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 7b _L0x7b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    75 BAlignEr   0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d LH_5       4b CSRRW_2    0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 7e eILL0a     da LDAF_a     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 7f WFI_5      bf IJT_1      0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 80 LBU_0      c8 unxc8      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 (null)     bf IJT_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 82 Fetch         (use dinx) 0000000000001000001111101010110000  Fr00  Read and latch instruction                        0000400b close to ij
 * 83 eFetch        (use dinx) 0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             0000400f close to fence
 * 84 XORI_0     37 ECALL_2    0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 86 SB_1       4b CSRRW_2    0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 87 (null)     c2 unxc2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 88 SB_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00004023 close to store
 * 89 CSRRW_3       (use dinx) 0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * 8a EBRKWFI2      (use dinx) 0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         40004023 close to store
 * 8b aF_SW_3    78 unx78      0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 8c XOR_0      3d SRxI_2     0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d CSRRW_4       (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * 8e WFI_4      fe ILLe       0010000000000000001011x01001xxxxx0        Prepare read PC                                   40004033 sloppy xor     
 * 8f SH_3       f9 unxf9      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * 90 aFault_2   4b CSRRW_2    0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 91 (null)     dd aF_SW_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 92 LDAF_a     4b CSRRW_2    0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * 93 (null)     e0 unxe0      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 94 jFault_1   4b CSRRW_2    0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 95 (null)     df eFetch     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 96 aF_SW_1    ad unxad      0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 97 (null)     de Fetch      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 98 BLT        22 unx22      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a LBU_2      4b CSRRW_2    0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 9b aFaulte       (use dinx) 0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 9c SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   00004073 close to csr/system 
 * 9d aF_SW         (use dinx) 0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 9e Fetch2     e8 unxe8      000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 9f jFault     9c unx9c      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * a0 LHU_0      46 ILL_1      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 (null)     a9 ILL_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a2 SB_4          (use dinx) 1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      0000500b close to ij
 * a3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000500f close to fence
 * a4 SRxI_0     55 aFaultb    0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 (null)     fb SB_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a6 MRET_6     68 unx68      0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * a7 (null)     8a unx8a      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a8 LBU_3         (use dinx) 0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00005023 close to store
 * a9 ECALL_5    4b CSRRW_2    0010000000000000101011001100100110        Q = 8                                             00000000 
 * aa BAERR_1       (use dinx) 0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             40005023 close to store
 * ab IJ_3       e2 unxe2      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ac _L0xac     5d SB_2       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad SH_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * ae _L0xae     5d SB_2       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af IJ_4       cb QINT_2     0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * b0 ORI_1      8d unx8d      0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * b1 (null)     dd aF_SW_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b2 aF_SW_2    82 unx82      0010000000000000101011001100100110        Q = 4                                             00000000 
 * b3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b4 IJT_3         (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b5 (null)     e6 StdIncPc   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b6 LH_3       e2 unxe2      0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * b7 (null)     af MRET_4     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b8 BGE        22 unx22      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00005067 close to jalr
 * ba WFI_1      2e unx2e      0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * bb EBREAK_1   8f ILL_3      0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * bc CSRRWI_0   75 BAlignEr   0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd BAERR_3    82 unx82      0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * be SB_5       35 SLLI_1     0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * bf BAERR_4    c9 MRET_2     0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * c0 NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00006003 close to load
 * c1 (null)     b4 i0reserv   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   0000600b close to ij
 * c3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600f close to fence
 * c4 ORI_0      b0 CSRRW_3    0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c6 JAERR_2    73 BAERR_1    0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * c7 (null)     eb LH_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c8 LBU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00006023 close to store
 * c9 IJT_2      ee eILL0a     0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * ca LB_6          (use dinx) 0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          40006023 close to store
 * cb MRET_5     78 unx78      0010000000000000000011101100010xx0        ~302                                              00000000 
 * cc OR_0       39 unx39      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd IJT_4         (use dinx) 0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * ce _LCSRRS_1  fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006033 sloppy or      
 * cf QINT_1     27 OR_2       0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * d0 WFI_2      53 LDAF_LH    0010000000000000101011101100100110        Check offset                                      00000000 
 * d1 (null)     e9 IJT_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 SB_3       09 LB_5       0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d3 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d4 i0reserv   dd aF_SW_1    xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     ea unxea      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       22 unx22      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 ILL_3         (use dinx) 0010000000000000101011101100100110        Q = 1                                             00006067 close to jalr
 * da NMI_2      db jFault_1   0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * db LDAF_2     dd aF_SW_1    0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * dc CSRRSI_0   75 BAlignEr   0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd LDAF_3     b2 CSRRW_4    0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * de SW_E2      9e SH_4       0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * df SW_E4      9e SH_4       0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * e0 SW_E3         (use dinx) 0010000000000000101111001100100110        Q = 3                                             00007003 close to load
 * e1 (null)     31 SLTX_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 ECALL_6       (use dinx) 0000110000001110100111000x00100000        mcause = 11                                       0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     2e unx2e      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     8b LB_6       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 SH_4       82 unx82      1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * e7 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 SH_5          (use dinx) 0000000000000001110011100100001xx0        Write d to a+k until accepted                     00007023 close to store
 * e9 MRET_2     cd unxcd      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * ea ECALL_4       (use dinx) 0010000000000000101011001100100110        Q = 4                                             40007023 close to store
 * eb QINT_2     7a SB_5       0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * ec AND_0      21 XORI_1     0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed _LCSRRCI_1    (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * ee MRET_3     fe ILLe       0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          40007033 sloppy and     
 * ef MRET_7     82 unx82      0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f0 (null)     a8 unxa8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     78 unx78      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     96 SH_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     94 SW_E4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     d0 ECALL_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     fa WFI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       22 unx22      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 ILL_4         (use dinx) 0000110000001110100111100x00100110        Store 2 to mcause                                 00007067 close to jalr
 * fa EBREAK_2   6d unx6d      0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * fb MRET_4     a2 unxa2      0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * fc CSRRCI_0   75 BAlignEr   0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      c0 unxc0      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       71 aFaultc    0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     cf MRET_7     0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 
 *  37  63 130 3135 Can not simplify, no legal mapping
 *  36  63 130 3135 Can not simplify, no legal mapping
 *  35  63  80 3185 
 * Candidate function 0120, used f7ff, inputs 1d
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       09 LB_5       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_3       6e unx6e      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 02 IJ_0       62 unx62      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     7e NMI_1      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     7e NMI_1      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    1a ANDI_1     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   1d ORI_2      0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     a6 ECAL_RET   0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_1       c1 IJT_2      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 0a _L0x0a     a6 ECAL_RET   0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LBU_1      58 unx58      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     7e NMI_1      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      22 unx22      0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     7e NMI_1      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 LH_1       c1 IJT_2      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 11 LDAF_LH    41 JALR_1     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 12 LHU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 13 LDAF_LHU   3a SRxI_1     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 14 aF_SW_1    3d SRxI_2     0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 15 (null)     06 LB_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 16 ORI_1      68 unx68      0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 17 (null)     30 SLTIX_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 18 BEQ        39 unx39      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     91 LDAF_2     0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_4       7e NMI_1      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 1b _L0x1b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   60 unx60      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d LB_5       7e NMI_1      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1e JAL_1      f9 unxf9      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 1f JAERR_1    e3 unxe3      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 20 LH_0       32 JAL_1      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 JALR_2     7e NMI_1      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 22 SUB_1         (use dinx) 0010000000000000111111101100000xx0        Q = ~RS2                                          0000100b close to ij
 * 23 _L0x23     7e NMI_1      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     7a SB_5       0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 eILL0b     5d SB_2       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     45 WFI_3      0010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     5e LHU_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 (null)     53 LDAF_LH    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 2a _L0x2a     5e LHU_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b (null)     6d unx6d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 2c SLL_0      8a unx8a      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     7e NMI_1      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e AND_1         (use dinx) 0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               40001033 sloppy sll     
 * 2f _L0x2f     7e NMI_1      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 BrOpFet    7e NMI_1      0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 31 BAlignEr   6a unx6a      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 32 LH_1       58 unx58      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 33 LDAF_LH    c0 unxc0      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 34 aF_SW_2    68 unx68      0010000000000000101011001100100110        Q = 4                                             00000000 
 * 35 (null)     7d BAERR_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 36 IJT_3      03 _L0x03     0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 37 (null)     79 unx79      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 38 BNE        39 unx39      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_2       (use dinx) 0010000000000000111111101100000xx0        ~RS2 in Q                                         00001067 close to jalr
 * 3a condb_3    88 unx88      0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 3b _L0x3b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    a1 ECALL_4    0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d condb_4    03 _L0x03     0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 3e LW_1       7a SB_5       0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    85 LBU_1      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 ANDI_1     21 XORI_1     0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 42 LH_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     0000200b close to ij
 * 43 aFaultb       (use dinx) 0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       0000200f close to fence
 * 44 SLTI_0     6a unx6a      0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 ORI_2      aa unxaa      0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 46 SW_1       9f SH_5       0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 47 SW_E1SWE   c3 unxc3      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 48 _L0x48     46 ILL_1      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 (null)     a2 unxa2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 4a _L0x4a     46 ILL_1      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b (null)     de Fetch      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 4c SLT_0      71 aFaultc    0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d aFault_1      (use dinx) 0010000000000000101011001100100110        Q = 4                                             00000000 
 * 4e LHU_2      fe ILLe       0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40002033 sloppy slt     
 * 4f aFaultc    7e NMI_1      0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 50 (null)     7e NMI_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 51 IJ_2       fa WFI_2      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 52 (null)     42 unx42      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 XORI_1     fa WFI_2      0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 54 LH_3       54 LH_2       0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 55 (null)     4d unx4d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 56 WFI_2      a5 MRET_3     0010000000000000101011101100100110        Check offset                                      00000000 
 * 57 (null)     c1 IJT_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 58 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             00002063 close to branch
 * 59 JALRE1        (use dinx) 0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00002067 close to jalr
 * 5a OR_1       a7 EBRKWFI1   0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 5b _L0x5b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    a1 ECALL_4    0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d OR_2       74 BrOpFet    0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5e SH_1       4e eILL0b     0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5f SW_E1SWH   fa WFI_2      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 60 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00003003 close to load
 * 61 EBRKWFI1   9d unx9d      0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 62 IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   0000300b close to ij
 * 63 IJT_1         (use dinx) 0010000010000000101111101100001xx0        Exit CSR, enter trap                              0000300f close to fence
 * 64 SLTIU_0    6a unx6a      0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XOR_1      83 unx83      0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 66 ECALL_1    8e _LCSRRS_1  0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 67 MRET_1     c8 unxc8      0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 68 Fetch         (use dinx) 0000000000001000001111101010110000  Fr00  Read and latch instruction                        00003023 close to store
 * 69 eFetch        (use dinx) 0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 6a SLTIX_1       (use dinx) 0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             40003023 close to store
 * 6b (null)     bb SH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 6c SLTU_0     71 aFaultc    0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SLTIX_2       (use dinx) 0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 6e LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     40003033 sloppy sltu    
 * 6f aFaultd    f3 aF_SW      0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 70 (null)     ffffffff (null)     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 71 SLTX_1     4d unx4d      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 72 (null)     41 JALR_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 JAL_3      b9 unxb9      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 74 SB_3       9a ECALL_6    0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * 75 (null)     b3 unxb3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 76 i0reserv   ba LHU_3      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * 77 (null)     bd IJ_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 78 eILL0c        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00003063 close to branch
 * 79 ECALL_3       (use dinx) 0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00003067 close to jalr
 * 7a SLLI_1     8e _LCSRRS_1  0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 7b _L0x7b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    a1 ECALL_4    0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SLLI_2     73 BAERR_1    0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 7e StdIncPc   c5 MRET_5     0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * 7f aFault     bd IJ_4       0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 80 LBU_0      0b JALR_2     0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 ECALL_2    bd IJ_4       0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 82 eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000400b close to ij
 * 83 WFI_5         (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch                                    0000400f close to fence
 * 84 XORI_0     53 LDAF_LH    0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SRxI_1     86 JAL_2      0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 86 LBU_2      73 BAERR_1    0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 87 aFaulte    bf IJT_1      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 88 SRxI_2        (use dinx) 0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00004023 close to store
 * 89 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 8a SLL_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              40004023 close to store
 * 8b (null)     7e NMI_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 8c XOR_0      65 WFI_4      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d SRx_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 8e SW_2       fe ILLe       0010000000000000001011x01000xxxxx0        Prepare read PC                                   40004033 sloppy xor     
 * 8f aF_SW      da LDAF_a     0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 90 (null)     73 BAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 91 JALR_1     c7 QINT_1     0010000000000000000011101100100110        Q=1                                               00000000 
 * 92 (null)     73 BAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 WFI_3      cd unxcd      0010000000000000101011101100100110        More check offset                                 00000000 
 * 94 (null)     73 BAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 95 (null)     ca unxca      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 96 (null)     e5 aF_SW_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 (null)     c8 unxc8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 98 BLT        39 unx39      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a Fetch2     73 BAERR_1    000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 9b jFault        (use dinx) 0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 9c WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   00004073 close to csr/system 
 * 9d EBREAK_1      (use dinx) 0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 9e ILL_1      d1 MRET_1     0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 9f ILL_2      8e _LCSRRS_1  0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * a0 LHU_0      12 unx12      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 CSRRW_1    e2 unxe2      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * a2 CSRRW_2       (use dinx) 0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    0000500b close to ij
 * a3 LH_4          (use dinx) 0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      0000500f close to fence
 * a4 SRxI_0     85 LBU_1      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 LH_5       dd aF_SW_1    0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * a6 SB_1       66 SW_1       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * a7 SB_2       a8 unxa8      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * a8 EBRKWFI2      (use dinx) 0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00005023 close to store
 * a9 (null)     73 BAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * aa WFI_4         (use dinx) 0010000000000000001011x01001xxxxx0        Prepare read PC                                   40005023 close to store
 * ab (null)     ce _LCSRRCI_1 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ac _L0xac     8d unx8d      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad SB_4          (use dinx) 1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * ae _L0xae     8d unx8d      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_6     e8 unxe8      0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * b0 (null)     e0 unxe0      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b1 LBU_3      c7 QINT_1     0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * b2 (null)     68 unx68      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 BAERR_1       (use dinx) 0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * b4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b5 (null)     cf MRET_7     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b6 (null)     ce _LCSRRCI_1 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 (null)     e6 StdIncPc   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b8 BGE        39 unx39      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00005067 close to jalr
 * ba BAERR_3    41 JALR_1     0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * bb SB_5       e1 ORI_1      0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * bc CSRRWI_0   a1 ECALL_4    0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd BAERR_4    68 unx68      0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * be NMI_1      51 LDAF_LW    0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * bf JALRE2     e7 aFault     0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * c0 JAERR_2       (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  00006003 close to load
 * c1 LB_6       36 SLLI_2     0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * c2 _LCSRRS_1     (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000600b close to ij
 * c3 ILL_3         (use dinx) 0010000000000000101011101100100110        Q = 1                                             0000600f close to fence
 * c4 ORI_0      16 condb_5    0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 NMI_2      af MRET_4     0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * c6 LDAF_2     9f SH_5       0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * c7 LDAF_3     ef WFI_5      0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * c8 SW_E2         (use dinx) 0000000000001101101111101000001xx0        Store address that faulted                        00006023 close to store
 * c9 (null)     d9 unxd9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ca SW_E4         (use dinx) 0000110000001110100111100x00101000        Store 6 to mcause                                 40006023 close to store
 * cb (null)     7e NMI_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * cc OR_0       5a SB_1       0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd SW_E3         (use dinx) 0010000000000000101111001100100110        Q = 3                                             00000000 
 * ce ECALL_6    fe ILLe       0000110000001110100111000x00100000        mcause = 11                                       40006033 sloppy or      
 * cf SH_4       27 OR_2       1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * d0 (null)     81 JAERR_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 SH_5       ee eILL0a     0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * d2 (null)     01 LB_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 ECALL_4    4d unx4d      0010000000000000101011001100100110        Q = 4                                             00000000 
 * d4 (null)     c7 QINT_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     d3 aFaultd    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       39 unx39      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MRET_3        (use dinx) 0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00006067 close to jalr
 * da ILL_4      c6 IJT_4      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * db EBREAK_2   c7 QINT_1     0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * dc CSRRSI_0   a1 ECALL_4    0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd MRET_4     34 JAL_3      0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * de CSRRW_3    9a ECALL_6    0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * df aF_SW_3    9a ECALL_6    0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * e0 CSRRW_4       (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00007003 close to load
 * e1 SH_3       45 WFI_3      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e2 ECALL_5       (use dinx) 0010000000000000101011001100100110        Q = 8                                             0000700b close to ij
 * e3 IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   0000700f close to fence
 * e4 ANDI_0     41 JALR_1     0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 SH_2       df eFetch     0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * e6 IJ_4       68 unx68      0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * e7 IJT_2      4d unx4d      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * e8 MRET_5        (use dinx) 0010000000000000000011101100010xx0        ~302                                              00007023 close to store
 * e9 (null)     ea unxea      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea IJT_4         (use dinx) 0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    40007023 close to store
 * eb (null)     a3 unxa3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      2e unx2e      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed QINT_1        (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * ee MRET_2     fe ILLe       0010000000000000011011001100100000        0xff+3 = 0x102                                    40007033 sloppy and     
 * ef QINT_2     68 unx68      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * f0 (null)     b1 aF_SW_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 _LCSRRCI_1 4d unx4d      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * f2 (null)     7e NMI_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 MRET_7     14 condb_3    0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     fb SB_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     56 LH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     db jFault_1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       39 unx39      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 aFault_2      (use dinx) 0000110000001110001011100x00100110        Store 5 to mcause                                 00007067 close to jalr
 * fa LDAF_a     93 SW_E2      0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * fb jFault_1   ad unxad      0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * fc CSRRCI_0   a1 ECALL_4    0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      be IJ_1       0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       9e SH_4       0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     ed unxed      0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0210, used dfff, inputs 59
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       30 SLTIX_2    0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_3       8e _LCSRRS_1  0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 02 IJ_0       88 unx88      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     9c unx9c      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     9c unx9c      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    09 LB_5       0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   0b JALR_2     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     a1 ECALL_4    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_4       c2 unxc2      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0a _L0x0a     a1 ECALL_4    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_5       7e NMI_1      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     9c unx9c      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      1d ORI_2      0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     9c unx9c      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 LH_1       c2 unxc2      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 11 LDAF_LH    2e unx2e      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 12 LHU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 13 LDAF_LHU   29 XOR_1      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 14 BrOpFet    2b SLTIX_1    0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 15 BAlignEr   06 LB_3       0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 16 LH_1       42 unx42      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    14 condb_3    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        22 unx22      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     7d BAERR_4    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a JALR_2     9c unx9c      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1b _L0x1b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   86 JAL_2      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d SUB_1      9c unx9c      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 1e JAL_1      eb LH_3       0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 1f JAERR_1    4d unx4d      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 20 LH_0       16 condb_5    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 AND_1      9c unx9c      0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 22 condb_2       (use dinx) 0010000000000000111111101100000xx0        ~RS2 in Q                                         0000100b close to ij
 * 23 _L0x23     9c unx9c      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     60 unx60      0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 eILL0b     3a SRxI_1     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     31 SLTX_1     0010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     82 unx82      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_3    37 ECALL_2    0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2a _L0x2a     82 unx82      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_4    4e eILL0b     0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 2c SLL_0      6e unx6e      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     9c unx9c      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     9c unx9c      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LB_1       9c unx9c      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 31 ORI_2      46 ILL_1      0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 32 LBU_1      7e NMI_1      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 33 aFault_1   c0 unxc0      0010000000000000101011001100100110        Q = 4                                             00000000 
 * 34 (null)     42 unx42      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 35 IJ_2       62 unx62      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 XORI_1     9b unx9b      0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 38 BNE        22 unx22      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 OR_1          (use dinx) 0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00001067 close to jalr
 * 3a OR_2       6a unx6a      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 3b _L0x3b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    91 LDAF_2     0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d XOR_1      03 _L0x03     0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 3e LW_1       60 unx60      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    68 unx68      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 (null)     1a ANDI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 42 Fetch         (use dinx) 0000000000001000001111101010110000  Fr00  Read and latch instruction                        0000200b close to ij
 * 43 eFetch        (use dinx) 0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             0000200f close to fence
 * 44 SLTI_0     46 ILL_1      0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 (null)     af MRET_4     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 46 SLTIX_1    8d unx8d      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 47 (null)     c8 unxc8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 48 _L0x48     5e LHU_1      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 SH_3       93 SW_E2      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * 4a _L0x4a     5e LHU_1      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b ECALL_5    f9 unxf9      0010000000000000101011001100100110        Q = 8                                             00000000 
 * 4c SLT_0      5a SB_1       0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 4e SLTIX_2    fe ILLe       0000000000000100001011101000110010        Registered ALU flag to rd                         40002033 sloppy slt     
 * 4f SH_2       9c unx9c      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 50 aF_SW_1    9c unx9c      0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 51 (null)     ed unxed      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 52 ORI_1      58 unx58      0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 53 (null)     ed unxed      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 54 aF_SW_2    70 LHU_2      0010000000000000101011001100100110        Q = 4                                             00000000 
 * 55 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 56 IJT_3      97 SW_E1SWH   0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 57 (null)     c2 unxc2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 58 LH_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00002063 close to branch
 * 59 aFaultb       (use dinx) 0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00002067 close to jalr
 * 5a SLTX_1     a5 MRET_3     0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 5b _L0x5b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    91 LDAF_2     0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d JAL_3      74 BrOpFet    0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 5e SW_1       78 unx78      0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 5f SW_E1SWE   ed unxed      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 60 SLLI_1        (use dinx) 0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00003003 close to load
 * 61 (null)     ab EBREAK_2   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 62 SLLI_2        (use dinx) 0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                0000300b close to ij
 * 63 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000300f close to fence
 * 64 SLTIU_0    46 ILL_1      0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 (null)     9f SH_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 66 ECALL_2    a6 ECAL_RET   0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 67 (null)     da LDAF_a     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 68 SRxI_1        (use dinx) 0000000000000100101001101100001xx1        Register to shift to Q                            00003023 close to store
 * 69 IJ_4          (use dinx) 0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * 6a SRxI_2        (use dinx) 0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                40003023 close to store
 * 6b IJT_2      bb SH_2       0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * 6c SLTU_0     5a SB_1       0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MRET_5        (use dinx) 0010000000000000000011101100010xx0        ~302                                              00000000 
 * 6e SLL_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              40003033 sloppy sltu    
 * 6f IJT_4      e9 IJT_3      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * 70 LH_3       ffffffff (null)     0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 71 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 72 WFI_2      2e unx2e      0010000000000000101011101100100110        Check offset                                      00000000 
 * 73 (null)     b9 unxb9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 74 SB_3       a8 unxa8      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * 75 (null)     b7 IJ_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 76 i0reserv   ba LHU_3      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * 77 (null)     bd IJ_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 78 LHU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00003063 close to branch
 * 79 aFaultc       (use dinx) 0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00003067 close to jalr
 * 7a SRx_1      a6 ECAL_RET   0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 7b _L0x7b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    91 LDAF_2     0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d JALR_1     5d SB_2       0010000000000000000011101100100110        Q=1                                               00000000 
 * 7e JAL_2      ca unxca      0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 7f JALRE1     bd IJ_4       0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 80 LBU_0      32 JAL_1      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 WFI_3      bd IJ_4       0010000000000000101011101100100110        More check offset                                 00000000 
 * 82 SH_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        0000400b close to ij
 * 83 SW_E1SWH      (use dinx) 0000000000001111001011100x00110000        Store faulting address alignment to mtval         0000400f close to fence
 * 84 XORI_0     37 ECALL_2    0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 ILL_1      a2 unxa2      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 86 ECAL_RET   5d SB_2       0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 87 EBRKWFI1   bf IJT_1      0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 88 IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00004023 close to store
 * 89 IJT_1         (use dinx) 0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 8a ECALL_1       (use dinx) 0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40004023 close to store
 * 8b MRET_1     9c unx9c      0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 8c XOR_0      3d SRxI_2     0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d ILL_2         (use dinx) 0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 8e LB_2       fe ILLe       0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     40004033 sloppy xor     
 * 8f aFaultd    e8 unxe8      0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 90 (null)     5d SB_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 91 CSRRW_1    d9 unxd9      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 92 (null)     5d SB_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 CSRRW_2    dd aF_SW_1    0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 94 (null)     5d SB_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 95 LH_4       db jFault_1   0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 96 (null)     4f MRET_8     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 LH_5       da LDAF_a     0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 98 BLT        22 unx22      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a eILL0c     5d SB_2       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 9b ECALL_3       (use dinx) 0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 9c StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00004073 close to csr/system 
 * 9d aFault        (use dinx) 0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 9e eILL0a     e0 unxe0      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 9f WFI_5      a6 ECAL_RET   0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * a0 LHU_0      12 unx12      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SB_1       4b CSRRW_2    0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * a2 LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     0000500b close to ij
 * a3 aFaulte       (use dinx) 0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      0000500f close to fence
 * a4 SRxI_0     68 unx68      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SB_2       ee eILL0a     0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * a6 SW_2       8a unx8a      0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * a7 aF_SW      ad unxad      0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * a8 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00005023 close to store
 * a9 jFault     5d SB_2       0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * aa WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   40005023 close to store
 * ab EBREAK_1   de Fetch      0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * ac _L0xac     7a SB_5       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad EBRKWFI2      (use dinx) 0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * ae _L0xae     7a SB_5       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af WFI_4      6d unx6d      0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * b0 (null)     fb SB_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b1 SB_4       d9 unxd9      1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b2 (null)     42 unx42      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 MRET_6        (use dinx) 0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * b4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b5 LBU_3      df eFetch     0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * b6 (null)     de Fetch      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 BAERR_1    69 unx69      0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * b8 BGE        22 unx22      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00005067 close to jalr
 * ba BAERR_3    2e unx2e      0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * bb SB_5       49 CSRRW_1    0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * bc CSRRWI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd BAERR_4    42 unx42      0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * be NMI_1      35 SLLI_1     0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * bf JALRE2     6b SB_4       0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * c0 JAERR_2       (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  00006003 close to load
 * c1 (null)     56 LH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 LB_6          (use dinx) 0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          0000600b close to ij
 * c3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600f close to fence
 * c4 ORI_0      52 LH_1       0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     b3 unxb3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c6 _LCSRRS_1  8d unx8d      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * c7 (null)     cd unxcd      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c8 ILL_3         (use dinx) 0010000000000000101011101100100110        Q = 1                                             00006023 close to store
 * c9 QINT_1     e6 StdIncPc   0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * ca NMI_2         (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        40006023 close to store
 * cb MRET_2     9c unx9c      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * cc OR_0       39 unx39      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd QINT_2        (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * ce LDAF_2     fe ILLe       0000110000001110001011000x00100110        Store 4 to mcause                                 40006033 sloppy or      
 * cf _LCSRRCI_1 27 OR_2       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d0 (null)     66 SW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 (null)     cb QINT_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 (null)     01 LB_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d4 (null)     d9 unxd9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     e2 unxe2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       22 unx22      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 LDAF_3        (use dinx) 0000000000001101100111100x00001xx0        PC to mepc                                        00006067 close to jalr
 * da SW_E2      ce _LCSRRCI_1 0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * db SW_E4      d9 unxd9      0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * dc CSRRSI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd SW_E3      54 LH_2       0010000000000000101111001100100110        Q = 3                                             00000000 
 * de ECALL_6    a8 unxa8      0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * df SH_4       a8 unxa8      1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * e0 SH_5          (use dinx) 0000000000000001110011100100001xx0        Write d to a+k until accepted                     00007003 close to load
 * e1 (null)     31 SLTX_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 ECALL_4       (use dinx) 0010000000000000101011001100100110        Q = 4                                             0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     2e unx2e      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     fa WFI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 MRET_3     42 unx42      0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * e7 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 ILL_4         (use dinx) 0000110000001110100111100x00100110        Store 2 to mcause                                 00007023 close to store
 * e9 MRET_7     6f MRET_6     0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * ea EBREAK_2      (use dinx) 0000000000001101101011101000001xx0        pc to mepc                                        40007023 close to store
 * eb aFault_2   95 SW_E3      0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * ec AND_0      21 XORI_1     0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed LDAF_a        (use dinx) 0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * ee MRET_4     fe ILLe       0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          40007033 sloppy and     
 * ef jFault_1   42 unx42      0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * f0 (null)     b5 SH_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     9c unx9c      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     50 LW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     ef WFI_5      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     72 LBU_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     ea unxea      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       22 unx22      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 CSRRW_3       (use dinx) 0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00007067 close to jalr
 * fa aF_SW_3    81 JAERR_2    0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * fb CSRRW_4    b1 aF_SW_3    0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * fc CSRRCI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      be IJ_1       0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       85 LBU_1      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     c9 MRET_2     0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0210, used dfff, inputs 99
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       30 SLTIX_2    0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_3       68 unx68      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 02 IJ_0       62 unx62      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     6e unx6e      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     6e unx6e      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    09 LB_5       0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   0b JALR_2     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     86 JAL_2      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_4       c2 unxc2      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0a _L0x0a     86 JAL_2      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_5       58 unx58      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     6e unx6e      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      1d ORI_2      0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     6e unx6e      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 LH_1       c2 unxc2      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 11 LDAF_LH    2e unx2e      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 12 LHU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 13 LDAF_LHU   29 XOR_1      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 14 BrOpFet    2b SLTIX_1    0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 15 BAlignEr   06 LB_3       0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 16 LH_1       82 unx82      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    14 condb_3    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        22 unx22      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     65 WFI_4      0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a JALR_2     6e unx6e      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1b _L0x1b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   60 unx60      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d SUB_1      6e unx6e      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 1e JAL_1      eb LH_3       0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 1f JAERR_1    8d unx8d      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 20 LH_0       16 condb_5    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 AND_1      6e unx6e      0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 22 condb_2       (use dinx) 0010000000000000111111101100000xx0        ~RS2 in Q                                         0000100b close to ij
 * 23 _L0x23     6e unx6e      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     4d unx4d      0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 eILL0b     3a SRxI_1     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     31 SLTX_1     0010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     5e LHU_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_3    37 ECALL_2    0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2a _L0x2a     5e LHU_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_4    45 WFI_3      0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 2c SLL_0      5a SB_1       0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     6e unx6e      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     6e unx6e      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LB_1       6e unx6e      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 31 ORI_2      41 JALR_1     0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 32 LBU_1      58 unx58      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 33 aFault_1   c0 unxc0      0010000000000000101011001100100110        Q = 4                                             00000000 
 * 34 (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 35 IJ_2       51 LDAF_LW    0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 XORI_1     6b SB_4       0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 38 BNE        22 unx22      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 OR_1          (use dinx) 0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00001067 close to jalr
 * 3a OR_2       57 LH_5       0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 3b _L0x3b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    75 BAlignEr   0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d XOR_1      03 _L0x03     0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 3e LW_1       4d unx4d      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    55 aFaultb    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 SLTIX_1    1a ANDI_1     0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 42 LH_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     0000200b close to ij
 * 43 aFaultb       (use dinx) 0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       0000200f close to fence
 * 44 SLTI_0     41 JALR_1     0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 SLTIX_2    8e _LCSRRS_1  0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 46 SW_1       73 BAERR_1    0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 47 SW_E1SWE   c8 unxc8      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 48 _L0x48     46 ILL_1      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 SLTX_1     77 BAERR_3    0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 4a _L0x4a     46 ILL_1      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b JAL_3      f9 unxf9      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 4c SLT_0      49 CSRRW_1    0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d SLLI_1        (use dinx) 0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 4e LHU_2      fe ILLe       0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40002033 sloppy slt     
 * 4f aFaultc    6e unx6e      0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 50 (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 51 SLLI_2     ed unxed      0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 52 (null)     42 unx42      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 ECALL_2    ed unxed      0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 54 (null)     b0 CSRRW_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 55 SRxI_1     33 JAERR_1    0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 56 (null)     7d BAERR_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 SRxI_2     c2 unxc2      0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 58 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             00002063 close to branch
 * 59 JALRE1        (use dinx) 0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00002067 close to jalr
 * 5a SLL_1      88 unx88      0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 5b _L0x5b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    75 BAlignEr   0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SRx_1      b4 i0reserv   0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 5e SH_1       4e eILL0b     0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5f SW_E1SWH   ed unxed      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 60 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00003003 close to load
 * 61 EBRKWFI1   9f SH_5       0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 62 IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   0000300b close to ij
 * 63 IJT_1         (use dinx) 0010000010000000101111101100001xx0        Exit CSR, enter trap                              0000300f close to fence
 * 64 SLTIU_0    41 JALR_1     0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 JALR_1     79 unx79      0010000000000000000011101100100110        Q=1                                               00000000 
 * 66 ECALL_1    9a ECALL_6    0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 67 MRET_1     da LDAF_a     0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 68 LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd       (use dinx) 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    bb SH_2       0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     49 CSRRW_1    0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d WFI_3         (use dinx) 0010000000000000101011101100100110        More check offset                                 00000000 
 * 6e StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    40003033 sloppy sltu    
 * 6f aFault     e9 IJT_3      0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 70 (null)     ffffffff (null)     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 71 ILL_1      33 JAERR_1    0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 72 (null)     2e unx2e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 ILL_2      b9 unxb9      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 74 (null)     9c unx9c      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 75 CSRRW_1    aa unxaa      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 76 (null)     ba LHU_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 CSRRW_2    bd IJ_4       0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 78 eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00003063 close to branch
 * 79 WFI_5         (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch                                    00003067 close to jalr
 * 7a LH_4       9a ECALL_6    0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 7b _L0x7b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    75 BAlignEr   0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d LH_5       4b CSRRW_2    0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 7e LBU_2      ca unxca      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 7f aFaulte    bd IJ_4       0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 80 LBU_0      32 JAL_1      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 (null)     bd IJ_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 82 Fetch         (use dinx) 0000000000001000001111101010110000  Fr00  Read and latch instruction                        0000400b close to ij
 * 83 eFetch        (use dinx) 0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             0000400f close to fence
 * 84 XORI_0     37 ECALL_2    0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 (null)     7e NMI_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 86 SB_1       4b CSRRW_2    0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 87 (null)     bf IJT_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 88 SB_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00004023 close to store
 * 89 SH_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * 8a EBRKWFI2      (use dinx) 0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         40004023 close to store
 * 8b ECALL_5    6e unx6e      0010000000000000101011001100100110        Q = 8                                             00000000 
 * 8c XOR_0      3d SRxI_2     0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 8e WFI_4      fe ILLe       0010000000000000001011x01001xxxxx0        Prepare read PC                                   40004033 sloppy xor     
 * 8f SH_2       e8 unxe8      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * 90 aF_SW_1    4b CSRRW_2    0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 91 (null)     d9 unxd9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 92 ORI_1      4b CSRRW_2    0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 93 (null)     dd aF_SW_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 94 aF_SW_2    4b CSRRW_2    0010000000000000101011001100100110        Q = 4                                             00000000 
 * 95 (null)     db jFault_1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 96 IJT_3      8f ILL_3      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 97 (null)     da LDAF_a     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 98 BLT        22 unx22      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a SW_2       4b CSRRW_2    0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 9b aF_SW         (use dinx) 0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 9c Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00004073 close to csr/system 
 * 9d jFault        (use dinx) 0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 9e WFI_1      e0 unxe0      0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 9f EBREAK_1   9a ECALL_6    0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * a0 LHU_0      12 unx12      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 (null)     8b LB_6       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a2 SB_4          (use dinx) 1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      0000500b close to ij
 * a3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000500f close to fence
 * a4 SRxI_0     55 aFaultb    0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 (null)     ee eILL0a     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a6 MRET_6     66 SW_1       0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * a7 (null)     8a unx8a      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a8 LBU_3         (use dinx) 0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00005023 close to store
 * a9 IJ_4       4b CSRRW_2    0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * aa BAERR_1       (use dinx) 0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             40005023 close to store
 * ab IJT_2      de Fetch      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * ac _L0xac     5d SB_2       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad MRET_5        (use dinx) 0010000000000000000011101100010xx0        ~302                                              00000000 
 * ae _L0xae     5d SB_2       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af IJT_4      ad unxad      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * b0 LH_3       fb SB_3       0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * b1 (null)     d9 unxd9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b2 WFI_2      82 unx82      0010000000000000101011101100100110        Check offset                                      00000000 
 * b3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b4 SB_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b5 (null)     df eFetch     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b6 i0reserv   de Fetch      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * b7 (null)     a9 ILL_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b8 BGE        22 unx22      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00005067 close to jalr
 * ba BAERR_3    2e unx2e      0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * bb SB_5       89 unx89      0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * bc CSRRWI_0   75 BAlignEr   0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd BAERR_4    82 unx82      0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * be NMI_1      35 SLLI_1     0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * bf JALRE2     ab EBREAK_2   0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * c0 JAERR_2       (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  00006003 close to load
 * c1 (null)     96 SH_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 LB_6          (use dinx) 0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          0000600b close to ij
 * c3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600f close to fence
 * c4 ORI_0      92 LDAF_3     0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c6 _LCSRRS_1  73 BAERR_1    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * c7 (null)     cd unxcd      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c8 ILL_3         (use dinx) 0010000000000000101011101100100110        Q = 1                                             00006023 close to store
 * c9 QINT_1     e6 StdIncPc   0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * ca NMI_2         (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        40006023 close to store
 * cb MRET_2     6e unx6e      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * cc OR_0       39 unx39      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd QINT_2        (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * ce LDAF_2     fe ILLe       0000110000001110001011000x00100110        Store 4 to mcause                                 40006033 sloppy or      
 * cf _LCSRRCI_1 27 OR_2       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d0 (null)     53 LDAF_LH    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 (null)     cb QINT_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 (null)     01 LB_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d4 (null)     d9 unxd9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     e2 unxe2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       22 unx22      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 LDAF_3        (use dinx) 0000000000001101100111100x00001xx0        PC to mepc                                        00006067 close to jalr
 * da SW_E2      ce _LCSRRCI_1 0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * db SW_E4      d9 unxd9      0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * dc CSRRSI_0   75 BAlignEr   0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd SW_E3      94 SW_E4      0010000000000000101111001100100110        Q = 3                                             00000000 
 * de ECALL_6    9c unx9c      0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * df SH_4       9c unx9c      1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * e0 SH_5          (use dinx) 0000000000000001110011100100001xx0        Write d to a+k until accepted                     00007003 close to load
 * e1 (null)     31 SLTX_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 ECALL_4       (use dinx) 0010000000000000101011001100100110        Q = 4                                             0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     2e unx2e      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     fa WFI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 MRET_3     82 unx82      0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * e7 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 ILL_4         (use dinx) 0000110000001110100111100x00100110        Store 2 to mcause                                 00007023 close to store
 * e9 MRET_7     af MRET_4     0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * ea EBREAK_2      (use dinx) 0000000000001101101011101000001xx0        pc to mepc                                        40007023 close to store
 * eb aFault_2   7a SB_5       0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * ec AND_0      21 XORI_1     0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed LDAF_a        (use dinx) 0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * ee MRET_4     fe ILLe       0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          40007033 sloppy and     
 * ef jFault_1   82 unx82      0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * f0 (null)     a8 unxa8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     90 NMI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     ef WFI_5      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     b2 CSRRW_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     ea unxea      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       22 unx22      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 CSRRW_3       (use dinx) 0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00007067 close to jalr
 * fa aF_SW_3    6d unx6d      0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * fb CSRRW_4    a2 unxa2      0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * fc CSRRCI_0   75 BAlignEr   0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      be IJ_1       0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       71 aFaultc    0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     c9 MRET_2     0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 
 *  34  66 128 3902 Can not simplify, no legal mapping
 *  33  66 253 3777 Can not simplify, no legal mapping
 *  32  82 160 3854 Can not simplify, no legal mapping
 *  31  82 256 3758 Can not simplify, can't represent fixed locations with any less than 7 bits of the index
 *  30  66  16 4014 
 * Candidate function 0040, used fffd, inputs 0f
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       09 LB_5       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 02 IJ_0       68 unx68      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     78 unx78      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     78 unx78      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 Fetch2     10 SUB_1      000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 07 jFault     1a ANDI_1     0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 08 _L0x08     90 NMI_2      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_1       a8 unxa8      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 0a _L0x0a     90 NMI_2      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_3       58 unx58      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      22 unx22      0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 LB_4       a8 unxa8      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 11 (null)     30 SLTIX_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 12 condb_5       (use dinx) 0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 13 condb_5t   2b SLTIX_1    0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 14 JAL_1      2e unx2e      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 15 JAERR_1    12 unx12      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 16 Fetch2     74 BrOpFet    000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 17 jFault     54 LH_2       0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 18 BEQ        29 XOR_1      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     77 BAERR_3    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       78 unx78      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     14 condb_3    0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   62 unx62      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     78 unx78      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e eILL0b     d4 aFault_2   0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 1f MRET_8     c7 QINT_1     0010000000000000101011101100100110        Prep +4                                           00000000 
 * 20 LH_0       34 JAL_3      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 (null)     78 unx78      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 22 SUB_1         (use dinx) 0010000000000000111111101100000xx0        Q = ~RS2                                          0000100b close to ij
 * 23 _L0x23     78 unx78      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     5a SB_1       0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 (null)     47 ILL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 27 AND_1      37 ECALL_2    0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 28 _L0x28     5e LHU_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_2    3d SRxI_2     0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2a _L0x2a     5e LHU_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_3    4d unx4d      0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2c SLL_0      6d unx6d      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_4       (use dinx) 0010000000000000110011101101001xx0        Branch on condition                               40001033 sloppy sll     
 * 2f _L0x2f     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 ANDI_1     78 unx78      0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 31 (null)     4b CSRRW_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 32 LW_1       58 unx58      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 33 LDAF_LW    a5 MRET_3     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 34 LH_1       74 BrOpFet    0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 35 LDAF_LH    5d SB_2       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 ORI_2      73 BAERR_1    0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 38 BNE        29 XOR_1      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 aFault_1      (use dinx) 0010000000000000101011001100100110        Q = 4                                             00001067 close to jalr
 * 3a IJ_2       67 SW_E1SWE   0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 3b _L0x3b     14 condb_3    0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    87 JALRE1     0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d XORI_1     03 _L0x03     0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 3e LH_2       5a SB_1       0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultb    65 WFI_4      0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 40 LW_0       32 JAL_1      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 (null)     1d ORI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 42 LHU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LHU      (use dinx) 0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     4b CSRRW_2    0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 OR_1       94 SW_E4      0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 46 (null)     85 LBU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 47 OR_2       aa unxaa      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 48 _L0x48     4e eILL0b     1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XOR_1      8d unx8d      0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 4a _L0x4a     4e eILL0b     1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b SLTIX_1    bf IJT_1      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 4c SLT_0      50 LW_1       0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d SLTIX_2       (use dinx) 0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 4e SW_1       fe ILLe       0000000000000011111011100100001xx0        Write d to a+k until accepted                     40002033 sloppy slt     
 * 4f SW_E1SWE   78 unx78      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 50 SLTX_1     78 unx78      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 51 (null)     d5 unxd5      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 52 LHU_2      3e SLL_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 53 aFaultc    d5 unxd5      0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 54 BrOpFet    de Fetch      0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 55 BAlignEr   39 unx39      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 56 (null)     8f ILL_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 JAL_3      a8 unxa8      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 58 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             00002063 close to branch
 * 59 JALRE1        (use dinx) 0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00002067 close to jalr
 * 5a SLLI_1     92 LDAF_3     0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 5b _L0x5b     14 condb_3    0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    87 JALRE1     0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLLI_2     e0 unxe0      0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 5e SH_1       52 LH_1       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5f SW_E1SWH   d5 unxd5      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 60 ECALL_2       (use dinx) 0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00003003 close to load
 * 61 (null)     8b LB_6       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 62 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000300b close to ij
 * 63 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000300f close to fence
 * 64 SLTIU_0    4b CSRRW_2    0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SRxI_1     7f JALRE2     0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 66 (null)     88 unx88      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 67 SRxI_2     b0 CSRRW_3    0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 68 IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00003023 close to store
 * 69 IJT_1         (use dinx) 0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 6a ECALL_1       (use dinx) 0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40003023 close to store
 * 6b MRET_1     9e SH_4       0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 6c SLTU_0     50 LW_1       0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SLL_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 6e LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     40003033 sloppy sltu    
 * 6f aFaultd    d3 aFaultd    0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 70 SRx_1      ffffffff (null)     0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 71 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 72 eILL0c     30 SLTIX_2    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 73 ECALL_3    9c unx9c      0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 74 Fetch      16 condb_5    0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 75 eFetch     9b unx9b      0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 76 (null)     9d unx9d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 JALR_1     9f SH_5       0010000000000000000011101100100110        Q=1                                               00000000 
 * 78 StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00003063 close to branch
 * 79 aFault        (use dinx) 0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00003067 close to jalr
 * 7a WFI_3      88 unx88      0010000000000000101011101100100110        More check offset                                 00000000 
 * 7b _L0x7b     14 condb_3    0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    87 JALRE1     0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d ILL_1      57 LH_5       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 7e eILL0a     ab EBREAK_2   0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 7f WFI_5      9f SH_5       0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 80 LBU_0      a7 EBRKWFI1   0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 (null)     9f SH_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 82 LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     0000400b close to ij
 * 83 aFaulte       (use dinx) 0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      0000400f close to fence
 * 84 XORI_0     3d SRxI_2     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 ILL_2      82 unx82      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 86 (null)     57 LH_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 87 CSRRW_1    a3 unxa3      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 88 SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   00004023 close to store
 * 89 aF_SW         (use dinx) 0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 8a WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   40004023 close to store
 * 8b EBREAK_1   78 unx78      0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 8c XOR_0      49 CSRRW_1    0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d CSRRW_2       (use dinx) 0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 8e LH_4       fe ILLe       0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      40004033 sloppy xor     
 * 8f LH_5       bb SH_2       0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 90 SB_1       57 LH_5       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 91 (null)     af MRET_4     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 92 SB_2       57 LH_5       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 93 EBRKWFI2   b3 unxb3      0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 94 WFI_4      57 LH_5       0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 95 SB_4       b2 CSRRW_4    1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 96 (null)     c8 unxc8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 MRET_6     b0 CSRRW_3    0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 98 BLT        29 XOR_1      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a LBU_3      57 LH_5       0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 9b BAERR_1       (use dinx) 0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 9c BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00004073 close to csr/system 
 * 9d BAERR_3       (use dinx) 0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * 9e SB_5       b7 IJ_3       0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 9f BAERR_4    88 unx88      0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * a0 LHU_0      42 unx42      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 (null)     c5 MRET_5     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a2 NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 0000500b close to ij
 * a3 JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   0000500f close to fence
 * a4 SRxI_0     65 WFI_4      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 JAERR_2    be IJ_1       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * a6 (null)     6a unx6a      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a7 LBU_1      93 SW_E2      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * a8 LB_6          (use dinx) 0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00005023 close to store
 * a9 _LCSRRS_1  57 LH_5       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * aa ILL_3         (use dinx) 0010000000000000101011101100100110        Q = 1                                             40005023 close to store
 * ab NMI_2      b4 i0reserv   0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * ac _L0xac     70 LHU_2      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad LDAF_2        (use dinx) 0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * ae _L0xae     70 LHU_2      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af LDAF_3     cb QINT_2     0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * b0 SW_E2      c2 unxc2      0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * b1 (null)     af MRET_4     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b2 SW_E4      74 BrOpFet    0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * b3 SW_E3         (use dinx) 0010000000000000101111001100100110        Q = 3                                             00000000 
 * b4 ECALL_6       (use dinx) 0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * b5 SH_4       b5 SH_3       1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b6 (null)     b4 i0reserv   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 SH_5       c9 MRET_2     0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b8 BGE        29 XOR_1      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 ECALL_4       (use dinx) 0010000000000000101011001100100110        Q = 4                                             00005067 close to jalr
 * ba MRET_3     30 SLTIX_2    0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * bb ILL_4      c3 unxc3      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * bc CSRRWI_0   87 JALRE1     0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd EBREAK_2   74 BrOpFet    0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * be MRET_4     3a SRxI_1     0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * bf CSRRW_3    ca unxca      0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * c0 aF_SW_3       (use dinx) 0000110000001110001011000x00100000        Store 7 to mcause                                 00006003 close to load
 * c1 (null)     dd aF_SW_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 CSRRW_4       (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      0000600b close to ij
 * c3 SH_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   0000600f close to fence
 * c4 ORI_0      da LDAF_a     0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 ECALL_5    97 SW_E1SWH   0010000000000000101011001100100110        Q = 8                                             00000000 
 * c6 (null)     85 LBU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c7 IJ_3       d0 ECALL_1    0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * c8 SH_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00006023 close to store
 * c9 IJ_4       ba LHU_3      0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * ca IJT_2         (use dinx) 0000000000001100101011101000110000        Read word is to be masked with ~3u                40006023 close to store
 * cb MRET_5     78 unx78      0010000000000000000011101100010xx0        ~302                                              00000000 
 * cc OR_0       45 WFI_3      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd IJT_4         (use dinx) 0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * ce QINT_1     fe ILLe       0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40006033 sloppy or      
 * cf MRET_2     1f IJ_2       0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * d0 QINT_2     60 unx60      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * d1 (null)     cf MRET_7     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 _LCSRRCI_1 0b JALR_2     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d3 MRET_7     39 unx39      0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * d4 aFault_2   af MRET_4     0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * d5 LDAF_a        (use dinx) 0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 jFault_1   b9 unxb9      0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * d8 BLTU       29 XOR_1      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 aF_SW_1       (use dinx) 0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00006067 close to jalr
 * da ORI_1      ad unxad      0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * db aF_SW_2    af MRET_4     0010000000000000101011001100100110        Q = 4                                             00000000 
 * dc CSRRSI_0   87 JALRE1     0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd IJT_3      db jFault_1   0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * de LH_3       16 condb_5    0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * df WFI_2      16 condb_5    0010000000000000101011101100100110        Check offset                                      00000000 
 * e0 SB_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   00007003 close to load
 * e1 (null)     37 ECALL_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 i0reserv      (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     30 SLTIX_2    0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     c0 unxc0      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 (null)     74 BrOpFet    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e7 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     cd unxcd      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     8e _LCSRRS_1  00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      27 OR_2       0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007033 sloppy and     
 * ef (null)     74 BrOpFet    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     78 unx78      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     d9 unxd9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     d7 ECALL_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     df eFetch     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     bd IJ_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       29 XOR_1      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     7a SB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     95 SW_E3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   87 JALRE1     0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      a2 unxa2      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       7d BAERR_4    0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     ce _LCSRRCI_1 0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0400, used fffd, inputs 17
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       0b JALR_2     0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 (null)     56 LH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 02 IJ_0       50 LW_1       0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     62 unx62      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     62 unx62      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    22 unx22      0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   2b SLTIX_1    0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     8f ILL_3      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 0a _L0x0a     8f ILL_3      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_1       42 unx42      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     62 unx62      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      33 JAERR_1    0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     62 unx62      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      a6 ECAL_RET   0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    4d unx4d      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 13 jFault     45 WFI_3      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 14 eILL0b     4b CSRRW_2    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 15 MRET_8     06 LB_3       0010000000000000101011101100100110        Prep +4                                           00000000 
 * 16 LW_1       5e LHU_1      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LW    3e SLL_1      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        3d SRxI_2     0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     85 LBU_1      0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a (null)     62 unx62      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   4e eILL0b     0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d LB_3       62 unx62      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 1e LH_1       d3 aFaultd    0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 1f LDAF_LH    c5 MRET_5     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 20 LH_0       1e aFault_1   0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 (null)     62 unx62      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 22 LB_4          (use dinx) 0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       0000100b close to ij
 * 23 _L0x23     62 unx62      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     78 unx78      0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LH_2       6d unx6d      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 27 aFaultb    53 LDAF_LH    0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 28 _L0x28     46 ILL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 (null)     65 WFI_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 2a _L0x2a     46 ILL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b LB_5       75 BAlignEr   0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 2c SLL_0      82 unx82      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     62 unx62      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e JALR_2        (use dinx) 0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        40001033 sloppy sll     
 * 2f _L0x2f     62 unx62      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      62 unx62      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   74 BrOpFet    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 (null)     42 unx42      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 SUB_1      a3 unxa3      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 34 SW_1       5e LHU_1      0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   79 unx79      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 LHU_2      03 _L0x03     0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 37 aFaultc    59 unx59      0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 38 BNE        3d SRxI_2     0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 AND_1         (use dinx) 0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00001067 close to jalr
 * 3a (null)     7f JALRE2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    8a unx8a      0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d condb_2    03 _L0x03     0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 3e BrOpFet    78 unx78      0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 3f BAlignEr   7e NMI_1      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 40 LW_0       16 condb_5    0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 (null)     2e unx2e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 42 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             0000200b close to ij
 * 43 JALRE1        (use dinx) 0000000000001101110011100x00001xx0  err   Store pc to mepc                                  0000200f close to fence
 * 44 SLTI_0     74 BrOpFet    0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 condb_3    93 SW_E2      0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 46 SH_1       88 unx88      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 47 SW_E1SWH   a8 unxa8      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 48 _L0x48     34 JAL_3      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 (null)     8b LB_6       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 4a _L0x4a     34 JAL_3      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b condb_4    be IJ_1       0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 4c SLT_0      76 BAERR_2    0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 4e ECAL_RET   fe ILLe       0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40002033 sloppy slt     
 * 4f EBRKWFI1   62 unx62      0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 50 IJ_1       62 unx62      0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 51 IJT_1      d4 aFault_2   0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 52 (null)     26 OR_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 ORI_2      d4 aFault_2   0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 54 ECALL_1    dd aF_SW_1    0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 55 MRET_1     5d SB_2       0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 56 LB_2       8e _LCSRRS_1  0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 57 aFaultd    a6 ECAL_RET   0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 58 eILL0c        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00002063 close to branch
 * 59 ECALL_3       (use dinx) 0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00002067 close to jalr
 * 5a (null)     90 NMI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    8a unx8a      0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d aFault_1   df eFetch     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 5e Fetch      36 SLLI_2     0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 5f eFetch     d4 aFault_2   0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 60 IJ_2          (use dinx) 0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00003003 close to load
 * 61 (null)     71 aFaultc    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 62 StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    0000300b close to ij
 * 63 aFault        (use dinx) 0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          0000300f close to fence
 * 64 SLTIU_0    74 BrOpFet    0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 XORI_1     67 SW_E1SWE   0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 66 eILL0a     6e unx6e      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 67 WFI_5      af MRET_4     0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 68 OR_1          (use dinx) 0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00003023 close to store
 * 69 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 6a LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40003023 close to store
 * 6b aFaulte    9d unx9d      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 6c SLTU_0     76 BAERR_2    0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d OR_2          (use dinx) 0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 6e SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   40003033 sloppy sltu    
 * 6f aF_SW      d1 MRET_1     0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 70 WFI_1      ffffffff (null)     0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 71 EBREAK_1   5d SB_2       0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 72 (null)     4d unx4d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 XOR_1      9b unx9b      0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 74 SLTIX_1    12 unx12      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 75 SLTIX_2    97 SW_E1SWH   0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 76 SLTX_1     9c unx9c      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 77 JAL_3      9e SH_4       0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 78 SLLI_1        (use dinx) 0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00003063 close to branch
 * 79 SLLI_2        (use dinx) 0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00003067 close to jalr
 * 7a (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    8a unx8a      0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d ECALL_2    77 BAERR_3    0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 7e SRxI_1     aa unxaa      0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 7f SRxI_2     9e SH_4       0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 80 LBU_0      a5 MRET_3     0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 (null)     9e SH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 82 SLL_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              0000400b close to ij
 * 83 SRx_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  0000400f close to fence
 * 84 XORI_0     65 WFI_4      0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 JALR_1     6a unx6a      0010000000000000000011101100100110        Q=1                                               00000000 
 * 86 WFI_3      77 BAERR_3    0010000000000000101011101100100110        More check offset                                 00000000 
 * 87 ILL_1      a2 unxa2      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 88 ILL_2         (use dinx) 0000000000001111101011101000001xx0        Store 0 to mtval                                  00004023 close to store
 * 89 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 8a CSRRW_1       (use dinx) 0010000000000000000011101100100110        Construct PC storage adr                          40004023 close to store
 * 8b CSRRW_2    62 unx62      0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 8c XOR_0      73 BAERR_1    0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d LH_4          (use dinx) 0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 8e LH_5       fe ILLe       0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               40004033 sloppy xor     
 * 8f SB_1       b9 unxb9      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 90 SB_2       77 BAERR_3    0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 91 EBRKWFI2   ad unxad      0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 92 (null)     77 BAERR_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 WFI_4      b1 aF_SW_3    0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 94 SB_4       77 BAERR_3    1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 95 MRET_6     b0 CSRRW_3    0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 96 LBU_3      c6 IJT_4      0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 97 BAERR_1    af MRET_4     0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 98 BLT        3d SRxI_2     0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a (null)     77 BAERR_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 9b BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 9c BAERR_3       (use dinx) 0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00004073 close to csr/system 
 * 9d SB_5          (use dinx) 0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 9e BAERR_4    b5 SH_3       0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 9f NMI_1      6e unx6e      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * a0 LHU_0      30 SLTIX_2    0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 (null)     c3 unxc3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a2 JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   0000500b close to ij
 * a3 JAERR_2       (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  0000500f close to fence
 * a4 SRxI_0     7e NMI_1      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 LBU_1      bd IJ_4       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * a6 LB_6       54 LH_2       0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * a7 _LCSRRS_1  91 LDAF_2     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * a8 ILL_3         (use dinx) 0010000000000000101011101100100110        Q = 1                                             00005023 close to store
 * a9 (null)     77 BAERR_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * aa NMI_2         (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        40005023 close to store
 * ab LDAF_2     b3 unxb3      0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * ac _L0xac     83 unx83      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad LDAF_3        (use dinx) 0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * ae _L0xae     83 unx83      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SW_E2      ca unxca      0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * b0 SW_E4      c0 unxc0      0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * b1 SW_E3      ad unxad      0010000000000000101111001100100110        Q = 3                                             00000000 
 * b2 (null)     5e LHU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 ECALL_6       (use dinx) 0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * b4 SH_4          (use dinx) 1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b5 SH_5       b4 i0reserv   0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b6 ECALL_4    b3 unxb3      0010000000000000101011001100100110        Q = 4                                             00000000 
 * b7 MRET_3     c7 QINT_1     0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * b8 BGE        3d SRxI_2     0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 ILL_4         (use dinx) 0000110000001110100111100x00100110        Store 2 to mcause                                 00005067 close to jalr
 * ba (null)     4d unx4d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * bb EBREAK_2   c2 unxc2      0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * bc CSRRWI_0   8a unx8a      0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd MRET_4     5e LHU_1      0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * be CSRRW_3    60 unx60      0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * bf aF_SW_3    c8 unxc8      0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * c0 CSRRW_4       (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00006003 close to load
 * c1 (null)     db jFault_1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 SH_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   0000600b close to ij
 * c3 ECALL_5       (use dinx) 0010000000000000101011001100100110        Q = 8                                             0000600f close to fence
 * c4 ORI_0      d7 ECALL_3    0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 IJ_3       95 SW_E3      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * c6 SH_2       88 unx88      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * c7 IJ_4       cf MRET_7     0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * c8 IJT_2         (use dinx) 0000000000001100101011101000110000        Read word is to be masked with ~3u                00006023 close to store
 * c9 (null)     b7 IJ_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ca MRET_5        (use dinx) 0010000000000000000011101100010xx0        ~302                                              40006023 close to store
 * cb IJT_4      62 unx62      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * cc OR_0       68 unx68      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd QINT_1        (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * ce MRET_2     fe ILLe       0010000000000000011011001100100000        0xff+3 = 0x102                                    40006033 sloppy or      
 * cf QINT_2     15 condb_4    0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * d0 _LCSRRCI_1 7d BAERR_4    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d1 MRET_7     ce _LCSRRCI_1 0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * d2 (null)     1d ORI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 aFault_2   5d SB_2       0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * d4 LDAF_a     ad unxad      0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * d5 jFault_1      (use dinx) 0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * d6 aF_SW_1    fe ILLe       0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * d7 ORI_1      b6 ECALL_5    0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * d8 BLTU       3d SRxI_2     0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 aF_SW_2       (use dinx) 0010000000000000101011001100100110        Q = 4                                             00006067 close to jalr
 * da (null)     ab EBREAK_2   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * db IJT_3      ad unxad      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * dc CSRRSI_0   8a unx8a      0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd LH_3       d9 unxd9      0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * de WFI_2      12 unx12      0010000000000000101011101100100110        Check offset                                      00000000 
 * df SB_3       12 unx12      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e0 i0reserv      (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00007003 close to load
 * e1 (null)     53 LDAF_LH    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     4d unx4d      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     bf IJT_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 (null)     5e LHU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e7 (null)     5d SB_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     cb QINT_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     8d unx8d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      39 unx39      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007033 sloppy and     
 * ef (null)     5e LHU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     96 SH_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     5d SB_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     62 unx62      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     d6 eILL0c     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     d5 unxd5      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     de Fetch      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     bb SH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       3d SRxI_2     0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     94 SW_E4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   8a unx8a      0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      9f SH_5       0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       87 JALRE1     0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     cd unxcd      0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0100, used f3ff, inputs 1b
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       78 unx78      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       6a unx6a      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     86 JAL_2      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     86 JAL_2      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     9e SH_4       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       b9 unxb9      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     9e SH_4       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       62 unx62      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     86 JAL_2      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      21 XORI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     86 JAL_2      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 Fetch2     b9 unxb9      000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 11 jFault     31 SLTX_1     0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 12 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 13 (null)     2b SLTIX_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 14 Fetch2     2e unx2e      000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 15 jFault     06 LB_3       0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 16 (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 17 (null)     60 unx60      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 18 BEQ        29 XOR_1      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     7d BAERR_4    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       86 JAL_2      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   68 unx68      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     86 JAL_2      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e JAL_1      e6 StdIncPc   0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 1f JAERR_1    d9 unxd9      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 20 LH_0       42 unx42      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      86 JAL_2      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1         (use dinx) 0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     86 JAL_2      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     5a SB_1       0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 eILL0b     45 WFI_3      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     35 SLLI_1     0010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_2    3d SRxI_2     0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2a _L0x2a     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_3    4d unx4d      0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2c SLL_0      75 BAlignEr   0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     86 JAL_2      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_4       (use dinx) 0010000000000000110011101101001xx0        Branch on condition                               40001033 sloppy sll     
 * 2f _L0x2f     86 JAL_2      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 31 ANDI_1     4b CSRRW_2    0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 32 (null)     62 unx62      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 (null)     b1 aF_SW_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 34 (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 35 ORI_2      5d SB_2       0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 (null)     7f JALRE2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 38 BNE        29 XOR_1      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 aFault_1      (use dinx) 0010000000000000101011001100100110        Q = 4                                             00001067 close to jalr
 * 3a IJ_2       71 aFaultc    0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 3b _L0x3b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    91 LDAF_2     0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d XORI_1     03 _L0x03     0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 3e LW_1       5a SB_1       0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    6d unx6d      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 OR_1       1d ORI_2      0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 42 LH_1          (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH       (use dinx) 0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     4b CSRRW_2    0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 OR_2       a2 unxa2      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 46 LH_2       8d unx8d      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    bb SH_2       0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     58 unx58      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XOR_1      95 SW_E3      0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 4a _L0x4a     58 unx58      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b SLTIX_1    cd unxcd      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 4c SLT_0      51 LDAF_LW    0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d SLTIX_2       (use dinx) 0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 4e LHU_1      fe ILLe       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40002033 sloppy slt     
 * 4f LDAF_LHU   86 JAL_2      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 50 (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 51 SLTX_1     e7 aFault     0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 52 (null)     46 ILL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 (null)     e7 aFault     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 54 (null)     ee eILL0a     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 55 JAL_3      39 unx39      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 56 (null)     9d unx9d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 (null)     b9 unxb9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 58 SW_1          (use dinx) 0000000000000011111011100100001xx0        Write d to a+k until accepted                     00002063 close to branch
 * 59 SW_E1SWE      (use dinx) 0000000000001111001011100x00110000        Store faulting address alignment to mtval         00002067 close to jalr
 * 5a SLLI_1     9f SH_5       0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 5b _L0x5b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    91 LDAF_2     0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLLI_2     f1 aFaulte    0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 5e LHU_2      5e LHU_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaultc    e7 aFault     0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 60 BrOpFet       (use dinx) 0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00003003 close to load
 * 61 BAlignEr   9b unx9b      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 62 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             0000300b close to ij
 * 63 JALRE1        (use dinx) 0000000000001101110011100x00001xx0  err   Store pc to mepc                                  0000300f close to fence
 * 64 SLTIU_0    4b CSRRW_2    0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 ECALL_2    89 unx89      0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 66 SH_1       8e _LCSRRS_1  0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 67 SW_E1SWH   c0 unxc0      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 68 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00003023 close to store
 * 69 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 6a IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   40003023 close to store
 * 6b IJT_1      aa unxaa      0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 6c SLTU_0     51 LDAF_LW    0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SRxI_1        (use dinx) 0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 6e ECALL_1       (use dinx) 0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40003033 sloppy sltu    
 * 6f MRET_1     e5 aF_SW_2    0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 70 (null)     ffffffff (null)     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 71 SRxI_2     39 unx39      0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 72 (null)     31 SLTX_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 (null)     a8 unxa8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 74 (null)     14 condb_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 75 SLL_1      a7 EBRKWFI1   0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 76 (null)     a9 ILL_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 (null)     ab EBREAK_2   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 78 LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003063 close to branch
 * 79 aFaultd       (use dinx) 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00003067 close to jalr
 * 7a SRx_1      8e _LCSRRS_1  0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 7b _L0x7b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    91 LDAF_2     0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d JALR_1     55 aFaultb    0010000000000000000011101100100110        Q=1                                               00000000 
 * 7e eILL0c     bd IJ_4       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 7f ECALL_3    ab EBREAK_2   0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 80 LBU_0      b5 SH_3       0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 WFI_3      ab EBREAK_2   0010000000000000101011101100100110        More check offset                                 00000000 
 * 82 Fetch         (use dinx) 0000000000001000001111101010110000  Fr00  Read and latch instruction                        0000400b close to ij
 * 83 eFetch        (use dinx) 0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             0000400f close to fence
 * 84 XORI_0     3d SRxI_2     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 ILL_1      8a unx8a      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 86 StdIncPc   55 aFaultb    0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * 87 aFault     af MRET_4     0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 88 eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00004023 close to store
 * 89 WFI_5         (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 8a LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40004023 close to store
 * 8b aFaulte    86 JAL_2      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 8c XOR_0      49 CSRRW_1    0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d ILL_2         (use dinx) 0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 8e SW_2       fe ILLe       0010000000000000001011x01000xxxxx0        Prepare read PC                                   40004033 sloppy xor     
 * 8f aF_SW      c9 MRET_2     0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 90 (null)     55 aFaultb    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 91 CSRRW_1    bf IJT_1      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 92 (null)     55 aFaultb    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 (null)     c2 unxc2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 94 (null)     55 aFaultb    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 95 CSRRW_2    c1 IJT_2      0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 96 (null)     da LDAF_a     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 (null)     c0 unxc0      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 98 BLT        29 XOR_1      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a WFI_1      55 aFaultb    0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 9b EBREAK_1      (use dinx) 0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 9c LH_4          (use dinx) 0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00004073 close to csr/system 
 * 9d LH_5          (use dinx) 0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 9e SB_1       c6 IJT_4      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 9f SB_2       8e _LCSRRS_1  0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * a0 LHU_0      4e eILL0b     0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 EBRKWFI2   d5 unxd5      0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * a2 WFI_4         (use dinx) 0010000000000000001011x01001xxxxx0        Prepare read PC                                   0000500b close to ij
 * a3 SB_4          (use dinx) 1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      0000500f close to fence
 * a4 SRxI_0     6d unx6d      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_6     cb QINT_2     0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * a6 LBU_3      6e unx6e      0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * a7 BAERR_1    a1 ECALL_4    0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * a8 BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00005023 close to store
 * a9 BAERR_3    55 aFaultb    0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * aa SB_5          (use dinx) 0000000000000010110011100100001xx0        Write d to a+k until accepted                     40005023 close to store
 * ab BAERR_4    c3 unxc3      0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * ac _L0xac     7a SB_5       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * ae _L0xae     7a SB_5       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af JALRE2     de Fetch      0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * b0 (null)     cf MRET_7     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b1 JAERR_2    bf IJT_1      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * b2 (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b5 LBU_1      c5 MRET_5     0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * b6 (null)     c3 unxc3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 (null)     db jFault_1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b8 BGE        29 XOR_1      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 LB_6          (use dinx) 0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00005067 close to jalr
 * ba _LCSRRS_1  31 SLTX_1     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bb ILL_3      d1 MRET_1     0010000000000000101011101100100110        Q = 1                                             00000000 
 * bc CSRRWI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd NMI_2      82 unx82      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * be LDAF_2     3a SRxI_1     0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * bf LDAF_3     dd aF_SW_1    0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * c0 SW_E2         (use dinx) 0000000000001101101111101000001xx0        Store address that faulted                        00006003 close to load
 * c1 SW_E4      ed unxed      0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * c2 SW_E3         (use dinx) 0010000000000000101111001100100110        Q = 3                                             0000600b close to ij
 * c3 ECALL_6       (use dinx) 0000110000001110100111000x00100000        mcause = 11                                       0000600f close to fence
 * c4 ORI_0      ea unxea      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 SH_4       a5 MRET_3     1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * c6 SH_5       8d unx8d      0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * c7 ECALL_4    e2 unxe2      0010000000000000101011001100100110        Q = 4                                             00000000 
 * c8 MRET_3        (use dinx) 0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00006023 close to store
 * c9 ILL_4      c8 unxc8      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * ca EBREAK_2      (use dinx) 0000000000001101101011101000001xx0        pc to mepc                                        40006023 close to store
 * cb MRET_4     86 JAL_2      0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * cc OR_0       41 JALR_1     0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd CSRRW_3       (use dinx) 0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * ce aF_SW_3    fe ILLe       0000110000001110001011000x00100000        Store 7 to mcause                                 40006033 sloppy or      
 * cf CSRRW_4    27 OR_2       0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d0 (null)     65 WFI_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 SH_3       e1 ORI_1      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d4 (null)     bf IJT_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 ECALL_5       (use dinx) 0010000000000000101011001100100110        Q = 8                                             00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     c7 QINT_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       29 XOR_1      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00006067 close to jalr
 * da SH_2       be IJ_1       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * db IJ_4       bf IJT_1      0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * dc CSRRSI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd IJT_2      eb LH_3       0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * de MRET_5     14 condb_3    0010000000000000000011101100010xx0        ~302                                              00000000 
 * df IJT_4      14 condb_3    0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * e0 QINT_1        (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00007003 close to load
 * e1 MRET_2     35 SLLI_1     0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * e2 QINT_2        (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        0000700b close to ij
 * e3 _LCSRRCI_1    (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000700f close to fence
 * e4 ANDI_0     31 SLTX_1     0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 MRET_7     ce _LCSRRCI_1 0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * e6 aFault_2   82 unx82      0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * e7 LDAF_a     39 unx39      0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * e8 jFault_1      (use dinx) 0000000000001110001011100x00100110        Store 1 to mcause                                 00007023 close to store
 * e9 aF_SW_1    df eFetch     0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * ea ORI_1         (use dinx) 0010000000000000000011101100001xx0        Q = RS1                                           40007023 close to store
 * eb aF_SW_2    9c unx9c      0010000000000000101011001100100110        Q = 4                                             00000000 
 * ec AND_0      22 unx22      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed IJT_3         (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ee LH_3       fe ILLe       0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 40007033 sloppy and     
 * ef WFI_2      82 unx82      0010000000000000101011101100100110        Check offset                                      00000000 
 * f0 (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 SB_3       39 unx39      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f2 (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     e9 IJT_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 i0reserv   e8 unxe8      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * f6 (null)     ef WFI_5      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     ca unxca      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       29 XOR_1      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     81 JAERR_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     a3 unxa3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      ad unxad      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       85 LBU_1      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     e0 unxe0      0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0100, used f3ff, inputs 1d
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       82 unx82      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       78 unx78      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     9a ECALL_6    0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     9a ECALL_6    0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    1d ORI_2      0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   21 XORI_1     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     ad unxad      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 _LCSRRCI_1 c7 QINT_1     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 0a _L0x0a     ad unxad      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b MRET_7     62 unx62      0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     9a ECALL_6    0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      2e unx2e      0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     9a ECALL_6    0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 Fetch2     c7 QINT_1     000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 11 jFault     3d SRxI_2     0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 12 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 13 jFault     39 unx39      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 14 (null)     3a SRxI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 15 (null)     06 LB_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 16 (null)     8e _LCSRRS_1  00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 17 (null)     60 unx60      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 18 BEQ        33 JAERR_1    0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     8a unx8a      0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_3       9a ECALL_6    0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 1b _L0x1b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   6e unx6e      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d LB_4       9a ECALL_6    0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 1e JAL_1      29 XOR_1      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 1f JAERR_1    ea unxea      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 20 LH_0       42 unx42      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 LB_5       9a ECALL_6    0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 22 JALR_2        (use dinx) 0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        0000100b close to ij
 * 23 _L0x23     9a ECALL_6    0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     71 aFaultc    0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 eILL0b     5a SB_1       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     41 JALR_1     0010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 aFault_2   51 LDAF_LW    0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 2a _L0x2a     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b LDAF_a     68 unx68      0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * 2c SLL_0      85 LBU_1      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     9a ECALL_6    0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e SUB_1         (use dinx) 0010000000000000111111101100000xx0        Q = ~RS2                                          40001033 sloppy sll     
 * 2f _L0x2f     9a ECALL_6    0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 31 AND_1      65 WFI_4      0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 32 (null)     62 unx62      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 condb_2    c5 MRET_5     0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 34 (null)     8e _LCSRRS_1  00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 35 (null)     73 BAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 (null)     87 JALRE1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 38 BNE        33 JAERR_1    0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_3       (use dinx) 0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00001067 close to jalr
 * 3a condb_4    81 JAERR_2    0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 3b _L0x3b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    a1 ECALL_4    0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ANDI_1     03 _L0x03     0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3e LW_1       71 aFaultc    0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    7d BAERR_4    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 ORI_2      22 unx22      0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 42 LH_1          (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH       (use dinx) 0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     65 WFI_4      0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 aFault_1   b3 unxb3      0010000000000000101011001100100110        Q = 4                                             00000000 
 * 46 LH_2       93 SW_E2      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    ca unxca      0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     58 unx58      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 jFault_1   a5 MRET_3     0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 4a _L0x4a     58 unx58      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b aF_SW_1    e3 unxe3      0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 4c SLT_0      6a unx6a      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d IJ_2          (use dinx) 0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 4e LHU_1      fe ILLe       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40002033 sloppy slt     
 * 4f LDAF_LHU   9a ECALL_6    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 50 (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 51 XORI_1     2b SLTIX_1    0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 52 (null)     46 ILL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 OR_1       2b SLTIX_1    0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 54 (null)     8b LB_6       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 55 (null)     45 WFI_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 56 (null)     aa unxaa      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 (null)     c7 QINT_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 58 SW_1          (use dinx) 0000000000000011111011100100001xx0        Write d to a+k until accepted                     00002063 close to branch
 * 59 SW_E1SWE      (use dinx) 0000000000001111001011100x00110000        Store faulting address alignment to mtval         00002067 close to jalr
 * 5a OR_2       af MRET_4     0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5b _L0x5b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    a1 ECALL_4    0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d XOR_1      ab EBREAK_2   0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 5e LHU_2      5e LHU_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaultc    2b SLTIX_1    0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 60 BrOpFet       (use dinx) 0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00003003 close to load
 * 61 BAlignEr   a7 EBRKWFI1   0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 62 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             0000300b close to ij
 * 63 JALRE1        (use dinx) 0000000000001101110011100x00001xx0  err   Store pc to mepc                                  0000300f close to fence
 * 64 SLTIU_0    65 WFI_4      0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLTIX_1    9d unx9d      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 66 SH_1       a2 unxa2      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 67 SW_E1SWH   d1 MRET_1     0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 68 SLTIX_2       (use dinx) 0000000000000100001011101000110010        Registered ALU flag to rd                         00003023 close to store
 * 69 ORI_1         (use dinx) 0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 6a SLTX_1        (use dinx) 0010000000000000111111101100000xx0        ~rs2 to Q                                         40003023 close to store
 * 6b aF_SW_2    c0 unxc0      0010000000000000101011001100100110        Q = 4                                             00000000 
 * 6c SLTU_0     6a unx6a      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d JAL_3         (use dinx) 0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 6e ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40003033 sloppy sltu    
 * 6f EBRKWFI1   0b JALR_2     0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 70 (null)     ffffffff (null)     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 71 SLLI_1     45 WFI_3      0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 72 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 SLLI_2     be IJ_1       0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 74 (null)     12 unx12      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 75 (null)     bd IJ_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 76 (null)     bf IJT_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 (null)     c1 IJT_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 78 IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00003063 close to branch
 * 79 IJT_1         (use dinx) 0010000010000000101111101100001xx0        Exit CSR, enter trap                              00003067 close to jalr
 * 7a ECALL_2    a2 unxa2      0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 7b _L0x7b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    a1 ECALL_4    0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SRxI_1     6d unx6d      0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 7e ECALL_1    cd unxcd      0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 7f MRET_1     c1 IJT_2      0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 80 LBU_0      c6 IJT_4      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SRxI_2     c1 IJT_2      0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 82 LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     0000400b close to ij
 * 83 aFaultd       (use dinx) 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       0000400f close to fence
 * 84 XORI_0     51 LDAF_LW    0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLL_1      9e SH_4       0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 86 eILL0c     6d unx6d      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 87 ECALL_3    c3 unxc3      0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 88 SRx_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00004023 close to store
 * 89 IJT_3         (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 8a JALR_1        (use dinx) 0010000000000000000011101100100110        Q=1                                               40004023 close to store
 * 8b LH_3       9a ECALL_6    0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 8c XOR_0      5d SB_2       0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d WFI_3         (use dinx) 0010000000000000101011101100100110        More check offset                                 00000000 
 * 8e Fetch      fe ILLe       0000000000001000001111101010110000  Fr00  Read and latch instruction                        40004033 sloppy xor     
 * 8f eFetch     e0 unxe0      0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 90 (null)     6d unx6d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 91 ILL_1      cf MRET_7     0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 92 (null)     6d unx6d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 ILL_2      d9 unxd9      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 94 (null)     6d unx6d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 95 (null)     d3 aFaultd    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 96 (null)     ed unxed      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 (null)     d1 MRET_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 98 BLT        33 JAERR_1    0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a StdIncPc   6d unx6d      0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * 9b aFault        (use dinx) 0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 9c eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00004073 close to csr/system 
 * 9d WFI_5         (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 9e LBU_2      dd aF_SW_1    0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 9f aFaulte    a2 unxa2      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * a0 LHU_0      4e eILL0b     0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 CSRRW_1    e8 unxe8      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * a2 SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   0000500b close to ij
 * a3 aF_SW         (use dinx) 0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     0000500f close to fence
 * a4 SRxI_0     7d BAERR_4    0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 CSRRW_2    e2 unxe2      0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * a6 WFI_1      7e NMI_1      0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * a7 EBREAK_1   b1 aF_SW_3    0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * a8 LH_4          (use dinx) 0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00005023 close to store
 * a9 WFI_2      6d unx6d      0010000000000000101011101100100110        Check offset                                      00000000 
 * aa LH_5          (use dinx) 0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               40005023 close to store
 * ab SB_3       da LDAF_a     0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * ac _L0xac     88 unx88      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad SB_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * ae _L0xae     88 unx88      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SB_2       f1 aFaulte    0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * b0 (null)     e6 StdIncPc   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b1 EBRKWFI2   cf MRET_7     0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * b2 (null)     8e _LCSRRS_1  00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 WFI_4         (use dinx) 0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * b4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b5 (null)     db jFault_1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b6 (null)     da LDAF_a     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 (null)     ee eILL0a     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b8 BGE        33 JAERR_1    0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SB_4          (use dinx) 1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00005067 close to jalr
 * ba MRET_6     3d SRxI_2     0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * bb LBU_3      e7 aFault     0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * bc CSRRWI_0   a1 ECALL_4    0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd BAERR_1    8e _LCSRRS_1  0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * be BAERR_2    4d unx4d      0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * bf BAERR_3    ef WFI_5      0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * c0 SB_5          (use dinx) 0000000000000010110011100100001xx0        Write d to a+k until accepted                     00006003 close to load
 * c1 BAERR_4    89 unx89      0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * c2 NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 0000600b close to ij
 * c3 JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   0000600f close to fence
 * c4 ORI_0      69 unx69      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 JAERR_2    ba LHU_3      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * c6 LBU_1      93 SW_E2      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * c7 LB_6       fb SB_3       0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * c8 _LCSRRS_1     (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00006023 close to store
 * c9 i0reserv   df eFetch     xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * ca ILL_3         (use dinx) 0010000000000000101011101100100110        Q = 1                                             40006023 close to store
 * cb (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * cc OR_0       53 LDAF_LH    0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd NMI_2         (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * ce LDAF_2     fe ILLe       0000110000001110001011000x00100110        Store 4 to mcause                                 40006033 sloppy or      
 * cf LDAF_3     27 OR_2       0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * d0 (null)     7a SB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 SW_E2      fa WFI_2      0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * d2 (null)     1a ANDI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 SW_E4      45 WFI_3      0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * d4 (null)     cf MRET_7     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     de Fetch      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       33 JAERR_1    0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 SW_E3         (use dinx) 0010000000000000101111001100100110        Q = 3                                             00006067 close to jalr
 * da ECALL_6    ce _LCSRRCI_1 0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * db SH_4       cf MRET_7     1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * dc CSRRSI_0   a1 ECALL_4    0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd SH_5       6b SB_4       0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * de ECALL_4    12 unx12      0010000000000000101011001100100110        Q = 4                                             00000000 
 * df MRET_3     12 unx12      0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * e0 ILL_4         (use dinx) 0000110000001110100111100x00100110        Store 2 to mcause                                 00007003 close to load
 * e1 EBREAK_2   41 JALR_1     0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * e2 MRET_4        (use dinx) 0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          0000700b close to ij
 * e3 CSRRW_3       (use dinx) 0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     0000700f close to fence
 * e4 ANDI_0     3d SRxI_2     0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 aF_SW_3    e5 aF_SW_2    0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * e6 CSRRW_4    8e _LCSRRS_1  0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * e7 SH_3       45 WFI_3      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e8 ECALL_5       (use dinx) 0010000000000000101011001100100110        Q = 8                                             00007023 close to store
 * e9 (null)     f3 aF_SW      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   40007023 close to store
 * eb (null)     a8 unxa8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      31 SLTX_1     0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed SH_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * ee IJ_4       fe ILLe       0100000010001010110111100100011xx0        Mask and use as PC                                40007033 sloppy and     
 * ef IJT_2      8e _LCSRRS_1  0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * f0 (null)     bb SH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 MRET_5     45 WFI_3      0010000000000000000011101100010xx0        ~302                                              00000000 
 * f2 (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 IJT_4      4b CSRRW_2    0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     49 CSRRW_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     a9 ILL_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     e1 ORI_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       33 JAERR_1    0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 QINT_1        (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00007067 close to jalr
 * fa MRET_2     8d unx8d      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * fb QINT_2     b9 unxb9      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * fc CSRRCI_0   a1 ECALL_4    0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      c2 unxc2      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       91 LDAF_2     0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     f9 unxf9      0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0400, used ffff, inputs 2b
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       56 LH_4       0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       52 LH_1       0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     60 unx60      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     60 unx60      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     83 unx83      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       95 SW_E3      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     83 unx83      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       46 ILL_1      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     60 unx60      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      21 XORI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     60 unx60      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      95 SW_E3      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    37 ECALL_2    0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 eILL0b        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2e unx2e      0010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       33 JAERR_1    0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       5e LHU_1      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    42 unx42      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        2b SLTIX_1    0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     78 unx78      0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       60 unx60      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   50 LW_1       0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     60 unx60      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       c2 unxc2      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    b4 i0reserv   0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      60 unx60      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000100b close to ij
 * 23 _L0x23     60 unx60      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     65 WFI_4      0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 Fetch2     49 CSRRW_1    000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 27 jFault     39 unx39      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 28 _L0x28     4e eILL0b     0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 AND_1      41 JALR_1     0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 2a _L0x2a     4e eILL0b     0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_2    5a SB_1       0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2c SLL_0      75 BAlignEr   0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     60 unx60      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_3       (use dinx) 0010000000000000001011101100100110        Calculate RS1+~RS2+1                              40001033 sloppy sll     
 * 2f _L0x2f     60 unx60      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LHU_1      60 unx60      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LHU   4d unx4d      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 (null)     46 ILL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 condb_4    93 SW_E2      0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 34 SW_1       5e LHU_1      0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 35 SW_E1SWE   67 SW_E1SWE   0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 ANDI_1     59 unx59      0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 38 BNE        2b SLTIX_1    0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 ORI_2         (use dinx) 0000000000000100001011101000111000        rd = Iimm | RS1                                   00001067 close to jalr
 * 3a aFault_1   74 BrOpFet    0010000000000000101011001100100110        Q = 4                                             00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    7e NMI_1      0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d IJ_2       03 _L0x03     0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 3e LHU_2      65 WFI_4      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    73 BAERR_1    0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       14 condb_3    0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 XORI_1     1d ORI_2      0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 42 BrOpFet       (use dinx) 0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    0000200b close to ij
 * 43 BAlignEr      (use dinx) 0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      0000200f close to fence
 * 44 SLTI_0     4d unx4d      0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 OR_1       87 JALRE1     0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 46 JAL_2      7d BAERR_4    0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 47 JALRE1     97 SW_E1SWH   0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 48 _L0x48     34 JAL_3      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 OR_2       7f JALRE2     0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 4a _L0x4a     34 JAL_3      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b XOR_1      ad unxad      0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 4c SLT_0      5d SB_2       0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d SLTIX_1       (use dinx) 0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 4e SH_1       fe ILLe       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        40002033 sloppy slt     
 * 4f SW_E1SWH   60 unx60      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 50 ECAL_RET   60 unx60      0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 51 EBRKWFI1   c3 unxc3      0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 52 IJ_1       1e aFault_1   0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 53 IJT_1      c3 unxc3      0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 54 ECALL_1    ca unxca      0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 55 MRET_1     3a SRxI_1     0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 56 LB_2       82 unx82      0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 57 aFaultd    95 SW_E3      0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 58 eILL0c        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00002063 close to branch
 * 59 ECALL_3       (use dinx) 0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00002067 close to jalr
 * 5a SLTIX_2    85 LBU_1      0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    7e NMI_1      0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLTX_1     cd unxcd      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 5e Fetch      3e SLL_1      0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 5f eFetch     c3 unxc3      0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 60 StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00003003 close to load
 * 61 aFault     71 aFaultc    0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 62 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000300b close to ij
 * 63 JAL_3         (use dinx) 0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                0000300f close to fence
 * 64 SLTIU_0    4d unx4d      0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLLI_1     69 unx69      0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 66 (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 67 SLLI_2     9d unx9d      0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 68 eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00003023 close to store
 * 69 WFI_5         (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 6a LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40003023 close to store
 * 6b aFaulte    8f ILL_3      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 6c SLTU_0     5d SB_2       0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d ECALL_2       (use dinx) 0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 6e SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   40003033 sloppy sltu    
 * 6f aF_SW      c1 IJT_2      0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 70 WFI_1      ffffffff (null)     0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 71 EBREAK_1   3a SRxI_1     0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 72 (null)     37 ECALL_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 SRxI_1     8d unx8d      0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 74 SRxI_2     26 OR_1       0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 75 SLL_1      8b LB_6       0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 76 (null)     8e _LCSRRS_1  00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 SRx_1      90 NMI_2      0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 78 JALR_1        (use dinx) 0010000000000000000011101100100110        Q=1                                               00003063 close to branch
 * 79 WFI_3         (use dinx) 0010000000000000101011101100100110        More check offset                                 00003067 close to jalr
 * 7a ILL_1      6e unx6e      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    7e NMI_1      0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d ILL_2      63 unx63      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 7e CSRRW_1    9a ECALL_6    0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 7f CSRRW_2    90 NMI_2      0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 80 LBU_0      94 SW_E4      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 LH_4       90 NMI_2      0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 82 LH_5          (use dinx) 0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               0000400b close to ij
 * 83 SB_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        0000400f close to fence
 * 84 XORI_0     41 JALR_1     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SB_2       6a unx6a      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 86 EBRKWFI2   63 unx63      0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 87 WFI_4      92 LDAF_3     0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 88 SB_4          (use dinx) 1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00004023 close to store
 * 89 MRET_6        (use dinx) 0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 8a LBU_3         (use dinx) 0010000000000000011011101100010xx0        Invert q. Prepare read mask                       40004023 close to store
 * 8b BAERR_1    60 unx60      0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 8c XOR_0      4b CSRRW_2    0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 8e BAERR_3    fe ILLe       0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       40004033 sloppy xor     
 * 8f SB_5       a9 ILL_4      0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 90 BAERR_4    63 unx63      0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 91 NMI_1      9c unx9c      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 92 JALRE2     63 unx63      0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * 93 JAERR_2    9f SH_5       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 94 LBU_1      63 unx63      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 95 LB_6       9e SH_4       0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 96 _LCSRRS_1  b5 SH_3       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 97 ILL_3      9d unx9d      0010000000000000101011101100100110        Q = 1                                             00000000 
 * 98 BLT        2b SLTIX_1    0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a NMI_2      63 unx63      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 9b LDAF_2        (use dinx) 0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 9c LDAF_3        (use dinx) 0000000000001101100111100x00001xx0        PC to mepc                                        00004073 close to csr/system 
 * 9d SW_E2         (use dinx) 0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 9e SW_E4      a5 MRET_3     0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 9f SW_E3      6e unx6e      0010000000000000101111001100100110        Q = 3                                             00000000 
 * a0 LHU_0      30 SLTIX_2    0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_6    b3 unxb3      0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * a2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000500b close to ij
 * a3 SH_4          (use dinx) 1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      0000500f close to fence
 * a4 SRxI_0     73 BAERR_1    0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SH_5       ab EBREAK_2   0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * a6 (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a7 ECALL_4    86 JAL_2      0010000000000000101011001100100110        Q = 4                                             00000000 
 * a8 MRET_3        (use dinx) 0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00005023 close to store
 * a9 ILL_4      63 unx63      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * aa EBREAK_2      (use dinx) 0000000000001101101011101000001xx0        pc to mepc                                        40005023 close to store
 * ab MRET_4     a1 ECALL_4    0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * ac _L0xac     77 BAERR_3    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad CSRRW_3       (use dinx) 0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * ae _L0xae     77 BAERR_3    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af aF_SW_3    ba LHU_3      0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * b0 CSRRW_4    b0 CSRRW_3    0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b1 SH_3       9c unx9c      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b2 (null)     5e LHU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 ECALL_5       (use dinx) 0010000000000000101011001100100110        Q = 8                                             00000000 
 * b4 IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b5 SH_2       a3 unxa3      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * b6 (null)     a1 ECALL_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 IJ_4       b7 IJ_3       0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * b8 BGE        2b SLTIX_1    0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 IJT_2         (use dinx) 0000000000001100101011101000110000        Read word is to be masked with ~3u                00005067 close to jalr
 * ba MRET_5     37 ECALL_2    0010000000000000000011101100010xx0        ~302                                              00000000 
 * bb IJT_4      b1 aF_SW_3    0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * bc CSRRWI_0   7e NMI_1      0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd QINT_1     5e LHU_1      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * be MRET_2     3d SRxI_2     0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * bf QINT_2     b9 unxb9      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * c0 _LCSRRCI_1    (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00006003 close to load
 * c1 MRET_7     c9 MRET_2     0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * c2 aFault_2      (use dinx) 0000110000001110001011100x00100110        Store 5 to mcause                                 0000600b close to ij
 * c3 LDAF_a        (use dinx) 0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      0000600f close to fence
 * c4 ORI_0      c7 QINT_1     0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 jFault_1   89 unx89      0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * c6 aF_SW_1    7d BAERR_4    0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * c7 ORI_1      bf IJT_1      0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * c8 aF_SW_2       (use dinx) 0010000000000000101011001100100110        Q = 4                                             00006023 close to store
 * c9 IJT_3      a8 unxa8      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ca LH_3          (use dinx) 0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 40006023 close to store
 * cb WFI_2      60 unx60      0010000000000000101011101100100110        Check offset                                      00000000 
 * cc OR_0       45 WFI_3      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd SB_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * ce i0reserv   fe ILLe       xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   40006033 sloppy or      
 * cf (null)     13 condb_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d0 (null)     6d unx6d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 (null)     be IJ_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 (null)     3a SRxI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d4 (null)     9c unx9c      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     a7 EBRKWFI1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       2b SLTIX_1    0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00006067 close to jalr
 * da (null)     9b unx9b      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * db (null)     9c unx9c      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * dc CSRRSI_0   7e NMI_1      0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd (null)     c8 unxc8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * de (null)     26 OR_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * df (null)     26 OR_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e0 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007003 close to load
 * e1 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     37 ECALL_2    0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     af MRET_4     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 (null)     5e LHU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e7 (null)     3a SRxI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     bb SH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     81 JAERR_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      29 XOR_1      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007033 sloppy and     
 * ef (null)     5e LHU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     8a unx8a      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     3a SRxI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     60 unx60      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     c6 IJT_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     c5 MRET_5     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     cb QINT_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     aa unxaa      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       2b SLTIX_1    0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     79 unx79      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     88 unx88      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   7e NMI_1      0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      91 LDAF_2     0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       7a SB_5       0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     bd IJ_4       0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0040, used ffff, inputs 33
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       60 unx60      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       54 LH_2       0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     68 unx68      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     68 unx68      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   17 condb_5t   0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     83 unx83      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       97 SW_E1SWH   0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     83 unx83      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       46 ILL_1      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     68 unx68      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      1f IJ_2       0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     68 unx68      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      97 SW_E1SWH   0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    2e unx2e      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 13 jFault     29 XOR_1      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 14 eILL0b     2b SLTIX_1    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 15 MRET_8     06 LB_3       0010000000000000101011101100100110        Prep +4                                           00000000 
 * 16 (null)     66 SW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 17 LB_5       42 unx42      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 18 BEQ        22 unx22      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     78 unx78      0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a (null)     68 unx68      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   50 LW_1       0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     68 unx68      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e (null)     c2 unxc2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 1f SUB_1      b5 SH_3       0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 20 LH_0       30 SLTIX_2    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 AND_1      68 unx68      0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 22 condb_2       (use dinx) 0010000000000000111111101100000xx0        ~RS2 in Q                                         0000100b close to ij
 * 23 _L0x23     68 unx68      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     5f LDAF_LHU   0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LW_1       49 CSRRW_1    0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LW    39 unx39      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     4e eILL0b     0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_3    41 JALR_1     0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2a _L0x2a     4e eILL0b     0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_4    53 LDAF_LH    0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 2c SLL_0      76 BAERR_2    0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     68 unx68      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     68 unx68      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_1       68 unx68      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LH    4d unx4d      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 LH_2       46 ILL_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 33 aFaultb    94 SW_E4      0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 34 LHU_1      66 SW_1       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 35 LDAF_LHU   65 WFI_4      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 36 SW_1       03 _L0x03     0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 37 SW_E1SWE   63 unx63      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 38 BNE        22 unx22      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 ORI_2         (use dinx) 0000000000000100001011101000111000        rd = Iimm | RS1                                   00001067 close to jalr
 * 3a aFault_1   75 BAlignEr   0010000000000000101011001100100110        Q = 4                                             00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    7e NMI_1      0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d IJ_2       03 _L0x03     0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 3e LHU_2      5f LDAF_LHU   0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultc    74 BrOpFet    0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 40 LW_0       26 OR_1       0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 XORI_1     1d ORI_2      0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 42 BrOpFet       (use dinx) 0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    0000200b close to ij
 * 43 BAlignEr      (use dinx) 0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      0000200f close to fence
 * 44 SLTI_0     4d unx4d      0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 OR_1       87 JALRE1     0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 46 JAL_2      7d BAERR_4    0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 47 JALRE1     9c unx9c      0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 48 _L0x48     36 SLLI_2     1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 OR_2       7f JALRE2     0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 4a _L0x4a     36 SLLI_2     1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b XOR_1      b0 CSRRW_3    0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 4c SLT_0      57 LH_5       0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d SLTIX_1       (use dinx) 0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 4e SH_1       fe ILLe       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        40002033 sloppy slt     
 * 4f SW_E1SWH   68 unx68      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 50 ECAL_RET   68 unx68      0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 51 EBRKWFI1   c3 unxc3      0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 52 (null)     32 JAL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 SLTIX_2    c3 unxc3      0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 54 IJ_1       ca unxca      0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 55 IJT_1      3a SRxI_1     0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 56 (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 SLTX_1     97 SW_E1SWH   0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 58 ECALL_1       (use dinx) 0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00002063 close to branch
 * 59 MRET_1        (use dinx) 0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00002067 close to jalr
 * 5a (null)     85 LBU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    7e NMI_1      0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d JAL_3      cd unxcd      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 5e (null)     3e SLL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 5f SLLI_1     c3 unxc3      0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 60 LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003003 close to load
 * 61 aFaultd    73 BAERR_1    0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 62 eILL0c        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000300b close to ij
 * 63 ECALL_3       (use dinx) 0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    0000300f close to fence
 * 64 SLTIU_0    4d unx4d      0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLLI_2     6b SB_4       0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 66 Fetch      70 LHU_2      0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 67 eFetch     a2 unxa2      0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 68 StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00003023 close to store
 * 69 aFault        (use dinx) 0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 6a eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b WFI_5      8f ILL_3      0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 6c SLTU_0     57 LH_5       0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d ECALL_2       (use dinx) 0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 6e LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40003033 sloppy sltu    
 * 6f aFaulte    c1 IJT_2      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 70 SW_2       ffffffff (null)     0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 71 aF_SW      3a SRxI_1     0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 72 WFI_1      2e unx2e      0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 73 EBREAK_1   8d unx8d      0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 74 SRxI_1     12 unx12      0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 75 SRxI_2     8b LB_6       0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 76 SLL_1      8e _LCSRRS_1  0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 77 SRx_1      90 NMI_2      0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 78 JALR_1        (use dinx) 0010000000000000000011101100100110        Q=1                                               00003063 close to branch
 * 79 WFI_3         (use dinx) 0010000000000000101011101100100110        More check offset                                 00003067 close to jalr
 * 7a ILL_1      70 LHU_2      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    7e NMI_1      0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d ILL_2      5d SB_2       0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 7e CSRRW_1    9d unx9d      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 7f CSRRW_2    90 NMI_2      0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 80 LBU_0      95 SW_E3      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 LH_4       90 NMI_2      0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 82 LH_5          (use dinx) 0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               0000400b close to ij
 * 83 SB_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        0000400f close to fence
 * 84 XORI_0     41 JALR_1     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SB_2       6e unx6e      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 86 EBRKWFI2   5d SB_2       0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 87 WFI_4      93 SW_E2      0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 88 SB_4          (use dinx) 1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00004023 close to store
 * 89 MRET_6        (use dinx) 0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 8a LBU_3         (use dinx) 0010000000000000011011101100010xx0        Invert q. Prepare read mask                       40004023 close to store
 * 8b BAERR_1    68 unx68      0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 8c XOR_0      4b CSRRW_2    0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 8e BAERR_3    fe ILLe       0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       40004033 sloppy xor     
 * 8f SB_5       ab EBREAK_2   0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 90 BAERR_4    5d SB_2       0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 91 NMI_1      a1 ECALL_4    0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 92 (null)     5d SB_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 JALRE2     a5 MRET_3     0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * 94 JAERR_2    5d SB_2       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 95 LBU_1      a3 unxa3      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 96 (null)     b6 ECALL_5    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 LB_6       a2 unxa2      0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 98 BLT        22 unx22      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a (null)     5d SB_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 9b _LCSRRS_1     (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 9c ILL_3         (use dinx) 0010000000000000101011101100100110        Q = 1                                             00004073 close to csr/system 
 * 9d NMI_2         (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 9e (null)     a8 unxa8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 9f LDAF_2     70 LHU_2      0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * a0 LHU_0      34 JAL_3      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 LDAF_3     b4 i0reserv   0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * a2 SW_E2         (use dinx) 0000000000001101101111101000001xx0        Store address that faulted                        0000500b close to ij
 * a3 SW_E4         (use dinx) 0000110000001110100111100x00101000        Store 6 to mcause                                 0000500f close to fence
 * a4 SRxI_0     74 BrOpFet    0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SW_E3      af MRET_4     0010000000000000101111001100100110        Q = 3                                             00000000 
 * a6 ECALL_6    58 unx58      0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * a7 SH_4       86 JAL_2      1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * a8 SH_5          (use dinx) 0000000000000001110011100100001xx0        Write d to a+k until accepted                     00005023 close to store
 * a9 ECALL_4    5d SB_2       0010000000000000101011001100100110        Q = 4                                             00000000 
 * aa MRET_3        (use dinx) 0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          40005023 close to store
 * ab ILL_4      a6 ECAL_RET   0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * ac _L0xac     77 BAERR_3    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad EBREAK_2      (use dinx) 0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * ae _L0xae     77 BAERR_3    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_4     ba LHU_3      0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b0 CSRRW_3    b2 CSRRW_4    0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b1 aF_SW_3    a1 ECALL_4    0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * b2 CSRRW_4    66 SW_1       0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b3 SH_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b4 ECALL_5       (use dinx) 0010000000000000101011001100100110        Q = 8                                             00000000 
 * b5 IJ_3       a7 EBRKWFI1   0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b6 SH_2       a6 ECAL_RET   0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * b7 IJ_4       b7 IJ_3       0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * b8 BGE        22 unx22      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 IJT_2         (use dinx) 0000000000001100101011101000110000        Read word is to be masked with ~3u                00005067 close to jalr
 * ba MRET_5     2e unx2e      0010000000000000000011101100010xx0        ~302                                              00000000 
 * bb IJT_4      b3 unxb3      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * bc CSRRWI_0   7e NMI_1      0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd QINT_1     66 SW_1       0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * be MRET_2     3d SRxI_2     0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * bf QINT_2     b9 unxb9      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * c0 _LCSRRCI_1    (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00006003 close to load
 * c1 MRET_7     c9 MRET_2     0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * c2 aFault_2      (use dinx) 0000110000001110001011100x00100110        Store 5 to mcause                                 0000600b close to ij
 * c3 LDAF_a        (use dinx) 0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      0000600f close to fence
 * c4 ORI_0      c7 QINT_1     0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 jFault_1   89 unx89      0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * c6 aF_SW_1    7d BAERR_4    0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * c7 ORI_1      bf IJT_1      0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * c8 aF_SW_2       (use dinx) 0010000000000000101011001100100110        Q = 4                                             00006023 close to store
 * c9 IJT_3      aa unxaa      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ca LH_3          (use dinx) 0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 40006023 close to store
 * cb WFI_2      68 unx68      0010000000000000101011101100100110        Check offset                                      00000000 
 * cc OR_0       45 WFI_3      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd SB_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * ce i0reserv   fe ILLe       xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   40006033 sloppy or      
 * cf (null)     15 condb_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d0 (null)     6d unx6d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 (null)     be IJ_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 (null)     3a SRxI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d4 (null)     a1 ECALL_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     a9 ILL_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       22 unx22      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00006067 close to jalr
 * da (null)     9f SH_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * db (null)     a1 ECALL_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * dc CSRRSI_0   7e NMI_1      0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd (null)     c8 unxc8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * de (null)     12 unx12      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * df (null)     12 unx12      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e0 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007003 close to load
 * e1 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     2e unx2e      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     b1 aF_SW_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 (null)     66 SW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e7 (null)     3a SRxI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     bb SH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     81 JAERR_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      21 XORI_1     0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007033 sloppy and     
 * ef (null)     66 SW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     8a unx8a      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     3a SRxI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     68 unx68      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     c6 IJT_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     c5 MRET_5     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     cb QINT_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     ad unxad      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       22 unx22      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     79 unx79      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     88 unx88      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   7e NMI_1      0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      91 LDAF_2     0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       7a SB_5       0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     bd IJ_4       0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0010, used cfff, inputs 39
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       78 unx78      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       6a unx6a      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     86 JAL_2      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     86 JAL_2      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   15 condb_4    0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     9c unx9c      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       b9 unxb9      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     9c unx9c      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       62 unx62      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     86 JAL_2      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      1a ANDI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     86 JAL_2      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 Fetch2     b9 unxb9      000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 11 jFault     2b SLTIX_1    0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 12 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 13 jFault     22 unx22      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 14 (null)     29 XOR_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 15 LB_5       06 LB_3       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 16 (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 17 JALR_2     60 unx60      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 18 BEQ        21 XORI_1     0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     7d BAERR_4    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a SUB_1      86 JAL_2      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 1b _L0x1b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   68 unx68      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d AND_1      86 JAL_2      0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 1e JAL_1      e3 unxe3      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 1f JAERR_1    d5 unxd5      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 20 LH_0       42 unx42      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 condb_2    86 JAL_2      0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 22 condb_3       (use dinx) 0010000000000000001011101100100110        Calculate RS1+~RS2+1                              0000100b close to ij
 * 23 _L0x23     86 JAL_2      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     55 aFaultb    0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 eILL0b     45 WFI_3      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     2e unx2e      0010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_4    3d SRxI_2     0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 2a _L0x2a     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b ANDI_1     4d unx4d      0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 2c SLL_0      6d unx6d      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     86 JAL_2      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e ORI_2         (use dinx) 0000000000000100001011101000111000        rd = Iimm | RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     86 JAL_2      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 31 (null)     4b CSRRW_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 32 (null)     62 unx62      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 (null)     ad unxad      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 34 (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 35 (null)     57 LH_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 (null)     7f JALRE2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 38 BNE        21 XORI_1     0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 aFault_1      (use dinx) 0010000000000000101011001100100110        Q = 4                                             00001067 close to jalr
 * 3a IJ_2       65 WFI_4      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 3b _L0x3b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    91 LDAF_2     0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d XORI_1     03 _L0x03     0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 3e LW_1       55 aFaultb    0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    5d SB_2       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 OR_1       17 condb_5t   0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 42 LH_1          (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH       (use dinx) 0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     4b CSRRW_2    0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 OR_2       9f SH_5       0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 46 LH_2       8d unx8d      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    bb SH_2       0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     58 unx58      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XOR_1      93 SW_E2      0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 4a _L0x4a     58 unx58      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b SLTIX_1    cd unxcd      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 4c SLT_0      51 LDAF_LW    0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d SLTIX_2       (use dinx) 0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 4e LHU_1      fe ILLe       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40002033 sloppy slt     
 * 4f LDAF_LHU   86 JAL_2      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 50 (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 51 SLTX_1     e5 aF_SW_2    0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 52 (null)     46 ILL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 JAL_3      e5 aF_SW_2    0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 54 (null)     eb LH_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 55 SLLI_1     39 unx39      0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 56 (null)     97 SW_E1SWH   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 SLLI_2     b9 unxb9      0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 58 SW_1          (use dinx) 0000000000000011111011100100001xx0        Write d to a+k until accepted                     00002063 close to branch
 * 59 SW_E1SWE      (use dinx) 0000000000001111001011100x00110000        Store faulting address alignment to mtval         00002067 close to jalr
 * 5a ECALL_2    9d unx9d      0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 5b _L0x5b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    91 LDAF_2     0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SRxI_1     ee eILL0a     0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 5e LHU_2      5e LHU_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaultc    e5 aF_SW_2    0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 60 BrOpFet       (use dinx) 0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00003003 close to load
 * 61 BAlignEr   9b unx9b      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 62 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             0000300b close to ij
 * 63 JALRE1        (use dinx) 0000000000001101110011100x00001xx0  err   Store pc to mepc                                  0000300f close to fence
 * 64 SLTIU_0    4b CSRRW_2    0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SRxI_2     89 unx89      0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 66 SH_1       8e _LCSRRS_1  0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 67 SW_E1SWH   c0 unxc0      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 68 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00003023 close to store
 * 69 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 6a IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   40003023 close to store
 * 6b IJT_1      a8 unxa8      0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 6c SLTU_0     51 LDAF_LW    0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SLL_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 6e ECALL_1       (use dinx) 0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40003033 sloppy sltu    
 * 6f MRET_1     e2 unxe2      0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 70 (null)     ffffffff (null)     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 71 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 72 (null)     2b SLTIX_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 74 (null)     12 unx12      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 75 (null)     a5 MRET_3     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 76 (null)     a7 EBRKWFI1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 (null)     a9 ILL_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 78 LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003063 close to branch
 * 79 aFaultd       (use dinx) 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00003067 close to jalr
 * 7a SRx_1      8e _LCSRRS_1  0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 7b _L0x7b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    91 LDAF_2     0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d JALR_1     53 LDAF_LH    0010000000000000000011101100100110        Q=1                                               00000000 
 * 7e eILL0c     bd IJ_4       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 7f ECALL_3    a9 ILL_4      0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 80 LBU_0      af MRET_4     0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 WFI_3      a9 ILL_4      0010000000000000101011101100100110        More check offset                                 00000000 
 * 82 Fetch         (use dinx) 0000000000001000001111101010110000  Fr00  Read and latch instruction                        0000400b close to ij
 * 83 eFetch        (use dinx) 0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             0000400f close to fence
 * 84 XORI_0     3d SRxI_2     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 ILL_1      8a unx8a      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 86 StdIncPc   53 LDAF_LH    0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * 87 aFault     ab EBREAK_2   0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 88 eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00004023 close to store
 * 89 WFI_5         (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 8a LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40004023 close to store
 * 8b aFaulte    86 JAL_2      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 8c XOR_0      49 CSRRW_1    0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d ILL_2         (use dinx) 0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 8e SW_2       fe ILLe       0010000000000000001011x01000xxxxx0        Prepare read PC                                   40004033 sloppy xor     
 * 8f aF_SW      c9 MRET_2     0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 90 (null)     53 LDAF_LH    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 91 CSRRW_1    bf IJT_1      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 92 (null)     53 LDAF_LH    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 CSRRW_2    c2 unxc2      0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 94 (null)     53 LDAF_LH    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 95 LH_4       c1 IJT_2      0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 96 (null)     d7 ECALL_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 LH_5       c0 unxc0      0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 98 BLT        21 XORI_1     0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a WFI_1      53 LDAF_LH    0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 9b EBREAK_1      (use dinx) 0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 9c SB_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00004073 close to csr/system 
 * 9d SB_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 9e EBRKWFI2   c6 IJT_4      0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 9f WFI_4      8e _LCSRRS_1  0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * a0 LHU_0      4e eILL0b     0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SB_4       d3 aFaultd    1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * a2 MRET_6        (use dinx) 0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            0000500b close to ij
 * a3 LBU_3         (use dinx) 0010000000000000011011101100010xx0        Invert q. Prepare read mask                       0000500f close to fence
 * a4 SRxI_0     5d SB_2       0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 BAERR_1    cb QINT_2     0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * a6 BAERR_2    6e unx6e      0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * a7 BAERR_3    9e SH_4       0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * a8 SB_5          (use dinx) 0000000000000010110011100100001xx0        Write d to a+k until accepted                     00005023 close to store
 * a9 BAERR_4    53 LDAF_LH    0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * aa NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40005023 close to store
 * ab JALRE2     c3 unxc3      0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * ac _L0xac     7a SB_5       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad JAERR_2       (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * ae _L0xae     7a SB_5       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af LBU_1      db jFault_1   0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * b0 (null)     cf MRET_7     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b1 (null)     bf IJT_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b2 (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b5 (null)     c5 MRET_5     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b6 (null)     c3 unxc3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 (null)     d9 unxd9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b8 BGE        21 XORI_1     0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 LB_6          (use dinx) 0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00005067 close to jalr
 * ba _LCSRRS_1  2b SLTIX_1    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bb ILL_3      d1 MRET_1     0010000000000000101011101100100110        Q = 1                                             00000000 
 * bc CSRRWI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd NMI_2      82 unx82      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * be LDAF_2     3a SRxI_1     0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * bf LDAF_3     da LDAF_a     0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * c0 SW_E2         (use dinx) 0000000000001101101111101000001xx0        Store address that faulted                        00006003 close to load
 * c1 SW_E4      ea unxea      0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * c2 SW_E3         (use dinx) 0010000000000000101111001100100110        Q = 3                                             0000600b close to ij
 * c3 ECALL_6       (use dinx) 0000110000001110100111000x00100000        mcause = 11                                       0000600f close to fence
 * c4 ORI_0      e8 unxe8      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 SH_4       a2 unxa2      1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * c6 SH_5       8d unx8d      0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * c7 ECALL_4    e0 unxe0      0010000000000000101011001100100110        Q = 4                                             00000000 
 * c8 MRET_3        (use dinx) 0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00006023 close to store
 * c9 ILL_4      c8 unxc8      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * ca EBREAK_2      (use dinx) 0000000000001101101011101000001xx0        pc to mepc                                        40006023 close to store
 * cb MRET_4     86 JAL_2      0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * cc OR_0       41 JALR_1     0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd CSRRW_3       (use dinx) 0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * ce aF_SW_3    fe ILLe       0000110000001110001011000x00100000        Store 7 to mcause                                 40006033 sloppy or      
 * cf CSRRW_4    27 OR_2       0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d0 (null)     5a SB_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 SH_3       df eFetch     0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 ECALL_5    39 unx39      0010000000000000101011001100100110        Q = 8                                             00000000 
 * d4 (null)     bf IJT_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 SH_2       c7 QINT_1     0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d8 BLTU       21 XORI_1     0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 IJ_4          (use dinx) 0100000010001010110111100100011xx0        Mask and use as PC                                00006067 close to jalr
 * da IJT_2      be IJ_1       0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * db MRET_5     bf IJT_1      0010000000000000000011101100010xx0        ~302                                              00000000 
 * dc CSRRSI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd IJT_4      e9 IJT_3      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * de QINT_1     12 unx12      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * df MRET_2     12 unx12      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * e0 QINT_2        (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        00007003 close to load
 * e1 _LCSRRCI_1 2e unx2e      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * e2 MRET_7        (use dinx) 0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               0000700b close to ij
 * e3 aFault_2      (use dinx) 0000110000001110001011100x00100110        Store 5 to mcause                                 0000700f close to fence
 * e4 ANDI_0     2b SLTIX_1    0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 LDAF_a     ce _LCSRRCI_1 0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * e6 jFault_1   82 unx82      0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * e7 aF_SW_1    39 unx39      0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * e8 ORI_1         (use dinx) 0010000000000000000011101100001xx0        Q = RS1                                           00007023 close to store
 * e9 aF_SW_2    dd aF_SW_1    0010000000000000101011001100100110        Q = 4                                             00000000 
 * ea IJT_3         (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   40007023 close to store
 * eb LH_3       95 SW_E3      0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * ec AND_0      1d ORI_2      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed WFI_2         (use dinx) 0010000000000000101011101100100110        Check offset                                      00000000 
 * ee SB_3       fe ILLe       0010000000000000000011101000110000        Prepare get back address to use                   40007033 sloppy and     
 * ef i0reserv   82 unx82      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * f0 (null)     a3 unxa3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     e7 aFault     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     e6 StdIncPc   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     ed unxed      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     ca unxca      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       21 XORI_1     0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     81 JAERR_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     a1 ECALL_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      aa unxaa      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       85 LBU_1      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     de Fetch      0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0400, used fdff, inputs 4b
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       68 unx68      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       58 unx58      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     78 unx78      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     78 unx78      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     8e _LCSRRS_1  0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       a1 ECALL_4    0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     8e _LCSRRS_1  0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       36 SLLI_2     0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      21 XORI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      a1 ECALL_4    0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    39 unx39      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 eILL0b        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2b SLTIX_1    0010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       2e unx2e      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       6e unx6e      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    34 JAL_3      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        29 XOR_1      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     77 BAERR_3    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       78 unx78      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   4e eILL0b     0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     78 unx78      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       cd unxcd      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    bb SH_2       0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      78 unx78      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1         (use dinx) 0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     78 unx78      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     60 unx60      0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LHU_1      50 LW_1       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LHU   3a SRxI_1     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     3e SLL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_2    4b CSRRW_2    0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2a _L0x2a     3e SLL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_3    57 LH_5       0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2c SLL_0      73 BAERR_1    0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_4       (use dinx) 0010000000000000110011101101001xx0        Branch on condition                               40001033 sloppy sll     
 * 2f _L0x2f     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SW_1       78 unx78      0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 31 SW_E1SWE   54 LH_2       0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 32 LHU_2      36 SLLI_2     0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 33 aFaultc    9e SH_4       0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 34 BrOpFet    6e unx6e      0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 35 BAlignEr   63 unx63      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 36 JAL_2      03 _L0x03     0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 37 JALRE1     6b SB_4       0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 38 BNE        29 XOR_1      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00001067 close to jalr
 * 3a ORI_2      70 LHU_2      0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    85 LBU_1      0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d aFault_1   03 _L0x03     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 3e SH_1       60 unx60      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 3f SW_E1SWH   6d unx6d      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 40 LW_0       14 condb_3    0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 (null)     1d ORI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 42 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     0000200b close to ij
 * 43 jFault        (use dinx) 0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000200f close to fence
 * 44 SLTI_0     54 LH_2       0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 (null)     91 LDAF_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 46 Fetch2     81 JAERR_2    000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 47 jFault     a3 unxa3      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 48 _L0x48     30 SLTIX_2    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 IJ_2       8a unx8a      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 4a _L0x4a     30 SLTIX_2    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b XORI_1     b5 SH_3       0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4c SLT_0      5a SB_1       0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d OR_1          (use dinx) 0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 4e ECAL_RET   fe ILLe       0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40002033 sloppy slt     
 * 4f EBRKWFI1   78 unx78      0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 50 OR_2       78 unx78      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 51 (null)     ce _LCSRRCI_1 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 52 (null)     1e aFault_1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 XOR_1      ce _LCSRRCI_1 0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 54 SLTIX_1    d9 unxd9      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 55 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 56 (null)     8d unx8d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 SLTIX_2    a1 ECALL_4    0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 58 IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00002063 close to branch
 * 59 IJT_1         (use dinx) 0010000010000000101111101100001xx0        Exit CSR, enter trap                              00002067 close to jalr
 * 5a SLTX_1     8f ILL_3      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    85 LBU_1      0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d JAL_3      db jFault_1   0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 5e ECALL_1    32 JAL_1      0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 5f MRET_1     ce _LCSRRCI_1 0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 60 SLLI_1        (use dinx) 0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00003003 close to load
 * 61 (null)     89 unx89      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 62 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000300b close to ij
 * 63 SLLI_2        (use dinx) 0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                0000300f close to fence
 * 64 SLTIU_0    54 LH_2       0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 (null)     7f JALRE2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 66 (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 67 ECALL_2    a8 unxa8      0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 68 LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd       (use dinx) 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    9a ECALL_6    0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     5a SB_1       0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SRxI_1        (use dinx) 0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 6e Fetch         (use dinx) 0000000000001000001111101010110000  Fr00  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     cb QINT_2     0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 SRxI_2     ffffffff (null)     0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 71 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 72 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 SLL_1      96 SH_1       0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 74 SRx_1      46 ILL_1      0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 75 (null)     95 SW_E3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 76 (null)     97 SW_E1SWH   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 JALR_1     9b unx9b      0010000000000000000011101100100110        Q=1                                               00000000 
 * 78 StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00003063 close to branch
 * 79 aFault        (use dinx) 0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00003067 close to jalr
 * 7a WFI_3      86 JAL_2      0010000000000000101011101100100110        More check offset                                 00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    85 LBU_1      0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d ILL_1      5d SB_2       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 7e eILL0a     a5 MRET_3     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 7f WFI_5      9b unx9b      0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 80 LBU_0      9f SH_5       0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 ILL_2      9b unx9b      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 82 LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     0000400b close to ij
 * 83 aFaulte       (use dinx) 0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      0000400f close to fence
 * 84 XORI_0     4b CSRRW_2    0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 CSRRW_1    82 unx82      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 86 SW_2       5d SB_2       0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 87 aF_SW      9d unx9d      0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 88 WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   00004023 close to store
 * 89 EBREAK_1      (use dinx) 0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 8a CSRRW_2       (use dinx) 0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    40004023 close to store
 * 8b LH_4       78 unx78      0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 8c XOR_0      53 LDAF_LH    0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d LH_5          (use dinx) 0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 8e SB_1       fe ILLe       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        40004033 sloppy xor     
 * 8f SB_2       b2 CSRRW_4    0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 90 EBRKWFI2   5d SB_2       0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 91 WFI_4      a7 EBRKWFI1   0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 92 SB_4       5d SB_2       1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 93 MRET_6     aa unxaa      0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 94 LBU_3      5d SB_2       0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 95 BAERR_1    a9 ILL_4      0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 96 BAERR_2    bd IJ_4       0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 97 BAERR_3    a8 unxa8      0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * 98 BLT        29 XOR_1      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a SB_5       5d SB_2       0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 9b BAERR_4       (use dinx) 0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 9c NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00004073 close to csr/system 
 * 9d JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * 9e JAERR_2    af MRET_4     0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 9f LBU_1      86 JAL_2      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * a0 LHU_0      26 OR_1       0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 LB_6       ba LHU_3      0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * a2 _LCSRRS_1     (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000500b close to ij
 * a3 ILL_3         (use dinx) 0010000000000000101011101100100110        Q = 1                                             0000500f close to fence
 * a4 SRxI_0     6d unx6d      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 NMI_2      b4 i0reserv   0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * a6 LDAF_2     5e LHU_1      0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * a7 LDAF_3     90 NMI_2      0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * a8 SW_E2         (use dinx) 0000000000001101101111101000001xx0        Store address that faulted                        00005023 close to store
 * a9 SW_E4      5d SB_2       0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * aa SW_E3         (use dinx) 0010000000000000101111001100100110        Q = 3                                             40005023 close to store
 * ab ECALL_6    ab EBREAK_2   0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * ac _L0xac     74 BrOpFet    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad SH_4          (use dinx) 1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * ae _L0xae     74 BrOpFet    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SH_5       c0 unxc0      0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b0 ECALL_4    b7 IJ_3       0010000000000000101011001100100110        Q = 4                                             00000000 
 * b1 MRET_3     a7 EBRKWFI1   0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * b2 ILL_4      6e unx6e      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * b3 EBREAK_2      (use dinx) 0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * b4 MRET_4        (use dinx) 0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b5 CSRRW_3    ad unxad      0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b6 aF_SW_3    ab EBREAK_2   0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * b7 CSRRW_4    be IJ_1       0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b8 BGE        29 XOR_1      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SH_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   00005067 close to jalr
 * ba ECALL_5    39 unx39      0010000000000000101011001100100110        Q = 8                                             00000000 
 * bb IJ_3       b9 unxb9      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * bc CSRRWI_0   85 LBU_1      0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SH_2       6e unx6e      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * be IJ_4       49 CSRRW_1    0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * bf IJT_2      bf IJT_1      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c0 MRET_5        (use dinx) 0010000000000000000011101100010xx0        ~302                                              00006003 close to load
 * c1 (null)     d7 ECALL_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600b close to ij
 * c3 IJT_4         (use dinx) 0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    0000600f close to fence
 * c4 ORI_0      d3 aFaultd    0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     93 SW_E2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c6 (null)     81 JAERR_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c7 QINT_1     c9 MRET_2     0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * c8 MRET_2        (use dinx) 0010000000000000011011001100100000        0xff+3 = 0x102                                    00006023 close to store
 * c9 QINT_2     b1 aF_SW_3    0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * ca _LCSRRCI_1    (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006023 close to store
 * cb MRET_7     78 unx78      0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * cc OR_0       4d unx4d      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd aFault_2      (use dinx) 0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * ce LDAF_a     fe ILLe       0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      40006033 sloppy or      
 * cf jFault_1   13 condb_2    0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * d0 aF_SW_1    67 SW_E1SWE   0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * d1 (null)     c8 unxc8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 ORI_1      3d SRxI_2     0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * d4 aF_SW_2    a7 EBRKWFI1   0010000000000000101011001100100110        Q = 4                                             00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 IJT_3      b0 CSRRW_3    0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * d8 BLTU       29 XOR_1      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 LH_3          (use dinx) 0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00006067 close to jalr
 * da WFI_2      a6 ECAL_RET   0010000000000000101011101100100110        Check offset                                      00000000 
 * db SB_3       a7 EBRKWFI1   0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * dc CSRRSI_0   85 LBU_1      0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd i0reserv   d4 aFault_2   xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * de (null)     46 ILL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * df (null)     46 ILL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e0 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007003 close to load
 * e1 (null)     3a SRxI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     39 unx39      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     b6 ECALL_5    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e7 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     c3 unxc3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     8b LB_6       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      22 unx22      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007033 sloppy and     
 * ef (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     94 SW_E4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     78 unx78      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     d0 ECALL_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     cf MRET_7     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     da LDAF_a     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     b3 unxb3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       29 XOR_1      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     7a SB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     92 LDAF_3     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   85 LBU_1      0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      9c unx9c      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       7d BAERR_4    0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     c7 QINT_1     0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0040, used f5ff, inputs 53
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       76 BAERR_2    0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       72 LBU_3      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     82 unx82      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     82 unx82      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   17 condb_5t   0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     97 SW_E1SWH   0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       af MRET_4     0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     97 SW_E1SWH   0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       58 unx58      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     82 unx82      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      1f IJ_2       0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     82 unx82      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      af MRET_4     0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    2e unx2e      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 13 jFault     29 XOR_1      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 14 eILL0b     2b SLTIX_1    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 15 MRET_8     06 LB_3       0010000000000000101011101100100110        Prep +4                                           00000000 
 * 16 (null)     7e NMI_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 17 LB_5       56 LH_4       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 18 BEQ        22 unx22      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     81 JAERR_2    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   70 LHU_2      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     82 unx82      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e (null)     e6 StdIncPc   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 1f SUB_1      d5 unxd5      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 20 LH_0       30 SLTIX_2    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 AND_1      82 unx82      0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 22 condb_2       (use dinx) 0010000000000000111111101100000xx0        ~RS2 in Q                                         0000100b close to ij
 * 23 _L0x23     82 unx82      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     62 unx62      0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LW_1       42 unx42      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LW    33 JAERR_1    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     5e LHU_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_3    3d SRxI_2     0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2a _L0x2a     5e LHU_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_4    5a SB_1       0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 2c SLL_0      7a SB_5       0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     82 unx82      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     82 unx82      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_1       82 unx82      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LH    4e eILL0b     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 (null)     58 unx58      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 ORI_2      ab EBREAK_2   0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 34 LH_2       7e NMI_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 35 aFaultb    66 SW_1       0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 aFault_1   79 unx79      0010000000000000101011001100100110        Q = 4                                             00000000 
 * 38 BNE        22 unx22      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 IJ_2          (use dinx) 0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00001067 close to jalr
 * 3a (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    91 LDAF_2     0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d XORI_1     03 _L0x03     0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 3e (null)     62 unx62      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 3f OR_1       6a unx6a      0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 40 LW_0       26 OR_1       0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 (null)     1d ORI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 42 OR_2          (use dinx) 0010000000000000000011101100100000        Q = rs2                                           0000200b close to ij
 * 43 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000200f close to fence
 * 44 SLTI_0     4e eILL0b     0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 (null)     9d unx9d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 46 XOR_1      90 NMI_2      0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 47 (null)     b1 aF_SW_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 48 _L0x48     52 LH_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 (null)     93 SW_E2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 4a _L0x4a     52 LH_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b (null)     d0 ECALL_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 4c SLT_0      5d SB_2       0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 4e SLTIX_1    fe ILLe       0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             40002033 sloppy slt     
 * 4f (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 50 LHU_1      82 unx82      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 51 LDAF_LHU   e8 unxe8      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 52 SW_1       34 JAL_3      0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 53 SW_E1SWE   e8 unxe8      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 54 LHU_2      f3 aF_SW      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 55 aFaultc    37 ECALL_2    0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 56 BrOpFet    95 SW_E3      0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 57 BAlignEr   af MRET_4     0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 58 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             00002063 close to branch
 * 59 JALRE1        (use dinx) 0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00002067 close to jalr
 * 5a SLTIX_2    9b unx9b      0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    91 LDAF_2     0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLTX_1     f5 jFault     0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 5e SH_1       54 LH_2       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5f SW_E1SWH   e8 unxe8      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 60 JAL_3         (use dinx) 0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00003003 close to load
 * 61 (null)     8f ILL_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 62 SLLI_1        (use dinx) 0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      0000300b close to ij
 * 63 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000300f close to fence
 * 64 SLTIU_0    4e eILL0b     0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 (null)     87 JALRE1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 66 SLLI_2     8a unx8a      0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 67 (null)     b7 IJ_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 68 ECALL_2       (use dinx) 0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00003023 close to store
 * 69 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 6a SRxI_1        (use dinx) 0000000000000100101001101100001xx1        Register to shift to Q                            40003023 close to store
 * 6b (null)     a7 EBRKWFI1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 6c SLTU_0     5d SB_2       0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 6e SRxI_2        (use dinx) 0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                40003033 sloppy sltu    
 * 6f (null)     e2 unxe2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 70 ECAL_RET   ffffffff (null)     0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 71 EBRKWFI1   37 ECALL_2    0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 72 IJ_1       2e unx2e      0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 73 IJT_1      a5 MRET_3     0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 74 ECALL_1    12 unx12      0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 75 MRET_1     a3 unxa3      0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 76 LB_2       a6 ECAL_RET   0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 77 aFaultd    a8 unxa8      0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 78 eILL0c        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00003063 close to branch
 * 79 ECALL_3       (use dinx) 0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00003067 close to jalr
 * 7a SLL_1      8a unx8a      0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    91 LDAF_2     0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SRx_1      60 unx60      0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 7e Fetch      b3 unxb3      0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 7f eFetch     a8 unxa8      0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 80 LBU_0      ad unxad      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 JALR_1     a8 unxa8      0010000000000000000011101100100110        Q=1                                               00000000 
 * 82 StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    0000400b close to ij
 * 83 aFault        (use dinx) 0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          0000400f close to fence
 * 84 XORI_0     3d SRxI_2     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 WFI_3      88 unx88      0010000000000000101011101100100110        More check offset                                 00000000 
 * 86 eILL0a     60 unx60      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 87 WFI_5      aa unxaa      0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 88 LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00004023 close to store
 * 89 aFaulte       (use dinx) 0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 8a SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   40004023 close to store
 * 8b aF_SW      82 unx82      0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 8c XOR_0      46 ILL_1      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d ILL_1         (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 8e WFI_1      fe ILLe       0010000000000000000011001100100110 WFI    To check offset                                   40004033 sloppy xor     
 * 8f EBREAK_1   c8 unxc8      0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 90 ILL_2      60 unx60      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 91 CSRRW_1    b5 SH_3       0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 92 (null)     60 unx60      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 CSRRW_2    bb SH_2       0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 94 LH_4       60 unx60      0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 95 LH_5       b9 unxb9      0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 96 (null)     d6 eILL0c     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 SB_1       b7 IJ_3       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 98 BLT        22 unx22      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a (null)     60 unx60      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 9b SB_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 9c EBRKWFI2      (use dinx) 0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00004073 close to csr/system 
 * 9d WFI_4         (use dinx) 0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 9e (null)     c0 unxc0      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 9f SB_4       8a unx8a      1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * a0 LHU_0      50 LW_1       0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 MRET_6     d4 aFault_2   0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * a2 LBU_3         (use dinx) 0010000000000000011011101100010xx0        Invert q. Prepare read mask                       0000500b close to ij
 * a3 BAERR_1       (use dinx) 0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             0000500f close to fence
 * a4 SRxI_0     6a unx6a      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 BAERR_2    ce _LCSRRCI_1 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * a6 BAERR_3    74 BrOpFet    0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * a7 SB_5       9c unx9c      0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * a8 BAERR_4       (use dinx) 0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00005023 close to store
 * a9 NMI_1      60 unx60      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * aa JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   40005023 close to store
 * ab JAERR_2    bd IJ_4       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * ac _L0xac     7d BAERR_4    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad LBU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * ae _L0xae     7d BAERR_4    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af LB_6       da LDAF_a     0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * b0 _LCSRRS_1  d2 LB_2       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b1 ILL_3      b5 SH_3       0010000000000000101011101100100110        Q = 1                                             00000000 
 * b2 (null)     7e NMI_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 NMI_2         (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * b4 LDAF_2        (use dinx) 0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * b5 LDAF_3     bf IJT_1      0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * b6 (null)     bd IJ_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 SW_E2      d7 ECALL_3    0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * b8 BGE        22 unx22      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SW_E4         (use dinx) 0000110000001110100111100x00101000        Store 6 to mcause                                 00005067 close to jalr
 * ba (null)     2e unx2e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * bb SW_E3      d3 aFaultd    0010000000000000101111001100100110        Q = 3                                             00000000 
 * bc CSRRWI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ECALL_6    7e NMI_1      0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * be (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * bf SH_4       d9 unxd9      1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * c0 SH_5          (use dinx) 0000000000000001110011100100001xx0        Write d to a+k until accepted                     00006003 close to load
 * c1 (null)     f2 SW_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 ECALL_4       (use dinx) 0010000000000000101011001100100110        Q = 4                                             0000600b close to ij
 * c3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600f close to fence
 * c4 ORI_0      f0 LBU_2      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     a1 ECALL_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c6 MRET_3     90 NMI_2      0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * c7 (null)     df eFetch     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c8 ILL_4         (use dinx) 0000110000001110100111100x00100110        Store 2 to mcause                                 00006023 close to store
 * c9 (null)     c6 IJT_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ca EBREAK_2      (use dinx) 0000000000001101101011101000001xx0        pc to mepc                                        40006023 close to store
 * cb (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * cc OR_0       3f SRx_1      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ce MRET_4     fe ILLe       0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          40006033 sloppy or      
 * cf (null)     15 condb_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d0 CSRRW_3    68 unx68      0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * d1 aF_SW_3    de Fetch      0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * d2 CSRRW_4    09 LB_5       0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d3 SH_3       37 ECALL_2    0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d4 ECALL_5    b5 SH_3       0010000000000000101011001100100110        Q = 8                                             00000000 
 * d5 IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * d6 SH_2       fe ILLe       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d7 IJ_4       c2 unxc2      0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * d8 BLTU       22 unx22      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 IJT_2         (use dinx) 0000000000001100101011101000110000        Read word is to be masked with ~3u                00006067 close to jalr
 * da MRET_5     b4 i0reserv   0010000000000000000011101100010xx0        ~302                                              00000000 
 * db IJT_4      b5 SH_3       0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * dc CSRRSI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd QINT_1     f1 aFaulte    0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * de MRET_2     12 unx12      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * df QINT_2     12 unx12      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * e0 _LCSRRCI_1    (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00007003 close to load
 * e1 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 MRET_7        (use dinx) 0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     2e unx2e      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     d1 MRET_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 aFault_2   7e NMI_1      0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * e7 (null)     37 ECALL_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 LDAF_a        (use dinx) 0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00007023 close to store
 * e9 (null)     db jFault_1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea jFault_1      (use dinx) 0000000000001110001011100x00100110        Store 1 to mcause                                 40007023 close to store
 * eb (null)     94 SW_E4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      21 XORI_1     0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee aF_SW_1    fe ILLe       0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      40007033 sloppy and     
 * ef (null)     7e NMI_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 ORI_1      a2 unxa2      0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * f1 aF_SW_2    37 ECALL_2    0010000000000000101011001100100110        Q = 4                                             00000000 
 * f2 IJT_3      82 unx82      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * f3 LH_3       ee eILL0a     0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f4 WFI_2         (use dinx) 0010000000000000101011101100100110        Check offset                                      00000000 
 * f5 SB_3       ea unxea      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f6 i0reserv   f4 Fetch2     xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * f7 (null)     ca unxca      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       22 unx22      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     85 LBU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     9f SH_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      a9 ILL_4      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       8d unx8d      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     dd aF_SW_1    0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0010, used cfff, inputs 59
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       9e SH_4       0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       9a ECALL_6    0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     a8 unxa8      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     a8 unxa8      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   15 condb_4    0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     95 SW_E3      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       ca unxca      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     95 SW_E3      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       88 unx88      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     a8 unxa8      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      1a ANDI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     a8 unxa8      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 Fetch2     ca unxca      000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 11 jFault     2b SLTIX_1    0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 12 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 13 jFault     22 unx22      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 14 (null)     29 XOR_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 15 LB_5       06 LB_3       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 16 (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 17 JALR_2     86 JAL_2      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 18 BEQ        21 XORI_1     0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     6e unx6e      0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a SUB_1      a8 unxa8      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 1b _L0x1b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   8e _LCSRRS_1  0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d AND_1      a8 unxa8      0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 1e JAL_1      4d unx4d      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 1f JAERR_1    67 SW_E1SWE   0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 20 LH_0       58 unx58      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 condb_2    a8 unxa8      0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 22 condb_3       (use dinx) 0010000000000000001011101100100110        Calculate RS1+~RS2+1                              0000100b close to ij
 * 23 _L0x23     a8 unxa8      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     5a SB_1       0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 eILL0b     39 unx39      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     2e unx2e      0010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     8a unx8a      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_4    35 SLLI_1     0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 2a _L0x2a     8a unx8a      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b ANDI_1     42 unx42      0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 2c SLL_0      68 unx68      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     a8 unxa8      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e ORI_2         (use dinx) 0000000000000100001011101000111000        rd = Iimm | RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     a8 unxa8      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 (null)     a8 unxa8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 31 aFault_1   3d SRxI_2     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 32 (null)     88 unx88      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 IJ_2       c6 IJT_4      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 34 (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 35 XORI_1     5d SB_2       0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 OR_1       a3 unxa3      0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 38 BNE        21 XORI_1     0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 OR_2          (use dinx) 0010000000000000000011101100100000        Q = rs2                                           00001067 close to jalr
 * 3a XOR_1      66 SW_1       0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 3b _L0x3b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    85 LBU_1      0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d SLTIX_1    03 _L0x03     0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 3e LW_1       5a SB_1       0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    62 unx62      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 EBREAK_2   17 condb_5t   0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * 42 SLTIX_2       (use dinx) 0000000000000100001011101000110010        Registered ALU flag to rd                         0000200b close to ij
 * 43 MRET_4        (use dinx) 0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          0000200f close to fence
 * 44 SLTI_0     3d SRxI_2     0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 CSRRW_3    a5 MRET_3     0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * 46 SLTX_1     81 JAERR_2    0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 47 aF_SW_3    d9 unxd9      0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 48 _L0x48     7e NMI_1      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 _LCSRRCI_1 8d unx8d      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 4a _L0x4a     7e NMI_1      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MRET_7     45 WFI_3      0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * 4c SLT_0      46 ILL_1      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d aFault_2      (use dinx) 0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 4e JAL_3      fe ILLe       0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                40002033 sloppy slt     
 * 4f LDAF_a     a8 unxa8      0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * 50 (null)     a8 unxa8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 51 (null)     4f MRET_8     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 52 (null)     5e LHU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 (null)     4f MRET_8     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 54 (null)     cb QINT_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 55 (null)     31 SLTX_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 56 (null)     93 SW_E2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 (null)     ca unxca      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 58 LH_1          (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00002063 close to branch
 * 59 LDAF_LH       (use dinx) 0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00002067 close to jalr
 * 5a SLLI_1     97 SW_E1SWH   0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 5b _L0x5b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    85 LBU_1      0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLLI_2     cf MRET_7     0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 5e LH_2       82 unx82      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaultb    4f MRET_8     0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 60 ECALL_2       (use dinx) 0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00003003 close to load
 * 61 CSRRW_4    db jFault_1   0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * 62 SRxI_1        (use dinx) 0000000000000100101001101100001xx1        Register to shift to Q                            0000300b close to ij
 * 63 SH_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   0000300f close to fence
 * 64 SLTIU_0    3d SRxI_2     0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 ECALL_5    ab EBREAK_2   0010000000000000101011001100100110        Q = 8                                             00000000 
 * 66 SRxI_2     be IJ_1       0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 67 IJ_3       e0 unxe0      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 68 SLL_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00003023 close to store
 * 69 jFault_1      (use dinx) 0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 6a SRx_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  40003023 close to store
 * 6b aF_SW_1    b9 unxb9      0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 6c SLTU_0     46 ILL_1      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d ORI_1         (use dinx) 0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 6e JALR_1        (use dinx) 0010000000000000000011101100100110        Q=1                                               40003033 sloppy sltu    
 * 6f aF_SW_2    4b CSRRW_2    0010000000000000101011001100100110        Q = 4                                             00000000 
 * 70 (null)     ffffffff (null)     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 71 (null)     31 SLTX_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 72 (null)     2b SLTIX_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 (null)     b5 SH_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 74 (null)     12 unx12      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 75 (null)     b3 unxb3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 76 (null)     b7 IJ_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 (null)     bd IJ_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 78 LHU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00003063 close to branch
 * 79 LDAF_LHU      (use dinx) 0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00003067 close to jalr
 * 7a WFI_3      be IJ_1       0010000000000000101011101100100110        More check offset                                 00000000 
 * 7b _L0x7b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    85 LBU_1      0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d ILL_1      4e eILL0b     0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 7e SW_1       dd aF_SW_1    0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 7f SW_E1SWE   bd IJ_4       0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 80 LBU_0      c8 unxc8      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 ILL_2      bd IJ_4       0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 82 LHU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     0000400b close to ij
 * 83 aFaultc       (use dinx) 0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      0000400f close to fence
 * 84 XORI_0     35 SLLI_1     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 CSRRW_1    ba LHU_3      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 86 BrOpFet    4e eILL0b     0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 87 BAlignEr   c2 unxc2      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 88 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             00004023 close to store
 * 89 JALRE1        (use dinx) 0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 8a SH_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        40004023 close to store
 * 8b SW_E1SWH   a8 unxa8      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 8c XOR_0      3a SRxI_1     0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d CSRRW_2       (use dinx) 0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 8e ECAL_RET   fe ILLe       0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40004033 sloppy xor     
 * 8f EBRKWFI1   fb SB_3       0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 90 (null)     4e eILL0b     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 91 LH_4       df eFetch     0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 92 (null)     4e eILL0b     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 LH_5       e6 StdIncPc   0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 94 (null)     4e eILL0b     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 95 SB_1       e2 unxe2      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 96 (null)     c1 IJT_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 SB_2       e0 unxe0      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 98 BLT        21 XORI_1     0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a IJ_1       4e eILL0b     0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 9b IJT_1         (use dinx) 0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 9c ECALL_1       (use dinx) 0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00004073 close to csr/system 
 * 9d MRET_1        (use dinx) 0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 9e LB_2       ee eILL0a     0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 9f aFaultd    be IJ_1       0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * a0 LHU_0      78 unx78      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 EBRKWFI2   65 WFI_4      0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * a2 eILL0c        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000500b close to ij
 * a3 ECALL_3       (use dinx) 0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    0000500f close to fence
 * a4 SRxI_0     62 unx62      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 WFI_4      43 unx43      0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * a6 Fetch      9c unx9c      0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * a7 eFetch     a1 ECALL_4    0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * a8 StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00005023 close to store
 * a9 aFault     4e eILL0b     0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * aa eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40005023 close to store
 * ab WFI_5      e8 unxe8      0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * ac _L0xac     6a unx6a      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad SB_4          (use dinx) 1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * ae _L0xae     6a unx6a      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_6     c7 QINT_1     0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * b0 (null)     61 EBRKWFI2   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b1 LBU_3      df eFetch     0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * b2 (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 BAERR_1       (use dinx) 0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * b4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b5 BAERR_2    ea unxea      0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * b6 (null)     e8 unxe8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 BAERR_3    c3 unxc3      0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * b8 BGE        21 XORI_1     0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SB_5          (use dinx) 0000000000000010110011100100001xx0        Write d to a+k until accepted                     00005067 close to jalr
 * ba LBU_2      2b SLTIX_1    0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * bb aFaulte    63 unx63      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * bc CSRRWI_0   85 LBU_1      0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd BAERR_4    a6 ECAL_RET   0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * be SW_2       33 JAERR_1    0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * bf aF_SW      c5 MRET_5     0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * c0 NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00006003 close to load
 * c1 SH_2       c9 MRET_2     0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * c2 JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   0000600b close to ij
 * c3 IJ_4          (use dinx) 0100000010001010110111100100011xx0        Mask and use as PC                                0000600f close to fence
 * c4 ORI_0      6d unx6d      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 IJT_2      af MRET_4     0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c6 JAERR_2    81 JAERR_2    0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * c7 MRET_5     e7 aFault     0010000000000000000011101100010xx0        ~302                                              00000000 
 * c8 LBU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00006023 close to store
 * c9 IJT_3      fa WFI_2      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ca LB_6          (use dinx) 0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          40006023 close to store
 * cb LH_3       a8 unxa8      0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * cc OR_0       37 ECALL_2    0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd WFI_2         (use dinx) 0010000000000000101011101100100110        Check offset                                      00000000 
 * ce _LCSRRS_1  fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006033 sloppy or      
 * cf SB_3       27 OR_2       0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d0 (null)     60 unx60      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 (null)     e5 aF_SW_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 (null)     31 SLTX_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d4 (null)     df eFetch     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     f9 unxf9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       21 XORI_1     0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 ILL_3         (use dinx) 0010000000000000101011101100100110        Q = 1                                             00006067 close to jalr
 * da WFI_1      de Fetch      0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * db EBREAK_1   df eFetch     0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * dc CSRRSI_0   85 LBU_1      0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd NMI_2      6f MRET_6     0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * de LDAF_2     12 unx12      0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * df LDAF_3     12 unx12      0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * e0 SW_E2         (use dinx) 0000000000001101101111101000001xx0        Store address that faulted                        00007003 close to load
 * e1 IJT_4      2e unx2e      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * e2 SW_E4         (use dinx) 0000110000001110100111100x00101000        Store 6 to mcause                                 0000700b close to ij
 * e3 QINT_1        (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 0000700f close to fence
 * e4 ANDI_0     2b SLTIX_1    0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 MRET_2     47 ILL_2      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * e6 SW_E3      a6 ECAL_RET   0010000000000000101111001100100110        Q = 3                                             00000000 
 * e7 QINT_2     31 SLTX_1     0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * e8 ECALL_6       (use dinx) 0000110000001110100111000x00100000        mcause = 11                                       00007023 close to store
 * e9 i0reserv   e1 ORI_1      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * ea SH_4          (use dinx) 1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      40007023 close to store
 * eb (null)     91 LDAF_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      1d ORI_2      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee SH_5       fe ILLe       0000000000000001110011100100001xx0        Write d to a+k until accepted                     40007033 sloppy and     
 * ef (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     b1 aF_SW_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     31 SLTX_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     a8 unxa8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     6b SB_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     69 unx69      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     cd unxcd      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     41 JALR_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       21 XORI_1     0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 ECALL_4       (use dinx) 0010000000000000101011001100100110        Q = 4                                             00007067 close to jalr
 * fa MRET_3     7a SB_5       0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * fb ILL_4      ad unxad      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * fc CSRRCI_0   85 LBU_1      0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      c0 unxc0      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       7d BAERR_4    0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     e3 unxe3      0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0400, used ffff, inputs 87
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       50 LW_1       0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       46 ILL_1      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     56 LH_4       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     56 LH_4       0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     77 BAERR_3    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       90 NMI_2      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     77 BAERR_3    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       36 SLLI_2     0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      21 XORI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      90 NMI_2      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    39 unx39      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 eILL0b        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2b SLTIX_1    0010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       2e unx2e      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       54 LH_2       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    34 JAL_3      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        29 XOR_1      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     6f MRET_6     0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       56 LH_4       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   42 unx42      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     56 LH_4       0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       bf IJT_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    b0 CSRRW_3    0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      56 LH_4       0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1         (use dinx) 0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     56 LH_4       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     67 SW_E1SWE   0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LHU_1      4b CSRRW_2    0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LHU   3a SRxI_1     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     3e SLL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_2    45 WFI_3      0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2a _L0x2a     3e SLL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_3    5d SB_2       0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2c SLL_0      6d unx6d      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_4       (use dinx) 0010000000000000110011101101001xx0        Branch on condition                               40001033 sloppy sll     
 * 2f _L0x2f     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SW_1       56 LH_4       0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 31 SW_E1SWE   5a SB_1       0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 32 LHU_2      36 SLLI_2     0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 33 aFaultc    8e _LCSRRS_1  0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 34 BrOpFet    54 LH_2       0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 35 BAlignEr   68 unx68      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 36 JAL_2      03 _L0x03     0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 37 JALRE1     53 LDAF_LH    0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 38 BNE        29 XOR_1      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00001067 close to jalr
 * 3a ORI_2      6b SB_4       0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    73 BAERR_1    0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d aFault_1   03 _L0x03     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 3e SH_1       67 SW_E1SWE   0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 3f SW_E1SWH   6a unx6a      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 40 LW_0       14 condb_3    0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 IJ_2       1d ORI_2      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 42 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000200b close to ij
 * 43 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000200f close to fence
 * 44 SLTI_0     5a SB_1       0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 XORI_1     7a SB_5       0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 46 IJ_1       72 LBU_3      0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 47 IJT_1      93 SW_E2      0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 48 _L0x48     30 SLTIX_2    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 OR_1       74 BrOpFet    0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 4a _L0x4a     30 SLTIX_2    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b OR_2       a8 unxa8      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 4c SLT_0      65 WFI_4      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d XOR_1         (use dinx) 0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 4e ECALL_1    fe ILLe       0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40002033 sloppy slt     
 * 4f MRET_1     56 LH_4       0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 50 LB_2       56 LH_4       0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 51 aFaultd    c0 unxc0      0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 52 eILL0c     1e aFault_1   0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 53 ECALL_3    c0 unxc0      0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 54 Fetch      c8 unxc8      0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 55 eFetch     3d SRxI_2     0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 56 StdIncPc   76 BAERR_2    0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * 57 aFault     90 NMI_2      0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 58 eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00002063 close to branch
 * 59 WFI_5         (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch                                    00002067 close to jalr
 * 5a SLTIX_1    78 unx78      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    73 BAERR_1    0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLTIX_2    cb QINT_2     0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 5e LBU_2      32 JAL_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaulte    c0 unxc0      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 60 SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   00003003 close to load
 * 61 aF_SW      63 unx63      0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 62 WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   0000300b close to ij
 * 63 EBREAK_1      (use dinx) 0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       0000300f close to fence
 * 64 SLTIU_0    5a SB_1       0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLTX_1     59 unx59      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 66 JAL_3      60 unx60      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 67 SLLI_1     97 SW_E1SWH   0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 68 SLLI_2        (use dinx) 0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00003023 close to store
 * 69 ECALL_2       (use dinx) 0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 6a SRxI_1        (use dinx) 0000000000000100101001101100001xx1        Register to shift to Q                            40003023 close to store
 * 6b SRxI_2     87 JALRE1     0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 6c SLTU_0     65 WFI_4      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SLL_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 6e SRx_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  40003033 sloppy sltu    
 * 6f JALR_1     be IJ_1       0010000000000000000011101100100110        Q=1                                               00000000 
 * 70 WFI_3      ffffffff (null)     0010000000000000101011101100100110        More check offset                                 00000000 
 * 71 ILL_1      3d SRxI_2     0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 72 ILL_2      39 unx39      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 73 CSRRW_1    85 LBU_1      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 74 CSRRW_2    8a unx8a      0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 75 LH_4       81 JAERR_2    0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 76 LH_5       86 JAL_2      0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 77 SB_1       88 unx88      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 78 SB_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00003063 close to branch
 * 79 EBRKWFI2      (use dinx) 0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00003067 close to jalr
 * 7a WFI_4      60 unx60      0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    73 BAERR_1    0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SB_4       66 SW_1       1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 7e MRET_6     94 SW_E4      0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 7f LBU_3      88 unx88      0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 80 LBU_0      8f ILL_3      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 BAERR_1    88 unx88      0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 82 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     0000400b close to ij
 * 83 jFault        (use dinx) 0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000400f close to fence
 * 84 XORI_0     45 WFI_3      0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 BAERR_2    5e LHU_1      0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 86 BAERR_3    66 SW_1       0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * 87 SB_5       8d unx8d      0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 88 BAERR_4       (use dinx) 0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00004023 close to store
 * 89 NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 8a Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     40004023 close to store
 * 8b jFault     56 LH_4       0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 8c XOR_0      4d unx4d      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * 8e JAERR_2    fe ILLe       0000000000001101101011100x00001xx0        Store PC to mepc                                  40004033 sloppy xor     
 * 8f LBU_1      a5 MRET_3     0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 90 LB_6       66 SW_1       0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 91 _LCSRRS_1  96 SH_1       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 92 (null)     66 SW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 ILL_3      9c unx9c      0010000000000000101011101100100110        Q = 1                                             00000000 
 * 94 NMI_2      66 SW_1       0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 95 LDAF_2     9b unx9b      0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 96 LDAF_3     b1 aF_SW_3    0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 97 SW_E2      97 SW_E1SWH   0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 98 BLT        29 XOR_1      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a (null)     66 SW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 9b SW_E4         (use dinx) 0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 9c SW_E3         (use dinx) 0010000000000000101111001100100110        Q = 3                                             00004073 close to csr/system 
 * 9d ECALL_6       (use dinx) 0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 9e SH_4       9f SH_5       1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 9f SH_5       60 unx60      0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * a0 LHU_0      26 OR_1       0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_4    af MRET_4     0010000000000000101011001100100110        Q = 4                                             00000000 
 * a2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000500b close to ij
 * a3 MRET_3        (use dinx) 0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          0000500f close to fence
 * a4 SRxI_0     6a unx6a      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 ILL_4      a7 EBRKWFI1   0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * a6 EBREAK_2   4e eILL0b     0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * a7 MRET_4     79 unx79      0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * a8 CSRRW_3       (use dinx) 0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00005023 close to store
 * a9 aF_SW_3    66 SW_1       0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * aa (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40005023 close to store
 * ab CSRRW_4    9d unx9d      0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * ac _L0xac     6e unx6e      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad SH_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * ae _L0xae     6e unx6e      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af ECALL_5    b5 SH_3       0010000000000000101011001100100110        Q = 8                                             00000000 
 * b0 IJ_3       ab EBREAK_2   0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b1 SH_2       96 SH_1       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * b2 (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 IJ_4          (use dinx) 0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * b4 IJT_2         (use dinx) 0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * b5 MRET_5     9e SH_4       0010000000000000000011101100010xx0        ~302                                              00000000 
 * b6 IJT_4      9d unx9d      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * b7 QINT_1     b3 unxb3      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * b8 BGE        29 XOR_1      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MRET_2        (use dinx) 0010000000000000011011001100100000        0xff+3 = 0x102                                    00005067 close to jalr
 * ba (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * bb QINT_2     ad unxad      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * bc CSRRWI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd _LCSRRCI_1 54 LH_2       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * be MRET_7     41 JALR_1     0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * bf aFault_2   b4 i0reserv   0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * c0 LDAF_a        (use dinx) 0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00006003 close to load
 * c1 jFault_1   c7 QINT_1     0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * c2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600b close to ij
 * c3 aF_SW_1       (use dinx) 0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      0000600f close to fence
 * c4 ORI_0      c5 MRET_5     0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 ORI_1      7e NMI_1      0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * c6 aF_SW_2    72 LBU_3      0010000000000000101011001100100110        Q = 4                                             00000000 
 * c7 IJT_3      bb SH_2       0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * c8 LH_3          (use dinx) 0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00006023 close to store
 * c9 WFI_2      a3 unxa3      0010000000000000101011101100100110        Check offset                                      00000000 
 * ca (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40006023 close to store
 * cb SB_3       56 LH_4       0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * cc OR_0       49 CSRRW_1    0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd i0reserv      (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * ce (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40006033 sloppy or      
 * cf (null)     13 condb_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d0 (null)     69 unx69      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 (null)     b9 unxb9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d4 (null)     96 SH_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     a1 ECALL_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       29 XOR_1      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00006067 close to jalr
 * da (null)     95 SW_E3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * db (null)     96 SH_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * dc CSRRSI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd (null)     c6 IJT_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * de (null)     8a unx8a      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * df (null)     8a unx8a      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e0 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007003 close to load
 * e1 (null)     3a SRxI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     39 unx39      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     a9 ILL_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e7 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     b6 ECALL_5    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     75 BAlignEr   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      22 unx22      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007033 sloppy and     
 * ef (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     7f JALRE2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     56 LH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     c3 unxc3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     c1 IJT_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     c9 MRET_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       29 XOR_1      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     70 LHU_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     7d BAERR_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      89 unx89      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       71 aFaultc    0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     b7 IJ_3       0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0400, used fdff, inputs 8b
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       50 LW_1       0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       46 ILL_1      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     56 LH_4       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     56 LH_4       0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     77 BAERR_3    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       94 SW_E4      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     77 BAERR_3    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       36 SLLI_2     0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      21 XORI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      94 SW_E4      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    39 unx39      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 eILL0b        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2b SLTIX_1    0010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       2e unx2e      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       54 LH_2       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    34 JAL_3      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        29 XOR_1      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     6f MRET_6     0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       56 LH_4       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   42 unx42      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     56 LH_4       0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       cd unxcd      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    bb SH_2       0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      56 LH_4       0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1         (use dinx) 0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     56 LH_4       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     67 SW_E1SWE   0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LHU_1      4b CSRRW_2    0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LHU   3a SRxI_1     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     3e SLL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_2    45 WFI_3      0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2a _L0x2a     3e SLL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_3    5d SB_2       0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2c SLL_0      6d unx6d      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_4       (use dinx) 0010000000000000110011101101001xx0        Branch on condition                               40001033 sloppy sll     
 * 2f _L0x2f     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SW_1       56 LH_4       0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 31 SW_E1SWE   5a SB_1       0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 32 LHU_2      36 SLLI_2     0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 33 aFaultc    90 NMI_2      0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 34 BrOpFet    54 LH_2       0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 35 BAlignEr   68 unx68      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 36 JAL_2      03 _L0x03     0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 37 JALRE1     53 LDAF_LH    0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 38 BNE        29 XOR_1      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00001067 close to jalr
 * 3a ORI_2      6b SB_4       0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    73 BAERR_1    0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d aFault_1   03 _L0x03     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 3e SH_1       67 SW_E1SWE   0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 3f SW_E1SWH   6a unx6a      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 40 LW_0       14 condb_3    0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 IJ_2       1d ORI_2      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 42 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000200b close to ij
 * 43 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000200f close to fence
 * 44 SLTI_0     5a SB_1       0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 XORI_1     7a SB_5       0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 46 IJ_1       72 LBU_3      0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 47 IJT_1      9a ECALL_6    0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 48 _L0x48     30 SLTIX_2    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 OR_1       74 BrOpFet    0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 4a _L0x4a     30 SLTIX_2    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b OR_2       b3 unxb3      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 4c SLT_0      65 WFI_4      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d XOR_1         (use dinx) 0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 4e ECALL_1    fe ILLe       0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40002033 sloppy slt     
 * 4f MRET_1     56 LH_4       0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 50 LB_2       56 LH_4       0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 51 aFaultd    ce _LCSRRCI_1 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 52 eILL0c     1e aFault_1   0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 53 ECALL_3    ce _LCSRRCI_1 0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 54 Fetch      d9 unxd9      0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 55 eFetch     3d SRxI_2     0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 56 StdIncPc   76 BAERR_2    0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * 57 aFault     94 SW_E4      0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 58 eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00002063 close to branch
 * 59 WFI_5         (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch                                    00002067 close to jalr
 * 5a SLTIX_1    78 unx78      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    73 BAERR_1    0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLTIX_2    db jFault_1   0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 5e LBU_2      32 JAL_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaulte    ce _LCSRRCI_1 0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 60 SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   00003003 close to load
 * 61 aF_SW      63 unx63      0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 62 WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   0000300b close to ij
 * 63 EBREAK_1      (use dinx) 0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       0000300f close to fence
 * 64 SLTIU_0    5a SB_1       0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLTX_1     59 unx59      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 66 JAL_3      60 unx60      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 67 SLLI_1     9e SH_4       0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 68 SLLI_2        (use dinx) 0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00003023 close to store
 * 69 ECALL_2       (use dinx) 0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 6a SRxI_1        (use dinx) 0000000000000100101001101100001xx1        Register to shift to Q                            40003023 close to store
 * 6b SRxI_2     8b LB_6       0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 6c SLTU_0     65 WFI_4      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SLL_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 6e SRx_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  40003033 sloppy sltu    
 * 6f JALR_1     cb QINT_2     0010000000000000000011101100100110        Q=1                                               00000000 
 * 70 WFI_3      ffffffff (null)     0010000000000000101011101100100110        More check offset                                 00000000 
 * 71 ILL_1      3d SRxI_2     0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 72 ILL_2      39 unx39      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 73 CSRRW_1    89 unx89      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 74 CSRRW_2    86 JAL_2      0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 75 LH_4       88 unx88      0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 76 LH_5       8a unx8a      0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 77 SB_1       8d unx8d      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 78 SB_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00003063 close to branch
 * 79 EBRKWFI2      (use dinx) 0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00003067 close to jalr
 * 7a WFI_4      60 unx60      0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    73 BAERR_1    0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SB_4       66 SW_1       1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 7e MRET_6     9b unx9b      0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 7f LBU_3      8d unx8d      0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 80 LBU_0      93 SW_E2      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 (null)     8d unx8d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 82 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     0000400b close to ij
 * 83 jFault        (use dinx) 0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000400f close to fence
 * 84 XORI_0     45 WFI_3      0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 (null)     5e LHU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 86 Fetch2     66 SW_1       000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 87 jFault     8f ILL_3      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 88 BAERR_1       (use dinx) 0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00004023 close to store
 * 89 BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 8a BAERR_3       (use dinx) 0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       40004023 close to store
 * 8b SB_5       56 LH_4       0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 8c XOR_0      4d unx4d      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d BAERR_4       (use dinx) 0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 8e NMI_1      fe ILLe       0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40004033 sloppy xor     
 * 8f JALRE2     ad unxad      0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * 90 JAERR_2    66 SW_1       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 91 (null)     9d unx9d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 92 (null)     66 SW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 LBU_1      a3 unxa3      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 94 LB_6       66 SW_1       0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 95 (null)     9f SH_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 96 (null)     bd IJ_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 _LCSRRS_1  9e SH_4       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 98 BLT        29 XOR_1      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a ILL_3      66 SW_1       0010000000000000101011101100100110        Q = 1                                             00000000 
 * 9b NMI_2         (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 9c LDAF_2        (use dinx) 0000110000001110001011000x00100110        Store 4 to mcause                                 00004073 close to csr/system 
 * 9d LDAF_3        (use dinx) 0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 9e SW_E2      a9 ILL_4      0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 9f SW_E4      60 unx60      0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * a0 LHU_0      26 OR_1       0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 (null)     ba LHU_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000500b close to ij
 * a3 SW_E3         (use dinx) 0010000000000000101111001100100110        Q = 3                                             0000500f close to fence
 * a4 SRxI_0     6a unx6a      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 (null)     b0 CSRRW_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a6 (null)     4e eILL0b     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a7 ECALL_6    79 unx79      0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * a8 SH_4          (use dinx) 1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00005023 close to store
 * a9 SH_5       66 SW_1       0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * aa ECALL_4       (use dinx) 0010000000000000101011001100100110        Q = 4                                             40005023 close to store
 * ab MRET_3     a7 EBRKWFI1   0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * ac _L0xac     6e unx6e      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad ILL_4         (use dinx) 0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * ae _L0xae     6e unx6e      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af EBREAK_2   c0 unxc0      0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * b0 MRET_4     b7 IJ_3       0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b1 (null)     9d unx9d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b2 (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 CSRRW_3       (use dinx) 0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b4 aF_SW_3       (use dinx) 0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * b5 (null)     a8 unxa8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b6 (null)     a7 EBRKWFI1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 CSRRW_4    be IJ_1       0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b8 BGE        29 XOR_1      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SH_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   00005067 close to jalr
 * ba ECALL_5    39 unx39      0010000000000000101011001100100110        Q = 8                                             00000000 
 * bb IJ_3       b9 unxb9      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * bc CSRRWI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SH_2       54 LH_2       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * be IJ_4       41 JALR_1     0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * bf IJT_2      bf IJT_1      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c0 MRET_5        (use dinx) 0010000000000000000011101100010xx0        ~302                                              00006003 close to load
 * c1 (null)     d7 ECALL_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600b close to ij
 * c3 IJT_4         (use dinx) 0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    0000600f close to fence
 * c4 ORI_0      d3 aFaultd    0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     7e NMI_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c6 (null)     72 LBU_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c7 QINT_1     c9 MRET_2     0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * c8 MRET_2        (use dinx) 0010000000000000011011001100100000        0xff+3 = 0x102                                    00006023 close to store
 * c9 QINT_2     ab EBREAK_2   0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * ca _LCSRRCI_1    (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006023 close to store
 * cb MRET_7     56 LH_4       0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * cc OR_0       49 CSRRW_1    0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd aFault_2      (use dinx) 0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * ce LDAF_a     fe ILLe       0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      40006033 sloppy or      
 * cf jFault_1   13 condb_2    0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * d0 aF_SW_1    69 unx69      0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * d1 (null)     c8 unxc8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 ORI_1      3d SRxI_2     0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * d4 aF_SW_2    9d unx9d      0010000000000000101011001100100110        Q = 4                                             00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 IJT_3      aa unxaa      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * d8 BLTU       29 XOR_1      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 LH_3          (use dinx) 0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00006067 close to jalr
 * da WFI_2      9c unx9c      0010000000000000101011101100100110        Check offset                                      00000000 
 * db SB_3       9d unx9d      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * dc CSRRSI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd i0reserv   d4 aFault_2   xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * de (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * df (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e0 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007003 close to load
 * e1 (null)     3a SRxI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     39 unx39      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     b4 i0reserv   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e7 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     c3 unxc3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     75 BAlignEr   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      22 unx22      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007033 sloppy and     
 * ef (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     7f JALRE2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     56 LH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     d0 ECALL_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     cf MRET_7     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     da LDAF_a     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     af MRET_4     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       29 XOR_1      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     70 LHU_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     7d BAERR_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      8e _LCSRRS_1  0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       71 aFaultc    0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     c7 QINT_1     0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0040, used f5ff, inputs 93
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       68 unx68      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       62 unx62      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     70 LHU_2      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     70 LHU_2      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   17 condb_5t   0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     95 SW_E3      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       b3 unxb3      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     95 SW_E3      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       54 LH_2       0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     70 LHU_2      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      1f IJ_2       0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     70 LHU_2      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      b3 unxb3      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    2e unx2e      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 13 jFault     29 XOR_1      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 14 eILL0b     2b SLTIX_1    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 15 MRET_8     06 LB_3       0010000000000000101011101100100110        Prep +4                                           00000000 
 * 16 (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 17 LB_5       50 LW_1       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 18 BEQ        22 unx22      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     7d BAERR_4    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a (null)     70 LHU_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   60 unx60      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     70 LHU_2      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e (null)     e6 StdIncPc   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 1f SUB_1      d5 unxd5      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 20 LH_0       30 SLTIX_2    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 AND_1      70 LHU_2      0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 22 condb_2       (use dinx) 0010000000000000111111101100000xx0        ~RS2 in Q                                         0000100b close to ij
 * 23 _L0x23     70 LHU_2      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     57 LH_5       0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LW_1       41 JALR_1     0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LW    33 JAERR_1    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     58 unx58      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_3    3d SRxI_2     0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2a _L0x2a     58 unx58      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_4    4b CSRRW_2    0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 2c SLL_0      73 BAERR_1    0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     70 LHU_2      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     70 LHU_2      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_1       70 LHU_2      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LH    49 CSRRW_1    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 ORI_2      b1 aF_SW_3    0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 34 LH_2       6e unx6e      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 35 aFaultb    5d SB_2       0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 aFault_1   6b SB_4       0010000000000000101011001100100110        Q = 4                                             00000000 
 * 38 BNE        22 unx22      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 IJ_2          (use dinx) 0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00001067 close to jalr
 * 3a (null)     6d unx6d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    88 unx88      0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d XORI_1     03 _L0x03     0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 3e (null)     57 LH_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 3f OR_1       65 WFI_4      0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 40 LW_0       26 OR_1       0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 OR_2       1d ORI_2      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 42 LHU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LHU      (use dinx) 0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     49 CSRRW_1    0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 XOR_1      9a ECALL_6    0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 46 SW_1       86 JAL_2      0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 47 SW_E1SWE   b5 SH_3       0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 48 _L0x48     46 ILL_1      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 SLTIX_1    8a unx8a      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 4a _L0x4a     46 ILL_1      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b SLTIX_2    d0 ECALL_1    0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 4c SLT_0      4d unx4d      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d SLTX_1        (use dinx) 0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 4e LHU_2      fe ILLe       0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40002033 sloppy slt     
 * 4f aFaultc    70 LHU_2      0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 50 BrOpFet    70 LHU_2      0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 51 BAlignEr   e8 unxe8      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 52 (null)     34 JAL_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 JAL_3      e8 unxe8      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 54 JAL_2      f3 aF_SW      0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 55 JALRE1     37 ECALL_2    0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 56 (null)     94 SW_E4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 SLLI_1     b3 unxb3      0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 58 SH_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00002063 close to branch
 * 59 SW_E1SWH      (use dinx) 0000000000001111001011100x00110000        Store faulting address alignment to mtval         00002067 close to jalr
 * 5a (null)     96 SH_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    88 unx88      0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLLI_2     f5 jFault     0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 5e (null)     4e eILL0b     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 5f ECALL_2    e8 unxe8      0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 60 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00003003 close to load
 * 61 EBRKWFI1   93 SW_E2      0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 62 IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   0000300b close to ij
 * 63 IJT_1         (use dinx) 0010000010000000101111101100001xx0        Exit CSR, enter trap                              0000300f close to fence
 * 64 SLTIU_0    49 CSRRW_1    0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SRxI_1     75 BAlignEr   0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 66 ECALL_1    90 NMI_2      0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 67 MRET_1     ba LHU_3      0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 68 LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd       (use dinx) 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    a6 ECAL_RET   0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     4d unx4d      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SRxI_2        (use dinx) 0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 6e Fetch         (use dinx) 0000000000001000001111101010110000  Fr00  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     e2 unxe2      0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 StdIncPc   ffffffff (null)     0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * 71 aFault     37 ECALL_2    0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 72 (null)     2e unx2e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 SLL_1      9f SH_5       0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 74 eILL0a     12 unx12      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 WFI_5      9e SH_4       0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 76 (null)     a2 unxa2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 SRx_1      a8 unxa8      0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 78 LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00003063 close to branch
 * 79 aFaulte       (use dinx) 0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00003067 close to jalr
 * 7a (null)     90 NMI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    88 unx88      0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d JALR_1     53 LDAF_LH    0010000000000000000011101100100110        Q=1                                               00000000 
 * 7e (null)     b6 ECALL_5    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 7f WFI_3      a8 unxa8      0010000000000000101011101100100110        More check offset                                 00000000 
 * 80 LBU_0      b2 CSRRW_4    0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 (null)     a8 unxa8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 82 ILL_1         (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  0000400b close to ij
 * 83 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000400f close to fence
 * 84 XORI_0     3d SRxI_2     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 (null)     78 unx78      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 86 ILL_2      53 LDAF_LH    0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 87 (null)     b0 CSRRW_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 88 CSRRW_1       (use dinx) 0010000000000000000011101100100110        Construct PC storage adr                          00004023 close to store
 * 89 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 8a CSRRW_2       (use dinx) 0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    40004023 close to store
 * 8b (null)     70 LHU_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 8c XOR_0      45 WFI_3      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 8e LH_4       fe ILLe       0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      40004033 sloppy xor     
 * 8f (null)     c8 unxc8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 90 SW_2       53 LDAF_LH    0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 91 aF_SW      b9 unxb9      0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 92 WFI_1      53 LDAF_LH    0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 93 EBREAK_1   bd IJ_4       0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 94 LH_5       53 LDAF_LH    0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 95 SB_1       bb SH_2       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 96 SB_2       d6 eILL0c     0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 97 EBRKWFI2   ba LHU_3      0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 98 BLT        22 unx22      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a WFI_4      53 LDAF_LH    0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 9b SB_4          (use dinx) 1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 9c MRET_6        (use dinx) 0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00004073 close to csr/system 
 * 9d LBU_3         (use dinx) 0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 9e BAERR_1    c0 unxc0      0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 9f BAERR_2    90 NMI_2      0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * a0 LHU_0      42 unx42      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 (null)     d4 aFault_2   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a2 BAERR_3       (use dinx) 0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       0000500b close to ij
 * a3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000500f close to fence
 * a4 SRxI_0     65 WFI_4      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 (null)     ce _LCSRRCI_1 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a6 SB_5       66 SW_1       0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * a7 (null)     97 SW_E1SWH   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a8 BAERR_4       (use dinx) 0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00005023 close to store
 * a9 (null)     53 LDAF_LH    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * aa NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40005023 close to store
 * ab (null)     be IJ_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ac _L0xac     77 BAERR_3    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ae _L0xae     77 BAERR_3    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af (null)     da LDAF_a     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b0 JALRE2     d2 LB_2       0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * b1 JAERR_2    b9 unxb9      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * b2 LBU_1      6e unx6e      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * b3 LB_6          (use dinx) 0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * b4 _LCSRRS_1     (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b5 ILL_3      bf IJT_1      0010000000000000101011101100100110        Q = 1                                             00000000 
 * b6 NMI_2      be IJ_1       0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * b7 LDAF_2     d7 ECALL_3    0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * b8 BGE        22 unx22      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 LDAF_3        (use dinx) 0000000000001101100111100x00001xx0        PC to mepc                                        00005067 close to jalr
 * ba SW_E2      2e unx2e      0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * bb SW_E4      d3 aFaultd    0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * bc CSRRWI_0   88 unx88      0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SW_E3      6e unx6e      0010000000000000101111001100100110        Q = 3                                             00000000 
 * be ECALL_6    39 unx39      0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * bf SH_4       d9 unxd9      1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * c0 SH_5          (use dinx) 0000000000000001110011100100001xx0        Write d to a+k until accepted                     00006003 close to load
 * c1 (null)     f2 SW_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 ECALL_4       (use dinx) 0010000000000000101011001100100110        Q = 4                                             0000600b close to ij
 * c3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600f close to fence
 * c4 ORI_0      f0 LBU_2      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     9c unx9c      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c6 MRET_3     86 JAL_2      0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * c7 (null)     df eFetch     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c8 ILL_4         (use dinx) 0000110000001110100111100x00100110        Store 2 to mcause                                 00006023 close to store
 * c9 (null)     c6 IJT_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ca EBREAK_2      (use dinx) 0000000000001101101011101000001xx0        pc to mepc                                        40006023 close to store
 * cb (null)     70 LHU_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * cc OR_0       3f SRx_1      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ce MRET_4     fe ILLe       0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          40006033 sloppy or      
 * cf (null)     15 condb_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d0 CSRRW_3    5f LDAF_LHU   0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * d1 aF_SW_3    de Fetch      0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * d2 CSRRW_4    09 LB_5       0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d3 SH_3       37 ECALL_2    0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d4 ECALL_5    b9 unxb9      0010000000000000101011001100100110        Q = 8                                             00000000 
 * d5 IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * d6 SH_2       fe ILLe       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d7 IJ_4       c2 unxc2      0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * d8 BLTU       22 unx22      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 IJT_2         (use dinx) 0000000000001100101011101000110000        Read word is to be masked with ~3u                00006067 close to jalr
 * da MRET_5     b7 IJ_3       0010000000000000000011101100010xx0        ~302                                              00000000 
 * db IJT_4      b9 unxb9      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * dc CSRRSI_0   88 unx88      0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd QINT_1     f1 aFaulte    0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * de MRET_2     12 unx12      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * df QINT_2     12 unx12      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * e0 _LCSRRCI_1    (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00007003 close to load
 * e1 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 MRET_7        (use dinx) 0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     2e unx2e      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     d1 MRET_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 aFault_2   6e unx6e      0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * e7 (null)     37 ECALL_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 LDAF_a        (use dinx) 0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00007023 close to store
 * e9 (null)     db jFault_1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea jFault_1      (use dinx) 0000000000001110001011100x00100110        Store 1 to mcause                                 40007023 close to store
 * eb (null)     8e _LCSRRS_1  00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      21 XORI_1     0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee aF_SW_1    fe ILLe       0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      40007033 sloppy and     
 * ef (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 ORI_1      9d unx9d      0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * f1 aF_SW_2    37 ECALL_2    0010000000000000101011001100100110        Q = 4                                             00000000 
 * f2 IJT_3      70 LHU_2      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * f3 LH_3       ee eILL0a     0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f4 WFI_2         (use dinx) 0010000000000000101011101100100110        Check offset                                      00000000 
 * f5 SB_3       ea unxea      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f6 i0reserv   f4 Fetch2     xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * f7 (null)     ca unxca      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       22 unx22      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     7f JALRE2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     9b unx9b      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   88 unx88      0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      aa unxaa      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       82 unx82      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     dd aF_SW_1    0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0010, used cfff, inputs 99
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       78 unx78      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       6a unx6a      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     9c unx9c      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     9c unx9c      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   15 condb_4    0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     7d BAERR_4    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       ca unxca      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     7d BAERR_4    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       62 unx62      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     9c unx9c      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      1a ANDI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     9c unx9c      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 Fetch2     ca unxca      000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 11 jFault     2b SLTIX_1    0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 12 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 13 jFault     22 unx22      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 14 (null)     29 XOR_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 15 LB_5       06 LB_3       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 16 (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 17 JALR_2     60 unx60      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 18 BEQ        21 XORI_1     0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     5d SB_2       0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a SUB_1      9c unx9c      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 1b _L0x1b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   68 unx68      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d AND_1      9c unx9c      0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 1e JAL_1      8d unx8d      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 1f JAERR_1    a7 EBRKWFI1   0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 20 LH_0       42 unx42      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 condb_2    9c unx9c      0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 22 condb_3       (use dinx) 0010000000000000001011101100100110        Calculate RS1+~RS2+1                              0000100b close to ij
 * 23 _L0x23     9c unx9c      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     4b CSRRW_2    0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 eILL0b     39 unx39      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     2e unx2e      0010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_4    35 SLLI_1     0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 2a _L0x2a     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b ANDI_1     41 JALR_1     0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 2c SLL_0      57 LH_5       0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     9c unx9c      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e ORI_2         (use dinx) 0000000000000100001011101000111000        rd = Iimm | RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     9c unx9c      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 (null)     9c unx9c      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 31 aFault_1   3d SRxI_2     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 32 (null)     62 unx62      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 IJ_2       c6 IJT_4      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 34 (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 35 XORI_1     4d unx4d      0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 OR_1       7f JALRE2     0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 38 BNE        21 XORI_1     0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 OR_2          (use dinx) 0010000000000000000011101100100000        Q = rs2                                           00001067 close to jalr
 * 3a XOR_1      55 aFaultb    0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 3b _L0x3b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    73 BAERR_1    0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d SLTIX_1    03 _L0x03     0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 3e LW_1       4b CSRRW_2    0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    53 LDAF_LH    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 SLTIX_2    17 condb_5t   0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 42 LH_1          (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH       (use dinx) 0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     3d SRxI_2     0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 SLTX_1     88 unx88      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 46 LH_2       71 aFaultc    0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    d9 unxd9      0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     58 unx58      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 JAL_3      75 BAlignEr   0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 4a _L0x4a     58 unx58      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b SLLI_1     85 LBU_1      0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 4c SLT_0      45 WFI_3      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d SLLI_2        (use dinx) 0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 4e LHU_1      fe ILLe       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40002033 sloppy slt     
 * 4f LDAF_LHU   9c unx9c      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 50 (null)     9c unx9c      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 51 ECALL_2    8f ILL_3      0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 52 (null)     46 ILL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 SRxI_1     8f ILL_3      0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 54 (null)     cb QINT_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 55 SRxI_2     31 SLTX_1     0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 56 (null)     7a SB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 SLL_1      ca unxca      0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 58 SW_1          (use dinx) 0000000000000011111011100100001xx0        Write d to a+k until accepted                     00002063 close to branch
 * 59 SW_E1SWE      (use dinx) 0000000000001111001011100x00110000        Store faulting address alignment to mtval         00002067 close to jalr
 * 5a SRx_1      82 unx82      0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 5b _L0x5b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    73 BAERR_1    0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d JALR_1     cf MRET_7     0010000000000000000011101100100110        Q=1                                               00000000 
 * 5e LHU_2      5e LHU_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaultc    8f ILL_3      0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 60 BrOpFet       (use dinx) 0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00003003 close to load
 * 61 BAlignEr   db jFault_1   0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 62 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             0000300b close to ij
 * 63 JALRE1        (use dinx) 0000000000001101110011100x00001xx0  err   Store pc to mepc                                  0000300f close to fence
 * 64 SLTIU_0    3d SRxI_2     0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 WFI_3      9f SH_5       0010000000000000101011101100100110        More check offset                                 00000000 
 * 66 SH_1       be IJ_1       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 67 SW_E1SWH   e0 unxe0      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 68 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00003023 close to store
 * 69 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 6a IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   40003023 close to store
 * 6b IJT_1      b9 unxb9      0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 6c SLTU_0     45 WFI_3      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d ILL_1         (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 6e ECALL_1       (use dinx) 0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40003033 sloppy sltu    
 * 6f MRET_1     8b LB_6       0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 70 (null)     ffffffff (null)     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 71 ILL_2      31 SLTX_1     0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 72 (null)     2b SLTIX_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 CSRRW_1    a8 unxa8      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 74 (null)     12 unx12      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 75 CSRRW_2    a6 ECAL_RET   0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 76 (null)     aa unxaa      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 LH_4       bd IJ_4       0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 78 LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003063 close to branch
 * 79 aFaultd       (use dinx) 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00003067 close to jalr
 * 7a LH_5       be IJ_1       0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 7b _L0x7b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    73 BAERR_1    0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SB_1       49 CSRRW_1    0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 7e eILL0c     dd aF_SW_1    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 7f ECALL_3    bd IJ_4       0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 80 LBU_0      c8 unxc8      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 EBREAK_2   bd IJ_4       0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * 82 SB_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   0000400b close to ij
 * 83 MRET_4        (use dinx) 0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          0000400f close to fence
 * 84 XORI_0     35 SLLI_1     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 CSRRW_3    ba LHU_3      0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * 86 EBRKWFI2   49 CSRRW_1    0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 87 aF_SW_3    c2 unxc2      0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 88 WFI_4         (use dinx) 0010000000000000001011x01001xxxxx0        Prepare read PC                                   00004023 close to store
 * 89 _LCSRRCI_1    (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 8a SB_4          (use dinx) 1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      40004023 close to store
 * 8b MRET_7     9c unx9c      0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * 8c XOR_0      3a SRxI_1     0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d aFault_2      (use dinx) 0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 8e MRET_6     fe ILLe       0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            40004033 sloppy xor     
 * 8f LDAF_a     fb SB_3       0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * 90 (null)     49 CSRRW_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 91 (null)     df eFetch     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 92 (null)     49 CSRRW_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 (null)     e6 StdIncPc   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 94 (null)     49 CSRRW_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 95 (null)     e2 unxe2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 96 (null)     c1 IJT_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 (null)     e0 unxe0      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 98 BLT        21 XORI_1     0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a Fetch      49 CSRRW_1    0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 9b eFetch        (use dinx) 0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 9c StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00004073 close to csr/system 
 * 9d aFault        (use dinx) 0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 9e eILL0a     ee eILL0a     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 9f WFI_5      be IJ_1       0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * a0 LHU_0      4e eILL0b     0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 CSRRW_4    a5 MRET_3     0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * a2 LBU_3         (use dinx) 0010000000000000011011101100010xx0        Invert q. Prepare read mask                       0000500b close to ij
 * a3 SH_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   0000500f close to fence
 * a4 SRxI_0     53 LDAF_LH    0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 ECALL_5    83 unx83      0010000000000000101011001100100110        Q = 8                                             00000000 
 * a6 BAERR_1    6e unx6e      0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * a7 IJ_3       86 JAL_2      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * a8 BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00005023 close to store
 * a9 jFault_1   49 CSRRW_1    0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * aa BAERR_3       (use dinx) 0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       40005023 close to store
 * ab aF_SW_1    e8 unxe8      0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * ac _L0xac     5a SB_1       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad ORI_1         (use dinx) 0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * ae _L0xae     5a SB_1       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af aF_SW_2    c7 QINT_1     0010000000000000101011001100100110        Q = 4                                             00000000 
 * b0 (null)     a1 ECALL_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b1 (null)     df eFetch     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b2 (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b5 (null)     ea unxea      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b6 (null)     e8 unxe8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 (null)     c3 unxc3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b8 BGE        21 XORI_1     0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SB_5          (use dinx) 0000000000000010110011100100001xx0        Write d to a+k until accepted                     00005067 close to jalr
 * ba LBU_2      2b SLTIX_1    0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * bb aFaulte    a3 unxa3      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * bc CSRRWI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd BAERR_4    9a ECALL_6    0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * be SW_2       33 JAERR_1    0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * bf aF_SW      c5 MRET_5     0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * c0 NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00006003 close to load
 * c1 SH_2       c9 MRET_2     0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * c2 JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   0000600b close to ij
 * c3 IJ_4          (use dinx) 0100000010001010110111100100011xx0        Mask and use as PC                                0000600f close to fence
 * c4 ORI_0      ad unxad      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 IJT_2      8e _LCSRRS_1  0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c6 JAERR_2    71 aFaultc    0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * c7 MRET_5     e7 aFault     0010000000000000000011101100010xx0        ~302                                              00000000 
 * c8 LBU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00006023 close to store
 * c9 IJT_3      fa WFI_2      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ca LB_6          (use dinx) 0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          40006023 close to store
 * cb LH_3       9c unx9c      0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * cc OR_0       37 ECALL_2    0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd WFI_2         (use dinx) 0010000000000000101011101100100110        Check offset                                      00000000 
 * ce _LCSRRS_1  fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006033 sloppy or      
 * cf SB_3       27 OR_2       0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d0 (null)     51 LDAF_LW    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 (null)     e5 aF_SW_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 (null)     31 SLTX_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d4 (null)     df eFetch     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     f9 unxf9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       21 XORI_1     0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 ILL_3         (use dinx) 0010000000000000101011101100100110        Q = 1                                             00006067 close to jalr
 * da WFI_1      de Fetch      0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * db EBREAK_1   df eFetch     0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * dc CSRRSI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd NMI_2      af MRET_4     0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * de LDAF_2     12 unx12      0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * df LDAF_3     12 unx12      0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * e0 SW_E2         (use dinx) 0000000000001101101111101000001xx0        Store address that faulted                        00007003 close to load
 * e1 IJT_4      2e unx2e      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * e2 SW_E4         (use dinx) 0000110000001110100111100x00101000        Store 6 to mcause                                 0000700b close to ij
 * e3 QINT_1        (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 0000700f close to fence
 * e4 ANDI_0     2b SLTIX_1    0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 MRET_2     87 JALRE1     0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * e6 SW_E3      9a ECALL_6    0010000000000000101111001100100110        Q = 3                                             00000000 
 * e7 QINT_2     31 SLTX_1     0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * e8 ECALL_6       (use dinx) 0000110000001110100111000x00100000        mcause = 11                                       00007023 close to store
 * e9 i0reserv   e1 ORI_1      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * ea SH_4          (use dinx) 1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      40007023 close to store
 * eb (null)     77 BAERR_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      1d ORI_2      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee SH_5       fe ILLe       0000000000000001110011100100001xx0        Write d to a+k until accepted                     40007033 sloppy and     
 * ef (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     a2 unxa2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     31 SLTX_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     9c unx9c      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     ab EBREAK_2   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     a9 ILL_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     cd unxcd      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     81 JAERR_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       21 XORI_1     0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 ECALL_4       (use dinx) 0010000000000000101011001100100110        Q = 4                                             00007067 close to jalr
 * fa MRET_3     65 WFI_4      0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * fb ILL_4      8a unx8a      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * fc CSRRCI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      c0 unxc0      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       6d unx6d      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     e3 unxe3      0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0400, used ffff, inputs a3
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       50 LW_1       0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       46 ILL_1      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     56 LH_4       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     56 LH_4       0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     77 BAERR_3    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       93 SW_E2      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     77 BAERR_3    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       36 SLLI_2     0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      21 XORI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      93 SW_E2      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    39 unx39      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 eILL0b        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2b SLTIX_1    0010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       2e unx2e      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       54 LH_2       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    34 JAL_3      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        29 XOR_1      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     6f MRET_6     0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       56 LH_4       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   42 unx42      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     56 LH_4       0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       bf IJT_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    b2 CSRRW_4    0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      56 LH_4       0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1         (use dinx) 0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     56 LH_4       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     67 SW_E1SWE   0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LHU_1      4b CSRRW_2    0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LHU   3a SRxI_1     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     3e SLL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_2    45 WFI_3      0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2a _L0x2a     3e SLL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_3    5d SB_2       0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2c SLL_0      6d unx6d      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_4       (use dinx) 0010000000000000110011101101001xx0        Branch on condition                               40001033 sloppy sll     
 * 2f _L0x2f     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SW_1       56 LH_4       0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 31 SW_E1SWE   5a SB_1       0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 32 LHU_2      36 SLLI_2     0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 33 aFaultc    90 NMI_2      0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 34 BrOpFet    54 LH_2       0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 35 BAlignEr   68 unx68      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 36 JAL_2      03 _L0x03     0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 37 JALRE1     53 LDAF_LH    0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 38 BNE        29 XOR_1      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00001067 close to jalr
 * 3a ORI_2      6b SB_4       0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    73 BAERR_1    0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d aFault_1   03 _L0x03     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 3e SH_1       67 SW_E1SWE   0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 3f SW_E1SWH   6a unx6a      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 40 LW_0       14 condb_3    0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 IJ_2       1d ORI_2      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 42 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000200b close to ij
 * 43 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000200f close to fence
 * 44 SLTI_0     5a SB_1       0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 XORI_1     7a SB_5       0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 46 IJ_1       72 LBU_3      0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 47 IJT_1      95 SW_E3      0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 48 _L0x48     30 SLTIX_2    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 OR_1       74 BrOpFet    0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 4a _L0x4a     30 SLTIX_2    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b OR_2       ab EBREAK_2   0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 4c SLT_0      65 WFI_4      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d XOR_1         (use dinx) 0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 4e ECALL_1    fe ILLe       0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40002033 sloppy slt     
 * 4f MRET_1     56 LH_4       0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 50 LB_2       56 LH_4       0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 51 aFaultd    c0 unxc0      0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 52 eILL0c     1e aFault_1   0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 53 ECALL_3    c0 unxc0      0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 54 Fetch      c9 MRET_2     0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 55 eFetch     3d SRxI_2     0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 56 StdIncPc   76 BAERR_2    0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * 57 aFault     93 SW_E2      0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 58 eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00002063 close to branch
 * 59 WFI_5         (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch                                    00002067 close to jalr
 * 5a SLTIX_1    78 unx78      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    73 BAERR_1    0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLTIX_2    cd unxcd      0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 5e LBU_2      32 JAL_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaulte    c0 unxc0      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 60 SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   00003003 close to load
 * 61 aF_SW      63 unx63      0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 62 WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   0000300b close to ij
 * 63 EBREAK_1      (use dinx) 0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       0000300f close to fence
 * 64 SLTIU_0    5a SB_1       0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLTX_1     59 unx59      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 66 JAL_3      60 unx60      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 67 SLLI_1     9d unx9d      0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 68 SLLI_2        (use dinx) 0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00003023 close to store
 * 69 ECALL_2       (use dinx) 0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 6a SRxI_1        (use dinx) 0000000000000100101001101100001xx1        Register to shift to Q                            40003023 close to store
 * 6b SRxI_2     89 unx89      0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 6c SLTU_0     65 WFI_4      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SLL_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 6e SRx_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  40003033 sloppy sltu    
 * 6f JALR_1     be IJ_1       0010000000000000000011101100100110        Q=1                                               00000000 
 * 70 WFI_3      ffffffff (null)     0010000000000000101011101100100110        More check offset                                 00000000 
 * 71 ILL_1      3d SRxI_2     0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 72 ILL_2      39 unx39      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 73 CSRRW_1    85 LBU_1      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 74 CSRRW_2    86 JAL_2      0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 75 LH_4       81 JAERR_2    0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 76 LH_5       88 unx88      0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 77 SB_1       8b LB_6       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 78 SB_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00003063 close to branch
 * 79 EBRKWFI2      (use dinx) 0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00003067 close to jalr
 * 7a WFI_4      60 unx60      0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    73 BAERR_1    0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SB_4       66 SW_1       1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 7e MRET_6     97 SW_E1SWH   0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 7f LBU_3      8b LB_6       0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 80 LBU_0      91 LDAF_2     0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 BAERR_1    8b LB_6       0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 82 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     0000400b close to ij
 * 83 jFault        (use dinx) 0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000400f close to fence
 * 84 XORI_0     45 WFI_3      0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 BAERR_2    5e LHU_1      0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 86 Fetch2     66 SW_1       000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 87 jFault     8f ILL_3      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 88 BAERR_3       (use dinx) 0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00004023 close to store
 * 89 SB_5          (use dinx) 0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 8a (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40004023 close to store
 * 8b BAERR_4    56 LH_4       0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 8c XOR_0      4d unx4d      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 8e (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40004033 sloppy xor     
 * 8f JALRE2     a8 unxa8      0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * 90 JAERR_2    66 SW_1       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 91 LBU_1      9c unx9c      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 92 (null)     66 SW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 LB_6       a1 ECALL_4    0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 94 _LCSRRS_1  66 SW_1       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 95 ILL_3      9f SH_5       0010000000000000101011101100100110        Q = 1                                             00000000 
 * 96 (null)     b3 unxb3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 NMI_2      9d unx9d      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 98 BLT        29 XOR_1      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a (null)     66 SW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 9b LDAF_2        (use dinx) 0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 9c LDAF_3        (use dinx) 0000000000001101100111100x00001xx0        PC to mepc                                        00004073 close to csr/system 
 * 9d SW_E2         (use dinx) 0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 9e (null)     a5 MRET_3     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 9f SW_E4      60 unx60      0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * a0 LHU_0      26 OR_1       0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SW_E3      b1 aF_SW_3    0010000000000000101111001100100110        Q = 3                                             00000000 
 * a2 ECALL_6       (use dinx) 0000110000001110100111000x00100000        mcause = 11                                       0000500b close to ij
 * a3 SH_4          (use dinx) 1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      0000500f close to fence
 * a4 SRxI_0     6a unx6a      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SH_5       aa unxaa      0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * a6 ECALL_4    4e eILL0b     0010000000000000101011001100100110        Q = 4                                             00000000 
 * a7 MRET_3     79 unx79      0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * a8 ILL_4         (use dinx) 0000110000001110100111100x00100110        Store 2 to mcause                                 00005023 close to store
 * a9 EBREAK_2   66 SW_1       0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * aa MRET_4        (use dinx) 0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          40005023 close to store
 * ab CSRRW_3    a2 unxa2      0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * ac _L0xac     6e unx6e      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad aF_SW_3       (use dinx) 0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * ae _L0xae     6e unx6e      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af CSRRW_4    b6 ECALL_5    0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b0 SH_3       af MRET_4     0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b1 ECALL_5    9c unx9c      0010000000000000101011001100100110        Q = 8                                             00000000 
 * b2 IJ_3       54 LH_2       0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b3 SH_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * b4 IJ_4          (use dinx) 0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * b5 IJT_2      a3 unxa3      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * b6 MRET_5     a2 unxa2      0010000000000000000011101100010xx0        ~302                                              00000000 
 * b7 IJT_4      b4 i0reserv   0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * b8 BGE        29 XOR_1      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 QINT_1        (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00005067 close to jalr
 * ba MRET_2     39 unx39      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * bb QINT_2     b0 CSRRW_3    0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * bc CSRRWI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd _LCSRRCI_1 54 LH_2       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * be MRET_7     41 JALR_1     0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * bf aFault_2   b5 SH_3       0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * c0 LDAF_a        (use dinx) 0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00006003 close to load
 * c1 jFault_1   c8 unxc8      0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * c2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600b close to ij
 * c3 aF_SW_1       (use dinx) 0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      0000600f close to fence
 * c4 ORI_0      c5 MRET_5     0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 ORI_1      7e NMI_1      0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * c6 (null)     72 LBU_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c7 aF_SW_2    bb SH_2       0010000000000000101011001100100110        Q = 4                                             00000000 
 * c8 IJT_3         (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00006023 close to store
 * c9 LH_3       a7 EBRKWFI1   0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * ca (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40006023 close to store
 * cb WFI_2      56 LH_4       0010000000000000101011101100100110        Check offset                                      00000000 
 * cc OR_0       49 CSRRW_1    0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd SB_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * ce (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40006033 sloppy or      
 * cf i0reserv   13 condb_2    xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * d0 (null)     69 unx69      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 (null)     ba LHU_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d4 (null)     9c unx9c      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       29 XOR_1      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00006067 close to jalr
 * da (null)     9b unx9b      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * db (null)     9c unx9c      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * dc CSRRSI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd (null)     c7 QINT_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * de (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * df (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e0 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007003 close to load
 * e1 (null)     3a SRxI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     39 unx39      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     ad unxad      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e7 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     b7 IJ_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     75 BAlignEr   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      22 unx22      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007033 sloppy and     
 * ef (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     7f JALRE2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     56 LH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     c3 unxc3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     c1 IJT_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     cb QINT_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     a9 ILL_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       29 XOR_1      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     70 LHU_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     7d BAERR_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      8d unx8d      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       71 aFaultc    0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     b9 unxb9      0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 
 *  29  81 2515 5340 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  28  81 2416 5439 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  27  81 1271 6584 Can not simplify, no legal mapping
 *  26  81 1147 6708 Can not simplify, no legal mapping
 *  25 515 3950 3471 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  24 515 2522 4899 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  23 1999 4604 1333 Can not simplify, no legal mapping
 *  22 1999 1824 4113 Can not simplify, can't represent fixed locations with any less than 7 bits of the index
 *  21 1565 5875 496 Can not simplify, can't represent fixed locations with any less than 5 bits of the index
 *  20 1565 5999 372 Can not simplify, can't represent fixed locations with any less than 7 bits of the index
 *  19 949 4945 2042 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  18  81  41 7814 
 * Candidate function 0040, used fffd, inputs 0f
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       09 LB_5       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 02 IJ_0       68 unx68      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     78 unx78      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     78 unx78      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 Fetch2     10 SUB_1      000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 07 jFault     1a ANDI_1     0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 08 _L0x08     90 NMI_2      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_1       a8 unxa8      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 0a _L0x0a     90 NMI_2      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_3       58 unx58      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      22 unx22      0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 LB_4       a8 unxa8      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 11 (null)     30 SLTIX_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 12 condb_5       (use dinx) 0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 13 condb_5t   2b SLTIX_1    0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 14 JAL_1      2e unx2e      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 15 JAERR_1    12 unx12      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 16 Fetch2     74 BrOpFet    000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 17 jFault     54 LH_2       0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 18 BEQ        29 XOR_1      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     77 BAERR_3    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       78 unx78      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     14 condb_3    0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   62 unx62      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     78 unx78      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e eILL0b     d4 aFault_2   0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 1f MRET_8     c7 QINT_1     0010000000000000101011101100100110        Prep +4                                           00000000 
 * 20 LH_0       34 JAL_3      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 (null)     78 unx78      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 22 SUB_1         (use dinx) 0010000000000000111111101100000xx0        Q = ~RS2                                          0000100b close to ij
 * 23 _L0x23     78 unx78      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     5a SB_1       0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 (null)     47 ILL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 27 AND_1      37 ECALL_2    0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 28 _L0x28     5e LHU_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_2    3d SRxI_2     0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2a _L0x2a     5e LHU_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_3    4d unx4d      0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2c SLL_0      6d unx6d      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_4       (use dinx) 0010000000000000110011101101001xx0        Branch on condition                               40001033 sloppy sll     
 * 2f _L0x2f     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 ANDI_1     78 unx78      0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 31 (null)     4b CSRRW_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 32 LW_1       58 unx58      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 33 LDAF_LW    a5 MRET_3     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 34 LH_1       74 BrOpFet    0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 35 LDAF_LH    5d SB_2       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 ORI_2      73 BAERR_1    0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 38 BNE        29 XOR_1      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 aFault_1      (use dinx) 0010000000000000101011001100100110        Q = 4                                             00001067 close to jalr
 * 3a IJ_2       67 SW_E1SWE   0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 3b _L0x3b     14 condb_3    0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    87 JALRE1     0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d XORI_1     03 _L0x03     0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 3e LH_2       5a SB_1       0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 3f aFaultb    65 WFI_4      0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 40 LW_0       32 JAL_1      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 (null)     1d ORI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 42 LHU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LHU      (use dinx) 0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     4b CSRRW_2    0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 OR_1       94 SW_E4      0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 46 (null)     85 LBU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 47 OR_2       aa unxaa      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 48 _L0x48     4e eILL0b     1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XOR_1      8d unx8d      0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 4a _L0x4a     4e eILL0b     1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b SLTIX_1    bf IJT_1      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 4c SLT_0      50 LW_1       0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d SLTIX_2       (use dinx) 0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 4e SW_1       fe ILLe       0000000000000011111011100100001xx0        Write d to a+k until accepted                     40002033 sloppy slt     
 * 4f SW_E1SWE   78 unx78      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 50 SLTX_1     78 unx78      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 51 (null)     d5 unxd5      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 52 LHU_2      3e SLL_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 53 aFaultc    d5 unxd5      0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 54 BrOpFet    de Fetch      0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 55 BAlignEr   39 unx39      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 56 (null)     8f ILL_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 JAL_3      a8 unxa8      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 58 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             00002063 close to branch
 * 59 JALRE1        (use dinx) 0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00002067 close to jalr
 * 5a SLLI_1     92 LDAF_3     0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 5b _L0x5b     14 condb_3    0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    87 JALRE1     0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLLI_2     e0 unxe0      0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 5e SH_1       52 LH_1       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5f SW_E1SWH   d5 unxd5      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 60 ECALL_2       (use dinx) 0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00003003 close to load
 * 61 (null)     8b LB_6       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 62 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000300b close to ij
 * 63 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000300f close to fence
 * 64 SLTIU_0    4b CSRRW_2    0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SRxI_1     7f JALRE2     0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 66 (null)     88 unx88      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 67 SRxI_2     b0 CSRRW_3    0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 68 IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00003023 close to store
 * 69 IJT_1         (use dinx) 0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 6a ECALL_1       (use dinx) 0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40003023 close to store
 * 6b MRET_1     9e SH_4       0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 6c SLTU_0     50 LW_1       0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SLL_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 6e LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     40003033 sloppy sltu    
 * 6f aFaultd    d3 aFaultd    0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 70 SRx_1      ffffffff (null)     0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 71 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 72 eILL0c     30 SLTIX_2    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 73 ECALL_3    9c unx9c      0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 74 Fetch      16 condb_5    0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 75 eFetch     9b unx9b      0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 76 (null)     9d unx9d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 JALR_1     9f SH_5       0010000000000000000011101100100110        Q=1                                               00000000 
 * 78 StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00003063 close to branch
 * 79 aFault        (use dinx) 0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00003067 close to jalr
 * 7a WFI_3      88 unx88      0010000000000000101011101100100110        More check offset                                 00000000 
 * 7b _L0x7b     14 condb_3    0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    87 JALRE1     0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d ILL_1      57 LH_5       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 7e eILL0a     ab EBREAK_2   0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 7f WFI_5      9f SH_5       0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 80 LBU_0      a7 EBRKWFI1   0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 (null)     9f SH_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 82 LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     0000400b close to ij
 * 83 aFaulte       (use dinx) 0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      0000400f close to fence
 * 84 XORI_0     3d SRxI_2     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 ILL_2      82 unx82      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 86 (null)     57 LH_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 87 CSRRW_1    a3 unxa3      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 88 SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   00004023 close to store
 * 89 aF_SW         (use dinx) 0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 8a WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   40004023 close to store
 * 8b EBREAK_1   78 unx78      0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 8c XOR_0      49 CSRRW_1    0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d CSRRW_2       (use dinx) 0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 8e LH_4       fe ILLe       0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      40004033 sloppy xor     
 * 8f LH_5       bb SH_2       0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 90 SB_1       57 LH_5       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 91 (null)     af MRET_4     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 92 SB_2       57 LH_5       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 93 EBRKWFI2   b3 unxb3      0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 94 WFI_4      57 LH_5       0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 95 SB_4       b2 CSRRW_4    1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 96 (null)     c8 unxc8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 MRET_6     b0 CSRRW_3    0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 98 BLT        29 XOR_1      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a LBU_3      57 LH_5       0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 9b BAERR_1       (use dinx) 0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 9c BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00004073 close to csr/system 
 * 9d BAERR_3       (use dinx) 0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * 9e SB_5       b7 IJ_3       0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 9f BAERR_4    88 unx88      0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * a0 LHU_0      42 unx42      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 (null)     c5 MRET_5     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a2 NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 0000500b close to ij
 * a3 JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   0000500f close to fence
 * a4 SRxI_0     65 WFI_4      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 JAERR_2    be IJ_1       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * a6 (null)     6a unx6a      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a7 LBU_1      93 SW_E2      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * a8 LB_6          (use dinx) 0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00005023 close to store
 * a9 _LCSRRS_1  57 LH_5       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * aa ILL_3         (use dinx) 0010000000000000101011101100100110        Q = 1                                             40005023 close to store
 * ab NMI_2      b4 i0reserv   0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * ac _L0xac     70 LHU_2      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad LDAF_2        (use dinx) 0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * ae _L0xae     70 LHU_2      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af LDAF_3     cb QINT_2     0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * b0 SW_E2      c2 unxc2      0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * b1 (null)     af MRET_4     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b2 SW_E4      74 BrOpFet    0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * b3 SW_E3         (use dinx) 0010000000000000101111001100100110        Q = 3                                             00000000 
 * b4 ECALL_6       (use dinx) 0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * b5 SH_4       b5 SH_3       1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * b6 (null)     b4 i0reserv   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 SH_5       c9 MRET_2     0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b8 BGE        29 XOR_1      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 ECALL_4       (use dinx) 0010000000000000101011001100100110        Q = 4                                             00005067 close to jalr
 * ba MRET_3     30 SLTIX_2    0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * bb ILL_4      c3 unxc3      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * bc CSRRWI_0   87 JALRE1     0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd EBREAK_2   74 BrOpFet    0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * be MRET_4     3a SRxI_1     0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * bf CSRRW_3    ca unxca      0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * c0 aF_SW_3       (use dinx) 0000110000001110001011000x00100000        Store 7 to mcause                                 00006003 close to load
 * c1 (null)     dd aF_SW_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 CSRRW_4       (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      0000600b close to ij
 * c3 SH_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   0000600f close to fence
 * c4 ORI_0      da LDAF_a     0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 ECALL_5    97 SW_E1SWH   0010000000000000101011001100100110        Q = 8                                             00000000 
 * c6 (null)     85 LBU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c7 IJ_3       d0 ECALL_1    0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * c8 SH_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00006023 close to store
 * c9 IJ_4       ba LHU_3      0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * ca IJT_2         (use dinx) 0000000000001100101011101000110000        Read word is to be masked with ~3u                40006023 close to store
 * cb MRET_5     78 unx78      0010000000000000000011101100010xx0        ~302                                              00000000 
 * cc OR_0       45 WFI_3      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd IJT_4         (use dinx) 0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * ce QINT_1     fe ILLe       0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40006033 sloppy or      
 * cf MRET_2     1f IJ_2       0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * d0 QINT_2     60 unx60      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * d1 (null)     cf MRET_7     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 _LCSRRCI_1 0b JALR_2     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d3 MRET_7     39 unx39      0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * d4 aFault_2   af MRET_4     0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * d5 LDAF_a        (use dinx) 0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 jFault_1   b9 unxb9      0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * d8 BLTU       29 XOR_1      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 aF_SW_1       (use dinx) 0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00006067 close to jalr
 * da ORI_1      ad unxad      0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * db aF_SW_2    af MRET_4     0010000000000000101011001100100110        Q = 4                                             00000000 
 * dc CSRRSI_0   87 JALRE1     0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd IJT_3      db jFault_1   0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * de LH_3       16 condb_5    0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * df WFI_2      16 condb_5    0010000000000000101011101100100110        Check offset                                      00000000 
 * e0 SB_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   00007003 close to load
 * e1 (null)     37 ECALL_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 i0reserv      (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     30 SLTIX_2    0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     c0 unxc0      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 (null)     74 BrOpFet    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e7 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     cd unxcd      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     8e _LCSRRS_1  00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      27 OR_2       0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007033 sloppy and     
 * ef (null)     74 BrOpFet    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     78 unx78      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     d9 unxd9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     d7 ECALL_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     df eFetch     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     bd IJ_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       29 XOR_1      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     7a SB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     95 SW_E3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   87 JALRE1     0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      a2 unxa2      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       7d BAERR_4    0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     ce _LCSRRCI_1 0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0100, used f3ff, inputs 1b
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       78 unx78      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       6a unx6a      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     86 JAL_2      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     86 JAL_2      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     9e SH_4       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       b9 unxb9      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     9e SH_4       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       62 unx62      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     86 JAL_2      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      21 XORI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     86 JAL_2      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 Fetch2     b9 unxb9      000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 11 jFault     31 SLTX_1     0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 12 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 13 (null)     2b SLTIX_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 14 Fetch2     2e unx2e      000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 15 jFault     06 LB_3       0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 16 (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 17 (null)     60 unx60      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 18 BEQ        29 XOR_1      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     7d BAERR_4    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       86 JAL_2      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   68 unx68      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     86 JAL_2      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e JAL_1      e6 StdIncPc   0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 1f JAERR_1    d9 unxd9      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 20 LH_0       42 unx42      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      86 JAL_2      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1         (use dinx) 0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     86 JAL_2      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     5a SB_1       0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 eILL0b     45 WFI_3      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     35 SLLI_1     0010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_2    3d SRxI_2     0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2a _L0x2a     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_3    4d unx4d      0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2c SLL_0      75 BAlignEr   0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     86 JAL_2      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_4       (use dinx) 0010000000000000110011101101001xx0        Branch on condition                               40001033 sloppy sll     
 * 2f _L0x2f     86 JAL_2      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 31 ANDI_1     4b CSRRW_2    0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 32 (null)     62 unx62      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 (null)     b1 aF_SW_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 34 (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 35 ORI_2      5d SB_2       0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 (null)     7f JALRE2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 38 BNE        29 XOR_1      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 aFault_1      (use dinx) 0010000000000000101011001100100110        Q = 4                                             00001067 close to jalr
 * 3a IJ_2       71 aFaultc    0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 3b _L0x3b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    91 LDAF_2     0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d XORI_1     03 _L0x03     0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 3e LW_1       5a SB_1       0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    6d unx6d      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 OR_1       1d ORI_2      0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 42 LH_1          (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH       (use dinx) 0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     4b CSRRW_2    0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 OR_2       a2 unxa2      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 46 LH_2       8d unx8d      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    bb SH_2       0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     58 unx58      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XOR_1      95 SW_E3      0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 4a _L0x4a     58 unx58      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b SLTIX_1    cd unxcd      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 4c SLT_0      51 LDAF_LW    0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d SLTIX_2       (use dinx) 0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 4e LHU_1      fe ILLe       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40002033 sloppy slt     
 * 4f LDAF_LHU   86 JAL_2      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 50 (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 51 SLTX_1     e7 aFault     0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 52 (null)     46 ILL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 (null)     e7 aFault     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 54 (null)     ee eILL0a     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 55 JAL_3      39 unx39      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 56 (null)     9d unx9d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 (null)     b9 unxb9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 58 SW_1          (use dinx) 0000000000000011111011100100001xx0        Write d to a+k until accepted                     00002063 close to branch
 * 59 SW_E1SWE      (use dinx) 0000000000001111001011100x00110000        Store faulting address alignment to mtval         00002067 close to jalr
 * 5a SLLI_1     9f SH_5       0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 5b _L0x5b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    91 LDAF_2     0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLLI_2     f1 aFaulte    0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 5e LHU_2      5e LHU_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaultc    e7 aFault     0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 60 BrOpFet       (use dinx) 0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00003003 close to load
 * 61 BAlignEr   9b unx9b      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 62 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             0000300b close to ij
 * 63 JALRE1        (use dinx) 0000000000001101110011100x00001xx0  err   Store pc to mepc                                  0000300f close to fence
 * 64 SLTIU_0    4b CSRRW_2    0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 ECALL_2    89 unx89      0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 66 SH_1       8e _LCSRRS_1  0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 67 SW_E1SWH   c0 unxc0      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 68 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00003023 close to store
 * 69 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 6a IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   40003023 close to store
 * 6b IJT_1      aa unxaa      0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 6c SLTU_0     51 LDAF_LW    0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SRxI_1        (use dinx) 0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 6e ECALL_1       (use dinx) 0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40003033 sloppy sltu    
 * 6f MRET_1     e5 aF_SW_2    0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 70 (null)     ffffffff (null)     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 71 SRxI_2     39 unx39      0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 72 (null)     31 SLTX_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 (null)     a8 unxa8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 74 (null)     14 condb_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 75 SLL_1      a7 EBRKWFI1   0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 76 (null)     a9 ILL_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 (null)     ab EBREAK_2   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 78 LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003063 close to branch
 * 79 aFaultd       (use dinx) 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00003067 close to jalr
 * 7a SRx_1      8e _LCSRRS_1  0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 7b _L0x7b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    91 LDAF_2     0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d JALR_1     55 aFaultb    0010000000000000000011101100100110        Q=1                                               00000000 
 * 7e eILL0c     bd IJ_4       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 7f ECALL_3    ab EBREAK_2   0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 80 LBU_0      b5 SH_3       0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 WFI_3      ab EBREAK_2   0010000000000000101011101100100110        More check offset                                 00000000 
 * 82 Fetch         (use dinx) 0000000000001000001111101010110000  Fr00  Read and latch instruction                        0000400b close to ij
 * 83 eFetch        (use dinx) 0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             0000400f close to fence
 * 84 XORI_0     3d SRxI_2     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 ILL_1      8a unx8a      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 86 StdIncPc   55 aFaultb    0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * 87 aFault     af MRET_4     0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 88 eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00004023 close to store
 * 89 WFI_5         (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 8a LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40004023 close to store
 * 8b aFaulte    86 JAL_2      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 8c XOR_0      49 CSRRW_1    0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d ILL_2         (use dinx) 0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 8e SW_2       fe ILLe       0010000000000000001011x01000xxxxx0        Prepare read PC                                   40004033 sloppy xor     
 * 8f aF_SW      c9 MRET_2     0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 90 (null)     55 aFaultb    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 91 CSRRW_1    bf IJT_1      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 92 (null)     55 aFaultb    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 (null)     c2 unxc2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 94 (null)     55 aFaultb    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 95 CSRRW_2    c1 IJT_2      0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 96 (null)     da LDAF_a     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 (null)     c0 unxc0      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 98 BLT        29 XOR_1      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a WFI_1      55 aFaultb    0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 9b EBREAK_1      (use dinx) 0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 9c LH_4          (use dinx) 0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00004073 close to csr/system 
 * 9d LH_5          (use dinx) 0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 9e SB_1       c6 IJT_4      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 9f SB_2       8e _LCSRRS_1  0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * a0 LHU_0      4e eILL0b     0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 EBRKWFI2   d5 unxd5      0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * a2 WFI_4         (use dinx) 0010000000000000001011x01001xxxxx0        Prepare read PC                                   0000500b close to ij
 * a3 SB_4          (use dinx) 1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      0000500f close to fence
 * a4 SRxI_0     6d unx6d      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_6     cb QINT_2     0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * a6 LBU_3      6e unx6e      0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * a7 BAERR_1    a1 ECALL_4    0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * a8 BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00005023 close to store
 * a9 BAERR_3    55 aFaultb    0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * aa SB_5          (use dinx) 0000000000000010110011100100001xx0        Write d to a+k until accepted                     40005023 close to store
 * ab BAERR_4    c3 unxc3      0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * ac _L0xac     7a SB_5       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * ae _L0xae     7a SB_5       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af JALRE2     de Fetch      0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * b0 (null)     cf MRET_7     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b1 JAERR_2    bf IJT_1      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * b2 (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b5 LBU_1      c5 MRET_5     0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * b6 (null)     c3 unxc3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 (null)     db jFault_1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b8 BGE        29 XOR_1      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 LB_6          (use dinx) 0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00005067 close to jalr
 * ba _LCSRRS_1  31 SLTX_1     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bb ILL_3      d1 MRET_1     0010000000000000101011101100100110        Q = 1                                             00000000 
 * bc CSRRWI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd NMI_2      82 unx82      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * be LDAF_2     3a SRxI_1     0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * bf LDAF_3     dd aF_SW_1    0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * c0 SW_E2         (use dinx) 0000000000001101101111101000001xx0        Store address that faulted                        00006003 close to load
 * c1 SW_E4      ed unxed      0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * c2 SW_E3         (use dinx) 0010000000000000101111001100100110        Q = 3                                             0000600b close to ij
 * c3 ECALL_6       (use dinx) 0000110000001110100111000x00100000        mcause = 11                                       0000600f close to fence
 * c4 ORI_0      ea unxea      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 SH_4       a5 MRET_3     1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * c6 SH_5       8d unx8d      0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * c7 ECALL_4    e2 unxe2      0010000000000000101011001100100110        Q = 4                                             00000000 
 * c8 MRET_3        (use dinx) 0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00006023 close to store
 * c9 ILL_4      c8 unxc8      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * ca EBREAK_2      (use dinx) 0000000000001101101011101000001xx0        pc to mepc                                        40006023 close to store
 * cb MRET_4     86 JAL_2      0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * cc OR_0       41 JALR_1     0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd CSRRW_3       (use dinx) 0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * ce aF_SW_3    fe ILLe       0000110000001110001011000x00100000        Store 7 to mcause                                 40006033 sloppy or      
 * cf CSRRW_4    27 OR_2       0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d0 (null)     65 WFI_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 SH_3       e1 ORI_1      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d4 (null)     bf IJT_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 ECALL_5       (use dinx) 0010000000000000101011001100100110        Q = 8                                             00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     c7 QINT_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       29 XOR_1      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00006067 close to jalr
 * da SH_2       be IJ_1       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * db IJ_4       bf IJT_1      0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * dc CSRRSI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd IJT_2      eb LH_3       0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * de MRET_5     14 condb_3    0010000000000000000011101100010xx0        ~302                                              00000000 
 * df IJT_4      14 condb_3    0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * e0 QINT_1        (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00007003 close to load
 * e1 MRET_2     35 SLLI_1     0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * e2 QINT_2        (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        0000700b close to ij
 * e3 _LCSRRCI_1    (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000700f close to fence
 * e4 ANDI_0     31 SLTX_1     0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 MRET_7     ce _LCSRRCI_1 0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * e6 aFault_2   82 unx82      0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * e7 LDAF_a     39 unx39      0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * e8 jFault_1      (use dinx) 0000000000001110001011100x00100110        Store 1 to mcause                                 00007023 close to store
 * e9 aF_SW_1    df eFetch     0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * ea ORI_1         (use dinx) 0010000000000000000011101100001xx0        Q = RS1                                           40007023 close to store
 * eb aF_SW_2    9c unx9c      0010000000000000101011001100100110        Q = 4                                             00000000 
 * ec AND_0      22 unx22      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed IJT_3         (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ee LH_3       fe ILLe       0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 40007033 sloppy and     
 * ef WFI_2      82 unx82      0010000000000000101011101100100110        Check offset                                      00000000 
 * f0 (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 SB_3       39 unx39      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f2 (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     e9 IJT_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 i0reserv   e8 unxe8      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * f6 (null)     ef WFI_5      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     ca unxca      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       29 XOR_1      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     81 JAERR_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     a3 unxa3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      ad unxad      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       85 LBU_1      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     e0 unxe0      0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0100, used f3ff, inputs 1d
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       82 unx82      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       78 unx78      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     9a ECALL_6    0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     9a ECALL_6    0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    1d ORI_2      0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   21 XORI_1     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     ad unxad      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 _LCSRRCI_1 c7 QINT_1     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 0a _L0x0a     ad unxad      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b MRET_7     62 unx62      0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     9a ECALL_6    0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      2e unx2e      0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     9a ECALL_6    0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 Fetch2     c7 QINT_1     000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 11 jFault     3d SRxI_2     0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 12 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 13 jFault     39 unx39      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 14 (null)     3a SRxI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 15 (null)     06 LB_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 16 (null)     8e _LCSRRS_1  00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 17 (null)     60 unx60      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 18 BEQ        33 JAERR_1    0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     8a unx8a      0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_3       9a ECALL_6    0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 1b _L0x1b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   6e unx6e      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d LB_4       9a ECALL_6    0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 1e JAL_1      29 XOR_1      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 1f JAERR_1    ea unxea      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 20 LH_0       42 unx42      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 LB_5       9a ECALL_6    0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 22 JALR_2        (use dinx) 0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        0000100b close to ij
 * 23 _L0x23     9a ECALL_6    0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     71 aFaultc    0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 eILL0b     5a SB_1       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     41 JALR_1     0010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 aFault_2   51 LDAF_LW    0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 2a _L0x2a     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b LDAF_a     68 unx68      0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * 2c SLL_0      85 LBU_1      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     9a ECALL_6    0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e SUB_1         (use dinx) 0010000000000000111111101100000xx0        Q = ~RS2                                          40001033 sloppy sll     
 * 2f _L0x2f     9a ECALL_6    0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 31 AND_1      65 WFI_4      0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 32 (null)     62 unx62      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 condb_2    c5 MRET_5     0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 34 (null)     8e _LCSRRS_1  00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 35 (null)     73 BAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 (null)     87 JALRE1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 38 BNE        33 JAERR_1    0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 condb_3       (use dinx) 0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00001067 close to jalr
 * 3a condb_4    81 JAERR_2    0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 3b _L0x3b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    a1 ECALL_4    0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d ANDI_1     03 _L0x03     0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 3e LW_1       71 aFaultc    0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    7d BAERR_4    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 ORI_2      22 unx22      0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 42 LH_1          (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH       (use dinx) 0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     65 WFI_4      0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 aFault_1   b3 unxb3      0010000000000000101011001100100110        Q = 4                                             00000000 
 * 46 LH_2       93 SW_E2      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    ca unxca      0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     58 unx58      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 jFault_1   a5 MRET_3     0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 4a _L0x4a     58 unx58      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b aF_SW_1    e3 unxe3      0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 4c SLT_0      6a unx6a      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d IJ_2          (use dinx) 0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 4e LHU_1      fe ILLe       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40002033 sloppy slt     
 * 4f LDAF_LHU   9a ECALL_6    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 50 (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 51 XORI_1     2b SLTIX_1    0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 52 (null)     46 ILL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 OR_1       2b SLTIX_1    0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 54 (null)     8b LB_6       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 55 (null)     45 WFI_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 56 (null)     aa unxaa      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 (null)     c7 QINT_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 58 SW_1          (use dinx) 0000000000000011111011100100001xx0        Write d to a+k until accepted                     00002063 close to branch
 * 59 SW_E1SWE      (use dinx) 0000000000001111001011100x00110000        Store faulting address alignment to mtval         00002067 close to jalr
 * 5a OR_2       af MRET_4     0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 5b _L0x5b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    a1 ECALL_4    0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d XOR_1      ab EBREAK_2   0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 5e LHU_2      5e LHU_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaultc    2b SLTIX_1    0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 60 BrOpFet       (use dinx) 0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00003003 close to load
 * 61 BAlignEr   a7 EBRKWFI1   0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 62 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             0000300b close to ij
 * 63 JALRE1        (use dinx) 0000000000001101110011100x00001xx0  err   Store pc to mepc                                  0000300f close to fence
 * 64 SLTIU_0    65 WFI_4      0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLTIX_1    9d unx9d      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 66 SH_1       a2 unxa2      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 67 SW_E1SWH   d1 MRET_1     0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 68 SLTIX_2       (use dinx) 0000000000000100001011101000110010        Registered ALU flag to rd                         00003023 close to store
 * 69 ORI_1         (use dinx) 0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 6a SLTX_1        (use dinx) 0010000000000000111111101100000xx0        ~rs2 to Q                                         40003023 close to store
 * 6b aF_SW_2    c0 unxc0      0010000000000000101011001100100110        Q = 4                                             00000000 
 * 6c SLTU_0     6a unx6a      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d JAL_3         (use dinx) 0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 6e ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40003033 sloppy sltu    
 * 6f EBRKWFI1   0b JALR_2     0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 70 (null)     ffffffff (null)     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 71 SLLI_1     45 WFI_3      0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 72 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 SLLI_2     be IJ_1       0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 74 (null)     12 unx12      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 75 (null)     bd IJ_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 76 (null)     bf IJT_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 (null)     c1 IJT_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 78 IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00003063 close to branch
 * 79 IJT_1         (use dinx) 0010000010000000101111101100001xx0        Exit CSR, enter trap                              00003067 close to jalr
 * 7a ECALL_2    a2 unxa2      0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 7b _L0x7b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    a1 ECALL_4    0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SRxI_1     6d unx6d      0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 7e ECALL_1    cd unxcd      0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 7f MRET_1     c1 IJT_2      0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 80 LBU_0      c6 IJT_4      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 SRxI_2     c1 IJT_2      0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 82 LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     0000400b close to ij
 * 83 aFaultd       (use dinx) 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       0000400f close to fence
 * 84 XORI_0     51 LDAF_LW    0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 SLL_1      9e SH_4       0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 86 eILL0c     6d unx6d      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 87 ECALL_3    c3 unxc3      0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 88 SRx_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00004023 close to store
 * 89 IJT_3         (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 8a JALR_1        (use dinx) 0010000000000000000011101100100110        Q=1                                               40004023 close to store
 * 8b LH_3       9a ECALL_6    0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 8c XOR_0      5d SB_2       0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d WFI_3         (use dinx) 0010000000000000101011101100100110        More check offset                                 00000000 
 * 8e Fetch      fe ILLe       0000000000001000001111101010110000  Fr00  Read and latch instruction                        40004033 sloppy xor     
 * 8f eFetch     e0 unxe0      0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 90 (null)     6d unx6d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 91 ILL_1      cf MRET_7     0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 92 (null)     6d unx6d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 ILL_2      d9 unxd9      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 94 (null)     6d unx6d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 95 (null)     d3 aFaultd    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 96 (null)     ed unxed      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 (null)     d1 MRET_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 98 BLT        33 JAERR_1    0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a StdIncPc   6d unx6d      0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * 9b aFault        (use dinx) 0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 9c eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00004073 close to csr/system 
 * 9d WFI_5         (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 9e LBU_2      dd aF_SW_1    0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 9f aFaulte    a2 unxa2      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * a0 LHU_0      4e eILL0b     0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 CSRRW_1    e8 unxe8      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * a2 SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   0000500b close to ij
 * a3 aF_SW         (use dinx) 0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     0000500f close to fence
 * a4 SRxI_0     7d BAERR_4    0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 CSRRW_2    e2 unxe2      0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * a6 WFI_1      7e NMI_1      0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * a7 EBREAK_1   b1 aF_SW_3    0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * a8 LH_4          (use dinx) 0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00005023 close to store
 * a9 WFI_2      6d unx6d      0010000000000000101011101100100110        Check offset                                      00000000 
 * aa LH_5          (use dinx) 0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               40005023 close to store
 * ab SB_3       da LDAF_a     0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * ac _L0xac     88 unx88      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad SB_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * ae _L0xae     88 unx88      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SB_2       f1 aFaulte    0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * b0 (null)     e6 StdIncPc   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b1 EBRKWFI2   cf MRET_7     0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * b2 (null)     8e _LCSRRS_1  00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 WFI_4         (use dinx) 0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * b4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b5 (null)     db jFault_1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b6 (null)     da LDAF_a     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 (null)     ee eILL0a     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b8 BGE        33 JAERR_1    0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SB_4          (use dinx) 1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00005067 close to jalr
 * ba MRET_6     3d SRxI_2     0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * bb LBU_3      e7 aFault     0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * bc CSRRWI_0   a1 ECALL_4    0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd BAERR_1    8e _LCSRRS_1  0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * be BAERR_2    4d unx4d      0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * bf BAERR_3    ef WFI_5      0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * c0 SB_5          (use dinx) 0000000000000010110011100100001xx0        Write d to a+k until accepted                     00006003 close to load
 * c1 BAERR_4    89 unx89      0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * c2 NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 0000600b close to ij
 * c3 JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   0000600f close to fence
 * c4 ORI_0      69 unx69      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 JAERR_2    ba LHU_3      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * c6 LBU_1      93 SW_E2      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * c7 LB_6       fb SB_3       0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * c8 _LCSRRS_1     (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00006023 close to store
 * c9 i0reserv   df eFetch     xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * ca ILL_3         (use dinx) 0010000000000000101011101100100110        Q = 1                                             40006023 close to store
 * cb (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * cc OR_0       53 LDAF_LH    0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd NMI_2         (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * ce LDAF_2     fe ILLe       0000110000001110001011000x00100110        Store 4 to mcause                                 40006033 sloppy or      
 * cf LDAF_3     27 OR_2       0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * d0 (null)     7a SB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 SW_E2      fa WFI_2      0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * d2 (null)     1a ANDI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 SW_E4      45 WFI_3      0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * d4 (null)     cf MRET_7     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     de Fetch      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       33 JAERR_1    0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 SW_E3         (use dinx) 0010000000000000101111001100100110        Q = 3                                             00006067 close to jalr
 * da ECALL_6    ce _LCSRRCI_1 0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * db SH_4       cf MRET_7     1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * dc CSRRSI_0   a1 ECALL_4    0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd SH_5       6b SB_4       0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * de ECALL_4    12 unx12      0010000000000000101011001100100110        Q = 4                                             00000000 
 * df MRET_3     12 unx12      0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * e0 ILL_4         (use dinx) 0000110000001110100111100x00100110        Store 2 to mcause                                 00007003 close to load
 * e1 EBREAK_2   41 JALR_1     0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * e2 MRET_4        (use dinx) 0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          0000700b close to ij
 * e3 CSRRW_3       (use dinx) 0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     0000700f close to fence
 * e4 ANDI_0     3d SRxI_2     0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 aF_SW_3    e5 aF_SW_2    0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * e6 CSRRW_4    8e _LCSRRS_1  0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * e7 SH_3       45 WFI_3      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * e8 ECALL_5       (use dinx) 0010000000000000101011001100100110        Q = 8                                             00007023 close to store
 * e9 (null)     f3 aF_SW      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   40007023 close to store
 * eb (null)     a8 unxa8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      31 SLTX_1     0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed SH_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * ee IJ_4       fe ILLe       0100000010001010110111100100011xx0        Mask and use as PC                                40007033 sloppy and     
 * ef IJT_2      8e _LCSRRS_1  0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * f0 (null)     bb SH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 MRET_5     45 WFI_3      0010000000000000000011101100010xx0        ~302                                              00000000 
 * f2 (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 IJT_4      4b CSRRW_2    0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     49 CSRRW_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     a9 ILL_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     e1 ORI_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       33 JAERR_1    0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 QINT_1        (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00007067 close to jalr
 * fa MRET_2     8d unx8d      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * fb QINT_2     b9 unxb9      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * fc CSRRCI_0   a1 ECALL_4    0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      c2 unxc2      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       91 LDAF_2     0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     f9 unxf9      0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0010, used cfff, inputs 39
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       78 unx78      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       6a unx6a      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     86 JAL_2      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     86 JAL_2      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   15 condb_4    0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     9c unx9c      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       b9 unxb9      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     9c unx9c      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       62 unx62      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     86 JAL_2      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      1a ANDI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     86 JAL_2      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 Fetch2     b9 unxb9      000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 11 jFault     2b SLTIX_1    0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 12 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 13 jFault     22 unx22      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 14 (null)     29 XOR_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 15 LB_5       06 LB_3       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 16 (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 17 JALR_2     60 unx60      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 18 BEQ        21 XORI_1     0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     7d BAERR_4    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a SUB_1      86 JAL_2      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 1b _L0x1b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   68 unx68      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d AND_1      86 JAL_2      0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 1e JAL_1      e3 unxe3      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 1f JAERR_1    d5 unxd5      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 20 LH_0       42 unx42      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 condb_2    86 JAL_2      0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 22 condb_3       (use dinx) 0010000000000000001011101100100110        Calculate RS1+~RS2+1                              0000100b close to ij
 * 23 _L0x23     86 JAL_2      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     55 aFaultb    0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 eILL0b     45 WFI_3      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     2e unx2e      0010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_4    3d SRxI_2     0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 2a _L0x2a     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b ANDI_1     4d unx4d      0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 2c SLL_0      6d unx6d      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     86 JAL_2      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e ORI_2         (use dinx) 0000000000000100001011101000111000        rd = Iimm | RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     86 JAL_2      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 31 (null)     4b CSRRW_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 32 (null)     62 unx62      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 (null)     ad unxad      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 34 (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 35 (null)     57 LH_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 (null)     7f JALRE2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 38 BNE        21 XORI_1     0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 aFault_1      (use dinx) 0010000000000000101011001100100110        Q = 4                                             00001067 close to jalr
 * 3a IJ_2       65 WFI_4      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 3b _L0x3b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    91 LDAF_2     0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d XORI_1     03 _L0x03     0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 3e LW_1       55 aFaultb    0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    5d SB_2       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 OR_1       17 condb_5t   0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 42 LH_1          (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH       (use dinx) 0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     4b CSRRW_2    0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 OR_2       9f SH_5       0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 46 LH_2       8d unx8d      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    bb SH_2       0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     58 unx58      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 XOR_1      93 SW_E2      0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 4a _L0x4a     58 unx58      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b SLTIX_1    cd unxcd      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 4c SLT_0      51 LDAF_LW    0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d SLTIX_2       (use dinx) 0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 4e LHU_1      fe ILLe       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40002033 sloppy slt     
 * 4f LDAF_LHU   86 JAL_2      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 50 (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 51 SLTX_1     e5 aF_SW_2    0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 52 (null)     46 ILL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 JAL_3      e5 aF_SW_2    0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 54 (null)     eb LH_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 55 SLLI_1     39 unx39      0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 56 (null)     97 SW_E1SWH   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 SLLI_2     b9 unxb9      0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 58 SW_1          (use dinx) 0000000000000011111011100100001xx0        Write d to a+k until accepted                     00002063 close to branch
 * 59 SW_E1SWE      (use dinx) 0000000000001111001011100x00110000        Store faulting address alignment to mtval         00002067 close to jalr
 * 5a ECALL_2    9d unx9d      0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 5b _L0x5b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    91 LDAF_2     0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SRxI_1     ee eILL0a     0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 5e LHU_2      5e LHU_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaultc    e5 aF_SW_2    0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 60 BrOpFet       (use dinx) 0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00003003 close to load
 * 61 BAlignEr   9b unx9b      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 62 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             0000300b close to ij
 * 63 JALRE1        (use dinx) 0000000000001101110011100x00001xx0  err   Store pc to mepc                                  0000300f close to fence
 * 64 SLTIU_0    4b CSRRW_2    0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SRxI_2     89 unx89      0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 66 SH_1       8e _LCSRRS_1  0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 67 SW_E1SWH   c0 unxc0      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 68 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00003023 close to store
 * 69 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 6a IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   40003023 close to store
 * 6b IJT_1      a8 unxa8      0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 6c SLTU_0     51 LDAF_LW    0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SLL_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 6e ECALL_1       (use dinx) 0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40003033 sloppy sltu    
 * 6f MRET_1     e2 unxe2      0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 70 (null)     ffffffff (null)     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 71 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 72 (null)     2b SLTIX_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 74 (null)     12 unx12      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 75 (null)     a5 MRET_3     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 76 (null)     a7 EBRKWFI1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 (null)     a9 ILL_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 78 LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003063 close to branch
 * 79 aFaultd       (use dinx) 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00003067 close to jalr
 * 7a SRx_1      8e _LCSRRS_1  0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 7b _L0x7b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    91 LDAF_2     0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d JALR_1     53 LDAF_LH    0010000000000000000011101100100110        Q=1                                               00000000 
 * 7e eILL0c     bd IJ_4       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 7f ECALL_3    a9 ILL_4      0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 80 LBU_0      af MRET_4     0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 WFI_3      a9 ILL_4      0010000000000000101011101100100110        More check offset                                 00000000 
 * 82 Fetch         (use dinx) 0000000000001000001111101010110000  Fr00  Read and latch instruction                        0000400b close to ij
 * 83 eFetch        (use dinx) 0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             0000400f close to fence
 * 84 XORI_0     3d SRxI_2     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 ILL_1      8a unx8a      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 86 StdIncPc   53 LDAF_LH    0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * 87 aFault     ab EBREAK_2   0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 88 eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00004023 close to store
 * 89 WFI_5         (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 8a LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40004023 close to store
 * 8b aFaulte    86 JAL_2      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 8c XOR_0      49 CSRRW_1    0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d ILL_2         (use dinx) 0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 8e SW_2       fe ILLe       0010000000000000001011x01000xxxxx0        Prepare read PC                                   40004033 sloppy xor     
 * 8f aF_SW      c9 MRET_2     0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 90 (null)     53 LDAF_LH    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 91 CSRRW_1    bf IJT_1      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 92 (null)     53 LDAF_LH    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 CSRRW_2    c2 unxc2      0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 94 (null)     53 LDAF_LH    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 95 LH_4       c1 IJT_2      0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 96 (null)     d7 ECALL_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 LH_5       c0 unxc0      0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 98 BLT        21 XORI_1     0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a WFI_1      53 LDAF_LH    0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 9b EBREAK_1      (use dinx) 0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 9c SB_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00004073 close to csr/system 
 * 9d SB_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 9e EBRKWFI2   c6 IJT_4      0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 9f WFI_4      8e _LCSRRS_1  0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * a0 LHU_0      4e eILL0b     0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SB_4       d3 aFaultd    1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * a2 MRET_6        (use dinx) 0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            0000500b close to ij
 * a3 LBU_3         (use dinx) 0010000000000000011011101100010xx0        Invert q. Prepare read mask                       0000500f close to fence
 * a4 SRxI_0     5d SB_2       0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 BAERR_1    cb QINT_2     0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * a6 BAERR_2    6e unx6e      0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * a7 BAERR_3    9e SH_4       0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * a8 SB_5          (use dinx) 0000000000000010110011100100001xx0        Write d to a+k until accepted                     00005023 close to store
 * a9 BAERR_4    53 LDAF_LH    0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * aa NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40005023 close to store
 * ab JALRE2     c3 unxc3      0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * ac _L0xac     7a SB_5       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad JAERR_2       (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * ae _L0xae     7a SB_5       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af LBU_1      db jFault_1   0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * b0 (null)     cf MRET_7     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b1 (null)     bf IJT_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b2 (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b5 (null)     c5 MRET_5     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b6 (null)     c3 unxc3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 (null)     d9 unxd9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b8 BGE        21 XORI_1     0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 LB_6          (use dinx) 0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00005067 close to jalr
 * ba _LCSRRS_1  2b SLTIX_1    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * bb ILL_3      d1 MRET_1     0010000000000000101011101100100110        Q = 1                                             00000000 
 * bc CSRRWI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd NMI_2      82 unx82      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * be LDAF_2     3a SRxI_1     0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * bf LDAF_3     da LDAF_a     0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * c0 SW_E2         (use dinx) 0000000000001101101111101000001xx0        Store address that faulted                        00006003 close to load
 * c1 SW_E4      ea unxea      0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * c2 SW_E3         (use dinx) 0010000000000000101111001100100110        Q = 3                                             0000600b close to ij
 * c3 ECALL_6       (use dinx) 0000110000001110100111000x00100000        mcause = 11                                       0000600f close to fence
 * c4 ORI_0      e8 unxe8      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 SH_4       a2 unxa2      1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * c6 SH_5       8d unx8d      0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * c7 ECALL_4    e0 unxe0      0010000000000000101011001100100110        Q = 4                                             00000000 
 * c8 MRET_3        (use dinx) 0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00006023 close to store
 * c9 ILL_4      c8 unxc8      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * ca EBREAK_2      (use dinx) 0000000000001101101011101000001xx0        pc to mepc                                        40006023 close to store
 * cb MRET_4     86 JAL_2      0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * cc OR_0       41 JALR_1     0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd CSRRW_3       (use dinx) 0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * ce aF_SW_3    fe ILLe       0000110000001110001011000x00100000        Store 7 to mcause                                 40006033 sloppy or      
 * cf CSRRW_4    27 OR_2       0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d0 (null)     5a SB_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 SH_3       df eFetch     0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 ECALL_5    39 unx39      0010000000000000101011001100100110        Q = 8                                             00000000 
 * d4 (null)     bf IJT_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 SH_2       c7 QINT_1     0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d8 BLTU       21 XORI_1     0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 IJ_4          (use dinx) 0100000010001010110111100100011xx0        Mask and use as PC                                00006067 close to jalr
 * da IJT_2      be IJ_1       0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * db MRET_5     bf IJT_1      0010000000000000000011101100010xx0        ~302                                              00000000 
 * dc CSRRSI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd IJT_4      e9 IJT_3      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * de QINT_1     12 unx12      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * df MRET_2     12 unx12      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * e0 QINT_2        (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        00007003 close to load
 * e1 _LCSRRCI_1 2e unx2e      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * e2 MRET_7        (use dinx) 0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               0000700b close to ij
 * e3 aFault_2      (use dinx) 0000110000001110001011100x00100110        Store 5 to mcause                                 0000700f close to fence
 * e4 ANDI_0     2b SLTIX_1    0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 LDAF_a     ce _LCSRRCI_1 0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * e6 jFault_1   82 unx82      0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * e7 aF_SW_1    39 unx39      0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * e8 ORI_1         (use dinx) 0010000000000000000011101100001xx0        Q = RS1                                           00007023 close to store
 * e9 aF_SW_2    dd aF_SW_1    0010000000000000101011001100100110        Q = 4                                             00000000 
 * ea IJT_3         (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   40007023 close to store
 * eb LH_3       95 SW_E3      0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * ec AND_0      1d ORI_2      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed WFI_2         (use dinx) 0010000000000000101011101100100110        Check offset                                      00000000 
 * ee SB_3       fe ILLe       0010000000000000000011101000110000        Prepare get back address to use                   40007033 sloppy and     
 * ef i0reserv   82 unx82      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * f0 (null)     a3 unxa3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     e7 aFault     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     e6 StdIncPc   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     ed unxed      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     ca unxca      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       21 XORI_1     0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     81 JAERR_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     a1 ECALL_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      aa unxaa      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       85 LBU_1      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     de Fetch      0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0400, used fdff, inputs 4b
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       68 unx68      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       58 unx58      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     78 unx78      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     78 unx78      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     8e _LCSRRS_1  0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       a1 ECALL_4    0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     8e _LCSRRS_1  0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       36 SLLI_2     0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      21 XORI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      a1 ECALL_4    0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    39 unx39      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 eILL0b        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2b SLTIX_1    0010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       2e unx2e      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       6e unx6e      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    34 JAL_3      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        29 XOR_1      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     77 BAERR_3    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       78 unx78      0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   4e eILL0b     0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     78 unx78      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       cd unxcd      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    bb SH_2       0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      78 unx78      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1         (use dinx) 0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     78 unx78      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     60 unx60      0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LHU_1      50 LW_1       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LHU   3a SRxI_1     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     3e SLL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_2    4b CSRRW_2    0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2a _L0x2a     3e SLL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_3    57 LH_5       0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2c SLL_0      73 BAERR_1    0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_4       (use dinx) 0010000000000000110011101101001xx0        Branch on condition                               40001033 sloppy sll     
 * 2f _L0x2f     78 unx78      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SW_1       78 unx78      0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 31 SW_E1SWE   54 LH_2       0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 32 LHU_2      36 SLLI_2     0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 33 aFaultc    9e SH_4       0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 34 BrOpFet    6e unx6e      0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 35 BAlignEr   63 unx63      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 36 JAL_2      03 _L0x03     0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 37 JALRE1     6b SB_4       0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 38 BNE        29 XOR_1      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00001067 close to jalr
 * 3a ORI_2      70 LHU_2      0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    85 LBU_1      0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d aFault_1   03 _L0x03     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 3e SH_1       60 unx60      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 3f SW_E1SWH   6d unx6d      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 40 LW_0       14 condb_3    0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 (null)     1d ORI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 42 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     0000200b close to ij
 * 43 jFault        (use dinx) 0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000200f close to fence
 * 44 SLTI_0     54 LH_2       0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 (null)     91 LDAF_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 46 Fetch2     81 JAERR_2    000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 47 jFault     a3 unxa3      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 48 _L0x48     30 SLTIX_2    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 IJ_2       8a unx8a      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 4a _L0x4a     30 SLTIX_2    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b XORI_1     b5 SH_3       0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 4c SLT_0      5a SB_1       0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d OR_1          (use dinx) 0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 4e ECAL_RET   fe ILLe       0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40002033 sloppy slt     
 * 4f EBRKWFI1   78 unx78      0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 50 OR_2       78 unx78      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 51 (null)     ce _LCSRRCI_1 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 52 (null)     1e aFault_1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 XOR_1      ce _LCSRRCI_1 0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 54 SLTIX_1    d9 unxd9      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 55 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 56 (null)     8d unx8d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 SLTIX_2    a1 ECALL_4    0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 58 IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00002063 close to branch
 * 59 IJT_1         (use dinx) 0010000010000000101111101100001xx0        Exit CSR, enter trap                              00002067 close to jalr
 * 5a SLTX_1     8f ILL_3      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    85 LBU_1      0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d JAL_3      db jFault_1   0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 5e ECALL_1    32 JAL_1      0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 5f MRET_1     ce _LCSRRCI_1 0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 60 SLLI_1        (use dinx) 0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00003003 close to load
 * 61 (null)     89 unx89      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 62 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000300b close to ij
 * 63 SLLI_2        (use dinx) 0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                0000300f close to fence
 * 64 SLTIU_0    54 LH_2       0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 (null)     7f JALRE2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 66 (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 67 ECALL_2    a8 unxa8      0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 68 LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd       (use dinx) 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    9a ECALL_6    0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     5a SB_1       0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SRxI_1        (use dinx) 0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 6e Fetch         (use dinx) 0000000000001000001111101010110000  Fr00  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     cb QINT_2     0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 SRxI_2     ffffffff (null)     0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 71 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 72 (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 SLL_1      96 SH_1       0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 74 SRx_1      46 ILL_1      0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 75 (null)     95 SW_E3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 76 (null)     97 SW_E1SWH   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 JALR_1     9b unx9b      0010000000000000000011101100100110        Q=1                                               00000000 
 * 78 StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00003063 close to branch
 * 79 aFault        (use dinx) 0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00003067 close to jalr
 * 7a WFI_3      86 JAL_2      0010000000000000101011101100100110        More check offset                                 00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    85 LBU_1      0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d ILL_1      5d SB_2       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 7e eILL0a     a5 MRET_3     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 7f WFI_5      9b unx9b      0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 80 LBU_0      9f SH_5       0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 ILL_2      9b unx9b      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 82 LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     0000400b close to ij
 * 83 aFaulte       (use dinx) 0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      0000400f close to fence
 * 84 XORI_0     4b CSRRW_2    0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 CSRRW_1    82 unx82      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 86 SW_2       5d SB_2       0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 87 aF_SW      9d unx9d      0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 88 WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   00004023 close to store
 * 89 EBREAK_1      (use dinx) 0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 8a CSRRW_2       (use dinx) 0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    40004023 close to store
 * 8b LH_4       78 unx78      0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 8c XOR_0      53 LDAF_LH    0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d LH_5          (use dinx) 0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 8e SB_1       fe ILLe       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        40004033 sloppy xor     
 * 8f SB_2       b2 CSRRW_4    0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 90 EBRKWFI2   5d SB_2       0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 91 WFI_4      a7 EBRKWFI1   0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 92 SB_4       5d SB_2       1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 93 MRET_6     aa unxaa      0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 94 LBU_3      5d SB_2       0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 95 BAERR_1    a9 ILL_4      0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 96 BAERR_2    bd IJ_4       0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 97 BAERR_3    a8 unxa8      0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * 98 BLT        29 XOR_1      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a SB_5       5d SB_2       0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 9b BAERR_4       (use dinx) 0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 9c NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00004073 close to csr/system 
 * 9d JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * 9e JAERR_2    af MRET_4     0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 9f LBU_1      86 JAL_2      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * a0 LHU_0      26 OR_1       0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 LB_6       ba LHU_3      0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * a2 _LCSRRS_1     (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000500b close to ij
 * a3 ILL_3         (use dinx) 0010000000000000101011101100100110        Q = 1                                             0000500f close to fence
 * a4 SRxI_0     6d unx6d      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 NMI_2      b4 i0reserv   0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * a6 LDAF_2     5e LHU_1      0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * a7 LDAF_3     90 NMI_2      0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * a8 SW_E2         (use dinx) 0000000000001101101111101000001xx0        Store address that faulted                        00005023 close to store
 * a9 SW_E4      5d SB_2       0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * aa SW_E3         (use dinx) 0010000000000000101111001100100110        Q = 3                                             40005023 close to store
 * ab ECALL_6    ab EBREAK_2   0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * ac _L0xac     74 BrOpFet    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad SH_4          (use dinx) 1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * ae _L0xae     74 BrOpFet    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af SH_5       c0 unxc0      0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * b0 ECALL_4    b7 IJ_3       0010000000000000101011001100100110        Q = 4                                             00000000 
 * b1 MRET_3     a7 EBRKWFI1   0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * b2 ILL_4      6e unx6e      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * b3 EBREAK_2      (use dinx) 0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * b4 MRET_4        (use dinx) 0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b5 CSRRW_3    ad unxad      0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b6 aF_SW_3    ab EBREAK_2   0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * b7 CSRRW_4    be IJ_1       0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b8 BGE        29 XOR_1      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SH_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   00005067 close to jalr
 * ba ECALL_5    39 unx39      0010000000000000101011001100100110        Q = 8                                             00000000 
 * bb IJ_3       b9 unxb9      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * bc CSRRWI_0   85 LBU_1      0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SH_2       6e unx6e      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * be IJ_4       49 CSRRW_1    0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * bf IJT_2      bf IJT_1      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c0 MRET_5        (use dinx) 0010000000000000000011101100010xx0        ~302                                              00006003 close to load
 * c1 (null)     d7 ECALL_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600b close to ij
 * c3 IJT_4         (use dinx) 0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    0000600f close to fence
 * c4 ORI_0      d3 aFaultd    0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     93 SW_E2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c6 (null)     81 JAERR_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c7 QINT_1     c9 MRET_2     0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * c8 MRET_2        (use dinx) 0010000000000000011011001100100000        0xff+3 = 0x102                                    00006023 close to store
 * c9 QINT_2     b1 aF_SW_3    0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * ca _LCSRRCI_1    (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006023 close to store
 * cb MRET_7     78 unx78      0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * cc OR_0       4d unx4d      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd aFault_2      (use dinx) 0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * ce LDAF_a     fe ILLe       0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      40006033 sloppy or      
 * cf jFault_1   13 condb_2    0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * d0 aF_SW_1    67 SW_E1SWE   0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * d1 (null)     c8 unxc8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 ORI_1      3d SRxI_2     0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * d4 aF_SW_2    a7 EBRKWFI1   0010000000000000101011001100100110        Q = 4                                             00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 IJT_3      b0 CSRRW_3    0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * d8 BLTU       29 XOR_1      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 LH_3          (use dinx) 0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00006067 close to jalr
 * da WFI_2      a6 ECAL_RET   0010000000000000101011101100100110        Check offset                                      00000000 
 * db SB_3       a7 EBRKWFI1   0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * dc CSRRSI_0   85 LBU_1      0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd i0reserv   d4 aFault_2   xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * de (null)     46 ILL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * df (null)     46 ILL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e0 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007003 close to load
 * e1 (null)     3a SRxI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     39 unx39      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     b6 ECALL_5    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e7 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     c3 unxc3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     8b LB_6       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      22 unx22      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007033 sloppy and     
 * ef (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     94 SW_E4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     78 unx78      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     d0 ECALL_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     cf MRET_7     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     da LDAF_a     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     b3 unxb3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       29 XOR_1      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     7a SB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     92 LDAF_3     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   85 LBU_1      0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      9c unx9c      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       7d BAERR_4    0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     c7 QINT_1     0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0040, used f5ff, inputs 53
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       76 BAERR_2    0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       72 LBU_3      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     82 unx82      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     82 unx82      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   17 condb_5t   0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     97 SW_E1SWH   0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       af MRET_4     0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     97 SW_E1SWH   0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       58 unx58      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     82 unx82      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      1f IJ_2       0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     82 unx82      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      af MRET_4     0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    2e unx2e      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 13 jFault     29 XOR_1      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 14 eILL0b     2b SLTIX_1    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 15 MRET_8     06 LB_3       0010000000000000101011101100100110        Prep +4                                           00000000 
 * 16 (null)     7e NMI_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 17 LB_5       56 LH_4       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 18 BEQ        22 unx22      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     81 JAERR_2    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   70 LHU_2      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     82 unx82      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e (null)     e6 StdIncPc   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 1f SUB_1      d5 unxd5      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 20 LH_0       30 SLTIX_2    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 AND_1      82 unx82      0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 22 condb_2       (use dinx) 0010000000000000111111101100000xx0        ~RS2 in Q                                         0000100b close to ij
 * 23 _L0x23     82 unx82      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     62 unx62      0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LW_1       42 unx42      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LW    33 JAERR_1    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     5e LHU_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_3    3d SRxI_2     0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2a _L0x2a     5e LHU_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_4    5a SB_1       0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 2c SLL_0      7a SB_5       0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     82 unx82      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     82 unx82      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_1       82 unx82      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LH    4e eILL0b     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 (null)     58 unx58      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 ORI_2      ab EBREAK_2   0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 34 LH_2       7e NMI_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 35 aFaultb    66 SW_1       0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 aFault_1   79 unx79      0010000000000000101011001100100110        Q = 4                                             00000000 
 * 38 BNE        22 unx22      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 IJ_2          (use dinx) 0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00001067 close to jalr
 * 3a (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    91 LDAF_2     0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d XORI_1     03 _L0x03     0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 3e (null)     62 unx62      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 3f OR_1       6a unx6a      0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 40 LW_0       26 OR_1       0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 (null)     1d ORI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 42 OR_2          (use dinx) 0010000000000000000011101100100000        Q = rs2                                           0000200b close to ij
 * 43 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000200f close to fence
 * 44 SLTI_0     4e eILL0b     0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 (null)     9d unx9d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 46 XOR_1      90 NMI_2      0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 47 (null)     b1 aF_SW_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 48 _L0x48     52 LH_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 (null)     93 SW_E2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 4a _L0x4a     52 LH_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b (null)     d0 ECALL_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 4c SLT_0      5d SB_2       0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 4e SLTIX_1    fe ILLe       0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             40002033 sloppy slt     
 * 4f (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 50 LHU_1      82 unx82      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 51 LDAF_LHU   e8 unxe8      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 52 SW_1       34 JAL_3      0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 53 SW_E1SWE   e8 unxe8      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 54 LHU_2      f3 aF_SW      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 55 aFaultc    37 ECALL_2    0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 56 BrOpFet    95 SW_E3      0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 57 BAlignEr   af MRET_4     0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 58 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             00002063 close to branch
 * 59 JALRE1        (use dinx) 0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00002067 close to jalr
 * 5a SLTIX_2    9b unx9b      0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    91 LDAF_2     0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLTX_1     f5 jFault     0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 5e SH_1       54 LH_2       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5f SW_E1SWH   e8 unxe8      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 60 JAL_3         (use dinx) 0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00003003 close to load
 * 61 (null)     8f ILL_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 62 SLLI_1        (use dinx) 0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      0000300b close to ij
 * 63 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000300f close to fence
 * 64 SLTIU_0    4e eILL0b     0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 (null)     87 JALRE1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 66 SLLI_2     8a unx8a      0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 67 (null)     b7 IJ_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 68 ECALL_2       (use dinx) 0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00003023 close to store
 * 69 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 6a SRxI_1        (use dinx) 0000000000000100101001101100001xx1        Register to shift to Q                            40003023 close to store
 * 6b (null)     a7 EBRKWFI1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 6c SLTU_0     5d SB_2       0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 6e SRxI_2        (use dinx) 0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                40003033 sloppy sltu    
 * 6f (null)     e2 unxe2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 70 ECAL_RET   ffffffff (null)     0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * 71 EBRKWFI1   37 ECALL_2    0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 72 IJ_1       2e unx2e      0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 73 IJT_1      a5 MRET_3     0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 74 ECALL_1    12 unx12      0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 75 MRET_1     a3 unxa3      0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 76 LB_2       a6 ECAL_RET   0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 77 aFaultd    a8 unxa8      0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 78 eILL0c        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00003063 close to branch
 * 79 ECALL_3       (use dinx) 0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00003067 close to jalr
 * 7a SLL_1      8a unx8a      0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    91 LDAF_2     0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SRx_1      60 unx60      0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 7e Fetch      b3 unxb3      0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 7f eFetch     a8 unxa8      0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 80 LBU_0      ad unxad      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 JALR_1     a8 unxa8      0010000000000000000011101100100110        Q=1                                               00000000 
 * 82 StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    0000400b close to ij
 * 83 aFault        (use dinx) 0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          0000400f close to fence
 * 84 XORI_0     3d SRxI_2     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 WFI_3      88 unx88      0010000000000000101011101100100110        More check offset                                 00000000 
 * 86 eILL0a     60 unx60      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 87 WFI_5      aa unxaa      0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 88 LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00004023 close to store
 * 89 aFaulte       (use dinx) 0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 8a SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   40004023 close to store
 * 8b aF_SW      82 unx82      0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 8c XOR_0      46 ILL_1      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d ILL_1         (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 8e WFI_1      fe ILLe       0010000000000000000011001100100110 WFI    To check offset                                   40004033 sloppy xor     
 * 8f EBREAK_1   c8 unxc8      0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 90 ILL_2      60 unx60      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 91 CSRRW_1    b5 SH_3       0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 92 (null)     60 unx60      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 CSRRW_2    bb SH_2       0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 94 LH_4       60 unx60      0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 95 LH_5       b9 unxb9      0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 96 (null)     d6 eILL0c     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 SB_1       b7 IJ_3       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 98 BLT        22 unx22      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a (null)     60 unx60      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 9b SB_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 9c EBRKWFI2      (use dinx) 0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00004073 close to csr/system 
 * 9d WFI_4         (use dinx) 0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 9e (null)     c0 unxc0      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 9f SB_4       8a unx8a      1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * a0 LHU_0      50 LW_1       0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 MRET_6     d4 aFault_2   0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * a2 LBU_3         (use dinx) 0010000000000000011011101100010xx0        Invert q. Prepare read mask                       0000500b close to ij
 * a3 BAERR_1       (use dinx) 0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             0000500f close to fence
 * a4 SRxI_0     6a unx6a      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 BAERR_2    ce _LCSRRCI_1 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * a6 BAERR_3    74 BrOpFet    0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * a7 SB_5       9c unx9c      0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * a8 BAERR_4       (use dinx) 0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00005023 close to store
 * a9 NMI_1      60 unx60      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * aa JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   40005023 close to store
 * ab JAERR_2    bd IJ_4       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * ac _L0xac     7d BAERR_4    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad LBU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * ae _L0xae     7d BAERR_4    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af LB_6       da LDAF_a     0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * b0 _LCSRRS_1  d2 LB_2       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b1 ILL_3      b5 SH_3       0010000000000000101011101100100110        Q = 1                                             00000000 
 * b2 (null)     7e NMI_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 NMI_2         (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * b4 LDAF_2        (use dinx) 0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * b5 LDAF_3     bf IJT_1      0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * b6 (null)     bd IJ_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 SW_E2      d7 ECALL_3    0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * b8 BGE        22 unx22      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SW_E4         (use dinx) 0000110000001110100111100x00101000        Store 6 to mcause                                 00005067 close to jalr
 * ba (null)     2e unx2e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * bb SW_E3      d3 aFaultd    0010000000000000101111001100100110        Q = 3                                             00000000 
 * bc CSRRWI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd ECALL_6    7e NMI_1      0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * be (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * bf SH_4       d9 unxd9      1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * c0 SH_5          (use dinx) 0000000000000001110011100100001xx0        Write d to a+k until accepted                     00006003 close to load
 * c1 (null)     f2 SW_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 ECALL_4       (use dinx) 0010000000000000101011001100100110        Q = 4                                             0000600b close to ij
 * c3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600f close to fence
 * c4 ORI_0      f0 LBU_2      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     a1 ECALL_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c6 MRET_3     90 NMI_2      0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * c7 (null)     df eFetch     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c8 ILL_4         (use dinx) 0000110000001110100111100x00100110        Store 2 to mcause                                 00006023 close to store
 * c9 (null)     c6 IJT_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ca EBREAK_2      (use dinx) 0000000000001101101011101000001xx0        pc to mepc                                        40006023 close to store
 * cb (null)     82 unx82      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * cc OR_0       3f SRx_1      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ce MRET_4     fe ILLe       0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          40006033 sloppy or      
 * cf (null)     15 condb_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d0 CSRRW_3    68 unx68      0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * d1 aF_SW_3    de Fetch      0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * d2 CSRRW_4    09 LB_5       0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d3 SH_3       37 ECALL_2    0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d4 ECALL_5    b5 SH_3       0010000000000000101011001100100110        Q = 8                                             00000000 
 * d5 IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * d6 SH_2       fe ILLe       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d7 IJ_4       c2 unxc2      0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * d8 BLTU       22 unx22      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 IJT_2         (use dinx) 0000000000001100101011101000110000        Read word is to be masked with ~3u                00006067 close to jalr
 * da MRET_5     b4 i0reserv   0010000000000000000011101100010xx0        ~302                                              00000000 
 * db IJT_4      b5 SH_3       0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * dc CSRRSI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd QINT_1     f1 aFaulte    0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * de MRET_2     12 unx12      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * df QINT_2     12 unx12      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * e0 _LCSRRCI_1    (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00007003 close to load
 * e1 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 MRET_7        (use dinx) 0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     2e unx2e      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     d1 MRET_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 aFault_2   7e NMI_1      0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * e7 (null)     37 ECALL_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 LDAF_a        (use dinx) 0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00007023 close to store
 * e9 (null)     db jFault_1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea jFault_1      (use dinx) 0000000000001110001011100x00100110        Store 1 to mcause                                 40007023 close to store
 * eb (null)     94 SW_E4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      21 XORI_1     0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee aF_SW_1    fe ILLe       0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      40007033 sloppy and     
 * ef (null)     7e NMI_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 ORI_1      a2 unxa2      0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * f1 aF_SW_2    37 ECALL_2    0010000000000000101011001100100110        Q = 4                                             00000000 
 * f2 IJT_3      82 unx82      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * f3 LH_3       ee eILL0a     0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f4 WFI_2         (use dinx) 0010000000000000101011101100100110        Check offset                                      00000000 
 * f5 SB_3       ea unxea      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f6 i0reserv   f4 Fetch2     xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * f7 (null)     ca unxca      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       22 unx22      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     85 LBU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     9f SH_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   91 LDAF_2     0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      a9 ILL_4      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       8d unx8d      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     dd aF_SW_1    0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0010, used cfff, inputs 59
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       9e SH_4       0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       9a ECALL_6    0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     a8 unxa8      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     a8 unxa8      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   15 condb_4    0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     95 SW_E3      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       ca unxca      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     95 SW_E3      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       88 unx88      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     a8 unxa8      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      1a ANDI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     a8 unxa8      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 Fetch2     ca unxca      000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 11 jFault     2b SLTIX_1    0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 12 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 13 jFault     22 unx22      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 14 (null)     29 XOR_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 15 LB_5       06 LB_3       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 16 (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 17 JALR_2     86 JAL_2      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 18 BEQ        21 XORI_1     0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     6e unx6e      0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a SUB_1      a8 unxa8      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 1b _L0x1b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   8e _LCSRRS_1  0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d AND_1      a8 unxa8      0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 1e JAL_1      4d unx4d      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 1f JAERR_1    67 SW_E1SWE   0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 20 LH_0       58 unx58      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 condb_2    a8 unxa8      0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 22 condb_3       (use dinx) 0010000000000000001011101100100110        Calculate RS1+~RS2+1                              0000100b close to ij
 * 23 _L0x23     a8 unxa8      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     5a SB_1       0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 eILL0b     39 unx39      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     2e unx2e      0010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     8a unx8a      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_4    35 SLLI_1     0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 2a _L0x2a     8a unx8a      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b ANDI_1     42 unx42      0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 2c SLL_0      68 unx68      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     a8 unxa8      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e ORI_2         (use dinx) 0000000000000100001011101000111000        rd = Iimm | RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     a8 unxa8      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 (null)     a8 unxa8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 31 aFault_1   3d SRxI_2     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 32 (null)     88 unx88      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 IJ_2       c6 IJT_4      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 34 (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 35 XORI_1     5d SB_2       0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 OR_1       a3 unxa3      0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 38 BNE        21 XORI_1     0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 OR_2          (use dinx) 0010000000000000000011101100100000        Q = rs2                                           00001067 close to jalr
 * 3a XOR_1      66 SW_1       0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 3b _L0x3b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    85 LBU_1      0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d SLTIX_1    03 _L0x03     0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 3e LW_1       5a SB_1       0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    62 unx62      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 EBREAK_2   17 condb_5t   0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * 42 SLTIX_2       (use dinx) 0000000000000100001011101000110010        Registered ALU flag to rd                         0000200b close to ij
 * 43 MRET_4        (use dinx) 0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          0000200f close to fence
 * 44 SLTI_0     3d SRxI_2     0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 CSRRW_3    a5 MRET_3     0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * 46 SLTX_1     81 JAERR_2    0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 47 aF_SW_3    d9 unxd9      0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 48 _L0x48     7e NMI_1      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 _LCSRRCI_1 8d unx8d      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 4a _L0x4a     7e NMI_1      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b MRET_7     45 WFI_3      0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * 4c SLT_0      46 ILL_1      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d aFault_2      (use dinx) 0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 4e JAL_3      fe ILLe       0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                40002033 sloppy slt     
 * 4f LDAF_a     a8 unxa8      0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * 50 (null)     a8 unxa8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 51 (null)     4f MRET_8     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 52 (null)     5e LHU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 (null)     4f MRET_8     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 54 (null)     cb QINT_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 55 (null)     31 SLTX_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 56 (null)     93 SW_E2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 (null)     ca unxca      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 58 LH_1          (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00002063 close to branch
 * 59 LDAF_LH       (use dinx) 0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00002067 close to jalr
 * 5a SLLI_1     97 SW_E1SWH   0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 5b _L0x5b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    85 LBU_1      0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLLI_2     cf MRET_7     0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 5e LH_2       82 unx82      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaultb    4f MRET_8     0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 60 ECALL_2       (use dinx) 0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00003003 close to load
 * 61 CSRRW_4    db jFault_1   0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * 62 SRxI_1        (use dinx) 0000000000000100101001101100001xx1        Register to shift to Q                            0000300b close to ij
 * 63 SH_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   0000300f close to fence
 * 64 SLTIU_0    3d SRxI_2     0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 ECALL_5    ab EBREAK_2   0010000000000000101011001100100110        Q = 8                                             00000000 
 * 66 SRxI_2     be IJ_1       0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 67 IJ_3       e0 unxe0      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * 68 SLL_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00003023 close to store
 * 69 jFault_1      (use dinx) 0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * 6a SRx_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  40003023 close to store
 * 6b aF_SW_1    b9 unxb9      0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * 6c SLTU_0     46 ILL_1      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d ORI_1         (use dinx) 0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * 6e JALR_1        (use dinx) 0010000000000000000011101100100110        Q=1                                               40003033 sloppy sltu    
 * 6f aF_SW_2    4b CSRRW_2    0010000000000000101011001100100110        Q = 4                                             00000000 
 * 70 (null)     ffffffff (null)     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 71 (null)     31 SLTX_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 72 (null)     2b SLTIX_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 (null)     b5 SH_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 74 (null)     12 unx12      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 75 (null)     b3 unxb3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 76 (null)     b7 IJ_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 (null)     bd IJ_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 78 LHU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00003063 close to branch
 * 79 LDAF_LHU      (use dinx) 0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00003067 close to jalr
 * 7a WFI_3      be IJ_1       0010000000000000101011101100100110        More check offset                                 00000000 
 * 7b _L0x7b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    85 LBU_1      0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d ILL_1      4e eILL0b     0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 7e SW_1       dd aF_SW_1    0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 7f SW_E1SWE   bd IJ_4       0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 80 LBU_0      c8 unxc8      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 ILL_2      bd IJ_4       0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 82 LHU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     0000400b close to ij
 * 83 aFaultc       (use dinx) 0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      0000400f close to fence
 * 84 XORI_0     35 SLLI_1     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 CSRRW_1    ba LHU_3      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 86 BrOpFet    4e eILL0b     0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 87 BAlignEr   c2 unxc2      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 88 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             00004023 close to store
 * 89 JALRE1        (use dinx) 0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 8a SH_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        40004023 close to store
 * 8b SW_E1SWH   a8 unxa8      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 8c XOR_0      3a SRxI_1     0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d CSRRW_2       (use dinx) 0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 8e ECAL_RET   fe ILLe       0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              40004033 sloppy xor     
 * 8f EBRKWFI1   fb SB_3       0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 90 (null)     4e eILL0b     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 91 LH_4       df eFetch     0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 92 (null)     4e eILL0b     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 LH_5       e6 StdIncPc   0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 94 (null)     4e eILL0b     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 95 SB_1       e2 unxe2      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 96 (null)     c1 IJT_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 SB_2       e0 unxe0      0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 98 BLT        21 XORI_1     0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a IJ_1       4e eILL0b     0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 9b IJT_1         (use dinx) 0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 9c ECALL_1       (use dinx) 0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00004073 close to csr/system 
 * 9d MRET_1        (use dinx) 0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 9e LB_2       ee eILL0a     0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 9f aFaultd    be IJ_1       0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * a0 LHU_0      78 unx78      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 EBRKWFI2   65 WFI_4      0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * a2 eILL0c        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 0000500b close to ij
 * a3 ECALL_3       (use dinx) 0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    0000500f close to fence
 * a4 SRxI_0     62 unx62      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 WFI_4      43 unx43      0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * a6 Fetch      9c unx9c      0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * a7 eFetch     a1 ECALL_4    0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * a8 StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00005023 close to store
 * a9 aFault     4e eILL0b     0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * aa eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40005023 close to store
 * ab WFI_5      e8 unxe8      0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * ac _L0xac     6a unx6a      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad SB_4          (use dinx) 1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * ae _L0xae     6a unx6a      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_6     c7 QINT_1     0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * b0 (null)     61 EBRKWFI2   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b1 LBU_3      df eFetch     0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * b2 (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 BAERR_1       (use dinx) 0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * b4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b5 BAERR_2    ea unxea      0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * b6 (null)     e8 unxe8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 BAERR_3    c3 unxc3      0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * b8 BGE        21 XORI_1     0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SB_5          (use dinx) 0000000000000010110011100100001xx0        Write d to a+k until accepted                     00005067 close to jalr
 * ba LBU_2      2b SLTIX_1    0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * bb aFaulte    63 unx63      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * bc CSRRWI_0   85 LBU_1      0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd BAERR_4    a6 ECAL_RET   0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * be SW_2       33 JAERR_1    0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * bf aF_SW      c5 MRET_5     0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * c0 NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00006003 close to load
 * c1 SH_2       c9 MRET_2     0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * c2 JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   0000600b close to ij
 * c3 IJ_4          (use dinx) 0100000010001010110111100100011xx0        Mask and use as PC                                0000600f close to fence
 * c4 ORI_0      6d unx6d      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 IJT_2      af MRET_4     0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c6 JAERR_2    81 JAERR_2    0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * c7 MRET_5     e7 aFault     0010000000000000000011101100010xx0        ~302                                              00000000 
 * c8 LBU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00006023 close to store
 * c9 IJT_3      fa WFI_2      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ca LB_6          (use dinx) 0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          40006023 close to store
 * cb LH_3       a8 unxa8      0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * cc OR_0       37 ECALL_2    0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd WFI_2         (use dinx) 0010000000000000101011101100100110        Check offset                                      00000000 
 * ce _LCSRRS_1  fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006033 sloppy or      
 * cf SB_3       27 OR_2       0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d0 (null)     60 unx60      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 (null)     e5 aF_SW_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 (null)     31 SLTX_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d4 (null)     df eFetch     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     f9 unxf9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       21 XORI_1     0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 ILL_3         (use dinx) 0010000000000000101011101100100110        Q = 1                                             00006067 close to jalr
 * da WFI_1      de Fetch      0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * db EBREAK_1   df eFetch     0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * dc CSRRSI_0   85 LBU_1      0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd NMI_2      6f MRET_6     0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * de LDAF_2     12 unx12      0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * df LDAF_3     12 unx12      0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * e0 SW_E2         (use dinx) 0000000000001101101111101000001xx0        Store address that faulted                        00007003 close to load
 * e1 IJT_4      2e unx2e      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * e2 SW_E4         (use dinx) 0000110000001110100111100x00101000        Store 6 to mcause                                 0000700b close to ij
 * e3 QINT_1        (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 0000700f close to fence
 * e4 ANDI_0     2b SLTIX_1    0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 MRET_2     47 ILL_2      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * e6 SW_E3      a6 ECAL_RET   0010000000000000101111001100100110        Q = 3                                             00000000 
 * e7 QINT_2     31 SLTX_1     0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * e8 ECALL_6       (use dinx) 0000110000001110100111000x00100000        mcause = 11                                       00007023 close to store
 * e9 i0reserv   e1 ORI_1      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * ea SH_4          (use dinx) 1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      40007023 close to store
 * eb (null)     91 LDAF_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      1d ORI_2      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee SH_5       fe ILLe       0000000000000001110011100100001xx0        Write d to a+k until accepted                     40007033 sloppy and     
 * ef (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     b1 aF_SW_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     31 SLTX_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     a8 unxa8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     6b SB_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     69 unx69      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     cd unxcd      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     41 JALR_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       21 XORI_1     0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 ECALL_4       (use dinx) 0010000000000000101011001100100110        Q = 4                                             00007067 close to jalr
 * fa MRET_3     7a SB_5       0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * fb ILL_4      ad unxad      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * fc CSRRCI_0   85 LBU_1      0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      c0 unxc0      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       7d BAERR_4    0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     e3 unxe3      0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0400, used ffff, inputs 87
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       50 LW_1       0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       46 ILL_1      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     56 LH_4       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     56 LH_4       0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     77 BAERR_3    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       90 NMI_2      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     77 BAERR_3    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       36 SLLI_2     0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      21 XORI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      90 NMI_2      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    39 unx39      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 eILL0b        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2b SLTIX_1    0010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       2e unx2e      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       54 LH_2       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    34 JAL_3      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        29 XOR_1      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     6f MRET_6     0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       56 LH_4       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   42 unx42      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     56 LH_4       0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       bf IJT_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    b0 CSRRW_3    0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      56 LH_4       0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1         (use dinx) 0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     56 LH_4       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     67 SW_E1SWE   0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LHU_1      4b CSRRW_2    0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LHU   3a SRxI_1     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     3e SLL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_2    45 WFI_3      0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2a _L0x2a     3e SLL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_3    5d SB_2       0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2c SLL_0      6d unx6d      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_4       (use dinx) 0010000000000000110011101101001xx0        Branch on condition                               40001033 sloppy sll     
 * 2f _L0x2f     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SW_1       56 LH_4       0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 31 SW_E1SWE   5a SB_1       0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 32 LHU_2      36 SLLI_2     0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 33 aFaultc    8e _LCSRRS_1  0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 34 BrOpFet    54 LH_2       0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 35 BAlignEr   68 unx68      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 36 JAL_2      03 _L0x03     0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 37 JALRE1     53 LDAF_LH    0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 38 BNE        29 XOR_1      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00001067 close to jalr
 * 3a ORI_2      6b SB_4       0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    73 BAERR_1    0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d aFault_1   03 _L0x03     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 3e SH_1       67 SW_E1SWE   0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 3f SW_E1SWH   6a unx6a      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 40 LW_0       14 condb_3    0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 IJ_2       1d ORI_2      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 42 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000200b close to ij
 * 43 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000200f close to fence
 * 44 SLTI_0     5a SB_1       0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 XORI_1     7a SB_5       0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 46 IJ_1       72 LBU_3      0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 47 IJT_1      93 SW_E2      0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 48 _L0x48     30 SLTIX_2    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 OR_1       74 BrOpFet    0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 4a _L0x4a     30 SLTIX_2    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b OR_2       a8 unxa8      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 4c SLT_0      65 WFI_4      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d XOR_1         (use dinx) 0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 4e ECALL_1    fe ILLe       0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40002033 sloppy slt     
 * 4f MRET_1     56 LH_4       0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 50 LB_2       56 LH_4       0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 51 aFaultd    c0 unxc0      0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 52 eILL0c     1e aFault_1   0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 53 ECALL_3    c0 unxc0      0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 54 Fetch      c8 unxc8      0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 55 eFetch     3d SRxI_2     0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 56 StdIncPc   76 BAERR_2    0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * 57 aFault     90 NMI_2      0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 58 eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00002063 close to branch
 * 59 WFI_5         (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch                                    00002067 close to jalr
 * 5a SLTIX_1    78 unx78      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    73 BAERR_1    0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLTIX_2    cb QINT_2     0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 5e LBU_2      32 JAL_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaulte    c0 unxc0      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 60 SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   00003003 close to load
 * 61 aF_SW      63 unx63      0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 62 WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   0000300b close to ij
 * 63 EBREAK_1      (use dinx) 0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       0000300f close to fence
 * 64 SLTIU_0    5a SB_1       0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLTX_1     59 unx59      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 66 JAL_3      60 unx60      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 67 SLLI_1     97 SW_E1SWH   0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 68 SLLI_2        (use dinx) 0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00003023 close to store
 * 69 ECALL_2       (use dinx) 0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 6a SRxI_1        (use dinx) 0000000000000100101001101100001xx1        Register to shift to Q                            40003023 close to store
 * 6b SRxI_2     87 JALRE1     0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 6c SLTU_0     65 WFI_4      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SLL_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 6e SRx_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  40003033 sloppy sltu    
 * 6f JALR_1     be IJ_1       0010000000000000000011101100100110        Q=1                                               00000000 
 * 70 WFI_3      ffffffff (null)     0010000000000000101011101100100110        More check offset                                 00000000 
 * 71 ILL_1      3d SRxI_2     0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 72 ILL_2      39 unx39      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 73 CSRRW_1    85 LBU_1      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 74 CSRRW_2    8a unx8a      0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 75 LH_4       81 JAERR_2    0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 76 LH_5       86 JAL_2      0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 77 SB_1       88 unx88      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 78 SB_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00003063 close to branch
 * 79 EBRKWFI2      (use dinx) 0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00003067 close to jalr
 * 7a WFI_4      60 unx60      0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    73 BAERR_1    0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SB_4       66 SW_1       1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 7e MRET_6     94 SW_E4      0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 7f LBU_3      88 unx88      0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 80 LBU_0      8f ILL_3      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 BAERR_1    88 unx88      0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 82 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     0000400b close to ij
 * 83 jFault        (use dinx) 0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000400f close to fence
 * 84 XORI_0     45 WFI_3      0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 BAERR_2    5e LHU_1      0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 86 BAERR_3    66 SW_1       0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * 87 SB_5       8d unx8d      0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 88 BAERR_4       (use dinx) 0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00004023 close to store
 * 89 NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 8a Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     40004023 close to store
 * 8b jFault     56 LH_4       0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 8c XOR_0      4d unx4d      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * 8e JAERR_2    fe ILLe       0000000000001101101011100x00001xx0        Store PC to mepc                                  40004033 sloppy xor     
 * 8f LBU_1      a5 MRET_3     0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 90 LB_6       66 SW_1       0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 91 _LCSRRS_1  96 SH_1       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 92 (null)     66 SW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 ILL_3      9c unx9c      0010000000000000101011101100100110        Q = 1                                             00000000 
 * 94 NMI_2      66 SW_1       0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 95 LDAF_2     9b unx9b      0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 96 LDAF_3     b1 aF_SW_3    0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 97 SW_E2      97 SW_E1SWH   0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 98 BLT        29 XOR_1      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a (null)     66 SW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 9b SW_E4         (use dinx) 0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 9c SW_E3         (use dinx) 0010000000000000101111001100100110        Q = 3                                             00004073 close to csr/system 
 * 9d ECALL_6       (use dinx) 0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 9e SH_4       9f SH_5       1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 9f SH_5       60 unx60      0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * a0 LHU_0      26 OR_1       0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_4    af MRET_4     0010000000000000101011001100100110        Q = 4                                             00000000 
 * a2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000500b close to ij
 * a3 MRET_3        (use dinx) 0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          0000500f close to fence
 * a4 SRxI_0     6a unx6a      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 ILL_4      a7 EBRKWFI1   0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * a6 EBREAK_2   4e eILL0b     0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * a7 MRET_4     79 unx79      0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * a8 CSRRW_3       (use dinx) 0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00005023 close to store
 * a9 aF_SW_3    66 SW_1       0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * aa (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40005023 close to store
 * ab CSRRW_4    9d unx9d      0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * ac _L0xac     6e unx6e      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad SH_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * ae _L0xae     6e unx6e      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af ECALL_5    b5 SH_3       0010000000000000101011001100100110        Q = 8                                             00000000 
 * b0 IJ_3       ab EBREAK_2   0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b1 SH_2       96 SH_1       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * b2 (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 IJ_4          (use dinx) 0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * b4 IJT_2         (use dinx) 0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * b5 MRET_5     9e SH_4       0010000000000000000011101100010xx0        ~302                                              00000000 
 * b6 IJT_4      9d unx9d      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * b7 QINT_1     b3 unxb3      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * b8 BGE        29 XOR_1      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 MRET_2        (use dinx) 0010000000000000011011001100100000        0xff+3 = 0x102                                    00005067 close to jalr
 * ba (null)     39 unx39      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * bb QINT_2     ad unxad      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * bc CSRRWI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd _LCSRRCI_1 54 LH_2       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * be MRET_7     41 JALR_1     0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * bf aFault_2   b4 i0reserv   0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * c0 LDAF_a        (use dinx) 0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00006003 close to load
 * c1 jFault_1   c7 QINT_1     0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * c2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600b close to ij
 * c3 aF_SW_1       (use dinx) 0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      0000600f close to fence
 * c4 ORI_0      c5 MRET_5     0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 ORI_1      7e NMI_1      0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * c6 aF_SW_2    72 LBU_3      0010000000000000101011001100100110        Q = 4                                             00000000 
 * c7 IJT_3      bb SH_2       0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * c8 LH_3          (use dinx) 0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00006023 close to store
 * c9 WFI_2      a3 unxa3      0010000000000000101011101100100110        Check offset                                      00000000 
 * ca (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40006023 close to store
 * cb SB_3       56 LH_4       0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * cc OR_0       49 CSRRW_1    0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd i0reserv      (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * ce (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40006033 sloppy or      
 * cf (null)     13 condb_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d0 (null)     69 unx69      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 (null)     b9 unxb9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d4 (null)     96 SH_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     a1 ECALL_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       29 XOR_1      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00006067 close to jalr
 * da (null)     95 SW_E3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * db (null)     96 SH_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * dc CSRRSI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd (null)     c6 IJT_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * de (null)     8a unx8a      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * df (null)     8a unx8a      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e0 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007003 close to load
 * e1 (null)     3a SRxI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     39 unx39      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     a9 ILL_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e7 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     b6 ECALL_5    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     75 BAlignEr   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      22 unx22      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007033 sloppy and     
 * ef (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     7f JALRE2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     56 LH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     c3 unxc3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     c1 IJT_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     c9 MRET_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       29 XOR_1      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     70 LHU_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     7d BAERR_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      89 unx89      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       71 aFaultc    0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     b7 IJ_3       0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0400, used fdff, inputs 8b
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       50 LW_1       0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       46 ILL_1      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     56 LH_4       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     56 LH_4       0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     77 BAERR_3    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       94 SW_E4      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     77 BAERR_3    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       36 SLLI_2     0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      21 XORI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      94 SW_E4      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    39 unx39      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 eILL0b        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2b SLTIX_1    0010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       2e unx2e      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       54 LH_2       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    34 JAL_3      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        29 XOR_1      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     6f MRET_6     0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       56 LH_4       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   42 unx42      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     56 LH_4       0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       cd unxcd      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    bb SH_2       0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      56 LH_4       0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1         (use dinx) 0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     56 LH_4       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     67 SW_E1SWE   0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LHU_1      4b CSRRW_2    0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LHU   3a SRxI_1     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     3e SLL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_2    45 WFI_3      0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2a _L0x2a     3e SLL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_3    5d SB_2       0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2c SLL_0      6d unx6d      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_4       (use dinx) 0010000000000000110011101101001xx0        Branch on condition                               40001033 sloppy sll     
 * 2f _L0x2f     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SW_1       56 LH_4       0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 31 SW_E1SWE   5a SB_1       0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 32 LHU_2      36 SLLI_2     0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 33 aFaultc    90 NMI_2      0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 34 BrOpFet    54 LH_2       0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 35 BAlignEr   68 unx68      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 36 JAL_2      03 _L0x03     0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 37 JALRE1     53 LDAF_LH    0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 38 BNE        29 XOR_1      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00001067 close to jalr
 * 3a ORI_2      6b SB_4       0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    73 BAERR_1    0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d aFault_1   03 _L0x03     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 3e SH_1       67 SW_E1SWE   0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 3f SW_E1SWH   6a unx6a      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 40 LW_0       14 condb_3    0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 IJ_2       1d ORI_2      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 42 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000200b close to ij
 * 43 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000200f close to fence
 * 44 SLTI_0     5a SB_1       0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 XORI_1     7a SB_5       0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 46 IJ_1       72 LBU_3      0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 47 IJT_1      9a ECALL_6    0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 48 _L0x48     30 SLTIX_2    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 OR_1       74 BrOpFet    0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 4a _L0x4a     30 SLTIX_2    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b OR_2       b3 unxb3      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 4c SLT_0      65 WFI_4      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d XOR_1         (use dinx) 0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 4e ECALL_1    fe ILLe       0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40002033 sloppy slt     
 * 4f MRET_1     56 LH_4       0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 50 LB_2       56 LH_4       0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 51 aFaultd    ce _LCSRRCI_1 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 52 eILL0c     1e aFault_1   0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 53 ECALL_3    ce _LCSRRCI_1 0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 54 Fetch      d9 unxd9      0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 55 eFetch     3d SRxI_2     0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 56 StdIncPc   76 BAERR_2    0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * 57 aFault     94 SW_E4      0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 58 eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00002063 close to branch
 * 59 WFI_5         (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch                                    00002067 close to jalr
 * 5a SLTIX_1    78 unx78      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    73 BAERR_1    0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLTIX_2    db jFault_1   0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 5e LBU_2      32 JAL_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaulte    ce _LCSRRCI_1 0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 60 SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   00003003 close to load
 * 61 aF_SW      63 unx63      0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 62 WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   0000300b close to ij
 * 63 EBREAK_1      (use dinx) 0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       0000300f close to fence
 * 64 SLTIU_0    5a SB_1       0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLTX_1     59 unx59      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 66 JAL_3      60 unx60      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 67 SLLI_1     9e SH_4       0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 68 SLLI_2        (use dinx) 0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00003023 close to store
 * 69 ECALL_2       (use dinx) 0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 6a SRxI_1        (use dinx) 0000000000000100101001101100001xx1        Register to shift to Q                            40003023 close to store
 * 6b SRxI_2     8b LB_6       0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 6c SLTU_0     65 WFI_4      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SLL_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 6e SRx_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  40003033 sloppy sltu    
 * 6f JALR_1     cb QINT_2     0010000000000000000011101100100110        Q=1                                               00000000 
 * 70 WFI_3      ffffffff (null)     0010000000000000101011101100100110        More check offset                                 00000000 
 * 71 ILL_1      3d SRxI_2     0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 72 ILL_2      39 unx39      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 73 CSRRW_1    89 unx89      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 74 CSRRW_2    86 JAL_2      0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 75 LH_4       88 unx88      0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 76 LH_5       8a unx8a      0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 77 SB_1       8d unx8d      0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 78 SB_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00003063 close to branch
 * 79 EBRKWFI2      (use dinx) 0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00003067 close to jalr
 * 7a WFI_4      60 unx60      0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    73 BAERR_1    0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SB_4       66 SW_1       1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 7e MRET_6     9b unx9b      0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 7f LBU_3      8d unx8d      0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 80 LBU_0      93 SW_E2      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 (null)     8d unx8d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 82 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     0000400b close to ij
 * 83 jFault        (use dinx) 0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000400f close to fence
 * 84 XORI_0     45 WFI_3      0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 (null)     5e LHU_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 86 Fetch2     66 SW_1       000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 87 jFault     8f ILL_3      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 88 BAERR_1       (use dinx) 0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00004023 close to store
 * 89 BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 8a BAERR_3       (use dinx) 0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       40004023 close to store
 * 8b SB_5       56 LH_4       0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 8c XOR_0      4d unx4d      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d BAERR_4       (use dinx) 0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 8e NMI_1      fe ILLe       0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40004033 sloppy xor     
 * 8f JALRE2     ad unxad      0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * 90 JAERR_2    66 SW_1       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 91 (null)     9d unx9d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 92 (null)     66 SW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 LBU_1      a3 unxa3      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 94 LB_6       66 SW_1       0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 95 (null)     9f SH_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 96 (null)     bd IJ_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 _LCSRRS_1  9e SH_4       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 98 BLT        29 XOR_1      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a ILL_3      66 SW_1       0010000000000000101011101100100110        Q = 1                                             00000000 
 * 9b NMI_2         (use dinx) 0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 9c LDAF_2        (use dinx) 0000110000001110001011000x00100110        Store 4 to mcause                                 00004073 close to csr/system 
 * 9d LDAF_3        (use dinx) 0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 9e SW_E2      a9 ILL_4      0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 9f SW_E4      60 unx60      0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * a0 LHU_0      26 OR_1       0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 (null)     ba LHU_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000500b close to ij
 * a3 SW_E3         (use dinx) 0010000000000000101111001100100110        Q = 3                                             0000500f close to fence
 * a4 SRxI_0     6a unx6a      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 (null)     b0 CSRRW_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a6 (null)     4e eILL0b     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a7 ECALL_6    79 unx79      0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * a8 SH_4          (use dinx) 1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00005023 close to store
 * a9 SH_5       66 SW_1       0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * aa ECALL_4       (use dinx) 0010000000000000101011001100100110        Q = 4                                             40005023 close to store
 * ab MRET_3     a7 EBRKWFI1   0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * ac _L0xac     6e unx6e      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad ILL_4         (use dinx) 0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * ae _L0xae     6e unx6e      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af EBREAK_2   c0 unxc0      0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * b0 MRET_4     b7 IJ_3       0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b1 (null)     9d unx9d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b2 (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 CSRRW_3       (use dinx) 0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b4 aF_SW_3       (use dinx) 0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * b5 (null)     a8 unxa8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b6 (null)     a7 EBRKWFI1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 CSRRW_4    be IJ_1       0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b8 BGE        29 XOR_1      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SH_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   00005067 close to jalr
 * ba ECALL_5    39 unx39      0010000000000000101011001100100110        Q = 8                                             00000000 
 * bb IJ_3       b9 unxb9      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * bc CSRRWI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SH_2       54 LH_2       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * be IJ_4       41 JALR_1     0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * bf IJT_2      bf IJT_1      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c0 MRET_5        (use dinx) 0010000000000000000011101100010xx0        ~302                                              00006003 close to load
 * c1 (null)     d7 ECALL_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600b close to ij
 * c3 IJT_4         (use dinx) 0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    0000600f close to fence
 * c4 ORI_0      d3 aFaultd    0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     7e NMI_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c6 (null)     72 LBU_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c7 QINT_1     c9 MRET_2     0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * c8 MRET_2        (use dinx) 0010000000000000011011001100100000        0xff+3 = 0x102                                    00006023 close to store
 * c9 QINT_2     ab EBREAK_2   0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * ca _LCSRRCI_1    (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006023 close to store
 * cb MRET_7     56 LH_4       0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * cc OR_0       49 CSRRW_1    0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd aFault_2      (use dinx) 0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * ce LDAF_a     fe ILLe       0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      40006033 sloppy or      
 * cf jFault_1   13 condb_2    0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * d0 aF_SW_1    69 unx69      0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * d1 (null)     c8 unxc8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 ORI_1      3d SRxI_2     0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * d4 aF_SW_2    9d unx9d      0010000000000000101011001100100110        Q = 4                                             00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 IJT_3      aa unxaa      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * d8 BLTU       29 XOR_1      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 LH_3          (use dinx) 0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00006067 close to jalr
 * da WFI_2      9c unx9c      0010000000000000101011101100100110        Check offset                                      00000000 
 * db SB_3       9d unx9d      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * dc CSRRSI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd i0reserv   d4 aFault_2   xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * de (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * df (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e0 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007003 close to load
 * e1 (null)     3a SRxI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     39 unx39      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     b4 i0reserv   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e7 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     c3 unxc3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     75 BAlignEr   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      22 unx22      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007033 sloppy and     
 * ef (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     7f JALRE2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     56 LH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     d0 ECALL_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     cf MRET_7     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     da LDAF_a     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     af MRET_4     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       29 XOR_1      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     70 LHU_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     7d BAERR_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      8e _LCSRRS_1  0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       71 aFaultc    0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     c7 QINT_1     0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0040, used f5ff, inputs 93
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       68 unx68      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       62 unx62      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     70 LHU_2      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     70 LHU_2      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   17 condb_5t   0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     95 SW_E3      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       b3 unxb3      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     95 SW_E3      0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       54 LH_2       0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     70 LHU_2      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      1f IJ_2       0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     70 LHU_2      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      b3 unxb3      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    2e unx2e      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 13 jFault     29 XOR_1      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 14 eILL0b     2b SLTIX_1    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 15 MRET_8     06 LB_3       0010000000000000101011101100100110        Prep +4                                           00000000 
 * 16 (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 17 LB_5       50 LW_1       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 18 BEQ        22 unx22      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     7d BAERR_4    0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a (null)     70 LHU_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   60 unx60      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     70 LHU_2      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e (null)     e6 StdIncPc   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 1f SUB_1      d5 unxd5      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 20 LH_0       30 SLTIX_2    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 AND_1      70 LHU_2      0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 22 condb_2       (use dinx) 0010000000000000111111101100000xx0        ~RS2 in Q                                         0000100b close to ij
 * 23 _L0x23     70 LHU_2      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     57 LH_5       0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LW_1       41 JALR_1     0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LW    33 JAERR_1    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     58 unx58      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_3    3d SRxI_2     0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2a _L0x2a     58 unx58      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_4    4b CSRRW_2    0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 2c SLL_0      73 BAERR_1    0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     70 LHU_2      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     70 LHU_2      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 LH_1       70 LHU_2      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 31 LDAF_LH    49 CSRRW_1    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 32 (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 ORI_2      b1 aF_SW_3    0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 34 LH_2       6e unx6e      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 35 aFaultb    5d SB_2       0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 aFault_1   6b SB_4       0010000000000000101011001100100110        Q = 4                                             00000000 
 * 38 BNE        22 unx22      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 IJ_2          (use dinx) 0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00001067 close to jalr
 * 3a (null)     6d unx6d      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    88 unx88      0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d XORI_1     03 _L0x03     0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 3e (null)     57 LH_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 3f OR_1       65 WFI_4      0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 40 LW_0       26 OR_1       0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 OR_2       1d ORI_2      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 42 LHU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LHU      (use dinx) 0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     49 CSRRW_1    0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 XOR_1      9a ECALL_6    0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 46 SW_1       86 JAL_2      0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 47 SW_E1SWE   b5 SH_3       0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 48 _L0x48     46 ILL_1      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 SLTIX_1    8a unx8a      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 4a _L0x4a     46 ILL_1      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b SLTIX_2    d0 ECALL_1    0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 4c SLT_0      4d unx4d      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d SLTX_1        (use dinx) 0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 4e LHU_2      fe ILLe       0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     40002033 sloppy slt     
 * 4f aFaultc    70 LHU_2      0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 50 BrOpFet    70 LHU_2      0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 51 BAlignEr   e8 unxe8      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 52 (null)     34 JAL_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 JAL_3      e8 unxe8      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 54 JAL_2      f3 aF_SW      0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 55 JALRE1     37 ECALL_2    0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 56 (null)     94 SW_E4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 SLLI_1     b3 unxb3      0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 58 SH_1          (use dinx) 0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00002063 close to branch
 * 59 SW_E1SWH      (use dinx) 0000000000001111001011100x00110000        Store faulting address alignment to mtval         00002067 close to jalr
 * 5a (null)     96 SH_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    88 unx88      0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLLI_2     f5 jFault     0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 5e (null)     4e eILL0b     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 5f ECALL_2    e8 unxe8      0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 60 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00003003 close to load
 * 61 EBRKWFI1   93 SW_E2      0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 62 IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   0000300b close to ij
 * 63 IJT_1         (use dinx) 0010000010000000101111101100001xx0        Exit CSR, enter trap                              0000300f close to fence
 * 64 SLTIU_0    49 CSRRW_1    0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SRxI_1     75 BAlignEr   0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 66 ECALL_1    90 NMI_2      0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * 67 MRET_1     ba LHU_3      0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 68 LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003023 close to store
 * 69 aFaultd       (use dinx) 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 6a eILL0c        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40003023 close to store
 * 6b ECALL_3    a6 ECAL_RET   0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 6c SLTU_0     4d unx4d      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SRxI_2        (use dinx) 0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 6e Fetch         (use dinx) 0000000000001000001111101010110000  Fr00  Read and latch instruction                        40003033 sloppy sltu    
 * 6f eFetch     e2 unxe2      0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 70 StdIncPc   ffffffff (null)     0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * 71 aFault     37 ECALL_2    0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 72 (null)     2e unx2e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 SLL_1      9f SH_5       0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 74 eILL0a     12 unx12      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 75 WFI_5      9e SH_4       0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * 76 (null)     a2 unxa2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 SRx_1      a8 unxa8      0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 78 LBU_2         (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00003063 close to branch
 * 79 aFaulte       (use dinx) 0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00003067 close to jalr
 * 7a (null)     90 NMI_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    88 unx88      0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d JALR_1     53 LDAF_LH    0010000000000000000011101100100110        Q=1                                               00000000 
 * 7e (null)     b6 ECALL_5    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 7f WFI_3      a8 unxa8      0010000000000000101011101100100110        More check offset                                 00000000 
 * 80 LBU_0      b2 CSRRW_4    0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 (null)     a8 unxa8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 82 ILL_1         (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  0000400b close to ij
 * 83 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000400f close to fence
 * 84 XORI_0     3d SRxI_2     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 (null)     78 unx78      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 86 ILL_2      53 LDAF_LH    0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 87 (null)     b0 CSRRW_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 88 CSRRW_1       (use dinx) 0010000000000000000011101100100110        Construct PC storage adr                          00004023 close to store
 * 89 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 8a CSRRW_2       (use dinx) 0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    40004023 close to store
 * 8b (null)     70 LHU_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 8c XOR_0      45 WFI_3      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 8e LH_4       fe ILLe       0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      40004033 sloppy xor     
 * 8f (null)     c8 unxc8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 90 SW_2       53 LDAF_LH    0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * 91 aF_SW      b9 unxb9      0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 92 WFI_1      53 LDAF_LH    0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * 93 EBREAK_1   bd IJ_4       0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * 94 LH_5       53 LDAF_LH    0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 95 SB_1       bb SH_2       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 96 SB_2       d6 eILL0c     0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 97 EBRKWFI2   ba LHU_3      0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 98 BLT        22 unx22      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a WFI_4      53 LDAF_LH    0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 9b SB_4          (use dinx) 1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 9c MRET_6        (use dinx) 0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00004073 close to csr/system 
 * 9d LBU_3         (use dinx) 0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 9e BAERR_1    c0 unxc0      0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 9f BAERR_2    90 NMI_2      0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * a0 LHU_0      42 unx42      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 (null)     d4 aFault_2   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a2 BAERR_3       (use dinx) 0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       0000500b close to ij
 * a3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000500f close to fence
 * a4 SRxI_0     65 WFI_4      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 (null)     ce _LCSRRCI_1 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a6 SB_5       66 SW_1       0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * a7 (null)     97 SW_E1SWH   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * a8 BAERR_4       (use dinx) 0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00005023 close to store
 * a9 (null)     53 LDAF_LH    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * aa NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 40005023 close to store
 * ab (null)     be IJ_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ac _L0xac     77 BAERR_3    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ae _L0xae     77 BAERR_3    0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af (null)     da LDAF_a     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b0 JALRE2     d2 LB_2       0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * b1 JAERR_2    b9 unxb9      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * b2 LBU_1      6e unx6e      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * b3 LB_6          (use dinx) 0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * b4 _LCSRRS_1     (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * b5 ILL_3      bf IJT_1      0010000000000000101011101100100110        Q = 1                                             00000000 
 * b6 NMI_2      be IJ_1       0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * b7 LDAF_2     d7 ECALL_3    0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * b8 BGE        22 unx22      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 LDAF_3        (use dinx) 0000000000001101100111100x00001xx0        PC to mepc                                        00005067 close to jalr
 * ba SW_E2      2e unx2e      0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * bb SW_E4      d3 aFaultd    0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * bc CSRRWI_0   88 unx88      0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd SW_E3      6e unx6e      0010000000000000101111001100100110        Q = 3                                             00000000 
 * be ECALL_6    39 unx39      0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * bf SH_4       d9 unxd9      1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * c0 SH_5          (use dinx) 0000000000000001110011100100001xx0        Write d to a+k until accepted                     00006003 close to load
 * c1 (null)     f2 SW_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c2 ECALL_4       (use dinx) 0010000000000000101011001100100110        Q = 4                                             0000600b close to ij
 * c3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600f close to fence
 * c4 ORI_0      f0 LBU_2      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 (null)     9c unx9c      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c6 MRET_3     86 JAL_2      0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * c7 (null)     df eFetch     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c8 ILL_4         (use dinx) 0000110000001110100111100x00100110        Store 2 to mcause                                 00006023 close to store
 * c9 (null)     c6 IJT_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ca EBREAK_2      (use dinx) 0000000000001101101011101000001xx0        pc to mepc                                        40006023 close to store
 * cb (null)     70 LHU_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * cc OR_0       3f SRx_1      0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ce MRET_4     fe ILLe       0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          40006033 sloppy or      
 * cf (null)     15 condb_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d0 CSRRW_3    5f LDAF_LHU   0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * d1 aF_SW_3    de Fetch      0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * d2 CSRRW_4    09 LB_5       0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * d3 SH_3       37 ECALL_2    0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d4 ECALL_5    b9 unxb9      0010000000000000101011001100100110        Q = 8                                             00000000 
 * d5 IJ_3          (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * d6 SH_2       fe ILLe       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * d7 IJ_4       c2 unxc2      0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * d8 BLTU       22 unx22      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 IJT_2         (use dinx) 0000000000001100101011101000110000        Read word is to be masked with ~3u                00006067 close to jalr
 * da MRET_5     b7 IJ_3       0010000000000000000011101100010xx0        ~302                                              00000000 
 * db IJT_4      b9 unxb9      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * dc CSRRSI_0   88 unx88      0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd QINT_1     f1 aFaulte    0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * de MRET_2     12 unx12      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * df QINT_2     12 unx12      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * e0 _LCSRRCI_1    (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00007003 close to load
 * e1 (null)     33 JAERR_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 MRET_7        (use dinx) 0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     2e unx2e      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     d1 MRET_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 aFault_2   6e unx6e      0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * e7 (null)     37 ECALL_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 LDAF_a        (use dinx) 0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00007023 close to store
 * e9 (null)     db jFault_1   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea jFault_1      (use dinx) 0000000000001110001011100x00100110        Store 1 to mcause                                 40007023 close to store
 * eb (null)     8e _LCSRRS_1  00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      21 XORI_1     0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee aF_SW_1    fe ILLe       0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      40007033 sloppy and     
 * ef (null)     6e unx6e      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 ORI_1      9d unx9d      0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * f1 aF_SW_2    37 ECALL_2    0010000000000000101011001100100110        Q = 4                                             00000000 
 * f2 IJT_3      70 LHU_2      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * f3 LH_3       ee eILL0a     0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * f4 WFI_2         (use dinx) 0010000000000000101011101100100110        Check offset                                      00000000 
 * f5 SB_3       ea unxea      0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * f6 i0reserv   f4 Fetch2     xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * f7 (null)     ca unxca      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       22 unx22      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     7f JALRE2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     9b unx9b      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   88 unx88      0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      aa unxaa      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       82 unx82      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     dd aF_SW_1    0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0010, used cfff, inputs 99
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       78 unx78      0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       6a unx6a      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     9c unx9c      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     9c unx9c      0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   15 condb_4    0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     7d BAERR_4    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       ca unxca      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     7d BAERR_4    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       62 unx62      0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     9c unx9c      0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      1a ANDI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     9c unx9c      0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 Fetch2     ca unxca      000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 11 jFault     2b SLTIX_1    0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 12 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 13 jFault     22 unx22      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 14 (null)     29 XOR_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 15 LB_5       06 LB_3       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 16 (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 17 JALR_2     60 unx60      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 18 BEQ        21 XORI_1     0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     5d SB_2       0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a SUB_1      9c unx9c      0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 1b _L0x1b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   68 unx68      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d AND_1      9c unx9c      0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 1e JAL_1      8d unx8d      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 1f JAERR_1    a7 EBRKWFI1   0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 20 LH_0       42 unx42      0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 condb_2    9c unx9c      0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 22 condb_3       (use dinx) 0010000000000000001011101100100110        Calculate RS1+~RS2+1                              0000100b close to ij
 * 23 _L0x23     9c unx9c      0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     4b CSRRW_2    0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 eILL0b     39 unx39      0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 27 MRET_8     2e unx2e      0010000000000000101011101100100110        Prep +4                                           00000000 
 * 28 _L0x28     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_4    35 SLLI_1     0010000000000000110011101101001xx0        Branch on condition                               00000000 
 * 2a _L0x2a     66 SW_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b ANDI_1     41 JALR_1     0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 2c SLL_0      57 LH_5       0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     9c unx9c      0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e ORI_2         (use dinx) 0000000000000100001011101000111000        rd = Iimm | RS1                                   40001033 sloppy sll     
 * 2f _L0x2f     9c unx9c      0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 (null)     9c unx9c      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 31 aFault_1   3d SRxI_2     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 32 (null)     62 unx62      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 33 IJ_2       c6 IJT_4      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 34 (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 35 XORI_1     4d unx4d      0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 36 (null)     03 _L0x03     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 37 OR_1       7f JALRE2     0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 38 BNE        21 XORI_1     0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 OR_2          (use dinx) 0010000000000000000011101100100000        Q = rs2                                           00001067 close to jalr
 * 3a XOR_1      55 aFaultb    0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 3b _L0x3b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    73 BAERR_1    0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d SLTIX_1    03 _L0x03     0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 3e LW_1       4b CSRRW_2    0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 3f LDAF_LW    53 LDAF_LH    0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 40 LW_0       3e SLL_1      0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 SLTIX_2    17 condb_5t   0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 42 LH_1          (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 0000200b close to ij
 * 43 LDAF_LH       (use dinx) 0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              0000200f close to fence
 * 44 SLTI_0     3d SRxI_2     0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 SLTX_1     88 unx88      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 46 LH_2       71 aFaultc    0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 47 aFaultb    d9 unxd9      0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 48 _L0x48     58 unx58      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 JAL_3      75 BAlignEr   0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 4a _L0x4a     58 unx58      1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b SLLI_1     85 LBU_1      0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 4c SLT_0      45 WFI_3      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d SLLI_2        (use dinx) 0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 4e LHU_1      fe ILLe       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 40002033 sloppy slt     
 * 4f LDAF_LHU   9c unx9c      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 50 (null)     9c unx9c      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 51 ECALL_2    8f ILL_3      0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 52 (null)     46 ILL_1      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 53 SRxI_1     8f ILL_3      0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 54 (null)     cb QINT_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 55 SRxI_2     31 SLTX_1     0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 56 (null)     7a SB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 57 SLL_1      ca unxca      0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 58 SW_1          (use dinx) 0000000000000011111011100100001xx0        Write d to a+k until accepted                     00002063 close to branch
 * 59 SW_E1SWE      (use dinx) 0000000000001111001011100x00110000        Store faulting address alignment to mtval         00002067 close to jalr
 * 5a SRx_1      82 unx82      0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 5b _L0x5b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    73 BAERR_1    0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d JALR_1     cf MRET_7     0010000000000000000011101100100110        Q=1                                               00000000 
 * 5e LHU_2      5e LHU_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaultc    8f ILL_3      0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 60 BrOpFet       (use dinx) 0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00003003 close to load
 * 61 BAlignEr   db jFault_1   0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 62 JAL_2         (use dinx) 0000000000000100110011000x00100110        Return address to TRG                             0000300b close to ij
 * 63 JALRE1        (use dinx) 0000000000001101110011100x00001xx0  err   Store pc to mepc                                  0000300f close to fence
 * 64 SLTIU_0    3d SRxI_2     0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 WFI_3      9f SH_5       0010000000000000101011101100100110        More check offset                                 00000000 
 * 66 SH_1       be IJ_1       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 67 SW_E1SWH   e0 unxe0      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 68 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00003023 close to store
 * 69 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * 6a IJ_1          (use dinx) 0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   40003023 close to store
 * 6b IJT_1      b9 unxb9      0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 6c SLTU_0     45 WFI_3      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d ILL_1         (use dinx) 0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 6e ECALL_1       (use dinx) 0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40003033 sloppy sltu    
 * 6f MRET_1     8b LB_6       0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 70 (null)     ffffffff (null)     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 71 ILL_2      31 SLTX_1     0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 72 (null)     2b SLTIX_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 73 CSRRW_1    a8 unxa8      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 74 (null)     12 unx12      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 75 CSRRW_2    a6 ECAL_RET   0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 76 (null)     aa unxaa      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 77 LH_4       bd IJ_4       0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 78 LB_2          (use dinx) 0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00003063 close to branch
 * 79 aFaultd       (use dinx) 0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00003067 close to jalr
 * 7a LH_5       be IJ_1       0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 7b _L0x7b     1e aFault_1   0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    73 BAERR_1    0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SB_1       49 CSRRW_1    0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 7e eILL0c     dd aF_SW_1    0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 7f ECALL_3    bd IJ_4       0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 80 LBU_0      c8 unxc8      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 EBREAK_2   bd IJ_4       0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * 82 SB_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   0000400b close to ij
 * 83 MRET_4        (use dinx) 0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          0000400f close to fence
 * 84 XORI_0     35 SLLI_1     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 CSRRW_3    ba LHU_3      0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * 86 EBRKWFI2   49 CSRRW_1    0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 87 aF_SW_3    c2 unxc2      0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * 88 WFI_4         (use dinx) 0010000000000000001011x01001xxxxx0        Prepare read PC                                   00004023 close to store
 * 89 _LCSRRCI_1    (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 8a SB_4          (use dinx) 1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      40004023 close to store
 * 8b MRET_7     9c unx9c      0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * 8c XOR_0      3a SRxI_1     0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d aFault_2      (use dinx) 0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * 8e MRET_6     fe ILLe       0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            40004033 sloppy xor     
 * 8f LDAF_a     fb SB_3       0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * 90 (null)     49 CSRRW_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 91 (null)     df eFetch     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 92 (null)     49 CSRRW_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 (null)     e6 StdIncPc   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 94 (null)     49 CSRRW_1    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 95 (null)     e2 unxe2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 96 (null)     c1 IJT_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 (null)     e0 unxe0      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 98 BLT        21 XORI_1     0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a Fetch      49 CSRRW_1    0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 9b eFetch        (use dinx) 0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 9c StdIncPc      (use dinx) 0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00004073 close to csr/system 
 * 9d aFault        (use dinx) 0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 9e eILL0a     ee eILL0a     0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 9f WFI_5      be IJ_1       0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * a0 LHU_0      4e eILL0b     0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 CSRRW_4    a5 MRET_3     0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * a2 LBU_3         (use dinx) 0010000000000000011011101100010xx0        Invert q. Prepare read mask                       0000500b close to ij
 * a3 SH_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   0000500f close to fence
 * a4 SRxI_0     53 LDAF_LH    0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 ECALL_5    83 unx83      0010000000000000101011001100100110        Q = 8                                             00000000 
 * a6 BAERR_1    6e unx6e      0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * a7 IJ_3       86 JAL_2      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * a8 BAERR_2       (use dinx) 0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00005023 close to store
 * a9 jFault_1   49 CSRRW_1    0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * aa BAERR_3       (use dinx) 0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       40005023 close to store
 * ab aF_SW_1    e8 unxe8      0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * ac _L0xac     5a SB_1       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad ORI_1         (use dinx) 0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * ae _L0xae     5a SB_1       0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af aF_SW_2    c7 QINT_1     0010000000000000101011001100100110        Q = 4                                             00000000 
 * b0 (null)     a1 ECALL_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b1 (null)     df eFetch     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b2 (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b5 (null)     ea unxea      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b6 (null)     e8 unxe8      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b7 (null)     c3 unxc3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * b8 BGE        21 XORI_1     0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 SB_5          (use dinx) 0000000000000010110011100100001xx0        Write d to a+k until accepted                     00005067 close to jalr
 * ba LBU_2      2b SLTIX_1    0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * bb aFaulte    a3 unxa3      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * bc CSRRWI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd BAERR_4    9a ECALL_6    0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * be SW_2       33 JAERR_1    0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * bf aF_SW      c5 MRET_5     0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * c0 NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00006003 close to load
 * c1 SH_2       c9 MRET_2     0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * c2 JALRE2        (use dinx) 0000000000001111101011100x00001xx0        mtval is target                                   0000600b close to ij
 * c3 IJ_4          (use dinx) 0100000010001010110111100100011xx0        Mask and use as PC                                0000600f close to fence
 * c4 ORI_0      ad unxad      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 IJT_2      8e _LCSRRS_1  0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c6 JAERR_2    71 aFaultc    0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * c7 MRET_5     e7 aFault     0010000000000000000011101100010xx0        ~302                                              00000000 
 * c8 LBU_1         (use dinx) 0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00006023 close to store
 * c9 IJT_3      fa WFI_2      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ca LB_6          (use dinx) 0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          40006023 close to store
 * cb LH_3       9c unx9c      0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * cc OR_0       37 ECALL_2    0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd WFI_2         (use dinx) 0010000000000000101011101100100110        Check offset                                      00000000 
 * ce _LCSRRS_1  fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006033 sloppy or      
 * cf SB_3       27 OR_2       0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * d0 (null)     51 LDAF_LW    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 (null)     e5 aF_SW_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 (null)     31 SLTX_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d4 (null)     df eFetch     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     f9 unxf9      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       21 XORI_1     0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 ILL_3         (use dinx) 0010000000000000101011101100100110        Q = 1                                             00006067 close to jalr
 * da WFI_1      de Fetch      0010000000000000000011001100100110 WFI    To check offset                                   00000000 
 * db EBREAK_1   df eFetch     0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * dc CSRRSI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd NMI_2      af MRET_4     0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * de LDAF_2     12 unx12      0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * df LDAF_3     12 unx12      0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * e0 SW_E2         (use dinx) 0000000000001101101111101000001xx0        Store address that faulted                        00007003 close to load
 * e1 IJT_4      2e unx2e      0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * e2 SW_E4         (use dinx) 0000110000001110100111100x00101000        Store 6 to mcause                                 0000700b close to ij
 * e3 QINT_1        (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 0000700f close to fence
 * e4 ANDI_0     2b SLTIX_1    0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 MRET_2     87 JALRE1     0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * e6 SW_E3      9a ECALL_6    0010000000000000101111001100100110        Q = 3                                             00000000 
 * e7 QINT_2     31 SLTX_1     0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * e8 ECALL_6       (use dinx) 0000110000001110100111000x00100000        mcause = 11                                       00007023 close to store
 * e9 i0reserv   e1 ORI_1      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * ea SH_4          (use dinx) 1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      40007023 close to store
 * eb (null)     77 BAERR_3    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      1d ORI_2      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee SH_5       fe ILLe       0000000000000001110011100100001xx0        Write d to a+k until accepted                     40007033 sloppy and     
 * ef (null)     9a ECALL_6    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     a2 unxa2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     31 SLTX_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     9c unx9c      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     ab EBREAK_2   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     a9 ILL_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     cd unxcd      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     81 JAERR_2    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       21 XORI_1     0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 ECALL_4       (use dinx) 0010000000000000101011001100100110        Q = 4                                             00007067 close to jalr
 * fa MRET_3     65 WFI_4      0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * fb ILL_4      8a unx8a      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * fc CSRRCI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      c0 unxc0      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       6d unx6d      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     e3 unxe3      0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 

 * Candidate function 0400, used ffff, inputs a3
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       50 LW_1       0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       46 ILL_1      0010010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     56 LH_4       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     56 LH_4       0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 condb_5    0b JALR_2     0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 07 condb_5t   1a ANDI_1     0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 08 _L0x08     77 BAERR_3    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_3       93 SW_E2      0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 0a _L0x0a     77 BAERR_3    0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b LB_4       36 SLLI_2     0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      21 XORI_1     0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 JAL_1      93 SW_E2      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 11 JAERR_1    39 unx39      0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 12 eILL0b        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 13 MRET_8     2b SLTIX_1    0010000000000000101011101100100110        Prep +4                                           00000000 
 * 14 LW_1       2e unx2e      0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 15 LDAF_LW    06 LB_3       0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 16 LH_1       54 LH_2       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 17 LDAF_LH    34 JAL_3      0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 18 BEQ        29 XOR_1      0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     6f MRET_6     0000000000001000101011101000100000 JALR   jj=RS1+imm                                        00000067 jalr    
 * 1a LB_5       56 LH_4       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 1b _L0x1b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   42 unx42      0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d JALR_2     56 LH_4       0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 1e LH_2       bf IJT_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 1f aFaultb    b2 CSRRW_4    0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 20 LH_0       16 condb_5    0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 SUB_1      56 LH_4       0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 22 AND_1         (use dinx) 0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               0000100b close to ij
 * 23 _L0x23     56 LH_4       0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     67 SW_E1SWE   0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 LHU_1      4b CSRRW_2    0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 27 LDAF_LHU   3a SRxI_1     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 28 _L0x28     3e SLL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 condb_2    45 WFI_3      0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 2a _L0x2a     3e SLL_1      0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b condb_3    5d SB_2       0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 2c SLL_0      6d unx6d      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e condb_4       (use dinx) 0010000000000000110011101101001xx0        Branch on condition                               40001033 sloppy sll     
 * 2f _L0x2f     56 LH_4       0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SW_1       56 LH_4       0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 31 SW_E1SWE   5a SB_1       0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 32 LHU_2      36 SLLI_2     0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 33 aFaultc    90 NMI_2      0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 34 BrOpFet    54 LH_2       0011001010000000101111101010001xx0 NewOp2 Read until instruction latched                    00000000 
 * 35 BAlignEr   68 unx68      0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 36 JAL_2      03 _L0x03     0000000000000100110011000x00100110        Return address to TRG                             00000000 
 * 37 JALRE1     53 LDAF_LH    0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 38 BNE        29 XOR_1      0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 ANDI_1        (use dinx) 0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00001067 close to jalr
 * 3a ORI_2      6b SB_4       0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 3b _L0x3b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    73 BAERR_1    0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d aFault_1   03 _L0x03     0010000000000000101011001100100110        Q = 4                                             00000000 
 * 3e SH_1       67 SW_E1SWE   0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 3f SW_E1SWH   6a unx6a      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 40 LW_0       14 condb_3    0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 IJ_2       1d ORI_2      0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 42 ECAL_RET      (use dinx) 0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              0000200b close to ij
 * 43 EBRKWFI1      (use dinx) 0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 0000200f close to fence
 * 44 SLTI_0     5a SB_1       0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 XORI_1     7a SB_5       0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 46 IJ_1       72 LBU_3      0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * 47 IJT_1      95 SW_E3      0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * 48 _L0x48     30 SLTIX_2    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 OR_1       74 BrOpFet    0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 4a _L0x4a     30 SLTIX_2    1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b OR_2       ab EBREAK_2   0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 4c SLT_0      65 WFI_4      0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d XOR_1         (use dinx) 0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 4e ECALL_1    fe ILLe       0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 40002033 sloppy slt     
 * 4f MRET_1     56 LH_4       0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * 50 LB_2       56 LH_4       0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * 51 aFaultd    c0 unxc0      0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * 52 eILL0c     1e aFault_1   0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 53 ECALL_3    c0 unxc0      0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * 54 Fetch      c9 MRET_2     0000000000001000001111101010110000  Fr00  Read and latch instruction                        00000000 
 * 55 eFetch     3d SRxI_2     0001001010001000101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * 56 StdIncPc   76 BAERR_2    0100000010001010110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * 57 aFault     93 SW_E2      0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * 58 eILL0a        (use dinx) 0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00002063 close to branch
 * 59 WFI_5         (use dinx) 0100000010001010110111000100100110        IncPC, OpFetch                                    00002067 close to jalr
 * 5a SLTIX_1    78 unx78      0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 5b _L0x5b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    73 BAERR_1    0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SLTIX_2    cd unxcd      0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 5e LBU_2      32 JAL_1      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 5f aFaulte    c0 unxc0      0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * 60 SW_2          (use dinx) 0010000000000000001011x01000xxxxx0        Prepare read PC                                   00003003 close to load
 * 61 aF_SW      63 unx63      0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * 62 WFI_1         (use dinx) 0010000000000000000011001100100110 WFI    To check offset                                   0000300b close to ij
 * 63 EBREAK_1      (use dinx) 0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       0000300f close to fence
 * 64 SLTIU_0    5a SB_1       0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 SLTX_1     59 unx59      0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 66 JAL_3      60 unx60      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 67 SLLI_1     9d unx9d      0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 68 SLLI_2        (use dinx) 0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00003023 close to store
 * 69 ECALL_2       (use dinx) 0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 6a SRxI_1        (use dinx) 0000000000000100101001101100001xx1        Register to shift to Q                            40003023 close to store
 * 6b SRxI_2     89 unx89      0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 6c SLTU_0     65 WFI_4      0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d SLL_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 6e SRx_1         (use dinx) 0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  40003033 sloppy sltu    
 * 6f JALR_1     be IJ_1       0010000000000000000011101100100110        Q=1                                               00000000 
 * 70 WFI_3      ffffffff (null)     0010000000000000101011101100100110        More check offset                                 00000000 
 * 71 ILL_1      3d SRxI_2     0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 72 ILL_2      39 unx39      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 73 CSRRW_1    85 LBU_1      0010000000000000000011101100100110        Construct PC storage adr                          00000000 
 * 74 CSRRW_2    86 JAL_2      0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 75 LH_4       81 JAERR_2    0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 76 LH_5       88 unx88      0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 77 SB_1       8b LB_6       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 78 SB_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00003063 close to branch
 * 79 EBRKWFI2      (use dinx) 0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00003067 close to jalr
 * 7a WFI_4      60 unx60      0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 7b _L0x7b     10 SUB_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    73 BAERR_1    0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d SB_4       66 SW_1       1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 7e MRET_6     97 SW_E1SWH   0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 7f LBU_3      8b LB_6       0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 80 LBU_0      91 LDAF_2     0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 BAERR_1    8b LB_6       0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 82 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     0000400b close to ij
 * 83 jFault        (use dinx) 0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         0000400f close to fence
 * 84 XORI_0     45 WFI_3      0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 BAERR_2    5e LHU_1      0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 86 Fetch2     66 SW_1       000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * 87 jFault     8f ILL_3      0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * 88 BAERR_3       (use dinx) 0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00004023 close to store
 * 89 SB_5          (use dinx) 0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 8a (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40004023 close to store
 * 8b BAERR_4    56 LH_4       0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 8c XOR_0      4d unx4d      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d NMI_1         (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 8e (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40004033 sloppy xor     
 * 8f JALRE2     a8 unxa8      0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * 90 JAERR_2    66 SW_1       0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 91 LBU_1      9c unx9c      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 92 (null)     66 SW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 93 LB_6       a1 ECALL_4    0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 94 _LCSRRS_1  66 SW_1       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * 95 ILL_3      9f SH_5       0010000000000000101011101100100110        Q = 1                                             00000000 
 * 96 (null)     b3 unxb3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 97 NMI_2      9d unx9d      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 98 BLT        29 XOR_1      0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen (at illegal entrypt)            00004067 close to jalr
 * 9a (null)     66 SW_1       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 9b LDAF_2        (use dinx) 0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 9c LDAF_3        (use dinx) 0000000000001101100111100x00001xx0        PC to mepc                                        00004073 close to csr/system 
 * 9d SW_E2         (use dinx) 0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 9e (null)     a5 MRET_3     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * 9f SW_E4      60 unx60      0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * a0 LHU_0      26 OR_1       0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 SW_E3      b1 aF_SW_3    0010000000000000101111001100100110        Q = 3                                             00000000 
 * a2 ECALL_6       (use dinx) 0000110000001110100111000x00100000        mcause = 11                                       0000500b close to ij
 * a3 SH_4          (use dinx) 1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      0000500f close to fence
 * a4 SRxI_0     6a unx6a      0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 SH_5       aa unxaa      0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * a6 ECALL_4    4e eILL0b     0010000000000000101011001100100110        Q = 4                                             00000000 
 * a7 MRET_3     79 unx79      0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * a8 ILL_4         (use dinx) 0000110000001110100111100x00100110        Store 2 to mcause                                 00005023 close to store
 * a9 EBREAK_2   66 SW_1       0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * aa MRET_4        (use dinx) 0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          40005023 close to store
 * ab CSRRW_3    a2 unxa2      0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * ac _L0xac     6e unx6e      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad aF_SW_3       (use dinx) 0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * ae _L0xae     6e unx6e      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af CSRRW_4    b6 ECALL_5    0100000010001010110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b0 SH_3       af MRET_4     0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b1 ECALL_5    9c unx9c      0010000000000000101011001100100110        Q = 8                                             00000000 
 * b2 IJ_3       54 LH_2       0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b3 SH_2          (use dinx) 0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * b4 IJ_4          (use dinx) 0100000010001010110111100100011xx0        Mask and use as PC                                00000000 
 * b5 IJT_2      a3 unxa3      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * b6 MRET_5     a2 unxa2      0010000000000000000011101100010xx0        ~302                                              00000000 
 * b7 IJT_4      b4 i0reserv   0100000000001101110111101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * b8 BGE        29 XOR_1      0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 QINT_1        (use dinx) 0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00005067 close to jalr
 * ba MRET_2     39 unx39      0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * bb QINT_2     b0 CSRRW_3    0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * bc CSRRWI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd _LCSRRCI_1 54 LH_2       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * be MRET_7     41 JALR_1     0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * bf aFault_2   b5 SH_3       0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * c0 LDAF_a        (use dinx) 0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00006003 close to load
 * c1 jFault_1   c8 unxc8      0000000000001110001011100x00100110        Store 1 to mcause                                 00000000 
 * c2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000600b close to ij
 * c3 aF_SW_1       (use dinx) 0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      0000600f close to fence
 * c4 ORI_0      c5 MRET_5     0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 ORI_1      7e NMI_1      0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * c6 (null)     72 LBU_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * c7 aF_SW_2    bb SH_2       0010000000000000101011001100100110        Q = 4                                             00000000 
 * c8 IJT_3         (use dinx) 0010000000000000110011001100100000        Construct Q = 3                                   00006023 close to store
 * c9 LH_3       a7 EBRKWFI1   0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * ca (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40006023 close to store
 * cb WFI_2      56 LH_4       0010000000000000101011101100100110        Check offset                                      00000000 
 * cc OR_0       49 CSRRW_1    0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd SB_3          (use dinx) 0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * ce (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40006033 sloppy or      
 * cf i0reserv   13 condb_2    xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * d0 (null)     69 unx69      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d1 (null)     ba LHU_3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d2 (null)     09 LB_5       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d3 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d4 (null)     9c unx9c      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d5 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d6 (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d7 (null)     a6 ECAL_RET   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * d8 BLTU       29 XOR_1      0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00006067 close to jalr
 * da (null)     9b unx9b      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * db (null)     9c unx9c      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * dc CSRRSI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd (null)     c7 QINT_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * de (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * df (null)     86 JAL_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e0 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007003 close to load
 * e1 (null)     3a SRxI_1     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e2 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700b close to ij
 * e3 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   0000700f close to fence
 * e4 ANDI_0     39 unx39      0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 (null)     ad unxad      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e6 (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e7 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * e8 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007023 close to store
 * e9 (null)     b7 IJ_3       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ea (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007023 close to store
 * eb (null)     75 BAlignEr   00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ec AND_0      22 unx22      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * ee (null)     fe ILLe       00x000000000000000xxxx00x00xx000xx QINT_0                                                   40007033 sloppy and     
 * ef (null)     54 LH_2       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f0 (null)     7f JALRE2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f1 (null)     3d SRxI_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f2 (null)     56 LH_4       00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f3 (null)     c3 unxc3      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f4 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f5 (null)     c1 IJT_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f6 (null)     cb QINT_2     00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f7 (null)     a9 ILL_4      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * f8 BGEU       29 XOR_1      0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 (null)        (use dinx) 00x000000000000000xxxx00x00xx000xx QINT_0                                                   00007067 close to jalr
 * fa (null)     70 LHU_2      00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fb (null)     7d BAERR_4    00x000000000000000xxxx00x00xx000xx QINT_0                                                   00000000 
 * fc CSRRCI_0   73 BAERR_1    0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      8d unx8d      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       71 aFaultc    0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     b9 unxb9      0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 
 *  17 2169 6463 2376 Can not simplify, can't represent fixed locations with any less than 7 bits of the index
 *  16 1512 4378 5118 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  15  93 133 10782 Can not simplify, no legal mapping
 *  14 2169 215 8624 Can not simplify, no legal mapping
 *  13 3373 4699 2936 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  12 1297 2874 6837 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  11 1297 2290 7421 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *  10 4233 1290 5485 Can not simplify, no legal mapping
 *   9 6309 1333 3366 Can not simplify, no legal mapping
 *   8 2169 433 8406 Can not simplify, no legal mapping
 *   7 2169 4300 4539 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *   6  93 6379 4536 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *   5 2169 4441 4398 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *   4 2169 5371 3468 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *   3  93 3601 7314 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *   2  93 6993 3922 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *   1  93 7792 3123 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 *   0  93 6095 4820 Can not simplify, can't represent fixed locations with any less than 8 bits of the index
 */
localparam u0_0 = 256'h30e6001030e608041886205a008b205a18091007000420e600e620be09d22001;
localparam u0_1 = 256'h30b726d438e630a6303218e620413013207436de4816261500140000001a008b;
localparam u0_2 = 256'h30e6000030e6003e2630209600212096201d00270004303500e6000000e62052;
localparam u0_3 = 256'h083a0835090330493032093d0000301348d72803083608de20812086002b32e6;
localparam u0_4 = 256'h26e600fe0000003108b02066264b2066088f08472665102b00000000260b2050;
localparam u0_5 = 256'h30da097028fb30493032085d00000000008b1857301e09eb30da095430da08e6;
localparam u0_6 = 256'h26cf000000000031087a000000000000309308f240ef102b0000000050f70000;
localparam u0_7 = 256'h087d089008343049303208f200000000267d0077007388f40876101a301e09ba;
localparam u0_8 = 256'h26a900fe0000002926e6000000000000087f263409f0102100000000087d2085;
localparam u0_9 = 256'h08f2089f000000000000203400fe3013309308bb269428340895083426923034;
localparam u0_A = 256'h26c5003f0000003f089a000026340000206130d026af303a0000000026b6205e;
localparam u0_B = 256'h08c1081f18de304928b5101a0000301320bd269a309e0000000026de209226b2;
localparam u0_C = 256'h404f00fe0000002630e6000020a5000008cb1847106f10e10000000030e90000;
localparam u0_D = 256'hb0f4b0f430e53049269200910000301330a100fe00002692301e090630c92637;
localparam u0_E = 256'h26de00fe000000111056000020c60000301e26de26b1101a00000000081d0000;
localparam u0_F = 256'h00c70046007e3049306b26450000301330ab26fa30db200000dd00e6301e0972;
localparam u1_0 = 256'h10ba03b210ba03bbb0ba23ab017b23ab017b01bb00b110ba00b2837b02fb036b;
localparam u1_1 = 256'h32ba02b310ba82f980b910ba22ba33baab7b2b71033b00bb03fb000003bb03fb;
localparam u1_2 = 256'h10ba000010ba03b0003aa3ab03bba3ab003b23ba00b103c800b2000010bab36b;
localparam u1_3 = 256'h03c803c8129b31ba80b9129b000033ba343a12db12db2b793cb830ba03fb10ba;
localparam u1_4 = 256'h02bb0030000003b20eb983bb003b83bb3eba36b802bb03fb00000000003b837b;
localparam u1_5 = 256'h3eb902fb32db31ba80b932db00000000023b023b3eba029b3eb902fb3eb912fa;
localparam u1_6 = 256'h003b0000000003b20b3b0000000000003cb80fb900b203fb0000000021ba0000;
localparam u1_7 = 256'h3eb8343a3a7831ba80b90b390000000036b800bb00b002fa3f3a01bb3eba029b;
localparam u1_8 = 256'h02bb0030000003f210ba0000000000003738133002fb03fb0000000036b8036b;
localparam u1_9 = 256'h0739073b0000000000003a70003033ba3cb832db02f33a7836fa367838b03d3a;
localparam u1_A = 256'h003b03b0000003b036ba00003a780000003b82f901bb03c80000000002b3b36b;
localparam u1_B = 256'h02fb02fb2b7931ba32db01fb000033ba033302b3003a000000002b7138b002b3;
localparam u1_C = 256'h01b20030000003f23d3a000001b30000343a377b003b23fa0000000032ba0000;
localparam u1_D = 256'h22fa20fa3eba31ba38b802b2000033ba3eba0030000038b83eba029b21ba00bb;
localparam u1_E = 256'h2b710030000003f201fb0000033300003eba2b7102b303fb00000000003b0000;
localparam u1_F = 256'h00b200b000b231ba003a02bb000033ba3cba00333eba6fff003100b23eba029b;
localparam u2_0 = 256'h00000080000000800001040000800400008000800080040000800490008a0580;
localparam u2_1 = 256'h00000c8000000080008100000400000005010102008004800080000000800080;
localparam u2_2 = 256'h0000000000000080048004000080040004800000008000800080000000000500;
localparam u2_3 = 256'h0080008000040000008100000000000000000004000001020400040000800000;
localparam u2_4 = 256'h0480008000000080002007810480078100000000048000800000000004800581;
localparam u2_5 = 256'h0000008a00040000008100000000000000800080000000840000008a00000042;
localparam u2_6 = 256'h0480000000000080038000000000000000000000008000800000000000000000;
localparam u2_7 = 256'h0000000000300000008100000000000004000080008000ca0000008000000084;
localparam u2_8 = 256'h00800080000000800c0000000000000000002c00008a00800000000000000580;
localparam u2_9 = 256'h00000380000000000000043000800000000000000c800030000000000c300030;
localparam u2_A = 256'h048000800000008000000000043000000480008104800080000000000c800500;
localparam u2_B = 256'h0082008201020000000400800000000004800c800080000000000d0204300c80;
localparam u2_C = 256'h0080008000000080003000000480000000000100008000000000000000000000;
localparam u2_D = 256'h004a000000000000040000800000000000000080000004300000008400000480;
localparam u2_E = 256'h0d02008000000080008000000480000000000d020c8000800000000000800000;
localparam u2_F = 256'h0080008000800000008004800000000000000c80000004000080008000000084;
