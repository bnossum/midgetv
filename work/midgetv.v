/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2020-2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * ----------------------------------------------------------------------------
 
   
   Simplified datapath                                                                            
   ======================
                                                               +------------- shcy[4] 
 Data input                                                    |                  
 DAT_I[31:0] --------------|\   ___  rDee                     /y\                 
      _______________      | |-|   |-+                        :::  __   ___       
     |SRAM ..x32     | +---|/  |   | |                   +----(((-|  | >   |  rshiftcnt[4:0]
     |===============| |       >___| |                   |   -((+-|  |-|   |-+    
     | DATAOUT[31:0] |-+             |                   |  +-+(--|  | |CE | |    
 +---|DATAIN[31:0]   |               |                   |  |  +--|__| |R__| |    
 | +-|ADR[14:0]      |               |                   |  |  |             |    
 | | | 64 or 128 KiB |               |                   |  |  0             |    
 | | >_______________|               |                   |  +----------------+    
 | |                                 |                   |                       
 | |  +------------------------------+        _______    |       
 | |  |                ___                   |Immed- |   |                        
 | |  |            +--|D Q|------------------|iate   |---(-+          +------ is_bcond 
 | |  |            |  |   |  6- 0 OPCODE     |expand |   | |          |           
 | |  |            |  |   | 11- 7 TRG        |_______|   | |      __  |  __ 
 | |  |            |  |   | 14-12 FUNC3   +--------------(-)-----|  |-+-|  |- raluF 
 | |  |            |  |   | 19-15 SRC1    |              | |  +--|__|   >__|      
 | |  |            |  |CE | 24-20 SRC2    | fC           | |  | fZ                
 | |  |            |  >___| 31-25 FUNC7  /y\             | | /y\                  
 | |  |rDee        |   ___________       :::  _______    | | :::  __     ___      
 | |  +------|\ Di | -| Di        | A   -(((-|~(A^QQ)| B | +-(((-|  | F >   |     I/O address
 | +-ADR_O/2-| |---+--| ~(Di^Q)   |------((+-|A^QQ^ci|-+-+---((+-|  |---|D Q|-+-- ADR_O[31:0] 
 +-(---------|/   +---| (~Di)&(~Q)|    +-+(--|       | |    -+(--|  |   |CE | |   
 | | DAT_O        |  -|_0_________|    |  +--|_______| |    --+--|__|   |R__| |   
 | |              |                    |  |ci          |      |       .       |   
 | +--------------+--------------|\ QQ |  |            |      0               |   
 | |    __      __               | |---+  |            |      Format expand   |   
 | | +-|+1|----| Q|-+- ccnt[5:0]-|/       0/1/raluF    |      and zero-find   |   
 | | | |__|    >__| |                                  |                      |   
 | | +--------------+                                  |                      |
 | |                                                   |                      |
 | +---------------------------------------------------(----------------------+
 |                                                     |                    
 +-----------------------------------------------------(-------------------+
                                                       |    ____________   |                
      jj        --|0000\                               |   |EBR ..x32   |  |                
      rinst     --|0001 |                              |   |============|  |      data output                 
      pc        --|0010 |                      B[31:0] |   | RDATA[31:0]|--+----- DAT_O[31:0]                 
      ttime     --|0011 | Rai                          +---|WDATA[31:0] |                      
      rInternISR--|0100 |----------------------------------|RADR[h-2:0] |                      
      rFFFFFF7F --|0101 |   ADR_O[h:2]-|00xx\  Wai         |            |                      
      r000000FF --|0110 |   TRG[4:0] --|01xx |-------------|WADR[h-2:0] |                      
      r0000FFFF --|0111 |   jj       --|1000 |             |            |
      rFFFF7FFF --|1000 |   rinst    --|1001 |             | 1, 2, 4    |                         
      mtvec     --|1001 |   pc       --|1010 |             > or 8 KiB   |                              
      r00000000 --|1010 |   ttime    --|1011 |             >____________|                              
      rFFFFFFFF --|1011 |   yy       --|1100 |                                         
      yy        --|1100 |   mecp     --|1101 |                                         
      B[h:2]   ---|1101 |   mcause   --|1110 |                                         
      SRC2[4:0] --|1110 |   mtval    --|1111/                                          
      SRC1[4:0] --|1111/                                                              

 
 
   midgetv as a component
   ======================
   
   
                       +----------------+
                CLK_I ->                |- WE_O
                RST_I -|                |- STB_O
                start -|    midgetv     |- CYC_O
                       |                |- SEL_O[3:0] 
                 meip -|                |- ADR_O[31:0]
                ACK_I -|                |- DAT_O[31:0]
    DAT_I[IWIDTH-1:0] -|                |
                       |                |- corerunning
                       |                |- dbga[31:0]
                       +----------------+

   Simplified datapath when MUL/DIV                                                                           
   ================================
 
Data input               __                                      +------------- shcy[4]           
DAT_I[31:0] ------------|or|-|\   ___  rDee                      |                                
+-----------------------|__| | |-|   |-+                        /y\                               
|       _______________  +---|/  |   | |                        :::  __   ___                     
|      |SRAM ..x32     | |       >___| |                   +----(((-|  | >   |  rshiftcnt[4:0]    
|      |===============| |             |                   |   -((+-|  |-|   |-+                  
|      | DATAOUT[31:0] |-+             |                   |  +-+(--|  | |CE | |                  
|  +---|DATAIN[31:0]   |               |                   |  |  +--|__| |R__| |                  
|  | +-|ADR[14:0]      |               |                   |  |  |             |                  
|  | | | 64 or 128 KiB |               |                   |  |  0             |                  
|  | | >_______________|               |                   |  +----------------+                  
|  | |                                 |                   |                                      
|  | |  +------------------------------+        _______    |                                      
|  | |  |                ___                   |Immed- |   |                                      
|  | |  |            +--|D Q|------------------|iate   |---(-+          +------ is_bcond          
|  | |  |            |  |   |  6- 0 OPCODE     |expand |   | |          |                         
|  | |  |            |  |   | 11- 7 TRG        |_______|   | |      __  |  __                     
|  | |  |            |  |   | 14-12 FUNC3   +--------------(-)-----|  |-+-|  |- raluF             
|  | |  |            |  |   | 19-15 SRC1    |              | |  +--|__|   >__|                    
|  | |  |            |  |CE | 24-20 SRC2    | fC           | |  | fZ                              
|  | |  |            |  >___| 31-25 FUNC7  /y\             | | /y\                                
|  | |  |rDee        |   ___________       :::  _______    | | :::  __     ___                    
|  | |  +------|\ Di | -| Di        | A   -(((-|~(A^QQ)| B | +-(((-|  | F >   |     I/O address   
|  | +-ADR_Od2-| |---+--| ~(Di^Q)   |------((+-|A^QQ^ci|-+-+---((+-|  |---|D Q|-+-- ADR_O[31:0]   
|  +-(---------|/   +---| (~Di)&(~Q)|    +-+(--|       | |    -+(--|  |   |CE | |                 
|  | | DAT_O        |  -|_0_________|    |  +--|_______| |    --+--|__|   |R__| |                 
|  | |              |                    |  |ci          |      |       .       |                 
|  | +--------------+--------------|\ QQ |  |            |      0               |                 
|  | |    __      __               | |---+  |            |      zero-           |                 
|  | | +-|+1|----| Q|-+- ccnt[5:0]-|/       0/1/raluF    |      find            |                 
|  | | | |__|    >__| |                                  |                      |                 
|  | | +--------------+                                  |                      |                 
|  | |                                                   |                      |                 
|  | +---------------------------------------------------(----------------------+                 
|  |                                                     |                                        
|  +-----------------------------------------------------(--------------------+                   
|                                                        |    ____________    |                   
|       jj        --|0000\                               |   |EBR ..x32   |   |                   
|       rinst     --|0001 |                              |   |============|   |     data output   
|       pc        --|0010 |                      B[31:0] |   | RDATA[31:0]|-+-+---- DAT_O[31:0]   
|       ttime     --|0011 | Rai                          +---|WDATA[31:0] | |                     
|       rInternISR--|0100 |----------------------------------|RADR[h-2:0] | |                     
|       rFFFFFF7F --|0101 |   ADR_O[h:2]-|00xx\  Wai         |            | |            ________ 
|       r000000FF --|0110 |   TRG[4:0] --|01xx |-------------|WADR[h-2:0] | +-- DAT_O --|Mul/Div |
|       r0000FFFF --|0111 |   jj       --|1000 |             |            |     A>>1  --|Logic   |-+
|       rFFFF7FFF --|1000 |   rinst    --|1001 |             | 1, 2, 4    |     A<<1  --|and     | |
|       mtvec     --|1001 |   pc       --|1010 |             > or 8 KiB   |     raluF --|Register| |
|       r00000000 --|1010 |   ttime    --|1011 |             >____________|  ADR_O[0] --|________| |
|       rFFFFFFFF --|1011 |   yy       --|1100 |                                                   |
|       yy        --|1100 |   mecp     --|1101 |                                                   |
|       B[h:2]   ---|1101 |   mcause   --|1110 |                                                   |
|       SRC2[4:0] --|1110 |   mtval    --|1111/                                                    |
|       SRC1[4:0] --|1111/                                                                         |
+--------------------------------------------------------------------------------------------------+
 
 ADR_Od2 
 ------------------------
 {1'b0,      ADR_O[31:1]} when SRL(I)
 {ADR_O[31], ADR_O[31:1]} when SRA(I) and ucodeMULH
 {~raluF,    ADR_O[31:1]} when ucodeMULHU
 
       

   Simplified datapath when MUL/DIV and compressed instructions                                                                           
   ============================================================
 
Data input               __                                      +------------- shcy[4]           
DAT_I[31:0] ------------|or|-|\   ___  rDee                      |                                
+-----------------------|__| | |-|   |-+                        /y\                               
|       _______________  +---|/  |   | |                        :::  __   ___                     
|      |SRAM ..x32     | |       >___| |                   +----(((-|  | >   |  rshiftcnt[4:0]    
|      |===============| |             |                   |   -((+-|  |-|   |-+                  
|      | DATAOUT[31:0] |-+             |                   |  +-+(--|  | |CE | |                  
|  +---|DATAIN[31:0]   |               |                   |  |  +--|__| |R__| |                  
|  | +-|ADR[14:0]      |               |                   |  |  |             |                  
|  | | | 64 or 128 KiB |               |                   |  |  0             |                  
|  | | >_______________|               |                   |  +----------------+                  
|  | |                                 |                   |                                      
|  | |  +------------------------------+        _______    |                                      
|  | |  |                ___                   |Immed- |   |                                      
|  | |  |               |  Q|------------------|iate   |---(-+          +------ is_bcond          
|  | |  |               |   |  6- 0 OPCODE     |expand |   | |          |                         
|  | |  |   __________  |   | 11- 7 TRG        |_______|   | |      __  |  __                     
|  | |  |  | RVC De-  |-|D  | 14-12 FUNC3   +--------------(-)-----|  |-+-|  |- raluF             
|  | |  |  | compress | |   | 19-15 SRC1    |              | |  +--|__|   >__|                    
|  | |  |  |__________| |CE | 24-20 SRC2    | fC           | |  | fZ                              
|  | |  |           |   >___| 31-25 FUNC7  /y\             | | /y\                                
|  | |  |rDee       |    ___________       :::  _______    | | :::  __     ___                    
|  | |  +------|\ Di|  -| Di        | A   -(((-|~(A^QQ)| B | +-(((-|  | F >   |     I/O address   
|  | +-ADR_Od2-| |--+---| ~(Di^Q)   |------((+-|A^QQ^ci|-+-+---((+-|  |---|D Q|-+-- ADR_O[31:0]   
|  +-(---------|/    +--| (~Di)&(~Q)|    +-+(--|       | |    -+(--|  |   |CE | |                 
|  | | DAT_O         | -|_0_________|    |  +--|_______| |    --+--|__|   |R__| |                 
|  | |               |                   |  |ci          |      |       .       |                 
|  | +---------------+-------------|\ QQ |  |            |      0               |                 
|  | |    __      __               | |---+  |            |      zero-           |                 
|  | | +-|+1|----| Q|-+- ccnt[5:0]-|/       0/1/raluF    |      find            |                 
|  | | | |__|    >__| |                                  |                      |                 
|  | | +--------------+                                  |                      |                 
|  | |                                                   |                      |                 
|  | +---------------------------------------------------(----------------------+                 
|  |                                                     |                                        
|  +-----------------------------------------------------(--------------------+                   
|                                                        |    ____________    |                   
|       jj        --|0000\                               |   |EBR ..x32   |   |                   
|       rinst     --|0001 |                              |   |============|   |     data output   
|       pc        --|0010 |                      B[31:0] |   | RDATA[31:0]|-+-+---- DAT_O[31:0]   
|       ttime     --|0011 | Rai                          +---|WDATA[31:0] | |                     
|       rInternISR--|0100 |----------------------------------|RADR[h-2:0] | |                     
|       rFFFFFF7F --|0101 |   ADR_O[h:2]-|00xx\  Wai         |            | |            ________ 
|       r000000FF --|0110 |   TRG[4:0] --|01xx |-------------|WADR[h-2:0] | +-- DAT_O --|Mul/Div |
|       r0000FFFF --|0111 |   jj       --|1000 |             |            |     A>>1  --|Logic   |-+
|       rFFFF7FFF --|1000 |   rinst    --|1001 |             | 1, 2, 4    |     A<<1  --|and     | |
|       mtvec     --|1001 |   pc       --|1010 |             > or 8 KiB   |     raluF --|Register| |
|       r00000000 --|1010 |   ttime    --|1011 |             >____________|  ADR_O[0] --|________| |
|       rFFFFFFFF --|1011 |   yy       --|1100 |                                                   |
|       yy        --|1100 |   mecp     --|1101 |                                                   |
|       B[h:2]   ---|1101 |   mcause   --|1110 |                                                   |
|       SRC2[4:0] --|1110 |   mtval    --|1111/                                                    |
|       SRC1[4:0] --|1111/                                                                         |
+--------------------------------------------------------------------------------------------------+
 
 ADR_Od2 
 ------------------------
 {1'b0,      ADR_O[31:1]} when SRL(I)
 {ADR_O[31], ADR_O[31:1]} when SRA(I) and ucodeMULH
 {~raluF,    ADR_O[31:1]} when ucodeMULHU
 
       
 * ----------------------------------------------------------------------------
 * m_midgetv_core signal description
 * =================================
 * 
 * Wishbone signals are implemented as per Wishbone specification b4,
 * see Wishbone B.4 data sheet for m_midgetv_core below.
 * 
 * input:RST_I. 
 * RST_I is a mandatory Wishbone input. On the core it acts like a NMI.
 *
 * Even though the granularity of the Wishbone interface is 8-bit, all
 * read operations happen as 32-bit operations. SEL_O == 4'b1111.
 * Selection of (signed/unsigned) byte and (signed/unsigned) hword is
 * done internally in midgetv. For write operations, the granularity
 * is 8-bit, and the SEL_O[3:0] signals have meaning. 
 * 
 * input:start
 * ------------------  
 * From power-on reset, it may be adventageous to delay startup of
 * midgetv until clocks are stable, etc. The start input signal is
 * included for this purpose. If midgetv does not include any cycle 
 * counter, this signal determines if the core is to be started.
 * If a cycle counter is implemented, start must be high for 128
 * consequtive cycles before midgetv is started. 
 * 
 * Once midgetv is started, the signal start has a different meaning:
 *  o If midgetv has no cycle counter, 'start' enable/disable an
 *    retired instruction counter.
 *  o If midgetv has a cycle counter, 'start' enable/disable the
 *    cycle counter.
 * It is suggested that once 'start' is set high, it should remain high.
 * 
 * midgetv does not have any hardware reset input. This is because
 * the state of midgetv resides in initialized EBR. Once midgetv is
 * started the only way to get back to initial state is a power cycle.
 * 
 * input:meip
 * ----------
 * This is the machine external interrupt pending signal. It should be
 * valid in the CLK_I clock domain.
 * 
 * output:dbga[31:0]
 * -----------------
 * A catchall hardware debugging aid. When not debugging dbga == 32'h0.
 * My intention is that by leaving this vector as is, different 
 * information may be emitted from the core without breaking programs 
 * that use the core allready.
 * 
 * output:midgetv_core_killwarnings
 * --------------------------------
 * This is a dummy output to remove warnings from different tools.
 * Do not connect.
 * 
 * Parameter description
 * =====================
 * 
 * SRAMADRWIDTH
 * ------------
 * Determines the amount of SRAM in midgetv. 
 * See m_ram.v for details.
 * 
 * IWIDTH
 * ------
 * Determines the width of external input to midgetv. To be
 * compliant with Wishbone, IWIDTH should be 8, 16 or 32.
 * When interrupts are included, IWIDTH should be 32.
 * Legal values: From 1 to 32.
 * 
 * NO_CYCLECNT
 * -----------
 * 0 : Cycle counter available
 * 1 : No cycle counter.
 * 
 * Normally midgetv support a 32-bit cycle counter (the low 32 bits of
 * mcycle). To save 11 LUTs, it can be suppressed. If suppressed, one
 * still have a 32 bit counter, that works as a retired instruction
 * counter. Legal values: 0 or 1.
 * 
 * MTIMETAP
 * -------
 * This is for mtime and control registers.
 * When MTIMETAP >= MTIMETAP_LOWLIM, the cycle counter give an 
 * interrupt after (1<<MTIMETAP) cycles. This interrupt is used to 
 * increment {mtimeh,mtime}. 
 * When MTIMETAP >= MTIMETAP_LOWLIM, we also enable interrupt 
 * support and registers mstatus,mie,mip as per the riscv
 * specification. Legal values: 0, MTIMETAP_LOWLIM to 31.
 * 
 * HIGHLEVEL
 * ---------
 * 0 : Use iCE primitives. Recommended
 * 1 : Use RTL synthesis
 * 
 * Most of the code for midgetv exists in "highlevel" RTL code, but also
 * in a version where iCE40 native building blocks (SB_LUT4, SB_DFF,
 * etc) are instantiated. For many of the modules the difference is
 * slight, but some modules (for example m_immexp_zfind_q) have a huge
 * difference in size.
 *  
 * DAT_I_ZERO_WHEN_INACTIVE
 * ------------------------
 * Wishbone B.3 does not mandate any default value for
 * DAT_O[] of connected devices when these are not active.
 * Indeed, for most examples in Wishbone B.3, DAT_O[] hold
 * some value when not active. However, with a suitable
 * SYSCON unit, we may easily have that the mux of all DAT_O[]
 * from devices (used as DAT_I[] to this module) is indeed 0
 * when inactive. If so is the case, we may save 32 SB_LUTs
 * in the input mux in some cases.
 *
 * 0: DAT_I[] unknown when not active
 * 1: DAT_I[] == 0 when not active. 
 * 
 * EBRADRWIDTH
 * -----------
 * Determines the size of EBR in midgetv. Legal values:
 *  8    1 kiB EBR 
 *  9    2 kiB EBR
 * 10    4 kiB EBR
 * 11    8 kiB EBR
 * See m_ebr.v for details.
 * 
 * prg00, prg01, ... prg0F
 * --------------------------------
 * These holds the program to initiate in the EBRs.
 * See m_ebr.v for details.
 * 
 * Wishbone B.4 data sheet for m_midgetv_core
 * --------------------------------------------------------------------
 * Inteface type:                   MASTER
 * General description:             Microcontroller
 * Supported cycles:                MASTER, READ/WRITE
 * Data port, size:                 32-bit
 * Data port, granularity:          8-bit
 * Data port, maximum operand size: 32-bit
 * Data transfer ordering:          Big endian and/or little endian
 * Data transfer sequencing:        Undefined
 * Supported signal list            Signal name   WISHBONE Equiv. 
 *   and cross-reference to         CLK_I         CLK_I        
 *   equivalent WISHBONE signals:   DAT_I[31:0]   DAT_I()
 *                                  ADR_O[31:0]   ADR_O()
 *                                  STB_O         STB_O
 *                                  WE_O          WE_O 
 *                                  CYC_O         CYC_O        
 *                                  SEL_O[3:0]    SEL_O()
 *                                  DAT_O[31:0]   DAT_O()
 *                                  ACK_I         ACK_I        
 *                                  RST_I         RST_I
 */

module m_midgetv_core
  # ( parameter 
      HAS_MINSTRET             = 0,
      HAS_EBR_MINSTRET         = 0,
      RVC                      = 0,
      MULDIV                   = 0,
      SRAMADRWIDTH             = 0,  
      EBRADRWIDTH              = 8, 
      IWIDTH                   = 8, 
      NO_CYCLECNT              = 0, 
      MTIMETAP                 = 0, 
      HIGHLEVEL                = 0, 
      DAT_I_ZERO_WHEN_INACTIVE = 0,
      DBGA                     = 0, // Only set to 1 during debugging

      parameter [4095:0] prg00 = 4096'h0, // | 
      parameter [4095:0] prg01 = 4096'h0, // | Always specified by module
      parameter [4095:0] prg02 = 4096'h0, // | that instantiates m_midgetv_core
      parameter [4095:0] prg03 = 4096'h0, // | 
      parameter [4095:0] prg04 = 4096'h0, // | 
      parameter [4095:0] prg05 = 4096'h0, // | 
      parameter [4095:0] prg06 = 4096'h0, // | 
      parameter [4095:0] prg07 = 4096'h0, // | 
      parameter [4095:0] prg08 = 4096'h0, // | 
      parameter [4095:0] prg09 = 4096'h0, // | 
      parameter [4095:0] prg0A = 4096'h0, // | 
      parameter [4095:0] prg0B = 4096'h0, // | 
      parameter [4095:0] prg0C = 4096'h0, // | 
      parameter [4095:0] prg0D = 4096'h0, // | 
      parameter [4095:0] prg0E = 4096'h0, // | 
      parameter [4095:0] prg0F = 4096'h0  // |
      )
   (
    // Wishbone signals:
    input              CLK_I, //       System clock, used on rising flank only
    input              RST_I, //       Wishbone reset equals NMI, valid in CLK_I domain.
    input              ACK_I, //       Acknowledge from I/O device. As I interpret Wishbone B.3, ACK_I is valid in CLK_I domain.    
    input [IWIDTH-1:0] DAT_I, //       Input devices data for midgetv, valid in CLK_I domain.
    output             CYC_O, //       We do not generate wait states. Observation 3.55 in wbspec_b4: CYC_O = STB_O
    output             STB_O, //       Qualifies ADR_O, DAT_O, SEL_O and WE_O.
    output             WE_O, //        Midgetv writes output to address ADR_O
    output [31:0]      ADR_O, //       Address for I/O devices 
    output [31:0]      DAT_O, //       Data from midgetv to output devices
    output [3:0]       SEL_O, //       Byte mask for read/write. 

    // The following Wishbone signals are not supported:
    //input        ERR_I,RTY_I,STALL_I
    //input [x:0]  TGD_I,
    //output       LOCK_O,
    //output [x:0] TGA_O,TGC_O,TGD_O, 

    // Non-Wishbone signals:
    input              meip, //        External interrupt(s) pending
    input              start, //       Control startup of midgetv
    output             corerunning, // midgetv should now be active. For synchronization of startup
    output [31:0]      dbga, //        For hardware debugging
    output             midgetv_core_killwarnings // To tie-off unused signals. Do not connect.
    );

   /* Local parameters
    *
    * 
    * LAZY_DECODE
    * -----------
    * 0: All supported instructions are fully decoded, riscv 
    *    compliance. Recommended
    * 1: Some minor code spaces are not checked. For example,
    *    "XOR" can be decoded by 
    *    ( funct3 = 3'b100, opcode = 7'b0110011). However, 
    *    one should really also check that funct7 = 7'b0000000.
    *    With LAZY_DECODE == 1, this check is not performed.
    *    In a few cases, executed instructions will hang the
    *    controller. Not recommended
    * 2: Nearly no checking. Not recommended, because illegal
    *    opcodes nearly certainly will hang the controler.
    * 
    * ALUWIDTH
    * --------
    * This is a constant. The reason for making it a parameter
    * is to allow simulation of the ALU with a smaller number
    * of bits.
    * 
    * DISREGARD_WB4_3_55 
    * -------------------
    * 0: Obey rule 3.55 of Wishbone B.3, recommended.
    * 1: Ignore rule 3.55. This should save one! LUT. 
    * 
    * MTIMETAP_LOWLIM
    * ---------------
    * A constant, but I propagate as a parameter because it is likely to
    * be changed once I know the maximum number of cycles needed to do
    * *any* CSR instruction.
    *  
    * NO_UCODEOPT
    * --------
    * 0: Use 2 EBRs + ~20 LUTs for control, recommended.
    * 1: Use 3 EBRs for control. 
    * 
    * 
    */
   localparam LAZY_DECODE        =  0;
   localparam DISREGARD_WB4_3_55 =  1;
   localparam ALUWIDTH           = 32; // Never change
   localparam MTIMETAP_LOWLIM    = 14; // Only location where this value is really to be set 
   localparam NO_UCODEOPT        =  0; // Only set to 1 during debugging
   
   wire                clk; //   My signal name for the clock.
   assign clk   = CLK_I;
   assign CYC_O = STB_O; //      See Wishbone B.4 permission 3.40
   
   
   /* verilator lint_off UNUSED */
   wire                 m_immexp_zfind_q_killwarnings;// From inst_immexp_zfind_q of m_immexp_zfind_q.v
   wire                 m_progressctrl_killwarnings;// From inst_progressctrl of m_progressctrl.v
   wire                 m_rai_killwarning;      // From inst_rai of m_rai.v
   wire                 m_ram_killwarnings;     // From inst_ram of m_ram.v
   wire                 m_status_and_interrupts_killwarnings;// From inst_status_and_interrupts of m_status_and_interrupts.v
   wire                 m_wai_killwarning;      // From inst_wai of m_wai.v
   wire                 ucode_killwarnings;     // From inst_ucode of m_ucode.v
   wire                 ucodepc_killwarnings;   // From inst_ucodepc of m_ucodepc.v
   wire                 m_mimux_killwarnings;   // From inst_mimux of m_mimux.v
   wire                 buserror;               // From inst_cyclecnt of m_cyclecnt.v
   wire [6:0]           dbg_rccnt;              // From inst_cyclecnt of m_cyclecnt.v
`ifdef verilator
   wire [4:0]           dbg_rshcnt;             // From inst_shiftcounter of m_shiftcounter.v
`endif
   wire [2:0]           FUNC3;                  // From inst_opreg of m_opreg.v
   wire                 m_condcode_killwarnings;// From inst_condcode of m_condcode.v
   wire                 cmb_rF2;                // From inst_condcode of m_condcode.v
      /* verilator lint_on UNUSED */
   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   wire                 A31;                    // From inst_alu of m_alu.v
   wire [ALUWIDTH-1:0]  B;                      // From inst_alu of m_alu.v
   wire [31:0]          Di;                     // From inst_mimux of m_mimux.v
   wire [31:0]          Dii;                    // From inst_RVC of m_RVC.v
   wire [31:0]          Dsram;                  // From inst_ram of m_ram.v
   wire [6:0]           FUNC7;                  // From inst_opreg of m_opreg.v
   wire [31:0]          INSTR;                  // From inst_opreg of m_opreg.v
   wire [ALUWIDTH-1:0]  MULDIVREG;              // From inst_shlr of m_shlr.v
   wire [31:0]          QQ;                     // From inst_cyclecnt of m_cyclecnt.v
   wire [EBRADRWIDTH-1:0] Rai;                  // From inst_rai of m_rai.v
   wire [4:0]           SRC1;                   // From inst_opreg of m_opreg.v
   wire [4:0]           SRC2;                   // From inst_opreg of m_opreg.v
   wire [4:0]           TRG;                    // From inst_opreg of m_opreg.v
   wire [EBRADRWIDTH-1:0] Wai;                  // From inst_wai of m_wai.v
   wire                 alu_carryin;            // From inst_alu_carryin of m_alu_carryin.v
   wire                 alu_carryout;           // From inst_alu of m_alu.v
   wire                 alu_minstretofl;        // From inst_alu of m_alu.v
   wire                 alu_tapout;             // From inst_alu of m_alu.v
   wire [3:0]           bmask;                  // From inst_progressctrl of m_progressctrl.v
   wire                 ceM;                    // From inst_ucode of m_ucode.v
   wire                 clrM;                   // From inst_ucode of m_ucode.v
   wire                 cond_holdq;             // From inst_progressctrl of m_progressctrl.v
   wire                 ctrl_pcinc_by_2;        // From inst_ucode of m_ucode.v
   wire                 ctrlreg_we;             // From inst_progressctrl of m_progressctrl.v
   wire                 enaQ;                   // From inst_progressctrl of m_progressctrl.v
   wire                 is_brcond;              // From inst_condcode of m_condcode.v
   wire                 is_valid_instrhigh;     // From inst_RVC of m_RVC.v
   wire                 is_valid_instrlow;      // From inst_RVC of m_RVC.v
   wire                 iwe;                    // From inst_progressctrl of m_progressctrl.v
   wire                 lastshift;              // From inst_shiftcounter of m_shiftcounter.v
   wire                 luh;                    // From inst_progressctrl of m_progressctrl.v
   wire                 meie;                   // From inst_status_and_interrupts of m_status_and_interrupts.v
   wire                 mie;                    // From inst_status_and_interrupts of m_status_and_interrupts.v
   wire [7:0]           minx;                   // From inst_ucodepc of m_ucodepc.v
   wire                 mpie;                   // From inst_status_and_interrupts of m_status_and_interrupts.v
   wire                 mrinstretie;            // From inst_status_and_interrupts of m_status_and_interrupts.v
   wire                 mrinstretip;            // From inst_status_and_interrupts of m_status_and_interrupts.v
   wire                 msie;                   // From inst_status_and_interrupts of m_status_and_interrupts.v
   wire                 msip;                   // From inst_status_and_interrupts of m_status_and_interrupts.v
   wire                 mtie;                   // From inst_status_and_interrupts of m_status_and_interrupts.v
   wire                 mtimeincie;             // From inst_status_and_interrupts of m_status_and_interrupts.v
   wire                 mtimeincip;             // From inst_status_and_interrupts of m_status_and_interrupts.v
   wire                 mtip;                   // From inst_status_and_interrupts of m_status_and_interrupts.v
   wire                 next_STB_O;             // From inst_progressctrl of m_progressctrl.v
   wire                 next_readvalue_unknown; // From inst_ebr of m_ebr.v
   wire                 next_sram_stb;          // From inst_progressctrl of m_progressctrl.v
   wire                 pc1;                    // From inst_progressctrl of m_progressctrl.v
   wire                 pcinc_by_2;             // From inst_progressctrl of m_progressctrl.v
   wire                 potentialMODbranch;     // From inst_ucode of m_ucode.v
   wire                 progress_ucode;         // From inst_progressctrl of m_progressctrl.v
   wire                 qACK;                   // From inst_progressctrl of m_progressctrl.v
   wire                 qualint;                // From inst_status_and_interrupts of m_status_and_interrupts.v
   wire [31:0]          rDee;                   // From inst_inputmux of m_inputmux.v
   wire                 raluF;                  // From inst_condcode of m_condcode.v
   wire [7:0]           rinx;                   // From inst_ucode of m_ucode.v
   wire                 rlastshift;             // From inst_alu_carryin of m_alu_carryin.v
   wire                 rzcy32;                 // From inst_immexp_zfind_q of m_immexp_zfind_q.v
   wire [2:0]           s_alu;                  // From inst_ucode of m_ucode.v
   wire [1:0]           s_alu_carryin;          // From inst_ucode of m_ucode.v
   wire [1:0]           s_cyclecnt;             // From inst_ucode of m_ucode.v
   wire [1:0]           s_shift;                // From inst_ucode of m_ucode.v
   wire                 sa00;                   // From inst_ucode of m_ucode.v
   wire                 sa11;                   // From inst_ucode of m_ucode.v
   wire                 sa12;                   // From inst_ucode of m_ucode.v
   wire                 sa14;                   // From inst_ucode of m_ucode.v
   wire                 sa15;                   // From inst_ucode of m_ucode.v
   wire                 sa20;                   // From inst_ucode of m_ucode.v
   wire                 sa21;                   // From inst_ucode of m_ucode.v
   wire                 sa22;                   // From inst_ucode of m_ucode.v
   wire                 sa23;                   // From inst_ucode of m_ucode.v
   wire                 sa24;                   // From inst_ucode of m_ucode.v
   wire                 sa25;                   // From inst_ucode of m_ucode.v
   wire                 sa26;                   // From inst_ucode of m_ucode.v
   wire                 sa27;                   // From inst_ucode of m_ucode.v
   wire                 sa28;                   // From inst_ucode of m_ucode.v
   wire                 sa29;                   // From inst_ucode of m_ucode.v
   wire                 sa30;                   // From inst_ucode of m_ucode.v
   wire                 sa32;                   // From inst_ucode of m_ucode.v
   wire                 sa33;                   // From inst_ucode of m_ucode.v
   wire                 sa34;                   // From inst_ucode of m_ucode.v
   wire                 sa37;                   // From inst_ucode of m_ucode.v
   wire                 sa38;                   // From inst_ucode of m_ucode.v
   wire                 sa39;                   // From inst_ucode of m_ucode.v
   wire                 sa40;                   // From inst_ucode of m_ucode.v
   wire                 sa41;                   // From inst_ucode of m_ucode.v
   wire                 sa42;                   // From inst_ucode of m_ucode.v
   wire                 sa43;                   // From inst_ucode of m_ucode.v
   wire                 sra_msb;                // From inst_alu_carryin of m_alu_carryin.v
   wire                 sram_ack;               // From inst_ram of m_ram.v
   wire                 sram_stb;               // From inst_progressctrl of m_progressctrl.v
   wire                 sysregack;              // From inst_inputmux of m_inputmux.v
   wire [31:0]          theio;                  // From inst_inputmux of m_inputmux.v
   wire                 was_rvc_instr;          // From inst_progressctrl of m_progressctrl.v
   // End of automatics

`ifdef verilator   
   function [7:0] get_minx;
      // verilator public
      get_minx = minx;
   endfunction
   function [31:0] get_DAT_O;
      // verilator public
      get_DAT_O = DAT_O;
   endfunction
   /*
    * SB_RAM40_4K will return rubbish when the read address equals the write address,
    * and a write is performed. I treat this as an error. But if the data
    * is not to be used, we have no problem. There is at least one frequent occasion
    * that must be weeded out: 
    * During opcode read from SRAM we do:
    * StdIncPC:  writePC readALU
    * Now, if the value of the PC  ends in 0x...88, the read and write address to
    * EBR are equal. However, the EBR read value is not used for anything. 
    * I weed out this case in the function below.
    * 
    * (And yes, it is a grave error to actually try to execute from address 0x80.
    *  example: 
    *  ADR        Contents
    *  00000080   nop
    *  
    *  The "addi r0,r0,0" is executed, the PC is incremented to 0x84, the
    *  read value is unknown, and an unknown instruction is executed.
    * 
    *  Similarly, jumping to 0x88 will give disaster.
    * )
    * 
    */
   wire                 sram_operand_fetch = sa32 & ~sa15;
   function [0:0] get_accesserror;
      // verilator public      
      get_accesserror = next_readvalue_unknown & ~sram_operand_fetch & ~next_STB_O & ~next_sram_stb;
   endfunction
   function [31:0] get_ADR_O;
      // verilator public
      get_ADR_O = ADR_O;
   endfunction
   function [31:0] get_B;
      // verilator public
      get_B = B;
   endfunction
   function [31:0] get_I;
      // verilator public
      get_I = INSTR;
   endfunction
   function [31:0] get_Di;
      // verilator public
      get_Di = Di;
   endfunction
   function [EBRADRWIDTH-1:0] get_Wai;
      // verilator public
      get_Wai = Wai;
   endfunction
   function [EBRADRWIDTH-1:0] get_Rai;
      // verilator public
      get_Rai = Rai;      
   endfunction
   function [3:0] get_progress_ucode_etc;
      // verilator public
      get_progress_ucode_etc = {progress_ucode,rlastshift, sa33, lastshift };
   endfunction
   function [0:0] get_iwe;
      // verilator public
      get_iwe = iwe;
   endfunction
   function [0:0] get_enaQ;
      // verilator public
      get_enaQ = enaQ;
   endfunction
   function [0:0] get_nclearQ;
      // verilator public
      get_nclearQ = sa14;
   endfunction
   function [0:0] get_use_dinx;
     // verilator public
     get_use_dinx = sa28;
   endfunction
   function [4:0] get_stb_ack;
      // verilator public
      get_stb_ack = {STB_O,sysregack,ACK_I,sram_stb,sram_ack};
   endfunction
   function [3:0] get_SEL_O;
      // verilator public
      get_SEL_O = SEL_O;
   endfunction
   function [31:0] get_rDee;
      // verilator public
      get_rDee = rDee;
   endfunction
   function [31:0] get_theio;
      // verilator public
      get_theio = theio;
   endfunction
   function [31:0] get_Dsram;
      // verilator public
      get_Dsram = Dsram;
   endfunction
   function [2:0] get_ALUOP;
      // verilator public
      get_ALUOP = {s_alu[2], mod_s_alu_1, s_alu[0]};
   endfunction
   function [0:0] get_corerunning;
      // verilator public
      get_corerunning = corerunning;
   endfunction
   function [4:0] get_shiftcnt;
      // verilator public
      get_shiftcnt = dbg_rshcnt;
   endfunction
   function [31:0] get_M;
      // verilator public
      get_M = MULDIVREG;
   endfunction
   function [0:0] get_raluF;
      // verilator public
      get_raluF = raluF;
   endfunction
   function [0:0] get_pc1;
      // verilator public
      get_pc1 = pc1;
   endfunction
   function [0:0] get_luh;
      // verilator public
      get_luh = luh;
   endfunction
`endif

   /* Flexibility comes at a price. Some variables are not
    * in use in certain configurations. I can not find any
    * better way to disable warnings than the following:
    */
   assign midgetv_core_killwarnings = sa38 & sa39 | meip | FUNC7[6] | &FUNC7[4:0] | alu_minstretofl | alu_tapout | ctrlreg_we;

   /* -----------------------------------------------------------------------------
    * Datapath
    */
   localparam xHIGHLEVEL = 1;
   
   m_inputmux #(.HIGHLEVEL(                HIGHLEVEL                ),
                .MULDIV(                   MULDIV                   ),
                .DAT_I_ZERO_WHEN_INACTIVE( DAT_I_ZERO_WHEN_INACTIVE ),
                .IWIDTH(                   IWIDTH                   ), 
                .SRAMADRWIDTH(             SRAMADRWIDTH             ),
                .MTIMETAP(                 MTIMETAP                 ),
                .MTIMETAP_LOWLIM(          MTIMETAP_LOWLIM          )) 
   inst_inputmux
     (/*AUTOINST*/
      // Outputs
      .sysregack                        (sysregack),
      .rDee                             (rDee[31:0]),
      .theio                            (theio[31:0]),
      // Inputs
      .clk                              (clk),
      .corerunning                      (corerunning),
      .STB_O                            (STB_O),
      .MULDIVREG                        (MULDIVREG[31:0]),
      .Dsram                            (Dsram[31:0]),
      .clrM                             (clrM),
      .ceM                              (ceM),
      .ADR_O                            (ADR_O[31:0]),
      .mie                              (mie),
      .mpie                             (mpie),
      .meie                             (meie),
      .mrinstretie                      (mrinstretie),
      .msie                             (msie),
      .mtie                             (mtie),
      .mtimeincie                       (mtimeincie),
      .mrinstretip                      (mrinstretip),
      .msip                             (msip),
      .mtip                             (mtip),
      .mtimeincip                       (mtimeincip),
      .meip                             (meip),
      .DAT_I                            (DAT_I[IWIDTH-1:0]));

   m_mimux #(.HIGHLEVEL(HIGHLEVEL))
   inst_mimux
     (/*AUTOINST*/
      // Outputs
      .Di                               (Di[31:0]),
      .m_mimux_killwarnings             (m_mimux_killwarnings),
      // Inputs
      .clk                              (clk),
      .sra_msb                          (sra_msb),
      .sa00                             (sa00),
      .sram_ack                         (sram_ack),
      .qACK                             (qACK),
      .corerunning                      (corerunning),
      .ADR_O                            (ADR_O[31:0]),
      .DAT_O                            (DAT_O[31:0]),
      .rDee                             (rDee[31:0]));


   m_cyclecnt #(.HIGHLEVEL(   HIGHLEVEL   ), 
                .NO_CYCLECNT( NO_CYCLECNT ),
                .RVC(         RVC         ))
   inst_cyclecnt
     (/*AUTOINST*/
      // Outputs
      .QQ                               (QQ[31:0]),
      .corerunning                      (corerunning),
      .buserror                         (buserror),
      .dbg_rccnt                        (dbg_rccnt[6:0]),
      // Inputs
      .clk                              (clk),
      .start                            (start),
      .s_cyclecnt                       (s_cyclecnt[1:0]),
      .pcinc_by_2                       (pcinc_by_2),
      .ctrl_pcinc_by_2                  (ctrl_pcinc_by_2),
      .STB_O                            (STB_O),
      .ADR_O                            (ADR_O[31:0]));

   // Problem with a write to mcause in _ILL_5 had nothing to do with mod_s_alu_1
   wire                 mod_s_alu_1;
   generate
      if ( MULDIV == 0 ) begin
         assign mod_s_alu_1 = s_alu[1];
      end else begin
         assign mod_s_alu_1 = (s_alu == 3'b100 && clrM == 1'b0) ? ~MULDIVREG[0] : s_alu[1];
      end
   endgenerate
   
   m_alu_carryin #(.HIGHLEVEL(HIGHLEVEL), .MULDIV(MULDIV)) 
   inst_alu_carryin
     (// Inputs
      .ADR_O_31                         (ADR_O[31]),
      .FUNC7_5                          (FUNC7[5]),
      .FUNC7_0                          (FUNC7[0]),
      .s_alu_1                          (s_alu[1]),
      .muldivregmsb                     (MULDIVREG[ALUWIDTH-1]),
      /*AUTOINST*/
      // Outputs
      .alu_carryin                      (alu_carryin),
      .sra_msb                          (sra_msb),
      .rlastshift                       (rlastshift),
      // Inputs
      .clk                              (clk),
      .lastshift                        (lastshift),
      .raluF                            (raluF),
      .mod_s_alu_1                      (mod_s_alu_1),
      .s_alu_carryin                    (s_alu_carryin[1:0]));

   m_alu #(.HIGHLEVEL(                 HIGHLEVEL       ), 
           .HAS_MINSTRET(              HAS_MINSTRET     ),
           .HAS_EBR_MINSTRET(          HAS_EBR_MINSTRET ),
           .ALUWIDTH(                  ALUWIDTH        ),
           .MTIMETAP(                  MTIMETAP        ),
           .MTIMETAP_LOWLIM(           MTIMETAP_LOWLIM )
           )
   inst_alu
     (// Inputs
      .s_alu                            ({s_alu[2],mod_s_alu_1,s_alu[0]}),
      /*AUTOINST*/
      // Outputs
      .B                                (B[ALUWIDTH-1:0]),
      .A31                              (A31),
      .alu_carryout                     (alu_carryout),
      .alu_tapout                       (alu_tapout),
      .alu_minstretofl                  (alu_minstretofl),
      // Inputs
      .Di                               (Di[ALUWIDTH-1:0]),
      .ADR_O                            (ADR_O[ALUWIDTH-1:0]),
      .QQ                               (QQ[ALUWIDTH-1:0]),
      .alu_carryin                      (alu_carryin),
      .sa27                             (sa27),
      .sa26                             (sa26),
      .sa25                             (sa25),
      .sa24                             (sa24));

   m_immexp_zfind_q #(.HIGHLEVEL(HIGHLEVEL) ) 
     inst_immexp_zfind_q
       (/*AUTOINST*/
        // Outputs
        .rzcy32                         (rzcy32),
        .ADR_O                          (ADR_O[ALUWIDTH-1:0]),
        .m_immexp_zfind_q_killwarnings  (m_immexp_zfind_q_killwarnings),
        // Inputs
        .B                              (B[ALUWIDTH-1:0]),
        .clk                            (clk),
        .sa11                           (sa11),
        .sa14                           (sa14),
        .corerunning                    (corerunning),
        .enaQ                           (enaQ),
        .INSTR                          (INSTR[31:0]));
   
   m_ebr #(.EBRADRWIDTH(EBRADRWIDTH),
           .prg00(prg00),.prg01(prg01),.prg02(prg02),.prg03(prg03),
           .prg04(prg04),.prg05(prg05),.prg06(prg06),.prg07(prg07),
           .prg08(prg08),.prg09(prg09),.prg0A(prg0A),.prg0B(prg0B),
           .prg0C(prg0C),.prg0D(prg0D),.prg0E(prg0E),.prg0F(prg0F)
           )
   inst_ebr
     (/*AUTOINST*/
      // Outputs
      .DAT_O                            (DAT_O[31:0]),
      .next_readvalue_unknown           (next_readvalue_unknown),
      // Inputs
      .B                                (B[31:0]),
      .Rai                              (Rai[EBRADRWIDTH-1:0]),
      .Wai                              (Wai[EBRADRWIDTH-1:0]),
      .clk                              (clk),
      .bmask                            (bmask[3:0]),
      .iwe                              (iwe));

   /* Nearly Wishbone B.4 data sheet for the ram interface of m_midgetv_core
    * ----------------------------------------------------------------------
    * Inteface type:                   MASTER
    * General description:             Microcontroller
    * Supported cycles:                MASTER, READ/WRITE
    * Data port, size:                 32-bit
    * Data port, granularity:          8-bit
    * Data port, maximum operand size: 32-bit
    * Data transfer ordering:          Big endian and/or little endian
    * Data transfer sequencing:        Undefined
    * Supported signal list            Signal name   WISHBONE Equiv. 
    *   and cross-reference to         CLK_I         CLK_I        
    *   equivalent WISHBONE signals:   Dsram[31:0]   DAT_I()
    *                                  ADR_O[31:0]   ADR_O()
    *                                  sram_stb      STB_O
    *                                  WE_O          WE_O 
    *                                  sram_stb      CYC_O    See Wb B.4 permission 3.40
    *                                  SEL_O[3:0]    SEL_O()
    *                                  DAT_O[31:0]   DAT_O()
    *                                  sram_ack      ACK_I        
    *                                  RST_I         RST_I
    * Comments Many signals are shared with the the microcontroller Wishbone interface
    *          Midgetv require a read latency of 1 cycle or higher. Hence this is not
    *          a full Wishbone interface.
    */
   m_ram  #(.HIGHLEVEL(HIGHLEVEL), 
            .SRAMADRWIDTH(SRAMADRWIDTH) 
            ) 
   inst_ram
     (// Outputs
      .DAT_O                              (Dsram[31:0]),
      .ACK_O                              (sram_ack),
      // Inputs
      .DAT_I                              (DAT_O[31:0]),
      .ADR_I                              (ADR_O[31:0]),
      .STB_I                              (sram_stb),
      .WE_I                               (WE_O),
      .SEL_I                              (SEL_O[3:0]),
      /*AUTOINST*/
      // Outputs
      .m_ram_killwarnings               (m_ram_killwarnings),
      // Inputs
      .CLK_I                            (CLK_I),
      .bmask                            (bmask[3:0]));
   
   /* -----------------------------------------------------------------------------
    * Control path / Data path interface
    */
   
   // Internal read addresses
   m_rai #(.HIGHLEVEL(HIGHLEVEL), .EBRADRWIDTH(EBRADRWIDTH))
   inst_rai
     (/*AUTOINST*/
      // Outputs
      .Rai                              (Rai[EBRADRWIDTH-1:0]),
      .m_rai_killwarning                (m_rai_killwarning),
      // Inputs
      .B                                (B[EBRADRWIDTH+1:0]),
      .SRC1                             (SRC1[4:0]),
      .SRC2                             (SRC2[4:0]),
      .sa20                             (sa20),
      .sa21                             (sa21),
      .sa22                             (sa22),
      .sa23                             (sa23),
      .sram_ack                         (sram_ack),
      .qACK                             (qACK),
      .sa34                             (sa34),
      .sa40                             (sa40),
      .STB_O                            (STB_O),
      .sram_stb                         (sram_stb));

   // Internal write addresses
   m_wai #(.HIGHLEVEL(HIGHLEVEL), .EBRADRWIDTH(EBRADRWIDTH))
   inst_wai
     (/*AUTOINST*/
      // Outputs
      .Wai                              (Wai[EBRADRWIDTH-1:0]),
      .m_wai_killwarning                (m_wai_killwarning),
      // Inputs
      .ADR_O                            (ADR_O[EBRADRWIDTH+1:0]),
      .TRG                              (TRG[4:0]),
      .sa24                             (sa24),
      .sa25                             (sa25),
      .sa26                             (sa26),
      .sa27                             (sa27));

   m_RVC #(.RVC(RVC))
   inst_RVC 
     (/*AUTOINST*/
      // Outputs
      .Dii                              (Dii[31:0]),
      .is_valid_instrlow                (is_valid_instrlow),
      .is_valid_instrhigh               (is_valid_instrhigh),
      // Inputs
      .Di                               (Di[31:0]),
      .pc1                              (pc1),
      .luh                              (luh),
      .sa12                             (sa12));

   m_opreg #(.HIGHLEVEL(HIGHLEVEL), .RVC(RVC))
     inst_opreg
       (/*AUTOINST*/
        // Outputs
        .INSTR                          (INSTR[31:0]),
        .TRG                            (TRG[4:0]),
        .SRC1                           (SRC1[4:0]),
        .SRC2                           (SRC2[4:0]),
        .FUNC3                          (FUNC3[2:0]),
        .FUNC7                          (FUNC7[6:0]),
        // Inputs
        .clk                            (clk),
        .is_valid_instrlow              (is_valid_instrlow),
        .is_valid_instrhigh             (is_valid_instrhigh),
        .Dii                            (Dii[31:0]));

   m_condcode #(.HIGHLEVEL(HIGHLEVEL), .MULDIV(MULDIV) ) 
     inst_condcode
       (// Inputs
        .s_alu                          ({s_alu[2],mod_s_alu_1,s_alu[0]}),
        .use_dinx                       (sa28),
//        .Di31                           (Di[31]),
        .QQ31                           (QQ[31]),
        /*AUTOINST*/
        // Outputs
        .raluF                          (raluF),
        .is_brcond                      (is_brcond),
        .cmb_rF2                        (cmb_rF2),
        .m_condcode_killwarnings        (m_condcode_killwarnings),
        // Inputs
        .clk                            (clk),
        .alu_carryout                   (alu_carryout),
        .INSTR                          (INSTR[31:0]),
        .A31                            (A31),
        .cond_holdq                     (cond_holdq),
        .ceM                            (ceM),
        .sa14                           (sa14),
        .rzcy32                         (rzcy32));

   m_shiftcounter #(.HIGHLEVEL(HIGHLEVEL))
     inst_shiftcounter
       (// Outputs
`ifdef verilator
        .dbg_rshcnt                     (dbg_rshcnt[4:0]),
`endif
        /*AUTOINST*/
        // Outputs
        .lastshift                      (lastshift),
        // Inputs
        .clk                            (clk),
        .s_shift                        (s_shift[1:0]),
        .B                              (B[4:0]));
   
   
   /* -----------------------------------------------------------------------------
    * Control path
    */
   wire                 lastshiftoverride = INSTR[25] & (INSTR[6:2] == 5'b01100);     // MULDIV. Can probably be simplified further
   wire                 isDIVREM = INSTR[25] & ( INSTR[6:2] == 5'b01100) & INSTR[14]; // Can probably be simplified further
   m_progressctrl #(.HIGHLEVEL(          HIGHLEVEL          ),
                    .RVC(                RVC                ),
                    .MULDIV(             MULDIV             ),
                    .DISREGARD_WB4_3_55( DISREGARD_WB4_3_55 ),
                    .NO_CYCLECNT(        NO_CYCLECNT        ),
                    .MTIMETAP(           MTIMETAP           ),
                    .SRAMADRWIDTH(       SRAMADRWIDTH       ), 
                    .MTIMETAP_LOWLIM(    MTIMETAP_LOWLIM    )) 
   inst_progressctrl
     (// Inputs      
      .alu_carryout                     (alu_carryout),
      .clrM                             (clrM),
      /*AUTOINST*/
      // Outputs
      .SEL_O                            (SEL_O[3:0]),
      .bmask                            (bmask[3:0]),
      .iwe                              (iwe),
      .ctrlreg_we                       (ctrlreg_we),
      .WE_O                             (WE_O),
      .STB_O                            (STB_O),
      .sram_stb                         (sram_stb),
      .enaQ                             (enaQ),
      .progress_ucode                   (progress_ucode),
      .qACK                             (qACK),
      .next_STB_O                       (next_STB_O),
      .next_sram_stb                    (next_sram_stb),
      .cond_holdq                       (cond_holdq),
      .pcinc_by_2                       (pcinc_by_2),
      .pc1                              (pc1),
      .was_rvc_instr                    (was_rvc_instr),
      .luh                              (luh),
      .m_progressctrl_killwarnings      (m_progressctrl_killwarnings),
      // Inputs
      .clk                              (clk),
      .corerunning                      (corerunning),
      .RST_I                            (RST_I),
      .ACK_I                            (ACK_I),
      .sram_ack                         (sram_ack),
      .sa15                             (sa15),
      .sa27                             (sa27),
      .sa26                             (sa26),
      .sa25                             (sa25),
      .sa24                             (sa24),
      .sa32                             (sa32),
      .sa41                             (sa41),
      .sa33                             (sa33),
      .sa42                             (sa42),
      .sa43                             (sa43),
      .sa14                             (sa14),
      .sa30                             (sa30),
      .lastshift                        (lastshift),
      .rlastshift                       (rlastshift),
      .B                                (B[31:0]),
      .buserror                         (buserror),
      .sysregack                        (sysregack),
      .sa12                             (sa12),
      .Di                               (Di[17:0]),
      .ceM                              (ceM),
      .isDIVREM                         (isDIVREM),
      .lastshiftoverride                (lastshiftoverride),
      .sa20                             (sa20),
      .sa21                             (sa21),
      .sa22                             (sa22),
      .sa23                             (sa23));
   
   m_ucode #(.NO_UCODEOPT(NO_UCODEOPT),
             .MULDIV(MULDIV), 
             .RVC(RVC),            
             .HAS_MINSTRET(     HAS_MINSTRET     ),
             .HAS_EBR_MINSTRET( HAS_EBR_MINSTRET )
             )
   inst_ucode
     (/*AUTOINST*/
      // Outputs
      .sa00                             (sa00),
      .s_alu_carryin                    (s_alu_carryin[1:0]),
      .s_alu                            (s_alu[2:0]),
      .s_shift                          (s_shift[1:0]),
      .s_cyclecnt                       (s_cyclecnt[1:0]),
      .sa11                             (sa11),
      .sa12                             (sa12),
      .sa14                             (sa14),
      .sa15                             (sa15),
      .sa20                             (sa20),
      .sa21                             (sa21),
      .sa22                             (sa22),
      .sa23                             (sa23),
      .sa24                             (sa24),
      .sa25                             (sa25),
      .sa26                             (sa26),
      .sa27                             (sa27),
      .sa28                             (sa28),
      .sa29                             (sa29),
      .sa30                             (sa30),
      .sa32                             (sa32),
      .sa33                             (sa33),
      .sa34                             (sa34),
      .sa37                             (sa37),
      .sa38                             (sa38),
      .sa39                             (sa39),
      .sa40                             (sa40),
      .sa41                             (sa41),
      .sa42                             (sa42),
      .sa43                             (sa43),
      .clrM                             (clrM),
      .ceM                              (ceM),
      .potentialMODbranch               (potentialMODbranch),
      .ctrl_pcinc_by_2                  (ctrl_pcinc_by_2),
      .rinx                             (rinx[7:0]),
      .ucode_killwarnings               (ucode_killwarnings),
      // Inputs
      .clk                              (clk),
      .minx                             (minx[7:0]),
      .progress_ucode                   (progress_ucode));

   m_ucodepc #(.LAZY_DECODE(LAZY_DECODE), .MULDIV(MULDIV), .RVC(RVC))
     inst_ucodepc
       (/*AUTOINST*/
        // Outputs
        .minx                           (minx[7:0]),
        .ucodepc_killwarnings           (ucodepc_killwarnings),
        // Inputs
        .corerunning                    (corerunning),
        .rinx                           (rinx[7:0]),
        .sa28                           (sa28),
        .sa29                           (sa29),
        .sa30                           (sa30),
        .sa37                           (sa37),
        .sa32                           (sa32),
        .sa15                           (sa15),
        .qualint                        (qualint),
        .is_brcond                      (is_brcond),
        .INSTR                          (INSTR[31:0]),
        .B                              (B[31:0]),
        .DAT_O                          (DAT_O[31:0]),
        .RST_I                          (RST_I),
        .buserror                       (buserror),
        .ceM                            (ceM),
        .rlastshift                     (rlastshift),
        .potentialMODbranch             (potentialMODbranch),
        .pc1                            (pc1),
        .was_rvc_instr                  (was_rvc_instr));
   
   /* Interrupts in midgetv is implemented in an "all or nothing" fashion.
    * If MTIMETAP < MTIMETAP_LOWLIM, we have a minimal system, and no 
    * interrupts. Else I implement registers mip, mie, and mstatus.
    */
   wire                 thedbg_r_incsr;
   generate
      if ( MTIMETAP >= MTIMETAP_LOWLIM ) begin
         m_status_and_interrupts  
           #(.HIGHLEVEL(HIGHLEVEL),
             .HAS_MINSTRET(     HAS_MINSTRET     ),
             .HAS_EBR_MINSTRET( HAS_EBR_MINSTRET )
             )
         inst_status_and_interrupts
           (/*AUTOINST*/
            // Outputs
            .mrinstretip                (mrinstretip),
            .mtimeincip                 (mtimeincip),
            .mtip                       (mtip),
            .msip                       (msip),
            .mrinstretie                (mrinstretie),
            .mtimeincie                 (mtimeincie),
            .meie                       (meie),
            .mtie                       (mtie),
            .msie                       (msie),
            .mpie                       (mpie),
            .mie                        (mie),
            .qualint                    (qualint),
            .m_status_and_interrupts_killwarnings(m_status_and_interrupts_killwarnings),
            // Inputs
            .clk                        (clk),
            .alu_tapout                 (alu_tapout),
            .alu_minstretofl            (alu_minstretofl),
            .B                          (B[31:0]),
            .DAT_O                      (DAT_O[31:0]),
            .ADR_O                      (ADR_O[31:0]),
            .sa38                       (sa38),
            .sa39                       (sa39),
            .meip                       (meip),
            .ctrlreg_we                 (ctrlreg_we));
         // assign thedbg_r_incsr = dbg_r_incsr; // Todo - let out r_incsr named as dbg_r_incsr from inst_status_and_interrupts
      end else begin
         
         assign qualint = 1'b0; // Smallest midgetv has no interrupts
         
         // Keep verilator happy
         assign meie        = 1'b0;                   
         assign mie         = 1'b0;                    
         assign mpie        = 1'b0;                   
         assign mrinstretie = 1'b0;            
         assign mrinstretip = 1'b0;            
         assign msie        = 1'b0;                   
         assign msip        = 1'b0;                   
         assign mtie        = 1'b0;                   
         assign mtimeincie  = 1'b0;             
         assign mtimeincip  = 1'b0;             
         assign mtip        = 1'b0;                   
         
         assign m_status_and_interrupts_killwarnings = 1'b0; // Keep SymplifyPro happy
         assign thedbg_r_incsr = 1'b0;
      end
   endgenerate
`ifdef verilator   
   function [12:0] get_interruptinfo;
      // verilator public
     get_interruptinfo = {msie,msip,mtie,mtip,meie,meip,mtimeincie,mtimeincip,mrinstretie,mrinstretip,mpie,mie,thedbg_r_incsr};
   endfunction
`endif

   /* Multiply and Divide instructions are optionally supported
    */
//   wire loadM =  ~sa14 | (~sa15 & sa14 & sa32); // For RVC
//   wire loadMn = ~loadM;
   m_shlr #( .ALUWIDTH(32), .MULDIV(MULDIV) )
     inst_shlr
       (// Inputs
        .loadMn     (sa14    ),
//        .loadMn     (loadMn),
        .ADR_O0     (ADR_O[0]),
        /*AUTOINST*/
        // Outputs
        .MULDIVREG                      (MULDIVREG[ALUWIDTH-1:0]),
        // Inputs
        .clk                            (clk),
        .ceM                            (ceM),
        .clrM                           (clrM),
        .cmb_rF2                        (cmb_rF2),
        .DAT_O                          (DAT_O[ALUWIDTH-1:0]));
   
   
   generate
      if ( DBGA == 0 ) begin
         assign dbga = 32'b0;
      end else begin
//         reg [31:0] rdbga;
//         always @(posedge clk) begin
////            rdbga[3] <= STB_O;
////            rdbga[2] <= iwe;
////            rdbga[1] <= sram_stb;
////            rdbga[0] <= progress_ucode;
//            //
//            // This established that we do progress_ucode, and iwe from times to times
//            // Never any STB_O, nor sram_stb
//            // So where do we write?
////            if ( iwe ) 
////              rdbga[3:0] <= {sa27,sa26,sa25,sa24};
////            else
////              rdbga[3:0] <= 4'h0;
//            //            
//            // Sequence 4,a,0,b,9,0,d,f -> We are entering a trap
//            // Reconfirm that we write to PC
////            if ( iwe & {sa27,sa26,sa25,sa24} == 4'b1010 ) begin
////               rdbga[3:0] <= 4'hf;
////            end else begin
////               rdbga[3:0] <= 4'h0;
////            end
//            //
//            // We do. Confirm that the upper 20 bits and the lower
//            // two bits of PC are always written to 0
////            if ( iwe & {sa27,sa26,sa25,sa24} == 4'b1010 ) begin
////               if ( B[31:12] != 20'h0 || B[1:0] != 2'b00 ) begin
////                  rdbga[3:0] <= 4'h1;
////               end
////            end
//            //
//            // OK, so now get the PC out. I use PC[0] as a sentinel.
//            // This relies on the fact that we use more than 3 cycles
//            // between each PC write.
////            if ( iwe & {sa27,sa26,sa25,sa24} == 4'b1010 ) begin
////               rdbga <= B | 32'b1;
////            end else begin
////               rdbga[27:0] <= rdbga[31:4];
////            end
//            //
//            // Seems we write 0x4 to PC, then 0 to PC ??
//            // Examine minx[3:0]
////            rdbga[3:0] <= minx[3:0];
//            //
//            // seems stuck at 0x8. 
//            // Examine minx[7:0]
//            rdbga[3:0] <= minx[7:4];
//         end
//         assign dbga = rdbga;
         assign dbga = 32'b0;
      end
   endgenerate
endmodule

/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * The input mux selects between:
 *   o 32 bit output from a SRAM (or cache or whatever)
 *   o a data input port
 *   o 32 bit output from the internal EBR ram (DAT_O)
 *   o A rightshifted ADR_O
 *   o register M for MUL/DIV instructions
 * 
 * There are many choices for the input mux. Not all are thoroghly tested. 
 * Common for all implementations is the last part. 
 * 
 */


/* verilator lint_off DECLFILENAME */


module m_inputmux
  # ( parameter HIGHLEVEL = 1, //      Presently not in use
      MULDIV = 0, //                   With MUL/DIV instructions?
      DAT_I_ZERO_WHEN_INACTIVE = 1, // With "wellbehaved" Wishbone input we may save 32 LUTs in certain situations
      IWIDTH = 32,  //                 Can in principle be from 1 to 32. Usually 8, 16 or 32.
      SRAMADRWIDTH = 0, //             External memory. Usually SRAM in iCE40UP
      MTIMETAP = 0, //                 Include system registers if MTIMETAP >= MTIMETAP_LOWLIM
      MTIMETAP_LOWLIM = 32 //          Really a constant
      )
   (
    /* verilator lint_off UNUSED */
    input              clk, //         System clock
    input              corerunning, // Only update registers after core is started
    input              STB_O, //       Selecte between SRAM and IO, must also lead to  ack when systemregisters written
    input [31:0]       MULDIVREG, //   MUL/DIV result register
    input [31:0]       Dsram, //       SRAM input
    input              clrM, //        To determine if MULDIVREG is to be read
    input              ceM, //         To determine if MULDIVREG is to be read
    input [31:0]       ADR_O, //       For select between system registers
    input              mie, //         Machine Interrupt enable in MSTATUS
    input              mpie, //        Machine Previous Interrupt enable in MSTATUS
    input              meie, //        Machine External Interrupt Enable in MIE
    input              mrinstretie, // Machine Retired Instructions Retired Interrupt Enable in MIE. RENAME
    input              msie, //        Machine Software Interrupt Enable in MIE
    input              mtie, //        Machine Timer Interrupt Enable in MIE
    input              mtimeincie, //  Machine Time Increment Interrupt Enable in MIE
    input              mrinstretip, // Machine Retired Instructions Retired Interrupt Pending in MIP. RENAME
    input              msip, //        Machine Software Interrupt Pending in MIP
    input              mtip,//         Machine Timer Interrupt Pending in MIP
    input              mtimeincip, //  Machine Time Increment Interrupt Pending in MIP
    input              meip, //        Machine External Interrupt Pending in MIP
    /* verilator lint_on UNUSED */
    input [IWIDTH-1:0] DAT_I, //       External input
    
    /* verilator lint_off UNDRIVEN */
    output             sysregack, //   Read/Write acknowledge from MIP/MIE/MSTATUS
    output [31:0]      rDee, //        Output used by mimux
    output [31:0]      theio //        Output for debugging purposes
    /* verilator lint_on UNDRIVEN */
//    output             m_inputmux_killwarnings
    );

   localparam pHASSYSREGS = MTIMETAP >= MTIMETAP_LOWLIM ? 4 : 0;
   localparam pHASSRAM = SRAMADRWIDTH != 0              ? 2 : 0;
   localparam INPUTMUXTYPE = pHASSYSREGS | pHASSRAM | MULDIV;

   /* verilator lint_off UNUSED */
    /* verilator lint_off UNDRIVEN */
   wire [32:0]         zeros = 33'b0;
   wire [32:0]         erDee;
   wire [32:0]         edati = {zeros[32:IWIDTH],DAT_I[IWIDTH-1:0]};
    /* verilator lint_on UNDRIVEN */
   /* verilator lint_on UNUSED */ 

   generate
      if ( INPUTMUXTYPE == 0 ) begin
         /* Simplest and smallest case. No SRAM, no system registers, no multiplier.
          *
          *               __   
          * DAT_I -------|  |- rDee
          *              >  |  
          * corerunning -E__|  
          * 
          * Total size: 33+IWIDTH SB_LUT4
          */
         reg [IWIDTH-1:0] ireg;
         
         always @(posedge clk)
           if ( corerunning )
             ireg <= DAT_I;
         assign erDee = {zeros[32:IWIDTH],ireg};
         assign sysregack = 0;
         assign theio = DAT_I;
         
      end else if ( INPUTMUXTYPE == 1 ) begin
         /* Multiplier present. No SRAM, no system registers.
          *
          * STB_O ------------+               
          * DAT_I -----------|1\         __   
          *                  |  |- a ---|  |- rDee
          * MULDIVREG -------|0/        >  |  
          *                corerunning -E__|  
          * 
          * Total size: 65 SB_LUT4
          */
         
         wire [31:0] a;
         reg [31:0]  ireg;
         assign a = STB_O ? edati[31:0] : MULDIVREG;
         always @(posedge clk)
           if ( corerunning )
             ireg <= a;
         assign erDee = {zeros[32:IWIDTH],ireg};
         assign sysregack = 0;
         assign theio = a;
         
    end else if ( INPUTMUXTYPE == 2 ) begin
       /* SRAM present. No multiplier, no system registers
        *
        * STB_O ------------+               
        * DAT_I -----------|1\         __   
        *                  |  |- a ---|  |- rDee
        * Dsram     -------|0/        >  |  
        *                corerunning -E__|  
        * 
        * Total size: 65 SB_LUT4
        */
       wire [31:0] a;
       reg [31:0]  ireg;
       assign a = STB_O ? edati[31:0] : Dsram;
       always @(posedge clk)
         if ( corerunning )
           ireg <= a;
       assign erDee = {zeros[32:IWIDTH],ireg};
       assign sysregack = 0;
       assign theio = a;
       
    end else if ( INPUTMUXTYPE == 3 ) begin
       
       wire [31:0] a;
       reg [31:0]  ireg;
       wire        STB_O_or_ReadM = STB_O | (clrM & ceM);

       if ( DAT_I_ZERO_WHEN_INACTIVE ) begin
          /* SRAM and multiplier both present. No system registers.
           * When DAT_I is inactive, it is zero. Note that this depends on the 
           * external INTERCON module. 
           *
           * STB_O_or_readM ---+               
           *             __    |
           * DAT_I -----|or|--|1\         __   
           * MULDIVREG -|__|  |  |- a ---|  |- rDee
           * Dsram     -------|0/        >  |  
           *                corerunning -E__|  
           * 
           * The lsb must be treated differently - MULDIVREG[0] is 1'b1 when idle.
           * 
           */
          assign a[31:1] = STB_O_or_ReadM ? (edati[31:1] | MULDIVREG[31:1]) : Dsram[31:1];
          wire b0;
          assign b0 = STB_O ? edati[0] : MULDIVREG[0];
          assign a[0] = STB_O_or_ReadM ? b0 : Dsram[0];
       end else begin
          /* SRAM and multiplier both present. No system registers.
           * When DAT_I is inactive, we know nothing about the value of DAT_I,
           * so we must use additional resources.
           *
           * STB_O_or_readM ------+               
           * STB_O ------+        |
           * DAT_I     -|1\       | 
           *            |  |- b -|1\         __   
           * MULDIVREG -|0/      |  |- a ---|  |- rDee
           * Dsram     ----------|0/        >  |  
           *                   corerunning -E__|  
           * 
           * Total size: IWIDTH+66 SB_LUT4
           */
          wire [31:0] b;
          assign b = STB_O ? edati[31:0] : MULDIVREG;
          assign a = STB_O_or_ReadM ? b : Dsram;          
       end
       always @(posedge clk)
         if ( corerunning )
           ireg <= a;
       assign erDee = {zeros[32:IWIDTH],ireg};
       assign sysregack = 0;
       assign theio = a;
       
    end else if ( INPUTMUXTYPE == 4 ) begin
       /* System registers, but no sram nor multipliers.
        */
       reg [31:0] a;
       reg        tmpsysregack;
       reg [31:0] ireg;
 
       /* Many bits implemented as this:
        * sysregack -----+
        * STB_O ----+    |    _          __
        * DAT_I   -|1\   +--o| |-- a ---|  |- rDee
        *          |  |------|_|        >  |
        *     0   -|0/     corerunning -E__|
        */
       always @(/*AS*/STB_O or edati or sysregack) begin
          a[2:0]   = sysregack ?  3'b0 : STB_O ?   edati[2:0] :  3'b0;
          a[6:4]   = sysregack ?  3'b0 : STB_O ?   edati[6:4] :  3'b0;
          a[10:8]  = sysregack ?  3'b0 : STB_O ?  edati[10:8] :  3'b0;
          a[15:13] = sysregack ?  3'b0 : STB_O ? edati[15:13] :  3'b0;
          a[31:18] = sysregack ? 14'b0 : STB_O ? edati[31:18] : 14'b0;
       end
       
       always @(/*AS*/ADR_O or STB_O or edati or meie or meip or mie
                or mpie or mrinstretie or mrinstretip or msie or msip
                or mtie or mtimeincie or mtimeincip or mtip) 
         casez ( {STB_O,ADR_O[29:27]} )
           4'b0??? : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b0,2'b00,                 1'b0,1'b0,1'b0,1'b0};
           4'b10?? : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b0,edati[17:16],          edati[12:11],edati[7],edati[3]};
           4'b1100 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b0,edati[17:16],          edati[12:11],edati[7],edati[3]}; // Don't care better?
           4'b1101 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b1,mrinstretip,mtimeincip,1'b0,meip,mtip,msip}; // MIP
           4'b1110 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b1,mrinstretie,mtimeincie,1'b0,meie,mtie,msie}; // MIE
           4'b1111 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b1,2'b00,                 1'b1,1'b1,mpie,mie }; // MSTATUS
         endcase
                                                         
       always @(posedge clk)
         if ( corerunning ) begin
            ireg <= a;
         end
       assign erDee = {zeros[32:IWIDTH],ireg};
       assign sysregack = tmpsysregack;
       assign theio = a;
       
    end else if ( INPUTMUXTYPE == 5 ) begin
       /* Multiplier and system registers, but no sram.
        * Many bits implemented as this:
        * sysregack -------+
        * STB_O ------+    |    _          __
        * DAT_I     -|1\   +--o| |-- a ---|  |- rDee
        *            |  |------|_|        >  |
        * MULDIVREG -|0/     corerunning -E__|
        */
       reg [31:0] a;
       reg        tmpsysregack;
       reg [31:0] ireg;
 
       always @(/*AS*/MULDIVREG or STB_O or edati or sysregack) begin
          a[2:0]   = sysregack ?  3'b0 : STB_O ?   edati[2:0] :   MULDIVREG[2:0];
          a[6:4]   = sysregack ?  3'b0 : STB_O ?   edati[6:4] :   MULDIVREG[6:4];
          a[10:8]  = sysregack ?  3'b0 : STB_O ?  edati[10:8] :  MULDIVREG[10:8];
          a[15:13] = sysregack ?  3'b0 : STB_O ? edati[15:13] : MULDIVREG[15:13];
          a[31:18] = sysregack ? 14'b0 : STB_O ? edati[31:18] : MULDIVREG[31:18];
       end
       always @(/*AS*/ADR_O or MULDIVREG or STB_O or edati or meie
                or meip or mie or mpie or mrinstretie or mrinstretip
                or msie or msip or mtie or mtimeincie or mtimeincip
                or mtip) 
         casez ( {STB_O,ADR_O[29:27]} )
           4'b0??? : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b0,MULDIVREG[17:16],MULDIVREG[12:11],MULDIVREG[7],MULDIVREG[3]};
           4'b10?? : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b0,edati[17:16],          edati[12:11],edati[7],edati[3]};
           4'b1100 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b0,edati[17:16],          edati[12:11],edati[7],edati[3]}; // Don't care smaller?
           4'b1101 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b1,mrinstretip,mtimeincip,1'b0,meip,mtip,msip}; // MIP
           4'b1110 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b1,mrinstretie,mtimeincie,1'b0,meie,mtie,msie}; // MIE
           4'b1111 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b1,2'b00,                 1'b1,1'b1,mpie,mie }; // MSTATUS
         endcase
                                                         
       always @(posedge clk)
         if ( corerunning ) begin
            ireg <= a;
         end
       assign erDee = {zeros[32:IWIDTH],ireg};
       assign sysregack = tmpsysregack;
       assign theio = a;
       
       

    end else if ( INPUTMUXTYPE == 6 ) begin
       /* System registers and sram. No multiplier. Most bits:
        * 
        * 
        * STB_O ------------+       
        * DAT_I -----------|1\               __     
        *                  |  |------- a ---|  |- rDee
        * Dsram     -------|0/              >  |                      
        *                      corerunning -E  |                      
        *                      sysregack  --R__|               
        * Total size: 81 SB_LUTS
        */
       reg [31:0] a;
       reg        tmpsysregack;
       reg [31:0] ireg;
 
       always @(*) begin
          a[2:0]   = sysregack ?  3'b0 : STB_O ?   edati[2:0] :   Dsram[2:0];
          a[6:4]   = sysregack ?  3'b0 : STB_O ?   edati[6:4] :   Dsram[6:4];
          a[10:8]  = sysregack ?  3'b0 : STB_O ?  edati[10:8] :  Dsram[10:8];
          a[15:13] = sysregack ?  3'b0 : STB_O ? edati[15:13] : Dsram[15:13];
          a[31:18] = sysregack ? 14'b0 : STB_O ? edati[31:18] : Dsram[31:18];
       end
       
       always @(*) 
         casez ( {STB_O,ADR_O[29:27]} )
           4'b0??? : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b0,Dsram[17:16],Dsram[12:11],Dsram[7],Dsram[3]};
           4'b10?? : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b0,edati[17:16],edati[12:11],edati[7],edati[3]};
           4'b1100 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b0,edati[17:16],edati[12:11],edati[7],edati[3]}; // Don't care better?
           4'b1101 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b1,mrinstretip,mtimeincip,1'b0,meip,mtip,msip}; // MIP
           4'b1110 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b1,mrinstretie,mtimeincie,1'b0,meie,mtie,msie}; // MIE
           4'b1111 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b1,2'b00,                 1'b1,1'b1,mpie,mie }; // MSTATUS
         endcase
                                                         
       always @(posedge clk)
         if ( corerunning ) begin
            ireg <= a;
         end
       assign erDee = {zeros[32:IWIDTH],ireg};
       assign sysregack = tmpsysregack;
       assign theio = a;
       
    end else if ( INPUTMUXTYPE == 7 ) begin

       if ( DAT_I_ZERO_WHEN_INACTIVE ) begin
          /* SRAM, multiplier, and system registers. When DAT_I is inactive, it is zero.
           * This depends on the external INTERCON module.
           * Most bits:
           *
           * STB_O_or_readM ---+               
           *             __    |
           * DAT_I -----|or|--|1\         __   
           * MULDIVREG -|__|  |  |- a ---|  |- rDee
           * Dsram     -------|0/        >  |  
           *                corerunning -E__|  
           * 
           */
          ProbableErrorHere SeeOtherCaseWith_DAT_I_ZERO_WHEN_INACTIVE();
          reg [31:0] a;
          reg        tmpsysregack;
          reg [31:0] ireg;
          wire       STB_O_or_ReadM = STB_O | (clrM & ceM);
          wire [31:0] d_or_m = edati[31:0] | MULDIVREG;
          
          always @(/*AS*/Dsram or STB_O_or_ReadM or d_or_m
                   or sysregack) begin
             a[2:0]   = sysregack ?  3'b0 : STB_O_or_ReadM ?   d_or_m[2:0] :   Dsram[2:0];
             a[6:4]   = sysregack ?  3'b0 : STB_O_or_ReadM ?   d_or_m[6:4] :   Dsram[6:4];
             a[10:8]  = sysregack ?  3'b0 : STB_O_or_ReadM ?  d_or_m[10:8] :  Dsram[10:8];
             a[15:13] = sysregack ?  3'b0 : STB_O_or_ReadM ? d_or_m[15:13] : Dsram[15:13];
             a[31:18] = sysregack ? 14'b0 : STB_O_or_ReadM ? d_or_m[31:18] : Dsram[31:18];
          end
       
       always @(/*AS*/ADR_O or Dsram or STB_O or d_or_m or meie
                or meip or mie or mpie or mrinstretie or mrinstretip
                or msie or msip or mtie or mtimeincie or mtimeincip
                or mtip) 
         casez ( {STB_O,ADR_O[29:27]} )
           4'b0??? : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b0,Dsram[17:16],  Dsram[12:11],Dsram[7],Dsram[3]};
           4'b10?? : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b0,d_or_m[17:16],d_or_m[12:11],d_or_m[7],d_or_m[3]};
           4'b1100 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b0,d_or_m[17:16],d_or_m[12:11],d_or_m[7],d_or_m[3]}; // Don't care better?
           4'b1101 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b1,mrinstretip,mtimeincip,1'b0,meip,mtip,msip}; // MIP
           4'b1110 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b1,mrinstretie,mtimeincie,1'b0,meie,mtie,msie}; // MIE
           4'b1111 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b1,2'b00,                 1'b1,1'b1,mpie,mie }; // MSTATUS
         endcase
          
          always @(posedge clk)
            if ( corerunning ) begin
               ireg <= a;
            end
          assign erDee = {zeros[32:IWIDTH],ireg};
          assign sysregack = tmpsysregack;
          assign theio = a;
          
       end else begin
          /* SRAM, multiplier, and system registers. When DAT_I is inactive, it is unknown.
           * Most bits:
           *
           * STB_O_or_readM ------+               
           * STB_O ------+        |
           * DAT_I     -|1\       |       
           *            |  |- b -|1\                 __                  
           * MULDIVREG -|0/      |  |--------- a ---|  |- rDee     
           * Dsram     ----------|0/                >  |       
           *                           corerunning -E  |       
           *                            sysregack --R__|
           */
          reg [31:0] a;
          reg        tmpsysregack;
          reg [31:0] ireg;
          wire       STB_O_or_ReadM = STB_O | (clrM & ceM);

          always @(/*AS*/DAT_I or Dsram or MULDIVREG or STB_O
                   or STB_O_or_ReadM) begin
             a[2:0]   = STB_O_or_ReadM ? (STB_O ?   DAT_I[2:0] :   MULDIVREG[2:0]) :   Dsram[2:0];
             a[6:4]   = STB_O_or_ReadM ? (STB_O ?   DAT_I[6:4] :   MULDIVREG[6:4]) :   Dsram[6:4];
             a[10:8]  = STB_O_or_ReadM ? (STB_O ?  DAT_I[10:8] :  MULDIVREG[10:8]) :  Dsram[10:8];
             a[15:13] = STB_O_or_ReadM ? (STB_O ? DAT_I[15:13] : MULDIVREG[15:13]) : Dsram[15:13];
             a[31:18] = STB_O_or_ReadM ? (STB_O ? DAT_I[31:18] : MULDIVREG[31:18]) : Dsram[31:18];
          end
          
          always @(/*AS*/ADR_O or Dsram or MULDIVREG or STB_O
                   or STB_O_or_ReadM or edati or meie or meip or mie
                   or mpie or mrinstretie or mrinstretip or msie
                   or msip or mtie or mtimeincie or mtimeincip or mtip) 
            casez ( {STB_O_or_ReadM,STB_O,ADR_O[29:27]} )
              5'b00??? : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b0,Dsram[17:16],Dsram[12:11],Dsram[7],Dsram[3]};
              5'b01??? : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b0,edati[17:16],edati[12:11],edati[7],edati[3]}; // This is an impossible case. Don't care better?
              5'b10??? : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b0,MULDIVREG[17:16],MULDIVREG[12:11],MULDIVREG[7],MULDIVREG[3]};
              5'b110?? : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b0,edati[17:16],edati[12:11],edati[7],edati[3]};
              5'b11100 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b0,edati[17:16],edati[12:11],edati[7],edati[3]}; // Don't care better?
              5'b11101 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b1,mrinstretip,mtimeincip,1'b0,meip,mtip,msip}; // MIP
              5'b11110 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b1,mrinstretie,mtimeincie,1'b0,meie,mtie,msie}; // MIE
              5'b11111 : {tmpsysregack,a[17:16],a[12:11],a[7],a[3]} = {1'b1,2'b00,                 1'b1,1'b1,mpie,mie }; // MSTATUS
            endcase
          
          always @(posedge clk)
            if ( corerunning ) begin
               ireg[2:0]   <= sysregack ? 3'b0  : a[2:0];
               ireg[3]     <= a[3];
               ireg[6:4]   <= sysregack ? 3'b0  : a[6:4];
               ireg[7]     <= a[7];
               ireg[10:8]  <= sysregack ? 3'b0  : a[10:8];
               ireg[12:11] <= a[12:11];
               ireg[15:13] <= sysregack ? 3'b0  : a[15:13];
               ireg[17:16] <= a[17:16];
               ireg[31:18] <= sysregack ? 14'b0  : a[31:18];
            end
          assign erDee = {zeros[32:IWIDTH],ireg};
          assign sysregack = tmpsysregack;
          assign theio = a;
          

       end
       
    end else begin
       NotYetDoneWTF WorkWTF();
    end
      
   endgenerate
   assign rDee = erDee[31:0];
endmodule


//    end else if ( INPUTMUXTYPE == 7 ) begin
//       if ( DAT_I_ZERO_WHEN_INACTIVE ) begin
//          /* System registers, SRAM and multiplier all present.
//           * When DAT_I is inactive, it is zero. Note that this depends on the 
//           * external INTERCON module. Most bits are identical to a previous case:
//           *
//           * STB_O_or_readM ---+               
//           *             __    |
//           * DAT_I -----|or|--|1\         __   
//           * MULDIVREG -|__|  |  |- a ---|  |- rDee
//           * Dsram     -------|0/        >  |  
//           *                corerunning -E  |                      
//           *                sysregack  --R__|               
//           *       
//           * Total size: 102 SB_LUT4
//           */
//          wire STB_O_or_ReadM = STB_O | (clrM & ceM);
//          wire [32:0] edati = {zeros[32:IWIDTH],DAT_I[IWIDTH-1:0]};
//          reg [31:0]  a;
//          reg         tmpsysregack;
//          reg [31:0]  ireg;
//          
//          always @(/*AS*/Dsram or MULDIVREG or STB_O_or_ReadM or edati
//                   or sysregack) begin
//             a[2:0]   = sysregack ?  3'b0 : STB_O_or_ReadM ? (  edati[2:0] |   MULDIVREG[2:0]) :   Dsram[2:0];
//             a[6:4]   = sysregack ?  3'b0 : STB_O_or_ReadM ? (  edati[6:4] |   MULDIVREG[6:4]) :   Dsram[6:4];
//             a[10:8]  = sysregack ?  3'b0 : STB_O_or_ReadM ? ( edati[10:8] |  MULDIVREG[10:8]) :  Dsram[10:8];
//             a[15:12] = sysregack ?  3'b0 : STB_O_or_ReadM ? (edati[15:12] | MULDIVREG[15:12]) : Dsram[15:12];
//             a[31:18] = sysregack ? 14'b0 : STB_O_or_ReadM ? (edati[31:18] | MULDIVREG[31:18]) : Dsram[31:18];
//          end
//          
//          always @(/*AS*/ADR_O or Dsram or MULDIVREG or STB_O_or_ReadM
//                   or edati or meie or meip or mie or mpie
//                   or mrinstretie or mrinstretip or msie or msip
//                   or mtie or mtimeincie or mtimeincip or mtip) 
//            casez ( {STB_O_or_ReadM,ADR_O[29:27]} )
//              4'b0??? : {tmpsysregack,a[17:16],a[11],a[7],a[3]} = {1'b0,Dsram[17:16],Dsram[11],Dsram[7],Dsram[3]};
//              4'b10?? : {tmpsysregack,a[17:16],a[11],a[7],a[3]} = {1'b0,{edati[17:16]|MULDIVREG[17:16]},{edati[11]|MULDIVREG[11]},{edati[7]|MULDIVREG[7]},{edati[3]|MULDIVREG[3]}};
//              4'b1100 : {tmpsysregack,a[17:16],a[11],a[7],a[3]} = {1'b0,{edati[17:16]|MULDIVREG[17:16]},{edati[11]|MULDIVREG[11]},{edati[7]|MULDIVREG[7]},{edati[3]|MULDIVREG[3]}}; // Don't care better?
//              4'b1101 : {tmpsysregack,a[17:16],a[11],a[7],a[3]} = {1'b1,mrinstretip,mtimeincip,meip,mtip,msip}; // MIP
//              4'b1110 : {tmpsysregack,a[17:16],a[11],a[7],a[3]} = {1'b1,mrinstretie,mtimeincie,meie,mtie,msie}; // MIE
//              4'b1111 : {tmpsysregack,a[17:16],a[11],a[7],a[3]} = {1'b1,2'b00,                 1'b1,mpie,mie }; // MSTATUS
//            endcase
//          
//          always @(posedge clk)
//            if ( corerunning ) begin
//               ireg[2:0]   <= sysregack ? 3'b0  : a[2:0];
//               ireg[3]     <= a[3];
//               ireg[6:4]   <= sysregack ? 3'b0  : a[6:4];
//               ireg[7]     <= a[7];
//               ireg[10:8]  <= sysregack ? 3'b0  : a[10:8];
//               ireg[11]    <= a[11];
//               ireg[15:12] <= sysregack ? 3'b0  : a[15:12];
//               ireg[17:16] <= a[17:16];
//               ireg[31:18] <= sysregack ? 3'b0  : a[31:18];
//            end
//          assign erDee = {zeros[32:IWIDTH],ireg};
//          assign sysregack = tmpsysregack;
//          assign theio = a;
// 
//       end else begin
//          /* System registers, SRAM and multiplier all present.
//           * When DAT_I is inactive, we know nothing about the value of DAT_I,
//           * so we must use additional resources. Most bits can be implemented like this:
//           *
//           * STB_O_or_readM ------+               
//           * STB_O ------+        |
//           * DAT_I     -|1\       |                ___          __            
//           *            |  |- b -|1\  sysregack -o| & |-- a ---|  |- rDee           
//           * MULDIVREG -|0/      |  |-------------|___|        >  |           
//           * Dsram     ----------|0/              corerunning -E__|  
//           *                   
//           * Total size around: IWIDTH+81 SB_LUT4 ???
//           */
//          wire STB_O_or_ReadM = STB_O | (clrM & ceM);
//          wire [32:0] edati = {zeros[32:IWIDTH],DAT_I[IWIDTH-1:0]};
//          reg [31:0]  a;
//          reg         tmpsysregack;
//          reg [31:0]  ireg;
//          
//          always @(/*AS*/Dsram or MULDIVREG or STB_O or STB_O_or_ReadM
//                   or edati) begin
//             a[2:0]   = sysregack ?  3'b0 : STB_O_or_ReadM ? (STB_O ?   edati[2:0] :   MULDIVREG[2:0]) :   Dsram[2:0];
//             a[6:4]   = sysregack ?  3'b0 : STB_O_or_ReadM ? (STB_O ?   edati[6:4] :   MULDIVREG[6:4]) :   Dsram[6:4];
//             a[10:8]  = sysregack ?  3'b0 : STB_O_or_ReadM ? (STB_O ?  edati[10:8] :  MULDIVREG[10:8]) :  Dsram[10:8];
//             a[15:12] = sysregack ?  3'b0 : STB_O_or_ReadM ? (STB_O ? edati[15:12] : MULDIVREG[15:12]) : Dsram[15:12];
//             a[31:18] = sysregack ? 14'b0 : STB_O_or_ReadM ? (STB_O ? edati[31:18] : MULDIVREG[31:18]) : Dsram[31:18];
//          end
//          
//          always @(/*AS*/ADR_O or Dsram or MULDIVREG or STB_O
//                   or STB_O_or_ReadM or edati or meie or meip or mie
//                   or mpie or mrinstretie or mrinstretip or msie
//                   or msip or mtie or mtimeincie or mtimeincip or mtip) 
//            casez ( {STB_O_or_ReadM,ADR_O[29:27]} )
//              4'b0??? : {tmpsysregack,a[17:16],a[11],a[7],a[3]} = {1'b0,Dsram[17:16],Dsram[11],Dsram[7],Dsram[3]};
//              4'b10?? : {tmpsysregack,a[17:16],a[11],a[7],a[3]} 
//                = {1'b0,{STB_O ? edati[17:16] : MULDIVREG[17:16]},{STB_O ? edati[11] : MULDIVREG[11]},{STB_O ? edati[7] : MULDIVREG[7]},{STB_O ? edati[3] : MULDIVREG[3]}};
//              4'b1100 : {tmpsysregack,a[17:16],a[11],a[7],a[3]} 
//                = {1'b0,{STB_O ? edati[17:16] : MULDIVREG[17:16]},{STB_O ? edati[11] : MULDIVREG[11]},{STB_O ? edati[7] : MULDIVREG[7]},{STB_O ? edati[3] : MULDIVREG[3]}}; // Don't care better?
//              4'b1101 : {tmpsysregack,a[17:16],a[11],a[7],a[3]} = {1'b1,mrinstretip,mtimeincip,meip,mtip,msip}; // MIP
//              4'b1110 : {tmpsysregack,a[17:16],a[11],a[7],a[3]} = {1'b1,mrinstretie,mtimeincie,meie,mtie,msie}; // MIE
//              4'b1111 : {tmpsysregack,a[17:16],a[11],a[7],a[3]} = {1'b1,2'b00,                 1'b1,mpie,mie }; // MSTATUS
//            endcase
//          
//          always @(posedge clk)
//            if ( corerunning )
//              ireg <= a;
//          assign erDee = {zeros[32:IWIDTH],ireg};
//          assign sysregack = tmpsysregack;
//          assign theio = a;
// 
//       end
//       
//    end else begin
//       InternalError Work();
//    end
//    
// //   assign m_inputmux_killwarnings = ADR_O[0];

/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019-2020. Copyright B. Nossum.
 * For licence, see LICENCE
 * ----------------------------------------------------------------------------ehdr
 * This is the fundamental input multiplexer, which is the last part of the 
 * inputmux
 * 
 * sa00mod ---------+
 * DAT_O ----+-----|0\
 * rDee ----|0\    |  |-- Di
 *          |  |---|1/
 * shADR_O--|1/               
 * 
 */
module m_mimux
  # ( parameter HIGHLEVEL = 1 )
   (
    input         clk, //
    input         sra_msb, //     Msb to use when rightshifing ADR_O
    input         sa00, //        Main select signal, pipelined
    input         sram_ack, //    Used to select data from SRAM/input devices
    input         qACK, //        Qualified acknowledge, usually (ACK_I | sysregack)
    input         corerunning, // Needed at startup
    /* verilator lint_off UNUSED */
    input [31:0]  ADR_O, //       For right-shift
    /* verilator lint_on UNUSED */
    input [31:0]  DAT_O, //       Output from EBR is input to mux
    input [31:0]  rDee, //        External input, SRAM, Multipler register
    output [31:0] Di, //          Data out of mux
    output        m_mimux_killwarnings
    );
   assign m_mimux_killwarnings = ADR_O[0];
   
   generate
      wire [31:0] shADR_O = {sra_msb,ADR_O[31:1]};
      if ( HIGHLEVEL ) begin
         reg sa00mod;
         always @(posedge clk)
           sa00mod <=  ~(qACK | sram_ack | sa00 | ~corerunning);
         assign Di = sa00mod ? DAT_O : (DAT_O & rDee | ~DAT_O & shADR_O);
      end else begin
         wire cmb_sa00mod;
         wire sa00mod;
         SB_LUT4 #(.LUT_INIT(16'h0100)) inst_presa00mod( .O(cmb_sa00mod), .I3(corerunning), .I2(sram_ack), .I1(qACK), .I0(sa00)); 
         SB_DFF sa00mod_r( .Q(sa00mod), .C(clk), .D(cmb_sa00mod));
         SB_LUT4 #(.LUT_INIT(16'hf0ca)) cmb [31:0] (.O(Di),.I3(sa00mod),.I2(DAT_O),.I1(rDee),.I0(shADR_O));
      end
   endgenerate
endmodule
// Work. Need to add code dependency to pack lastshift as shown in diagram [a]
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * 
 * The alu carry input. It must be selectable. raluF is used by slt(u), slti(u)
 * instructions. alu_carryin must be put on the carry chain.
 * 
 * Free resources here give sra_msb and rlastshift
 * Size of module : 2 SB_LUT4s
 * 
 *                                          
 *                    | alu_carryin           s_alu_carryin[1]       FUNC7_5 
 *                   /y\     ___              |s_alu_carryin[0]      |Q[31]    
 * ADR_O[31] --------(((----|I0 |             ||  prealucyin         ||      sra_msb    
 * s_alu_carryin[0] -+((----|I1 |-- sra_msb   00  0                  00      0      
 * s_alu_carryin[1] --(+----|I2 |             01  raluF              01      0
 * FUNC7_5 -----------(-----|I3_|             10  raluF              10      0
 *                    | prealucyin            11  1                  11      1
 *                   /y\     ___                     __        
 * lastshift   ------(((----|I0 |-- lastshift_dup --|  |-- rlastshift
 * raluF ------------+||    |I1 |                   |  | 
 * GND ---------------(+    |I2 |                   >__|    
 *                    |     |I3_|
 *                    |
 *                    VCC
 * 
 * Minor changes after MULDIV implemented:
 * raluF only need to be put on the carry chain for SLT[I][U], all other situations are don't care
 * It is not evident, but from ucode.h we see that ADR_O == 0 when raluF is indeed used. This
 * mean we can squeze in this solution:
 * 
 * diagram [a]                                         
 *                    | alu_carryin           
 *                   /y\     ___              
 * lastshift --------(((----|I0 |                    __                         
 * s_alu_carryin[0] -+||    |I1 |-- lastshift_dup --|  |-- rlastshift 
 * s_alu_carryin[1] --(+    |I2 |                   |  |                        
 *                    |     |I3_|                   >__|                        
 *                    | prealucyin            
 *                   /y\     ___    
 * FUNC7_0 ----------(((----|I0 |-- sra_msb   
 * raluF ------------+((----|I1 |   
 * ADR_O[31]----------(+----|I2 |   
 * FUNC7_5 -----------(-----|I3_|
 *                    |
 *                    VCC
 * 
 * FUNC7_5
 * |FUNC7_0  
 * ||         sra_msb
 * 00         0
 * 01         raluF
 * 10         ADR_O_31
 * 11         ADR_O_31
 * 
 * ADR_O[31]
 * |s_alu_carryin[1] 
 * ||s_alu_carryin[0]
 * |||  prealucyin   
 * x00  0            
 * 001  raluF        
 * 010  raluF        
 * 101  1 (not used)
 * 110  1 (not used)
 * x11  1            
 */

module m_alu_carryin  # ( parameter HIGHLEVEL = 1, MULDIV = 1 )   
   (
    input       clk, lastshift, raluF, FUNC7_5, ADR_O_31,
    /* verilator lint_off UNUSED */
    input       mod_s_alu_1, s_alu_1,muldivregmsb,
    input       FUNC7_0, 
    /* verilator lint_on UNUSED */
    input [1:0] s_alu_carryin,
    output      alu_carryin, sra_msb, rlastshift
    );
   
   generate
      if ( HIGHLEVEL != 0 ) begin

         if ( MULDIV != 0 ) begin
                        
            wire [1:0] mod_s_alu_carryin;
            wire       mod_raluF; 
            assign mod_s_alu_carryin = (mod_s_alu_1 ^ s_alu_1) ? 2'b00 : s_alu_carryin;
            assign mod_raluF  = s_alu_carryin[1] ? muldivregmsb : raluF;
            
            reg        rrlastshift;
            always @(posedge clk)
              rrlastshift <= lastshift;
            assign rlastshift = rrlastshift;
            
            wire       prealucyin;
            assign sra_msb = FUNC7_5 ? ADR_O_31 : (FUNC7_0 ? mod_raluF : 0);
            assign prealucyin = mod_raluF | ADR_O_31;
            assign alu_carryin = &mod_s_alu_carryin | (mod_s_alu_carryin[1] & prealucyin) | (mod_s_alu_carryin[0] & prealucyin);

         end else begin

            reg r_alu_carryin, r_sra_msb;
            always @(/*AS*/raluF or s_alu_carryin) 
              case ( s_alu_carryin )
                2'b00 : r_alu_carryin = 1'b0;
                2'b01 : r_alu_carryin = raluF;
                2'b10 : r_alu_carryin = raluF;
                2'b11 : r_alu_carryin = 1'b1;
              endcase
            always @(/*AS*/ADR_O_31 or FUNC7_5) 
              r_sra_msb = FUNC7_5 ? ADR_O_31 : 1'b0;
            assign sra_msb = r_sra_msb;
            assign alu_carryin = r_alu_carryin;
            reg rrlastshift;
            always @(posedge clk)
              rrlastshift <= lastshift;
            assign rlastshift = rrlastshift;

         end
      end else begin
         
         if ( MULDIV != 0 ) begin

            wire [1:0] mod_s_alu_carryin;
            wire       mod_raluF;
            /*
             * When MULDIV was added, control to this module was changed like this:
             *     assign mod_s_alu_carryin = (mod_s_alu_1 ^ s_alu_1) ? 2'b00 : s_alu_carryin;
             * Experimentally, it seems to be enough to do 
             *     assign mod_s_alu_carryin[0] = (mod_s_alu_1 ^ s_alu_1) ? 1'b0 : s_alu_carryin[0];
             *     assign mod_s_alu_carryin[1] = s_alu_carryin[1];
             * so until further, I go with this reduced version.
             */
            bn_l4v #(.I(16'h8282)) lmod_s_alu_carryin0( .o(mod_s_alu_carryin[0]), .i({1'b0,mod_s_alu_1,s_alu_1,s_alu_carryin[0]}));
            assign mod_s_alu_carryin[1] = s_alu_carryin[1];

            bn_l4v #(.I(16'hcaca)) lmod_raluF(.o(mod_raluF), .i({1'b0,s_alu_carryin[1],muldivregmsb,raluF}));
            
            wire prealucyin,dup_lastshift;
            bn_lcy4v_b #(.I(16'hf088)) lb(.o(sra_msb),       .co(prealucyin),  .ci(1'b1),       .i({FUNC7_5,ADR_O_31,mod_raluF,FUNC7_0}));
            bn_lcy4v_b #(.I(16'haaaa)) la(.o(dup_lastshift), .co(alu_carryin), .ci(prealucyin), .i({1'b0,mod_s_alu_carryin,lastshift}));
            SB_DFF reglastshift( .Q(rlastshift), .C(clk), .D(dup_lastshift));

         end else begin
            
            wire prealucyin,dup_lastshift;
            bn_lcy4v_b #(.I(16'hf088)) lb(.o(sra_msb),       .co(prealucyin),  .ci(1'b1),       .i({FUNC7_5,ADR_O_31,raluF,FUNC7_0}));
            bn_lcy4v_b #(.I(16'haaaa)) la(.o(dup_lastshift), .co(alu_carryin), .ci(prealucyin), .i({1'b0,s_alu_carryin,lastshift}));
            SB_DFF reglastshift( .Q(rlastshift), .C(clk), .D(dup_lastshift));

//            wire prealucyin,dup_lastshift;
//            bn_lcy4v_b #(.I(16'haaaa)) la(.o(dup_lastshift), .co(prealucyin),  .ci(1'b1),       .i({1'b0,1'b0,raluF,lastshift}));
//            bn_lcy4v_b #(.I(16'haa00)) lb(.o(sra_msb),       .co(alu_carryin), .ci(prealucyin), .i({FUNC7_5,s_alu_carryin,ADR_O_31}));
//            SB_DFF reglastshift( .Q(rlastshift), .C(clk), .D(dup_lastshift));            
         end
      end
      
   endgenerate
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * The alu. Operations:
 * 
 * s_alu[2:0]
 * 000 : nearXOR  B = D^(~Q)   
 * 001 : PASSD    B = D
 * 010 : INVQ     B = ~Q       
 * 011 : nearAND  B = D&(~Q)   
 * 100 : ADD      B = D+Q+cin  
 * 101 : SHLQ     B = (Q<<1)|cin (with D=0xffffffff) 
 * 110 : PASSQ    B = Q+cin
 * 111 : nearIOR  B = (~D)|Q     (with cin==0)     
 * 
 * The ALU is constructed out of two columns of LUTs. 
 *      
 *                                | co                            s_alu[1]         
 *                               /y\               s_alu[2]       |s_alu[0]        
 *             ___               |||     ___       |   B          ||  A            
 * Q        --|I0 | A s_alu[2] --(((----|I0 | B    -   -          --  -            
 * s_alu[0] --|I1 |--------------+((----|I1 |--    0   ~(A^QQ)    00  Di           
 * Di       --|I2 |        QQ  ---(+----|I2 |      1   A^QQ^cin   01  ~(Di^Q)      
 * s_alu[1] --|I3_|               +-----|I3_|                     10  0         
 *                                |                               11  (~Di)&(~Q)    
 *                                cin       
 *   
 *  luta=0x01b4 lutb=0xc369
 * 
 * 
 * MTIMETAP_LOWLIM
 * ---------------
 * A constant, but I propagate as a parameter because it is likely to be
 * changed once I know the maximum number of cycles needed to do *any*
 * CSR instruction.
 * 
 * MTIMETAP
 * --------
 * Parameter MTIMETAP determines the frequency of an increment of mtime. If CSR
 * is implemented the value should be between MTIMETAP_LOWLIM and 31 inclusive, 
 * because CSR instructions can take many cycles, and we don't want to skip any 
 * update of mtime.
 * 
 * HIGHLEVEL
 * ---------
 * To get the INSTRUCTION registers packed with the luts of the input mux, and 
 * using the combinatorical output of the input mux to the A-part of the alu, 
 * hand-placement is needed. Easiest done with the  low level implementation. 
 * The low level implementation is the tested one.
 * 
 * ALUWIDTH
 * --------
 * The ALU is always 32 bits in programs, but to ease standalone simulation 
 * it can be instantiated in a slimmer version. To avoid to have to make
 * a wrapper program for simulation the default value of ALUWIDTH is set to 8,
 * while as instantiated from m_midgetv_core ALUWIDTH is always 32.
 * 
 * 
 * A note on the size of the module. 
 * I compiled this module as in a scratch project to assess the size.
 *                          
 * HIGHLEVEL Lattice LSE :  97 SB_LUT4s
 * HIGHLEVEL Synplify Pro:  66 SB_LUT4s
 * LOWLEVEL:                65 SB_LUT4s       
 */

/* verilator lint_off DECLFILENAME */

module m_alu
  # ( parameter HIGHLEVEL = 0,
      HAS_MINSTRET = 0,
      HAS_EBR_MINSTRET = 0,
      MTIMETAP = 0,
`ifdef verilator      
      ALUWIDTH = 8,
`else
      ALUWIDTH = 32,
`endif
      MTIMETAP_LOWLIM = 32
      )
   (
    input [ALUWIDTH-1:0]  Di, //                  First operand to the ALU
    input [ALUWIDTH-1:0]  ADR_O, //               Normally second operand to ALU
    input [ALUWIDTH-1:0]  QQ, //                  Alternate second operand to ALU
    input                 alu_carryin, //         Carry in to ALU
    input [2:0]           s_alu,//                Determines ALU operation
    input                 sa27,sa26,sa25,sa24, // To decode Wttime and Wrinst
    output [ALUWIDTH-1:0] B, //                   ALU result
    output                A31, //                 A[31] == Di[31] during ADD, used in m_condcode. fitte. Rename Amsb
    output                alu_carryout, //        ALU carry out
    output                alu_tapout, //          Used to trigger interrupt for mtime increment/mcycle update
    output                alu_minstretofl //      Used to trigger interrupt for retired instructions
    );

   if ( HIGHLEVEL ) begin
      m_alu_highlevel #
        (.ALUWIDTH(                  ALUWIDTH        ),
         .HAS_MINSTRET(     HAS_MINSTRET     ),
         .HAS_EBR_MINSTRET( HAS_EBR_MINSTRET ),
         .MTIMETAP(                  MTIMETAP        ),
         .MTIMETAP_LOWLIM(           MTIMETAP_LOWLIM )
         )
      inst
        (/*AUTOINST*/
         // Outputs
         .B                             (B[ALUWIDTH-1:0]),
         .A31                           (A31),
         .alu_carryout                  (alu_carryout),
         .alu_tapout                    (alu_tapout),
         .alu_minstretofl               (alu_minstretofl),
         // Inputs
         .Di                            (Di[ALUWIDTH-1:0]),
         .ADR_O                         (ADR_O[ALUWIDTH-1:0]),
         .QQ                            (QQ[ALUWIDTH-1:0]),
         .alu_carryin                   (alu_carryin),
         .s_alu                         (s_alu[2:0]),
         .sa27                          (sa27),
         .sa26                          (sa26),
         .sa25                          (sa25),
         .sa24                          (sa24));
   end else begin
      m_alu_lowlevel #
        (.ALUWIDTH(        ALUWIDTH        ),
         .HAS_MINSTRET(     HAS_MINSTRET     ),
         .HAS_EBR_MINSTRET( HAS_EBR_MINSTRET ),
         .MTIMETAP(        MTIMETAP        ),
         .MTIMETAP_LOWLIM( MTIMETAP_LOWLIM )
         )
      inst
        (/*AUTOINST*/
         // Outputs
         .B                             (B[ALUWIDTH-1:0]),
         .A31                           (A31),
         .alu_carryout                  (alu_carryout),
         .alu_tapout                    (alu_tapout),
         .alu_minstretofl               (alu_minstretofl),
         // Inputs
         .Di                            (Di[ALUWIDTH-1:0]),
         .ADR_O                         (ADR_O[ALUWIDTH-1:0]),
         .QQ                            (QQ[ALUWIDTH-1:0]),
         .alu_carryin                   (alu_carryin),
         .s_alu                         (s_alu[2:0]),
         .sa27                          (sa27),
         .sa26                          (sa26),
         .sa25                          (sa25),
         .sa24                          (sa24));
   end
endmodule



/* =============================================================================
 */
module m_alu_highlevel
  # ( parameter MTIMETAP = 0,
      HAS_MINSTRET = 0,
      HAS_EBR_MINSTRET = 0,
      ALUWIDTH = 8,
      MTIMETAP_LOWLIM = 32
      )
   (
    input [ALUWIDTH-1:0]  Di,
    input [ALUWIDTH-1:0]  ADR_O,
    input [ALUWIDTH-1:0]  QQ, 
    input                 alu_carryin,
    input [2:0]           s_alu,
/* verilator lint_off UNUSED */
    input                 sa27,sa26,sa25,sa24, 
/* verilator lint_on UNUSED */ 
    output [ALUWIDTH-1:0] B,
    output                A31,
    output                alu_carryout,
    output                alu_tapout,
    output                alu_minstretofl
    );   
   reg [ALUWIDTH-1:0]     A;
   
   /* Model of the first row of LUTs. Also set A31 used instead of Di[31] 
    * in m_condcode so a chained LUT can be used. See m_condcode.
    */
   always @(*) 
     case ({s_alu[1],s_alu[0]})
       2'b00 : A = Di;
       2'b01 : A = ~(Di^ADR_O);
       2'b10 : A = 0;
       2'b11 : A = (~Di)&(~ADR_O);
     endcase
   assign A31 = A[ALUWIDTH-1];
   
   /* Model second row of LUTs. The carry out is different in the highlevel
    * and the low-level code, but is equal when it counts - during ADD.
    */
   assign {alu_carryout,B} = s_alu[2] ? A+QQ+{{ALUWIDTH{1'b0}},alu_carryin} : {1'b0,~(A^QQ)};

   /* For mtimeinc interrupts, only defined when we tap out
    * a bit of mtime.
    */
   if ( MTIMETAP < MTIMETAP_LOWLIM || MTIMETAP >= ALUWIDTH ) begin
      assign alu_tapout = 1'b0;
   end else begin
      wire isWttime;
      assign isWttime = {sa27,sa26,sa25,sa24} == 4'b1011;      
      assign alu_tapout = (~A[MTIMETAP] & B[MTIMETAP]) & isWttime;
   end
   
   /* For retired instructions interrupt
    */
   if ( (MTIMETAP < MTIMETAP_LOWLIM) ||
        (HAS_MINSTRET == 0 && HAS_EBR_MINSTRET == 0)        
        )  begin
      assign alu_minstretofl = 1'b0; 
   end else begin
      wire isWrinst = {sa27,sa26,sa25,sa24} == 4'b1001;
      assign alu_minstretofl = alu_carryout & isWrinst;
   end
endmodule

/* =============================================================================
 */
module m_alu_lowlevel
  # ( parameter MTIMETAP = 0,
      HAS_MINSTRET = 0,
      HAS_EBR_MINSTRET = 0,
      ALUWIDTH = 8,
      MTIMETAP_LOWLIM = 32
      )
   (
    input [ALUWIDTH-1:0]  Di,
    input [ALUWIDTH-1:0]  ADR_O,
    input [ALUWIDTH-1:0]  QQ, 
    input                 alu_carryin, 
    input [2:0]           s_alu,
/* verilator lint_off UNUSED */
    input                 sa27,sa26,sa25,sa24,
/* verilator lint_on UNUSED */ 
    output [ALUWIDTH-1:0] B,
    output                A31,
    output                alu_carryout,
    output                alu_tapout,
    output                alu_minstretofl
    );
   
   wire [ALUWIDTH-1:0]    A;
   
   /* verilator lint_off UNOPTFLAT */
   wire [ALUWIDTH:0]      alucy; 
   /* verilator lint_on UNOPTFLAT */

   /* This is the alu proper
    */
   assign alucy[0] = alu_carryin;
   bn_l4 #(.I(16'h04b4)) a [ALUWIDTH-1:0] (.o(A), .i3(s_alu[1]), .i2(Di), .i1(s_alu[0]), .i0(ADR_O));
   bn_lcy4 #(.I(16'hc369)) b [ALUWIDTH-1:0] (.o(B), .co(alucy[ALUWIDTH:1]), .i3(alucy[ALUWIDTH-1:0]), .i2(QQ), .i1(A),.i0(s_alu[2]));
   assign A31 = A[ALUWIDTH-1];

   /* When we increment the low 32-bit of mtime, we have a carry into bit MTIMETAP only
    * when the output bit B[MTIMETAP] is set, but the input bit A[MTIMETAP] was clear. 
    */
   if ( MTIMETAP < MTIMETAP_LOWLIM || MTIMETAP > ALUWIDTH ) begin
      assign alu_tapout = 1'b0;
   end else begin
      wire isWttime;
      bn_l4v #(.I(16'h0800)) l_isWttime( .o(isWttime), .i({sa27,sa26,sa25,sa24}));
      bn_l4v #(.I(16'h4040)) l_alu_tapout( .o(alu_tapout), .i({1'b0,isWttime,B[MTIMETAP],A[MTIMETAP]}));
   end 

   /* If we have interrupts I assume we also have an instruction counter.
    * This is not neccesarely true, but due to dependencies in the microcode,
    * I presently always make this logic.
    * To replicate the carry out of the ALU, I add one more element to the column.
    * See issue #13.
    */
   wire propcy;
   if ( (MTIMETAP < MTIMETAP_LOWLIM) ||
        (HAS_MINSTRET == 0 && HAS_EBR_MINSTRET == 0) 
        ) begin
      assign propcy = alucy[ALUWIDTH];
      assign alu_minstretofl = 1'b0; // Keep Verilator happy
   end else begin
      wire isWrinst;
      bn_l4v #(.I(16'h0200)) l_isWrinst( .o(isWrinst), .i({sa27,sa26,sa25,sa24}));
      bn_lcy4v #(.I(16'haa00)) l_alu_minstretofl( .o(alu_minstretofl), .co(propcy), .i({alucy[ALUWIDTH],2'b01,isWrinst}));
   end
   assign alu_carryout = propcy;
   
endmodule

/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * Immediate operand expander, zero-finder, and working register ADR_O.
 * The high level code seems to work, but is some 60 LUTs larger than 
 * the low level code of 49 LUTs.
 */
module m_immexp_zfind_q
  # ( parameter HIGHLEVEL = 0, ALUWIDTH = 32 )
   (
    input [ALUWIDTH-1:0]  B, //           Output from ALU
    input                 clk, //         System clock
    input                 sa11, //        True when immediate expand
    input                 sa14, //        If low, clear Q. (enaQ must also be high)
    input                 corerunning, // When not running, keep Q clear.
    input                 enaQ, //        Update Q
   /* verilator lint_off UNUSED */
    input [31:0]          INSTR, //       
   /* verilator lint_on UNUSED */
    output                rzcy32, //      When 0, ADR_O==32'h0 
    output [ALUWIDTH-1:0] ADR_O, //       Register used in many places, also I/O address
    output                m_immexp_zfind_q_killwarnings
    );
   assign m_immexp_zfind_q_killwarnings = &INSTR[1:0];
   
   /* Instruction 
    * sa11 (immediate expand)
    * |
    * |             sa09
    * |             |sa08
    * | 65432 10    ||sa07
    * - ----- --    ---
    * 0             111   Cycle in instruction that is not decode
    * 1 00000 11    101   Load    I-type
    * 1 00100 11    101   Reg-Int I-type
    * 1 11001 11    101   JALR    I-type
    * 1 00101 11    000   AUIPC   U-type
    * 1 01000 11    100   Store   S-type
    * 1 01100 11    101   Reg-Reg I-type (may be don't care)
    * 1 01101 11    000   LUI     U-type
    * 1 11000 11    010   condb   B-type
    * 1 11011 11    001   JAL     J-type
    * 1 11100 11    101   CSR     I-type
    * 1             xxx   illegal
    * 
    */
//
//   wire sa10 = (sa09 & sa08 & sa07) | (~sa09 & ~sa08 & ~sa07);
//   wire sa31 = (sa09 & sa08 & sa07) | (~sa09 & ~sa08);
//   wire sa13 = ( sa09 & ~sa08 & I[31]) |
//        (~sa09 &  sa08 & ~sa07 & I[31]) |
//        (~sa09 & ~sa08 & (I[31] | ~sa07));
//   wire sa13b = ( sa09 & ~sa08 & I[31]) |
//        (~sa09 &  sa08 & ~sa07 & I[31]) |
//        (~sa09 & ~sa08);

   /* sa09
    * 65432     
    * 00101     0
    * 01101     0
    * 11000     0
    * 11011     0
    
    * 00000     1
    * 00100     1
    * 01000     1
    * 01100     1
    * 11001     1
    * 11100     1
    */
   
   /* sa07
    * 65432     sa07
    * -----     -
    * 00101     0   AUIPC   U-type
    * 01000     0   Store   S-type
    * 01101     0   LUI     U-type
    * 11000     0   condb   B-type

    * 00000     1   Load    I-type
    * 00100     1   Reg-Int I-type
    * 01100     1   Reg-Reg I-type (may be don't care)
    * 11001     1   JALR    I-type
    * 11011     1   JAL     J-type
    * 11100     1   CSR     I-type
    */
   generate
      if ( HIGHLEVEL != 0 ) begin

         // =======================================================
         // HIGLEVEL
         // =======================================================
         
         reg [ALUWIDTH-1:0] r_ADR_O;
         /* verilator lint_off UNUSED */
         reg [31:0] F;
         /* verilator lint_on UNUSED */
         reg [2:0]          instrty;
         reg                r_rzcy32;
         wire               BisnotZero;
         
         always @(/*AS*/INSTR or sa11)
           casez ({sa11,INSTR[6:2]})
             6'b0????? : instrty = 3'b111;  //  Cycle in instruction that is not decode
             6'b100000 : instrty = 3'b101;  //  Load    I-type                         
             6'b100100 : instrty = 3'b101;  //  Reg-Int I-type                         
             6'b111001 : instrty = 3'b101;  //  JALR    I-type                         
             6'b100101 : instrty = 3'b000;  //  AUIPC   U-type                         
             6'b101000 : instrty = 3'b100;  //  Store   S-type                         
             6'b101100 : instrty = 3'b101;  //  Reg-Reg I-type (may be don't care)     
             6'b101101 : instrty = 3'b000;  //  LUI     U-type                         
             6'b111000 : instrty = 3'b010;  //  condb   B-type                         
             6'b111011 : instrty = 3'b001;  //  JAL     J-type                         
             6'b111100 : instrty = 3'b101;  //  CSR     I-type
             6'b100010 : instrty = 3'b101;  //  Custom "ij"
             default :   instrty = 3'b000;  //  illegal                                
           endcase
         
         always @(/*AS*/B or INSTR or instrty)
           casez (instrty)
             3'b000 : F = INSTR & 32'hfffff000; // U-type
             3'b001 : F = {{12{INSTR[31]}},INSTR[19:12],INSTR[20],INSTR[30:21],1'b0}; // J-type
             3'b010 : F = {{20{INSTR[31]}},INSTR[7],INSTR[30:25],INSTR[11:8],1'b0};   // B-type
             3'b100 : F = {{21{INSTR[31]}},INSTR[30:25],INSTR[11:8],INSTR[7]};        // S-type
             3'b101 : F = {{21{INSTR[31]}},INSTR[30:25],INSTR[24:20]};                // I-type
             3'b111 : F[ALUWIDTH-1:0] = B; // No immediate expansion
//           default :F = 32'h?;  // This line makes verilator fail -- why?
             default :F = 32'hdeadbabe; 
           endcase
         assign BisnotZero = B != 0; // Note: This is NOT 100% eqivalent to the low level version, where we get it out of a carry chain.

         always @(posedge clk) begin
            if ( enaQ ) begin
               if ( ~sa14 | ~corerunning ) begin
                  r_ADR_O <= {ALUWIDTH{1'b0}};
                  r_rzcy32 <= 1'b0;
               end else begin
                  r_ADR_O <= F[ALUWIDTH-1:0];
                  r_rzcy32 <= BisnotZero;
               end
            end
         end
         assign ADR_O = r_ADR_O;
         assign rzcy32 = r_rzcy32;
         
      end else begin

         // =======================================================
         // LOWLEVEL
         // =======================================================
         
         wire           sa07h;
         wire           sa09,sa08,sa07;
         wire           sa09h,sa10,sa31,sa13,sa13b;
         //   wire zcy[32:0];         Verilator throws an UNOPTFLAT warning at this. Because I must write
         //   assign zcy[0] = 1'b0;   so many lines anyway, I chose to split out the signals to avoid the warning.
         wire           zcy32,zcy31,zcy30,
                        zcy29,zcy28,zcy27,zcy26,zcy25,zcy24,zcy23,zcy22,zcy21,zcy20,
                        zcy19,zcy18,zcy17,zcy16,zcy15,zcy14,zcy13,zcy12,zcy11,zcy10,
                        zcy9,zcy8,zcy7,zcy6,zcy5,zcy4,zcy3,zcy2,zcy1,zcy0;   
         wire           imm0a,imm1a,imm2a,imm3a,imm4a,imm11a,imm11b,BisnotZero;
         wire [31:0]    F;
         genvar         j;

         SB_LUT4 # (.LUT_INIT(16'hee45)) L_1598(.O(sa07h),.I3(INSTR[6]),.I2(INSTR[5]),.I1(INSTR[4]),.I0(INSTR[2]));
         SB_LUT4 # (.LUT_INIT(16'hf0ff)) l_sa07(.O(sa07), .I3(sa11), .I2(sa07h), .I1(1'b0), .I0(1'b0));
         SB_LUT4 # (.LUT_INIT(16'h10ff)) L_1599(.O(sa08),.I3(sa11),.I2(INSTR[6]),.I1(INSTR[4]),.I0(INSTR[2]));             
         SB_LUT4 # (.LUT_INIT(16'hf255)) l_sa09h(.O(sa09h),.I3(INSTR[6]),.I2(INSTR[4]),.I1(INSTR[3]),.I0(INSTR[2]));
         SB_LUT4 # (.LUT_INIT(16'hf0ff)) l_sa09(.O(sa09), .I3(sa11), .I2(sa09h), .I1(1'b0), .I0(1'b0));
         SB_LUT4 # (.LUT_INIT(16'h8181)) L_1603(.O(sa10),.I3(1'b0),.I2(sa09),.I1(sa08),.I0(sa07));                            
         SB_LUT4 # (.LUT_INIT(16'h8383)) L_1604(.O(sa31),.I3(1'b0),.I2(sa09),.I1(sa08),.I0(sa07));                            
         SB_LUT4 # (.LUT_INIT(16'h0a2b)) L_1605(.O(sa13),.I3(sa09),.I2(sa08),.I1(sa07),.I0(INSTR[31]));                    
         SB_LUT4 # (.LUT_INIT(16'h0a2f)) L_1606(.O(sa13b),.I3(sa09),.I2(sa08),.I1(sa07),.I0(INSTR[31]));          
         
/*                                                          
 * Immediate expansion is combined with zero-detect of the ALU result.
 * Drawing is not 100% correct, but give the idea.
 *
 *                                                   ___
 *                                               ---|O0 |
 *                                               ---|I1 |-- is_brcond
 *                                               ---|I2 | 
 *                                               +--|I3_|   
 *                                               | zcy[32]
 *                                              /y\  ___            sa10 
 *                               LoadImmD[31] --(((-|O0 |           |sa13
 *                                      B[31] --((+-|I1 |-- F[31]   ||     F[31]
 *                                       sa10 --+(--|I2 |           00     0 = LoadImmD[31]
 *                                       sa13 ---(--|I3_|           01     1 = LoadImmD[31] 
 *                                               |                  10     B[31]  
 *                                               |                  11     LoadImmD[31]
 *                                               |
 *                                               |                  sa10
 *                                              /y\  ___            |sa13         
 *                               LoadImmD[30] --(((-|O0 |           ||     F[30] 
 *                                      B[30] --((+-|I1 |-- F[30]   00     0 = LoadImmD[31]
 *                                       sa10 --+(--|I2 |           01     1 = LoadImmD[31]
 *                                       sa13 ---(--|I3_|           10     B[30]  
 *                                               |                  11     LoadImmD[30]
 *                                               |
 *                                               :                  sa10
 *                                              /y\  ___            |sa13
 *                               LoadImmD[20] --(((-|O0 |           ||     F[20]
 *                                      B[20] --((+-|I1 |-- F[20]   00     0 == LoadImmD[31]
 *                                       sa10 --+(--|I2 |           01     B[20]  
 *                                       sa13 ---(--|I3_|           10     1 == LoadImmD[31]
 *                                               |                  11     LoadImmD[20]
 *                                               |
 *                                              /y\  ___            sa31
 *                               LoadImmD[19] --(((-|O0 |           |sa13  F[19]
 *                                      B[19] --((+-|I1 |-- F[19]   00     0 == LoadImmD[31]    
 *                                       sa31 --+(--|I2 |           01     B[19]  
 *                                       sa13 ---(--|I3_|           10     1 == LoadImmD[31]
 *                                               |                  11     LoadImmD[19]
 *                                               :
 *                                              /y\  ___            sa13          
 *                               LoadImmD[12] --(((-|O0 |           |sa31  F[12]  
 *                                      B[12] --((+-|I1 |-- F[12]   00     0  == LoadImmD[31] 
 *                                       sa31 --+(--|I2 |           01     B[12]  
 *                                       sa13 ---(--|I3_|           10     1  == LoadImmD[31] 
 *                                               |                  11     LoadImmD[12]
 *                                               |
 *                               ___            /y\  ___            sa09
 *                 LoadImmD[7] -|O0 |---b-------(((-|O0 |           |sa08
 *                LoadImmD[31] -|I1 |   B[11] --((+-|I1 |-- F[11]   ||sa07    a            b            F[11]  = a&b&B[11] | ~a&b | ~b&a
 *                        sa08 -|I2 |      1  --+(--|I2 |           000       0            0            0     
 *                        sa09 -|I3_| +-a--------(--|I3_|           001       LoadImmD[20] 0            LoadImmD[20] *                       B[11]                     
 *                                    |          |                  010       0            LoadImmD[7]  LoadImmD[7]  *                     a1|b                        
 *                               ___  |          |                  100       0            LoadImmD[31] LoadImmD[31] *      a         b    ||||  F[11]                 
 *                LoadImmD[20] -|O0 |-+          |                  101       0            LoadImmD[31] LoadImmD[31] * 0000 0    0000  0   0000 x                      
 *                        sa07 -|I1 |            |                  111       1            1            B[11]        * 0001 0    0001  0   0001 x                      
 *                        sa08 -|I2 |            |                                                                   * 0010  0   0010  0   0010 x                      
 *                        sa09 -|I3_|            |                                                                   * 0011  1   0011  0   0011 x                      
 *                                              /y\  ___            sa10                                             * 0100 0    0100 0    0100                        
 *                               LoadImmD[30] --(((-|O0 |           |sa09 F[10]                                      * 0101 0    0101 1    0101  1                     
 *                                      B[10] --((+-|I1 |-- F[10]   00    LoadImmD[30]                               * 0110      0110 0    0110                        
 *                                       sa09 --+(--|I2 |           01    LoadImmD[30]                               * 0111      0111 1    0111  1                     
 *                                       sa10 ---(--|I3_|           10    0                                          * 1000 0    1000  0   1000 x                      
 *                                               |                  11    B[10]                                      * 1001 0    1001  0   1001 x                      
 *                                               :                                                                   * 1010 0    1010  1   1010 x                      
 *                                              /y\  ___            sa10                                             * 1011 0    1011  1   1011 x                      
 *                               LoadImmD[25] --(((-|O0 |           |sa09 F[5]                                       * 1100      1100 1    1100   1                    
 *                                       B[5] --((+-|I1 |-- F[5]    00    LoadImmD[25]                               * 1101      1101 1    1101  0                     
 *                                       sa09 --+(--|I2 |           01    LoadImmD[25]                               * 1110 1    1110 1    1110   1                    
 *                                       sa10 ---(--|I3_|           10    0                                          * 1111 1    1111 1    1111  1   => d0a0, use ddaa.
 *                                               |                  11    B[5] 
 *                                               |
 *                            ___               /y\  ___            sa09
 *             LoadImmD[11] -|O0 | LoadImmD[24]-(((-|O0 |           |sa08
 *                     sa07 -|I1 |       B[4] --((+-|I1 |-- F[4]    ||sa07    a            F[4]
 *                     sa08--|I2 |       sa07 --+(--|I2 |           000       LoadImmD[11] 0
 *                     sa09 -|I3_|---------------(--|I3_|           001       LoadImmD[24] LoadImmD[24]
 *                                               |                  010       LoadImmD[11] LoadImmD[11] 
 *                                               |                  100       LoadImmD[11] LoadImmD[11] 
 *                                               |                  101       LoadImmD[24] LoadImmD[24] 
 *                                               |                  111       LoadImmD[24] B[5] 
 *                                               :
 *                            ___               /y\  ___            sa09                 
 *              LoadImmD[8] -|O0 | LoadImmD[21]-(((-|O0 |           |sa08                
 *                     sa07 -|I1 |       B[1] --((+-|I1 |-- F[1]    ||sa07    a            F[1] 
 *                     sa08--|I2 |       sa07 --+(--|I2 |           000       0            a=0  
 *                     sa09 -|I3_|-------a-------(--|I3_|           001       0            LoadImmD[21]  
 *                                               |                  010       LoadImmD[8]  a=LoadImmD[8] 
 *                                               |                  100       LoadImmD[8]  a=LoadImmD[8] 
 *                                               |                  101       0            LoadImmD[21]  
 *                                               |                  111       1            B[1] 
 *                                               |                  
 *                               ___            /y\  ___            sa09                 
 *                 LoadImmD[7] -|O0 |----a------(((-|O0 |           |sa08                
 *                LoadImmD[20] -|I1 |    B[0] --((+-|I1 |-- F[0]    ||sa07    a            F[0] 
 *                        sa07 -|I2 |    sa08 --+(--|I2 |           000       0            a=0
 *                        sa09 -|I3_|    sa07 ---(--|I3_|           001       0            a=0
 *                                               |                  010       0            0
 *                                              GND                 100       LoadImmD[7]  a=LoadImmD[7]
 *                                                                  101       LoadImmD[20] a=LoadImmD[20]
 *                                                                  111       LoadImmD[20] B[0]
 */
                  
         assign zcy0 = 1'b0;
         SB_LUT4 # ( .LUT_INIT(16'hca00)) L_1788(.O(imm0a), .I3(sa09),  .I2(sa07),.I1(INSTR[20]),.I0(INSTR[7]));      
         SB_LUT4 # ( .LUT_INIT(16'hca0a)) L_1789(.O(F[0]),  .I3(sa07),  .I2(sa08),.I1(B[0]), .I0(imm0a));      SB_CARRY CY_1789(.CO(zcy1), .CI(zcy0), .I1(sa08),.I0(B[0]));
         SB_LUT4 # ( .LUT_INIT(16'hf220)) L_1790(.O(imm1a), .I3(sa09),  .I2(sa08),.I1(sa07), .I0(INSTR[8]));                                          
         SB_LUT4 # ( .LUT_INIT(16'hcfa0)) L_1791(.O(F[1]),  .I3(imm1a), .I2(sa07),.I1(B[1]), .I0(INSTR[21]));  SB_CARRY CY_1791(.CO(zcy2), .CI(zcy1), .I1(sa07),.I0(B[1]));
         SB_LUT4 # ( .LUT_INIT(16'hf220)) L_1792(.O(imm2a), .I3(sa09),  .I2(sa08),.I1(sa07), .I0(INSTR[9]));                                          
         SB_LUT4 # ( .LUT_INIT(16'hcfa0)) L_1793(.O(F[2]),  .I3(imm2a), .I2(sa07),.I1(B[2]), .I0(INSTR[22]));  SB_CARRY CY_1793(.CO(zcy3), .CI(zcy2), .I1(sa07),.I0(B[2]));
         SB_LUT4 # ( .LUT_INIT(16'hf220)) L_1794(.O(imm3a), .I3(sa09),  .I2(sa08),.I1(sa07), .I0(INSTR[10]));                                         
         SB_LUT4 # ( .LUT_INIT(16'hcfa0)) L_1795(.O(F[3]),  .I3(imm3a), .I2(sa07),.I1(B[3]), .I0(INSTR[23]));  SB_CARRY CY_1795(.CO(zcy4), .CI(zcy3), .I1(sa07),.I0(B[3]));
         SB_LUT4 # ( .LUT_INIT(16'hf220)) L_1796(.O(imm4a), .I3(sa09),  .I2(sa08),.I1(sa07), .I0(INSTR[11]));                                         
         SB_LUT4 # ( .LUT_INIT(16'hcfa0)) L_1797(.O(F[4]),  .I3(imm4a), .I2(sa07),.I1(B[4]), .I0(INSTR[24]));  SB_CARRY CY_1797(.CO(zcy5), .CI(zcy4), .I1(sa07),.I0(B[4]));
         SB_LUT4 # ( .LUT_INIT(16'hc0aa)) L_1798(.O(F[5]),  .I3(sa10),  .I2(sa09),.I1(B[5]), .I0(INSTR[25]));  SB_CARRY CY_1798(.CO(zcy6), .CI(zcy5), .I1(sa09),.I0(B[5]));
         SB_LUT4 # ( .LUT_INIT(16'hc0aa)) L_1799(.O(F[6]),  .I3(sa10),  .I2(sa09),.I1(B[6]), .I0(INSTR[26]));  SB_CARRY CY_1799(.CO(zcy7), .CI(zcy6), .I1(sa09),.I0(B[6]));
         SB_LUT4 # ( .LUT_INIT(16'hc0aa)) L_1800(.O(F[7]),  .I3(sa10),  .I2(sa09),.I1(B[7]), .I0(INSTR[27]));  SB_CARRY CY_1800(.CO(zcy8), .CI(zcy7), .I1(sa09),.I0(B[7]));
         SB_LUT4 # ( .LUT_INIT(16'hc0aa)) L_1801(.O(F[8]),  .I3(sa10),  .I2(sa09),.I1(B[8]), .I0(INSTR[28]));  SB_CARRY CY_1801(.CO(zcy9), .CI(zcy8), .I1(sa09),.I0(B[8]));
         SB_LUT4 # ( .LUT_INIT(16'hc0aa)) L_1802(.O(F[9]),  .I3(sa10),  .I2(sa09),.I1(B[9]), .I0(INSTR[29]));  SB_CARRY CY_1802(.CO(zcy10),.CI(zcy9), .I1(sa09),.I0(B[9]));
         SB_LUT4 # ( .LUT_INIT(16'hc0aa)) L_1803(.O(F[10]), .I3(sa10),  .I2(sa09),.I1(B[10]),.I0(INSTR[30]));  SB_CARRY CY_1803(.CO(zcy11),.CI(zcy10),.I1(sa09),.I0(B[10]));
         SB_LUT4 # ( .LUT_INIT(16'hc008)) L_1804(.O(imm11a),.I3(sa09),  .I2(sa08),.I1(sa07), .I0(INSTR[20]));            
         SB_LUT4 # ( .LUT_INIT(16'hfca0)) L_1805(.O(imm11b),.I3(sa09),  .I2(sa08),.I1(INSTR[31]),.I0(INSTR[7]));     
         SB_LUT4 # ( .LUT_INIT(16'hddaa)) L_1806(.O(F[11]), .I3(imm11a),.I2(1'b1),.I1(B[11]),.I0(imm11b));     SB_CARRY CY_1806(.CO(zcy12),.CI(zcy11),.I1(1'b1),.I0(B[11]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1808(.O(F[12]), .I3(sa13b), .I2(sa31),.I1(B[12]),.I0(INSTR[12]));  SB_CARRY CY_1808(.CO(zcy13),.CI(zcy12),.I1(sa31),.I0(B[12]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1810(.O(F[13]), .I3(sa13b), .I2(sa31),.I1(B[13]),.I0(INSTR[13]));  SB_CARRY CY_1810(.CO(zcy14),.CI(zcy13),.I1(sa31),.I0(B[13]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1811(.O(F[14]), .I3(sa13b), .I2(sa31),.I1(B[14]),.I0(INSTR[14]));  SB_CARRY CY_1811(.CO(zcy15),.CI(zcy14),.I1(sa31),.I0(B[14]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1812(.O(F[15]), .I3(sa13b), .I2(sa31),.I1(B[15]),.I0(INSTR[15]));  SB_CARRY CY_1812(.CO(zcy16),.CI(zcy15),.I1(sa31),.I0(B[15]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1813(.O(F[16]), .I3(sa13b), .I2(sa31),.I1(B[16]),.I0(INSTR[16]));  SB_CARRY CY_1813(.CO(zcy17),.CI(zcy16),.I1(sa31),.I0(B[16]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1814(.O(F[17]), .I3(sa13b), .I2(sa31),.I1(B[17]),.I0(INSTR[17]));  SB_CARRY CY_1814(.CO(zcy18),.CI(zcy17),.I1(sa31),.I0(B[17]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1815(.O(F[18]), .I3(sa13b), .I2(sa31),.I1(B[18]),.I0(INSTR[18]));  SB_CARRY CY_1815(.CO(zcy19),.CI(zcy18),.I1(sa31),.I0(B[18]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1816(.O(F[19]), .I3(sa13b), .I2(sa31),.I1(B[19]),.I0(INSTR[19]));  SB_CARRY CY_1816(.CO(zcy20),.CI(zcy19),.I1(sa31),.I0(B[19]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1818(.O(F[20]), .I3(sa13),  .I2(sa10),.I1(B[20]),.I0(INSTR[20]));  SB_CARRY CY_1818(.CO(zcy21),.CI(zcy20),.I1(sa10),.I0(B[20]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1819(.O(F[21]), .I3(sa13),  .I2(sa10),.I1(B[21]),.I0(INSTR[21]));  SB_CARRY CY_1819(.CO(zcy22),.CI(zcy21),.I1(sa10),.I0(B[21]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1820(.O(F[22]), .I3(sa13),  .I2(sa10),.I1(B[22]),.I0(INSTR[22]));  SB_CARRY CY_1820(.CO(zcy23),.CI(zcy22),.I1(sa10),.I0(B[22]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1821(.O(F[23]), .I3(sa13),  .I2(sa10),.I1(B[23]),.I0(INSTR[23]));  SB_CARRY CY_1821(.CO(zcy24),.CI(zcy23),.I1(sa10),.I0(B[23]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1822(.O(F[24]), .I3(sa13),  .I2(sa10),.I1(B[24]),.I0(INSTR[24]));  SB_CARRY CY_1822(.CO(zcy25),.CI(zcy24),.I1(sa10),.I0(B[24]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1823(.O(F[25]), .I3(sa13),  .I2(sa10),.I1(B[25]),.I0(INSTR[25]));  SB_CARRY CY_1823(.CO(zcy26),.CI(zcy25),.I1(sa10),.I0(B[25]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1824(.O(F[26]), .I3(sa13),  .I2(sa10),.I1(B[26]),.I0(INSTR[26]));  SB_CARRY CY_1824(.CO(zcy27),.CI(zcy26),.I1(sa10),.I0(B[26]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1825(.O(F[27]), .I3(sa13),  .I2(sa10),.I1(B[27]),.I0(INSTR[27]));  SB_CARRY CY_1825(.CO(zcy28),.CI(zcy27),.I1(sa10),.I0(B[27]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1826(.O(F[28]), .I3(sa13),  .I2(sa10),.I1(B[28]),.I0(INSTR[28]));  SB_CARRY CY_1826(.CO(zcy29),.CI(zcy28),.I1(sa10),.I0(B[28]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1827(.O(F[29]), .I3(sa13),  .I2(sa10),.I1(B[29]),.I0(INSTR[29]));  SB_CARRY CY_1827(.CO(zcy30),.CI(zcy29),.I1(sa10),.I0(B[29]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1828(.O(F[30]), .I3(sa13),  .I2(sa10),.I1(B[30]),.I0(INSTR[30]));  SB_CARRY CY_1828(.CO(zcy31),.CI(zcy30),.I1(sa10),.I0(B[30]));
         SB_LUT4 # ( .LUT_INIT(16'hafc0)) L_1829(.O(F[31]), .I3(sa13),  .I2(sa10),.I1(B[31]),.I0(INSTR[31]));  SB_CARRY CY_1829(.CO(zcy32),.CI(zcy31),.I1(sa10),.I0(B[31]));
         
         SB_LUT4 # ( .LUT_INIT(16'hff00)) cmb_zcy32(.O(BisnotZero), .I3(zcy32), .I2(1'b0), .I1(1'b0), .I0(1'b0));

//         SB_LUT4 # ( .LUT_INIT(16'hbbbb)) cmb_sa14_or_nCORERUNNING( .O(sa14_or_nCORERUNNING), .I3(1'b0), .I2(1'b0), .I1(corerunning), .I0(sa14));
         wire           nsa14_or_nCORERUNNING;
         SB_LUT4 # ( .LUT_INIT(16'h7777)) cmb_sa14_or_nCORERUNNING( .O(nsa14_or_nCORERUNNING), .I3(1'b0), .I2(1'b0), .I1(corerunning), .I0(sa14));
         for ( j = 0; j < 32; j = j + 1 ) begin : blk0
            SB_DFFESR r(.Q(ADR_O[j]), .C(clk), .E(enaQ), .D(F[j]), .R(nsa14_or_nCORERUNNING));
         end
//         SB_DFFESR rNE0(.Q(rzcy32), .D(BisnotZero), .C(clk), .E(enaQ), .R(sa14));
         SB_DFFESR rNE0(.Q(rzcy32), .D(BisnotZero), .C(clk), .E(enaQ), .R(nsa14_or_nCORERUNNING));
      end
      endgenerate
   
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * This is a wrapper unit.
 * 
 * 
 * Nearly Wishbone B.4 data sheet for m_ram. The only reason I can not
 * call this a Wishbone interface is that midgetv require a read latency
 * of 1 cycle (or higher). In other words, midgetv can not support SRAM
 * implemented as a Wishbone classical read cycle with no latency.
 * 
 * --------------------------------------------------------------------
 * Inteface type:                   SLAVE
 * General description:             0/16384/32768 * 32-bit memory
 * Supported cycles:                SLAVE, READ/WRITE
 *                                  SLAVE, BLOCK READ/WRITE
 *                                  SLAVE, RMW
 * Data port, size:                 32-bit
 * Data port, granularity:          8-bit
 * Data port, maximum operand size: 32-bit
 * Data transfer ordering:          Big endian and/or little endian
 * Data transfer sequencing:        Undefined
 * Supported signal list            Signal name   WISHBONE Equiv. 
 *   and cross-reference to         CLK_I         CLK_I        
 *   equivalent WISHBONE signals:   DAT_I[31:0]   DAT_I()
 *                                  ADR_I[31:0]   ADR_I()
 *                                  STB_I         STB_I        
 *                                  WE_I          WE_I         
 *                                  SEL_I[3:0]    SEL_I()
 *                                  DAT_O[31:0]   DAT_O()
 *                                  ACK_O         ACK_O        
 * 
 * The interface to RAM follows the Wishbone B.4 specification, except:
 *  o  RST_I is not implemented. 
 *     The reason is that if SRAM_READLATENCY == 1 and SRAM_WRITELATENCY == 0,
 *     the wishbone interface of this module can not profit on RST_I in any way.
 *  o  CYC_I is not implemented. This is simply because midgetv sets 
 *     CYC_O == STB_O, so adding CYC_I does not enhance this module in any way.
 *  o  Whishbone B.4 rule 3.55 is disregarded
 * 
 * Please tell me if these assumptions are unresonable. 
 * 
 * The motivation to interface RAM with a Wishbone interface is to later on
 * be able to use a cache. The wrapper is written for efficient instantiation
 * of SRAM in ICE40UP. It is also written so that simulation may play with
 * higher latencies.
 * 
 * Please note: This module should also be able to simulate SRAM_READLATENCY == 0.
 * But the microcode of midgetv depends upon a SRAM_READLATENCY >= 1.
 * 
 * Parameter description: SRAMADRWIDTH
 * --------------------------------
 *
 * Implemented 
 * | Tested
 * | |  SRAMADRWIDTH
 * | |  |    Capacity in KiB
 * | |  |    |    Resources used for datapath/comment
 * x x  0    0    No SRAM implemented                       
 *      9    0.5  1 EBR and logic masquarading as SRAM
 * x   10    1    2 EBRs masquerading as SRAM
 * x   11    2    4 EBRs masquerading as SRAM
 * x x 12    4    8 EBRs masquerading as SRAM
 * x   13    8    16 EBRs masquerading as SRAM
 *     14   16    32 EBRs and logic masquerading as SRAM
 *     15   32    1 SB_SPRAM256KA and logic              
 * x x 16   64    2 SB_SPRAM256KA. Organized as 32 * 14.  
 * x x 17  128    4 SB_SPRAM256KA. Organized as 32 * 15.  
 */
module m_ram
  # ( parameter HIGHLEVEL = 0, SRAMADRWIDTH = 16 )
   (
    input         CLK_I, // System clock
    input [31:0]  DAT_I, // Data out from core, into RAM
    input [31:0]  ADR_I, // Address to read/write
    input         STB_I, // Ram is accessed
    input         WE_I, //  Write cycle
    input [3:0]   SEL_I, // Byte select signals
    /* verilator lint_off UNUSED */
    input [3:0]   bmask, // Inverse of above
    /* verilator lint_on UNUSED */
    output [31:0] DAT_O, // Data out
    output        ACK_O, // Acknowledge after operation
    output        m_ram_killwarnings
    );

   /*AUTOWIRE*/
   
   generate
      if ( SRAMADRWIDTH == 0 ) begin
         // No SRAM at all
         assign DAT_O = 32'h0;
         assign ACK_O = 1'b0;
         assign m_ram_killwarnings = CLK_I & STB_I & WE_I & &ADR_I & &DAT_I & &SEL_I;
      end else if ( SRAMADRWIDTH == 17 ) begin
         wire            m_ram_a17_killwarnings;
         // End of automatics
         m_ram_a17 #(.HIGHLEVEL(HIGHLEVEL))
         m_ram_inst
           (/*AUTOINST*/
            // Outputs
            .DAT_O                      (DAT_O[31:0]),
            .ACK_O                      (ACK_O),
            .m_ram_a17_killwarnings     (m_ram_a17_killwarnings),
            // Inputs
            .CLK_I                      (CLK_I),
            .DAT_I                      (DAT_I[31:0]),
            .ADR_I                      (ADR_I[16:0]),
            .STB_I                      (STB_I),
            .WE_I                       (WE_I),
            .SEL_I                      (SEL_I[3:0]));

         assign m_ram_killwarnings = &bmask & CLK_I & STB_I & WE_I & &ADR_I & &DAT_I & &SEL_I | m_ram_a17_killwarnings;

      end else if ( SRAMADRWIDTH == 16 ) begin

         wire            m_ram_a16_killwarnings;
         m_ram_a16 #(.HIGHLEVEL(HIGHLEVEL)) // 15:2 used as address
         m_ram_inst
           (/*AUTOINST*/
            // Outputs
            .DAT_O                      (DAT_O[31:0]),
            .ACK_O                      (ACK_O),
            .m_ram_a16_killwarnings     (m_ram_a16_killwarnings),
            // Inputs
            .CLK_I                      (CLK_I),
            .DAT_I                      (DAT_I[31:0]),
            .ADR_I                      (ADR_I[15:0]),
            .STB_I                      (STB_I),
            .WE_I                       (WE_I),
            .SEL_I                      (SEL_I[3:0]));
         assign m_ram_killwarnings = &bmask & CLK_I & STB_I & WE_I & &ADR_I & &DAT_I & &SEL_I | m_ram_a16_killwarnings;
         
      end else if ( SRAMADRWIDTH >= 10 && SRAMADRWIDTH <= 13 ) begin

         wire we;
         if ( HIGHLEVEL ) begin
            assign we  = STB_I & WE_I;
            reg  readack;
            wire cmb_readack = ~readack & STB_I & ~WE_I;
            always @(posedge CLK_I)
              readack <= cmb_readack;
            assign ACK_O = readack | we;
         end else begin
            wire readack;
            wire cmb_readack;
            SB_LUT4 #(.LUT_INIT(16'h8888)) we_l(.O(we), .I3(1'b0), .I2(1'b0), .I1(STB_I), .I0(WE_I));
            SB_LUT4 #(.LUT_INIT(16'h0404)) readack_l(.O(cmb_readack), .I3(1'b0), .I2(readack), .I1(STB_I), .I0(WE_I)); 
            SB_DFF readack_r(.Q(readack), .C(CLK_I), .D(cmb_readack));
            SB_LUT4 #(.LUT_INIT(16'hf8f8)) ACK_O_l(.O(ACK_O), .I3(1'b0), .I2(readack), .I1(STB_I), .I0(WE_I)); 
         end

         
         wire       next_readvalue_unknown;
         m_ebr #(.EBRADRWIDTH(SRAMADRWIDTH-2))
         inst_ram (// Inputs
                   .Rai                 (ADR_I[SRAMADRWIDTH-1:2]),
                   .Wai                 (ADR_I[SRAMADRWIDTH-1:2]),
                   .iwe                 (we),
                   .B                   (DAT_I[31:0]),
                   .clk                 (CLK_I),
                   /*AUTOINST*/
                   // Outputs
                   .DAT_O               (DAT_O[31:0]),
                   .next_readvalue_unknown(next_readvalue_unknown),
                   // Inputs
                   .bmask               (bmask[3:0]));

         assign m_ram_killwarnings = &ADR_I | next_readvalue_unknown;
         
      end
`ifndef verilator
      else begin
         unsupported_sramwidth inst_can_not_have_this();
      end
`endif
   endgenerate
endmodule

/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * 64 KiB ram using two SB_SPRAM256KA.
 * The highlevel version can be used in simulations to test out different 
 * read/write latencies.
 */
module m_ram_a16
  # ( parameter HIGHLEVEL = 1 )
   (
    input         CLK_I, // System clock
    input [31:0]  DAT_I, // Data out from core, into RAM
    input [15:0]  ADR_I, // Address to read/write
    input         STB_I, // Ram is accessed
    input         WE_I, //  Write cycle
    input [3:0]   SEL_I, // Byte select signals
    output [31:0] DAT_O, // Data out
    output        ACK_O, // Acknowledge after operation
    output        m_ram_a16_killwarnings
    );
   
   localparam SRAM_READLATENCY =  1; // No smaller than 1. For simulation of slow SRAMs can be larger
   localparam SRAM_WRITELATENCY = 0; // Can be higher for simulation of slow SRAMs.
   
   // -----------------------------------------------------------------------------
   // SRAM
   // -----------------------------------------------------------------------------
   wire [31:0]    o;
`ifdef verilator
   wire [31:0]    zo;
`endif
   wire [0:0]     we;
   wire [7:0]     srammask;
   wire           readack;
   wire [31:0]    preDAT_O;
   genvar         j,k;
   
   assign srammask = {{2{SEL_I[3]}},{2{SEL_I[2]}},{2{SEL_I[1]}},{2{SEL_I[0]}}};
   
   SB_SPRAM256KA sram0
     (
      .DATAIN     ( DAT_I[15 : 0]   ),
      .ADDRESS    ( ADR_I[15 : 2]   ),
      .MASKWREN   ( srammask[3 : 0] ),
      .WREN       ( we[0]           ),
      .CLOCK      ( CLK_I           ),
      .CHIPSELECT ( 1'b1            ),
      .POWEROFF   ( 1'b1            ), // Note. Shockingly bad name. Shame on Lattice
      .STANDBY    ( 1'b0            ),
      .SLEEP      ( 1'b0            ),
`ifdef verilator                       
      .preDATAOUT ( zo[15 : 0]      ),
`endif
      .DATAOUT    ( o[15 : 0]       )
      );
   
   SB_SPRAM256KA sram1
     (
      .DATAIN     ( DAT_I[31 :16]   ),
      .ADDRESS    ( ADR_I[15 : 2]   ),
      .MASKWREN   ( srammask[7 : 4] ),
      .WREN       ( we[0]           ),
      .CLOCK      ( CLK_I           ),
      .CHIPSELECT ( 1'b1            ),
      .POWEROFF   ( 1'b1            ), // Note. Shockingly bad name. Shame on Lattice
      .STANDBY    ( 1'b0            ),
      .SLEEP      ( 1'b0            ),
`ifdef verilator                       
      .preDATAOUT ( zo[31 :16]      ),
`endif
      .DATAOUT    ( o[31 :16]       )
      );
   
   generate
      if ( HIGHLEVEL == 1 ) begin
         // -----------------------------------------------------------------------------
         // HIGHLEVEL
         // -----------------------------------------------------------------------------
         wire writeack;
         wire readstrobe;
         
         assign we = STB_I & WE_I;
         if ( SRAM_WRITELATENCY == 0 ) begin
            assign writeack = we;
         end else begin
            /* verilator lint_off UNUSED */
            reg [SRAM_WRITELATENCY:0] writeackdly;
            /* verilator lint_on UNUSED */
            always @(posedge CLK_I) begin
               if ( writeackdly == 0 )
                 writeackdly[SRAM_WRITELATENCY:0] <= {we,writeackdly[SRAM_WRITELATENCY:1]};
               else
                 writeackdly[SRAM_WRITELATENCY:0] <= {1'b0,writeackdly[SRAM_WRITELATENCY:1]};
            end
            assign writeack = writeackdly[1];
         end
         
         assign readstrobe = STB_I & ~WE_I;
         if ( SRAM_READLATENCY == 0) begin
            assign readack = readstrobe;
         end else begin
            /* verilator lint_off UNUSED */
            reg [SRAM_READLATENCY:0] readackdly;
            /* verilator lint_on UNUSED */
            always @(posedge CLK_I) begin
               if ( readackdly == 0 ) 
                 readackdly[SRAM_READLATENCY:0] <= {readstrobe,readackdly[SRAM_READLATENCY:1]};
               else
                 readackdly[SRAM_READLATENCY:0] <= {1'b0,readackdly[SRAM_READLATENCY:1]};
            end
            assign readack = readackdly[1];
         end
         assign ACK_O = readack | writeack;
         
`ifdef verilator
         if ( SRAM_READLATENCY == 0 ) begin
            assign preDAT_O = zo[31:0];
         end else begin
            assign preDAT_O = o[31:0];
         end
         assign DAT_O = ACK_O ? preDAT_O : 32'habbababa;
`else
         assign preDAT_O = o[31:0];
         assign DAT_O = preDAT_O;
`endif
         
      end else begin
         
         // -----------------------------------------------------------------------------
         // LOWLEVEL
         // -----------------------------------------------------------------------------
         
         SB_LUT4 #(.LUT_INIT(16'h8888)) we_l(.O(we[0]), .I3(1'b0), .I2(1'b0), .I1(STB_I), .I0(WE_I)); 
         assign preDAT_O = o[31:0];
         
         wire cmb_readack;
         SB_LUT4 #(.LUT_INIT(16'h0404)) readack_l(.O(cmb_readack), .I3(1'b0), .I2(readack), .I1(STB_I), .I0(WE_I)); 
         SB_DFF readack_r(.Q(readack), .C(CLK_I), .D(cmb_readack));
         
         //assign ACK_O = readack | writeack;
         SB_LUT4 #(.LUT_INIT(16'hf8f8)) ACK_O_l(.O(ACK_O), .I3(1'b0), .I2(readack), .I1(STB_I), .I0(WE_I)); 
         
         
`ifdef verilator
         /* Not strictly wanted in low-level code,
          * but keep output strictly equal to
          * highlevel. This is only in simulation.
          */
         assign DAT_O = ACK_O ? preDAT_O : 32'habbababa;
`else
         assign DAT_O = preDAT_O;
`endif
      end // HIGHLEVEL
   endgenerate

   assign m_ram_a16_killwarnings = &ADR_I |
`ifdef verilator                                     
                                   &zo |
`endif
                                   &o;            
endmodule      
   
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * 128 KiB ram using 4 SB_SPRAM256KAs.
 */
module m_ram_a17
  # ( parameter HIGHLEVEL = 1 )
   (
    input         CLK_I, // System clock
    input [31:0]  DAT_I, // Data out from core, into RAM
    input [16:0]  ADR_I, // Address to read/write
    input         STB_I, // Ram is accessed
    input         WE_I, //  Write cycle
    input [3:0]   SEL_I, // Byte select signals
    output [31:0] DAT_O, // Data out
    output        ACK_O, // Acknowledge after operation
    output        m_ram_a17_killwarnings
    );
   
         // -----------------------------------------------------------------------------
         // SRAM
         // -----------------------------------------------------------------------------
   wire [63:0]    o;
`ifdef verilator
   wire [63:0]    zo;
`endif
   wire [7:0]     srammask = {{2{SEL_I[3]}},{2{SEL_I[2]}},{2{SEL_I[1]}},{2{SEL_I[0]}}};
   wire [1:0]     we;
   
   generate
      genvar      j,k;
      
      for ( j = 0; j < 2; j = j + 1 ) begin : blk0 //    j is Parallell based on ADR_I[16]
         for ( k = 0; k < 2; k = k + 1 ) begin : blk1 // k is low/high of a word
            SB_SPRAM256KA sram
                   (
                    .DATAIN     ( DAT_I[k*16+15 : k*16]       ),
                    .ADDRESS    ( ADR_I[15 : 2]               ),
                    .MASKWREN   ( srammask[k*4+3 : k*4]       ),
                    .WREN       ( we[j]                       ),
                    .CLOCK      ( CLK_I                       ),
                    .CHIPSELECT ( 1'b1                        ),
                    .POWEROFF   ( 1'b1 ), // Note. Shockingly bad name. Shame on Lattice
                    .STANDBY    ( 1'b0                        ),
                    .SLEEP      ( 1'b0                        ),
`ifdef verilator                       
                    .preDATAOUT ( zo[j*32+k*16+15 : j*32+k*16]),
`endif
                    .DATAOUT    ( o[j*32+k*16+15 : j*32+k*16] )
                    );
         end
      end
   endgenerate
   
   
   wire [31:0] preDAT_O;
   wire        readack;
   
   generate
      if ( HIGHLEVEL != 0 ) begin
         // -----------------------------------------------------------------------------
         // HIGHLEVEL
         // Note to self - at some stage I had a problem with this ram. Erostathenes
         // passed ok, but verify_maxupduino failed.
         // This either had to do with 
         //   o  how the writestrobe was deasserted
         //   o  pipelining of A[16]
         //   o  how readack was declared.
         // But when I now try to pin it down, everything works. Leave this messy
         // code until such time that I can find out what happens.
         // -----------------------------------------------------------------------------
//bn         wire hello_readack;
         wire writestrobe;
         wire writeack;
         wire readstrobe;
         
         assign writestrobe = STB_I &  WE_I;
         assign readstrobe  = STB_I & ~WE_I;

         assign writeack = writestrobe;
         
         /* verilator lint_off UNUSED */
         reg [1:0] readackdly;
         /* verilator lint_on UNUSED */
         always @(posedge CLK_I) begin
            if ( readackdly == 0 ) 
              readackdly[1:0] <= {readstrobe,readackdly[1:1]};
            else
              readackdly[1:0] <= {1'b0,readackdly[1:1]};
         end
//bn         assign hello_readack = readackdly[1];
//bn         assign ACK_O = hello_readack | writeack;

         assign readack = readackdly[1];
         assign ACK_O = readack | writeack;


//         wire writestrobe = STB_I &  WE_I;
//         reg hello_readack;
//         wire cmb_readack = ~hello_readack & STB_I & ~WE_I;
//         always @(posedge CLK_I)
//           hello_readack <= cmb_readack;
//         assign ACK_O = hello_readack | writestrobe;
         
         assign we[0] = writestrobe & ~ADR_I[16];
         assign we[1] = writestrobe &  ADR_I[16];
         // ADR_I[] stable until ACK_O, so need not pipeline ADR_I[16]
         assign preDAT_O = ADR_I[16] ? o[63:32] : o[31:0];

`ifdef verilator
         assign DAT_O = ACK_O ? preDAT_O : 32'habbababa;
`else
         assign DAT_O = preDAT_O;
`endif
      
      end else begin
            
         // -----------------------------------------------------------------------------
         // LOWLEVEL
         // -----------------------------------------------------------------------------
//bn         wire        readack;
         
         SB_LUT4 #(.LUT_INIT(16'h0808)) we0_l(.O(we[0]), .I3(1'b0), .I2(ADR_I[16]), .I1(STB_I), .I0(WE_I)); // assign we[0] = writeack & ~ADR_I[16];
         SB_LUT4 #(.LUT_INIT(16'h8080)) we1_l(.O(we[1]), .I3(1'b0), .I2(ADR_I[16]), .I1(STB_I), .I0(WE_I)); // assign we[1] = writeack &  ADR_I[16];
         // ADR_I[] stable until ACK_O, so need not pipeline ADR_I[16]
         assign preDAT_O = ADR_I[16] ? o[63:32] : o[31:0];

         wire cmb_readack;
         SB_LUT4 #(.LUT_INIT(16'h0404)) readack_l(.O(cmb_readack), .I3(1'b0), .I2(readack), .I1(STB_I), .I0(WE_I)); 
         SB_DFF readack_r(.Q(readack), .C(CLK_I), .D(cmb_readack));
         //assign readstrobe = STB_I & ~WE_I;
         //reg r_readack;
         //always @(posedge CLK_I) 
         //   r_readack <= readstrobe & ~r_readack;
         //assign readack = r_readack;
         
         //assign ACK_O = readack | writeack;
         SB_LUT4 #(.LUT_INIT(16'hf8f8)) ACK_O_l(.O(ACK_O), .I3(1'b0), .I2(readack), .I1(STB_I), .I0(WE_I)); 
         
         
         
         /* Not strictly wanted in low-level code,
          * but keep output strictly equal to
          * highlevel. This is only in simulation.
          */
`ifdef verilator
         assign DAT_O = ACK_O ? preDAT_O : 32'habbababa;
`else
         assign DAT_O = preDAT_O;
`endif
      end // HIGHLEVEL
      
      assign m_ram_a17_killwarnings = &ADR_I |
`ifdef verilator                                     
                                      &zo |
`endif
                                      &o;            
   endgenerate
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * EBR holds constants, registers, and code. This is a wrapper,
 * EBRADRWIDTH  EBRs  Organization   Gives     Capacity  WRITE/READ mode
 *  8           2     16 x  8 *  2   32 x  8   1 kiB     0
 *  9           4      8 x  9 *  4   32 x  9   2 kiB     1
 * 10           8      4 x 10 *  8   32 x 10   4 kiB     2
 * 11           16     2 x 11 * 16   32 x 11   8 kiB     3
 * 
 * In this illustration, for brevity; m0 = bmask0 etc, w=iwe
 * EBRADRWIDTH
 *    EBR15 EBR14 EBR13 EBR12 EBR11 EBR10 EBR9  EBR8  EBR7  EBR6  EBR5  EBR4  EBR3  EBR2  EBR1  EBR0
 *  8                                                                                     w     w
 *  9                                                                         w&m3  w&m2  w&m1  w&m0
 * 10                                                 w&m3  w&m3  w&m2  w&m2  w&m1  w&m1  w&m0  w&m0
 * 11 w&m3  w&m3  w&m3  w&m3  ie&m2 ie&m2 ie&m2 ie&m2 w&m1  w&m1  w&m1  w&m1  w&m0  w&m0  w&m0  w&m0
 * 
 * Rather belatedly I saw a reference to a a silicon bug, https://github.com/YosysHQ/yosys/issues/101.
 * It seems that one should use RCLKE/WCLKE instead of RE/WE. As luck will have it, the bug is that
 * mem[0] is spuriously written by 0 between configuration and before the core is released. As luck 
 * will have it, mem[0] should **always** be 0 in midgetv, so I do not change anything now.
 * Fixed Sept 2020.
 */
module m_ebr
  # ( parameter EBRADRWIDTH = 8,
      parameter [4095:0] prg00 = 4096'h0,
      parameter [4095:0] prg01 = 4096'h0,
      parameter [4095:0] prg02 = 4096'h0,
      parameter [4095:0] prg03 = 4096'h0,
      parameter [4095:0] prg04 = 4096'h0,
      parameter [4095:0] prg05 = 4096'h0,
      parameter [4095:0] prg06 = 4096'h0,
      parameter [4095:0] prg07 = 4096'h0,
      parameter [4095:0] prg08 = 4096'h0,
      parameter [4095:0] prg09 = 4096'h0,
      parameter [4095:0] prg0A = 4096'h0,
      parameter [4095:0] prg0B = 4096'h0,
      parameter [4095:0] prg0C = 4096'h0,
      parameter [4095:0] prg0D = 4096'h0,
      parameter [4095:0] prg0E = 4096'h0,
      parameter [4095:0] prg0F = 4096'h0
      )
   (
    input [31:0]            B, //     Output from ALU
    input [EBRADRWIDTH-1:0] Rai, //   Read address
    input [EBRADRWIDTH-1:0] Wai, //   Write address    
    input                   clk, //   System clock
    input [3:0]             bmask, // Byte masks for write, active LOW
    input                   iwe, //   Write enable
    output [31:0]           DAT_O, //  Register used in many places, also I/O output
    output                  next_readvalue_unknown // For debugging only
    );
   wire [31:0]              eDAT_O;
`ifdef verilator 
   reg                      readvalue_unknown;
   assign next_readvalue_unknown =  ( Rai == Wai && iwe );
   always @(posedge clk)
     readvalue_unknown <= next_readvalue_unknown;
   assign DAT_O = readvalue_unknown ? 32'hdeaddead : eDAT_O;
`else
   assign next_readvalue_unknown = 1'b0;
   assign DAT_O = eDAT_O;
`endif

   /* Split the up to 8 KiB program into low and high halfword
    */
   localparam [4095:0]
     pb7 = {prg0F[4079:4064],prg0F[4047:4032],prg0F[4015:4000],prg0F[3983:3968],prg0F[3951:3936],prg0F[3919:3904],prg0F[3887:3872],prg0F[3855:3840],
            prg0F[3823:3808],prg0F[3791:3776],prg0F[3759:3744],prg0F[3727:3712],prg0F[3695:3680],prg0F[3663:3648],prg0F[3631:3616],prg0F[3599:3584],
            prg0F[3567:3552],prg0F[3535:3520],prg0F[3503:3488],prg0F[3471:3456],prg0F[3439:3424],prg0F[3407:3392],prg0F[3375:3360],prg0F[3343:3328],
            prg0F[3311:3296],prg0F[3279:3264],prg0F[3247:3232],prg0F[3215:3200],prg0F[3183:3168],prg0F[3151:3136],prg0F[3119:3104],prg0F[3087:3072],
            prg0F[3055:3040],prg0F[3023:3008],prg0F[2991:2976],prg0F[2959:2944],prg0F[2927:2912],prg0F[2895:2880],prg0F[2863:2848],prg0F[2831:2816],
            prg0F[2799:2784],prg0F[2767:2752],prg0F[2735:2720],prg0F[2703:2688],prg0F[2671:2656],prg0F[2639:2624],prg0F[2607:2592],prg0F[2575:2560],
            prg0F[2543:2528],prg0F[2511:2496],prg0F[2479:2464],prg0F[2447:2432],prg0F[2415:2400],prg0F[2383:2368],prg0F[2351:2336],prg0F[2319:2304],
            prg0F[2287:2272],prg0F[2255:2240],prg0F[2223:2208],prg0F[2191:2176],prg0F[2159:2144],prg0F[2127:2112],prg0F[2095:2080],prg0F[2063:2048],
            prg0F[2031:2016],prg0F[1999:1984],prg0F[1967:1952],prg0F[1935:1920],prg0F[1903:1888],prg0F[1871:1856],prg0F[1839:1824],prg0F[1807:1792],
            prg0F[1775:1760],prg0F[1743:1728],prg0F[1711:1696],prg0F[1679:1664],prg0F[1647:1632],prg0F[1615:1600],prg0F[1583:1568],prg0F[1551:1536],
            prg0F[1519:1504],prg0F[1487:1472],prg0F[1455:1440],prg0F[1423:1408],prg0F[1391:1376],prg0F[1359:1344],prg0F[1327:1312],prg0F[1295:1280],
            prg0F[1263:1248],prg0F[1231:1216],prg0F[1199:1184],prg0F[1167:1152],prg0F[1135:1120],prg0F[1103:1088],prg0F[1071:1056],prg0F[1039:1024],
            prg0F[1007: 992],prg0F[ 975: 960],prg0F[ 943: 928],prg0F[ 911: 896],prg0F[ 879: 864],prg0F[ 847: 832],prg0F[ 815: 800],prg0F[ 783: 768],
            prg0F[ 751: 736],prg0F[ 719: 704],prg0F[ 687: 672],prg0F[ 655: 640],prg0F[ 623: 608],prg0F[ 591: 576],prg0F[ 559: 544],prg0F[ 527: 512],
            prg0F[ 495: 480],prg0F[ 463: 448],prg0F[ 431: 416],prg0F[ 399: 384],prg0F[ 367: 352],prg0F[ 335: 320],prg0F[ 303: 288],prg0F[ 271: 256],
            prg0F[ 239: 224],prg0F[ 207: 192],prg0F[ 175: 160],prg0F[ 143: 128],prg0F[ 111:  96],prg0F[  79:  64],prg0F[  47:  32],prg0F[  15:   0],
            prg0E[4079:4064],prg0E[4047:4032],prg0E[4015:4000],prg0E[3983:3968],prg0E[3951:3936],prg0E[3919:3904],prg0E[3887:3872],prg0E[3855:3840],
            prg0E[3823:3808],prg0E[3791:3776],prg0E[3759:3744],prg0E[3727:3712],prg0E[3695:3680],prg0E[3663:3648],prg0E[3631:3616],prg0E[3599:3584],
            prg0E[3567:3552],prg0E[3535:3520],prg0E[3503:3488],prg0E[3471:3456],prg0E[3439:3424],prg0E[3407:3392],prg0E[3375:3360],prg0E[3343:3328],
            prg0E[3311:3296],prg0E[3279:3264],prg0E[3247:3232],prg0E[3215:3200],prg0E[3183:3168],prg0E[3151:3136],prg0E[3119:3104],prg0E[3087:3072],
            prg0E[3055:3040],prg0E[3023:3008],prg0E[2991:2976],prg0E[2959:2944],prg0E[2927:2912],prg0E[2895:2880],prg0E[2863:2848],prg0E[2831:2816],
            prg0E[2799:2784],prg0E[2767:2752],prg0E[2735:2720],prg0E[2703:2688],prg0E[2671:2656],prg0E[2639:2624],prg0E[2607:2592],prg0E[2575:2560],
            prg0E[2543:2528],prg0E[2511:2496],prg0E[2479:2464],prg0E[2447:2432],prg0E[2415:2400],prg0E[2383:2368],prg0E[2351:2336],prg0E[2319:2304],
            prg0E[2287:2272],prg0E[2255:2240],prg0E[2223:2208],prg0E[2191:2176],prg0E[2159:2144],prg0E[2127:2112],prg0E[2095:2080],prg0E[2063:2048],
            prg0E[2031:2016],prg0E[1999:1984],prg0E[1967:1952],prg0E[1935:1920],prg0E[1903:1888],prg0E[1871:1856],prg0E[1839:1824],prg0E[1807:1792],
            prg0E[1775:1760],prg0E[1743:1728],prg0E[1711:1696],prg0E[1679:1664],prg0E[1647:1632],prg0E[1615:1600],prg0E[1583:1568],prg0E[1551:1536],
            prg0E[1519:1504],prg0E[1487:1472],prg0E[1455:1440],prg0E[1423:1408],prg0E[1391:1376],prg0E[1359:1344],prg0E[1327:1312],prg0E[1295:1280],
            prg0E[1263:1248],prg0E[1231:1216],prg0E[1199:1184],prg0E[1167:1152],prg0E[1135:1120],prg0E[1103:1088],prg0E[1071:1056],prg0E[1039:1024],
            prg0E[1007: 992],prg0E[ 975: 960],prg0E[ 943: 928],prg0E[ 911: 896],prg0E[ 879: 864],prg0E[ 847: 832],prg0E[ 815: 800],prg0E[ 783: 768],
            prg0E[ 751: 736],prg0E[ 719: 704],prg0E[ 687: 672],prg0E[ 655: 640],prg0E[ 623: 608],prg0E[ 591: 576],prg0E[ 559: 544],prg0E[ 527: 512],
            prg0E[ 495: 480],prg0E[ 463: 448],prg0E[ 431: 416],prg0E[ 399: 384],prg0E[ 367: 352],prg0E[ 335: 320],prg0E[ 303: 288],prg0E[ 271: 256],
            prg0E[ 239: 224],prg0E[ 207: 192],prg0E[ 175: 160],prg0E[ 143: 128],prg0E[ 111:  96],prg0E[  79:  64],prg0E[  47:  32],prg0E[  15:   0]};
   localparam [4095:0]
     pb6 = {prg0D[4079:4064],prg0D[4047:4032],prg0D[4015:4000],prg0D[3983:3968],prg0D[3951:3936],prg0D[3919:3904],prg0D[3887:3872],prg0D[3855:3840],
            prg0D[3823:3808],prg0D[3791:3776],prg0D[3759:3744],prg0D[3727:3712],prg0D[3695:3680],prg0D[3663:3648],prg0D[3631:3616],prg0D[3599:3584],
            prg0D[3567:3552],prg0D[3535:3520],prg0D[3503:3488],prg0D[3471:3456],prg0D[3439:3424],prg0D[3407:3392],prg0D[3375:3360],prg0D[3343:3328],
            prg0D[3311:3296],prg0D[3279:3264],prg0D[3247:3232],prg0D[3215:3200],prg0D[3183:3168],prg0D[3151:3136],prg0D[3119:3104],prg0D[3087:3072],
            prg0D[3055:3040],prg0D[3023:3008],prg0D[2991:2976],prg0D[2959:2944],prg0D[2927:2912],prg0D[2895:2880],prg0D[2863:2848],prg0D[2831:2816],
            prg0D[2799:2784],prg0D[2767:2752],prg0D[2735:2720],prg0D[2703:2688],prg0D[2671:2656],prg0D[2639:2624],prg0D[2607:2592],prg0D[2575:2560],
            prg0D[2543:2528],prg0D[2511:2496],prg0D[2479:2464],prg0D[2447:2432],prg0D[2415:2400],prg0D[2383:2368],prg0D[2351:2336],prg0D[2319:2304],
            prg0D[2287:2272],prg0D[2255:2240],prg0D[2223:2208],prg0D[2191:2176],prg0D[2159:2144],prg0D[2127:2112],prg0D[2095:2080],prg0D[2063:2048],
            prg0D[2031:2016],prg0D[1999:1984],prg0D[1967:1952],prg0D[1935:1920],prg0D[1903:1888],prg0D[1871:1856],prg0D[1839:1824],prg0D[1807:1792],
            prg0D[1775:1760],prg0D[1743:1728],prg0D[1711:1696],prg0D[1679:1664],prg0D[1647:1632],prg0D[1615:1600],prg0D[1583:1568],prg0D[1551:1536],
            prg0D[1519:1504],prg0D[1487:1472],prg0D[1455:1440],prg0D[1423:1408],prg0D[1391:1376],prg0D[1359:1344],prg0D[1327:1312],prg0D[1295:1280],
            prg0D[1263:1248],prg0D[1231:1216],prg0D[1199:1184],prg0D[1167:1152],prg0D[1135:1120],prg0D[1103:1088],prg0D[1071:1056],prg0D[1039:1024],
            prg0D[1007: 992],prg0D[ 975: 960],prg0D[ 943: 928],prg0D[ 911: 896],prg0D[ 879: 864],prg0D[ 847: 832],prg0D[ 815: 800],prg0D[ 783: 768],
            prg0D[ 751: 736],prg0D[ 719: 704],prg0D[ 687: 672],prg0D[ 655: 640],prg0D[ 623: 608],prg0D[ 591: 576],prg0D[ 559: 544],prg0D[ 527: 512],
            prg0D[ 495: 480],prg0D[ 463: 448],prg0D[ 431: 416],prg0D[ 399: 384],prg0D[ 367: 352],prg0D[ 335: 320],prg0D[ 303: 288],prg0D[ 271: 256],
            prg0D[ 239: 224],prg0D[ 207: 192],prg0D[ 175: 160],prg0D[ 143: 128],prg0D[ 111:  96],prg0D[  79:  64],prg0D[  47:  32],prg0D[  15:   0],
            prg0C[4079:4064],prg0C[4047:4032],prg0C[4015:4000],prg0C[3983:3968],prg0C[3951:3936],prg0C[3919:3904],prg0C[3887:3872],prg0C[3855:3840],
            prg0C[3823:3808],prg0C[3791:3776],prg0C[3759:3744],prg0C[3727:3712],prg0C[3695:3680],prg0C[3663:3648],prg0C[3631:3616],prg0C[3599:3584],
            prg0C[3567:3552],prg0C[3535:3520],prg0C[3503:3488],prg0C[3471:3456],prg0C[3439:3424],prg0C[3407:3392],prg0C[3375:3360],prg0C[3343:3328],
            prg0C[3311:3296],prg0C[3279:3264],prg0C[3247:3232],prg0C[3215:3200],prg0C[3183:3168],prg0C[3151:3136],prg0C[3119:3104],prg0C[3087:3072],
            prg0C[3055:3040],prg0C[3023:3008],prg0C[2991:2976],prg0C[2959:2944],prg0C[2927:2912],prg0C[2895:2880],prg0C[2863:2848],prg0C[2831:2816],
            prg0C[2799:2784],prg0C[2767:2752],prg0C[2735:2720],prg0C[2703:2688],prg0C[2671:2656],prg0C[2639:2624],prg0C[2607:2592],prg0C[2575:2560],
            prg0C[2543:2528],prg0C[2511:2496],prg0C[2479:2464],prg0C[2447:2432],prg0C[2415:2400],prg0C[2383:2368],prg0C[2351:2336],prg0C[2319:2304],
            prg0C[2287:2272],prg0C[2255:2240],prg0C[2223:2208],prg0C[2191:2176],prg0C[2159:2144],prg0C[2127:2112],prg0C[2095:2080],prg0C[2063:2048],
            prg0C[2031:2016],prg0C[1999:1984],prg0C[1967:1952],prg0C[1935:1920],prg0C[1903:1888],prg0C[1871:1856],prg0C[1839:1824],prg0C[1807:1792],
            prg0C[1775:1760],prg0C[1743:1728],prg0C[1711:1696],prg0C[1679:1664],prg0C[1647:1632],prg0C[1615:1600],prg0C[1583:1568],prg0C[1551:1536],
            prg0C[1519:1504],prg0C[1487:1472],prg0C[1455:1440],prg0C[1423:1408],prg0C[1391:1376],prg0C[1359:1344],prg0C[1327:1312],prg0C[1295:1280],
            prg0C[1263:1248],prg0C[1231:1216],prg0C[1199:1184],prg0C[1167:1152],prg0C[1135:1120],prg0C[1103:1088],prg0C[1071:1056],prg0C[1039:1024],
            prg0C[1007: 992],prg0C[ 975: 960],prg0C[ 943: 928],prg0C[ 911: 896],prg0C[ 879: 864],prg0C[ 847: 832],prg0C[ 815: 800],prg0C[ 783: 768],
            prg0C[ 751: 736],prg0C[ 719: 704],prg0C[ 687: 672],prg0C[ 655: 640],prg0C[ 623: 608],prg0C[ 591: 576],prg0C[ 559: 544],prg0C[ 527: 512],
            prg0C[ 495: 480],prg0C[ 463: 448],prg0C[ 431: 416],prg0C[ 399: 384],prg0C[ 367: 352],prg0C[ 335: 320],prg0C[ 303: 288],prg0C[ 271: 256],
            prg0C[ 239: 224],prg0C[ 207: 192],prg0C[ 175: 160],prg0C[ 143: 128],prg0C[ 111:  96],prg0C[  79:  64],prg0C[  47:  32],prg0C[  15:   0]};
   localparam [4095:0]
     pb5 = {prg0B[4079:4064],prg0B[4047:4032],prg0B[4015:4000],prg0B[3983:3968],prg0B[3951:3936],prg0B[3919:3904],prg0B[3887:3872],prg0B[3855:3840],
            prg0B[3823:3808],prg0B[3791:3776],prg0B[3759:3744],prg0B[3727:3712],prg0B[3695:3680],prg0B[3663:3648],prg0B[3631:3616],prg0B[3599:3584],
            prg0B[3567:3552],prg0B[3535:3520],prg0B[3503:3488],prg0B[3471:3456],prg0B[3439:3424],prg0B[3407:3392],prg0B[3375:3360],prg0B[3343:3328],
            prg0B[3311:3296],prg0B[3279:3264],prg0B[3247:3232],prg0B[3215:3200],prg0B[3183:3168],prg0B[3151:3136],prg0B[3119:3104],prg0B[3087:3072],
            prg0B[3055:3040],prg0B[3023:3008],prg0B[2991:2976],prg0B[2959:2944],prg0B[2927:2912],prg0B[2895:2880],prg0B[2863:2848],prg0B[2831:2816],
            prg0B[2799:2784],prg0B[2767:2752],prg0B[2735:2720],prg0B[2703:2688],prg0B[2671:2656],prg0B[2639:2624],prg0B[2607:2592],prg0B[2575:2560],
            prg0B[2543:2528],prg0B[2511:2496],prg0B[2479:2464],prg0B[2447:2432],prg0B[2415:2400],prg0B[2383:2368],prg0B[2351:2336],prg0B[2319:2304],
            prg0B[2287:2272],prg0B[2255:2240],prg0B[2223:2208],prg0B[2191:2176],prg0B[2159:2144],prg0B[2127:2112],prg0B[2095:2080],prg0B[2063:2048],
            prg0B[2031:2016],prg0B[1999:1984],prg0B[1967:1952],prg0B[1935:1920],prg0B[1903:1888],prg0B[1871:1856],prg0B[1839:1824],prg0B[1807:1792],
            prg0B[1775:1760],prg0B[1743:1728],prg0B[1711:1696],prg0B[1679:1664],prg0B[1647:1632],prg0B[1615:1600],prg0B[1583:1568],prg0B[1551:1536],
            prg0B[1519:1504],prg0B[1487:1472],prg0B[1455:1440],prg0B[1423:1408],prg0B[1391:1376],prg0B[1359:1344],prg0B[1327:1312],prg0B[1295:1280],
            prg0B[1263:1248],prg0B[1231:1216],prg0B[1199:1184],prg0B[1167:1152],prg0B[1135:1120],prg0B[1103:1088],prg0B[1071:1056],prg0B[1039:1024],
            prg0B[1007: 992],prg0B[ 975: 960],prg0B[ 943: 928],prg0B[ 911: 896],prg0B[ 879: 864],prg0B[ 847: 832],prg0B[ 815: 800],prg0B[ 783: 768],
            prg0B[ 751: 736],prg0B[ 719: 704],prg0B[ 687: 672],prg0B[ 655: 640],prg0B[ 623: 608],prg0B[ 591: 576],prg0B[ 559: 544],prg0B[ 527: 512],
            prg0B[ 495: 480],prg0B[ 463: 448],prg0B[ 431: 416],prg0B[ 399: 384],prg0B[ 367: 352],prg0B[ 335: 320],prg0B[ 303: 288],prg0B[ 271: 256],
            prg0B[ 239: 224],prg0B[ 207: 192],prg0B[ 175: 160],prg0B[ 143: 128],prg0B[ 111:  96],prg0B[  79:  64],prg0B[  47:  32],prg0B[  15:   0],
            prg0A[4079:4064],prg0A[4047:4032],prg0A[4015:4000],prg0A[3983:3968],prg0A[3951:3936],prg0A[3919:3904],prg0A[3887:3872],prg0A[3855:3840],
            prg0A[3823:3808],prg0A[3791:3776],prg0A[3759:3744],prg0A[3727:3712],prg0A[3695:3680],prg0A[3663:3648],prg0A[3631:3616],prg0A[3599:3584],
            prg0A[3567:3552],prg0A[3535:3520],prg0A[3503:3488],prg0A[3471:3456],prg0A[3439:3424],prg0A[3407:3392],prg0A[3375:3360],prg0A[3343:3328],
            prg0A[3311:3296],prg0A[3279:3264],prg0A[3247:3232],prg0A[3215:3200],prg0A[3183:3168],prg0A[3151:3136],prg0A[3119:3104],prg0A[3087:3072],
            prg0A[3055:3040],prg0A[3023:3008],prg0A[2991:2976],prg0A[2959:2944],prg0A[2927:2912],prg0A[2895:2880],prg0A[2863:2848],prg0A[2831:2816],
            prg0A[2799:2784],prg0A[2767:2752],prg0A[2735:2720],prg0A[2703:2688],prg0A[2671:2656],prg0A[2639:2624],prg0A[2607:2592],prg0A[2575:2560],
            prg0A[2543:2528],prg0A[2511:2496],prg0A[2479:2464],prg0A[2447:2432],prg0A[2415:2400],prg0A[2383:2368],prg0A[2351:2336],prg0A[2319:2304],
            prg0A[2287:2272],prg0A[2255:2240],prg0A[2223:2208],prg0A[2191:2176],prg0A[2159:2144],prg0A[2127:2112],prg0A[2095:2080],prg0A[2063:2048],
            prg0A[2031:2016],prg0A[1999:1984],prg0A[1967:1952],prg0A[1935:1920],prg0A[1903:1888],prg0A[1871:1856],prg0A[1839:1824],prg0A[1807:1792],
            prg0A[1775:1760],prg0A[1743:1728],prg0A[1711:1696],prg0A[1679:1664],prg0A[1647:1632],prg0A[1615:1600],prg0A[1583:1568],prg0A[1551:1536],
            prg0A[1519:1504],prg0A[1487:1472],prg0A[1455:1440],prg0A[1423:1408],prg0A[1391:1376],prg0A[1359:1344],prg0A[1327:1312],prg0A[1295:1280],
            prg0A[1263:1248],prg0A[1231:1216],prg0A[1199:1184],prg0A[1167:1152],prg0A[1135:1120],prg0A[1103:1088],prg0A[1071:1056],prg0A[1039:1024],
            prg0A[1007: 992],prg0A[ 975: 960],prg0A[ 943: 928],prg0A[ 911: 896],prg0A[ 879: 864],prg0A[ 847: 832],prg0A[ 815: 800],prg0A[ 783: 768],
            prg0A[ 751: 736],prg0A[ 719: 704],prg0A[ 687: 672],prg0A[ 655: 640],prg0A[ 623: 608],prg0A[ 591: 576],prg0A[ 559: 544],prg0A[ 527: 512],
            prg0A[ 495: 480],prg0A[ 463: 448],prg0A[ 431: 416],prg0A[ 399: 384],prg0A[ 367: 352],prg0A[ 335: 320],prg0A[ 303: 288],prg0A[ 271: 256],
            prg0A[ 239: 224],prg0A[ 207: 192],prg0A[ 175: 160],prg0A[ 143: 128],prg0A[ 111:  96],prg0A[  79:  64],prg0A[  47:  32],prg0A[  15:   0]};
   localparam [4095:0]
     pb4 = {prg09[4079:4064],prg09[4047:4032],prg09[4015:4000],prg09[3983:3968],prg09[3951:3936],prg09[3919:3904],prg09[3887:3872],prg09[3855:3840],
            prg09[3823:3808],prg09[3791:3776],prg09[3759:3744],prg09[3727:3712],prg09[3695:3680],prg09[3663:3648],prg09[3631:3616],prg09[3599:3584],
            prg09[3567:3552],prg09[3535:3520],prg09[3503:3488],prg09[3471:3456],prg09[3439:3424],prg09[3407:3392],prg09[3375:3360],prg09[3343:3328],
            prg09[3311:3296],prg09[3279:3264],prg09[3247:3232],prg09[3215:3200],prg09[3183:3168],prg09[3151:3136],prg09[3119:3104],prg09[3087:3072],
            prg09[3055:3040],prg09[3023:3008],prg09[2991:2976],prg09[2959:2944],prg09[2927:2912],prg09[2895:2880],prg09[2863:2848],prg09[2831:2816],
            prg09[2799:2784],prg09[2767:2752],prg09[2735:2720],prg09[2703:2688],prg09[2671:2656],prg09[2639:2624],prg09[2607:2592],prg09[2575:2560],
            prg09[2543:2528],prg09[2511:2496],prg09[2479:2464],prg09[2447:2432],prg09[2415:2400],prg09[2383:2368],prg09[2351:2336],prg09[2319:2304],
            prg09[2287:2272],prg09[2255:2240],prg09[2223:2208],prg09[2191:2176],prg09[2159:2144],prg09[2127:2112],prg09[2095:2080],prg09[2063:2048],
            prg09[2031:2016],prg09[1999:1984],prg09[1967:1952],prg09[1935:1920],prg09[1903:1888],prg09[1871:1856],prg09[1839:1824],prg09[1807:1792],
            prg09[1775:1760],prg09[1743:1728],prg09[1711:1696],prg09[1679:1664],prg09[1647:1632],prg09[1615:1600],prg09[1583:1568],prg09[1551:1536],
            prg09[1519:1504],prg09[1487:1472],prg09[1455:1440],prg09[1423:1408],prg09[1391:1376],prg09[1359:1344],prg09[1327:1312],prg09[1295:1280],
            prg09[1263:1248],prg09[1231:1216],prg09[1199:1184],prg09[1167:1152],prg09[1135:1120],prg09[1103:1088],prg09[1071:1056],prg09[1039:1024],
            prg09[1007: 992],prg09[ 975: 960],prg09[ 943: 928],prg09[ 911: 896],prg09[ 879: 864],prg09[ 847: 832],prg09[ 815: 800],prg09[ 783: 768],
            prg09[ 751: 736],prg09[ 719: 704],prg09[ 687: 672],prg09[ 655: 640],prg09[ 623: 608],prg09[ 591: 576],prg09[ 559: 544],prg09[ 527: 512],
            prg09[ 495: 480],prg09[ 463: 448],prg09[ 431: 416],prg09[ 399: 384],prg09[ 367: 352],prg09[ 335: 320],prg09[ 303: 288],prg09[ 271: 256],
            prg09[ 239: 224],prg09[ 207: 192],prg09[ 175: 160],prg09[ 143: 128],prg09[ 111:  96],prg09[  79:  64],prg09[  47:  32],prg09[  15:   0],
            prg08[4079:4064],prg08[4047:4032],prg08[4015:4000],prg08[3983:3968],prg08[3951:3936],prg08[3919:3904],prg08[3887:3872],prg08[3855:3840],
            prg08[3823:3808],prg08[3791:3776],prg08[3759:3744],prg08[3727:3712],prg08[3695:3680],prg08[3663:3648],prg08[3631:3616],prg08[3599:3584],
            prg08[3567:3552],prg08[3535:3520],prg08[3503:3488],prg08[3471:3456],prg08[3439:3424],prg08[3407:3392],prg08[3375:3360],prg08[3343:3328],
            prg08[3311:3296],prg08[3279:3264],prg08[3247:3232],prg08[3215:3200],prg08[3183:3168],prg08[3151:3136],prg08[3119:3104],prg08[3087:3072],
            prg08[3055:3040],prg08[3023:3008],prg08[2991:2976],prg08[2959:2944],prg08[2927:2912],prg08[2895:2880],prg08[2863:2848],prg08[2831:2816],
            prg08[2799:2784],prg08[2767:2752],prg08[2735:2720],prg08[2703:2688],prg08[2671:2656],prg08[2639:2624],prg08[2607:2592],prg08[2575:2560],
            prg08[2543:2528],prg08[2511:2496],prg08[2479:2464],prg08[2447:2432],prg08[2415:2400],prg08[2383:2368],prg08[2351:2336],prg08[2319:2304],
            prg08[2287:2272],prg08[2255:2240],prg08[2223:2208],prg08[2191:2176],prg08[2159:2144],prg08[2127:2112],prg08[2095:2080],prg08[2063:2048],
            prg08[2031:2016],prg08[1999:1984],prg08[1967:1952],prg08[1935:1920],prg08[1903:1888],prg08[1871:1856],prg08[1839:1824],prg08[1807:1792],
            prg08[1775:1760],prg08[1743:1728],prg08[1711:1696],prg08[1679:1664],prg08[1647:1632],prg08[1615:1600],prg08[1583:1568],prg08[1551:1536],
            prg08[1519:1504],prg08[1487:1472],prg08[1455:1440],prg08[1423:1408],prg08[1391:1376],prg08[1359:1344],prg08[1327:1312],prg08[1295:1280],
            prg08[1263:1248],prg08[1231:1216],prg08[1199:1184],prg08[1167:1152],prg08[1135:1120],prg08[1103:1088],prg08[1071:1056],prg08[1039:1024],
            prg08[1007: 992],prg08[ 975: 960],prg08[ 943: 928],prg08[ 911: 896],prg08[ 879: 864],prg08[ 847: 832],prg08[ 815: 800],prg08[ 783: 768],
            prg08[ 751: 736],prg08[ 719: 704],prg08[ 687: 672],prg08[ 655: 640],prg08[ 623: 608],prg08[ 591: 576],prg08[ 559: 544],prg08[ 527: 512],
            prg08[ 495: 480],prg08[ 463: 448],prg08[ 431: 416],prg08[ 399: 384],prg08[ 367: 352],prg08[ 335: 320],prg08[ 303: 288],prg08[ 271: 256],
            prg08[ 239: 224],prg08[ 207: 192],prg08[ 175: 160],prg08[ 143: 128],prg08[ 111:  96],prg08[  79:  64],prg08[  47:  32],prg08[  15:   0]};
   localparam [4095:0]
     pb3 = {prg07[4079:4064],prg07[4047:4032],prg07[4015:4000],prg07[3983:3968],prg07[3951:3936],prg07[3919:3904],prg07[3887:3872],prg07[3855:3840],
            prg07[3823:3808],prg07[3791:3776],prg07[3759:3744],prg07[3727:3712],prg07[3695:3680],prg07[3663:3648],prg07[3631:3616],prg07[3599:3584],
            prg07[3567:3552],prg07[3535:3520],prg07[3503:3488],prg07[3471:3456],prg07[3439:3424],prg07[3407:3392],prg07[3375:3360],prg07[3343:3328],
            prg07[3311:3296],prg07[3279:3264],prg07[3247:3232],prg07[3215:3200],prg07[3183:3168],prg07[3151:3136],prg07[3119:3104],prg07[3087:3072],
            prg07[3055:3040],prg07[3023:3008],prg07[2991:2976],prg07[2959:2944],prg07[2927:2912],prg07[2895:2880],prg07[2863:2848],prg07[2831:2816],
            prg07[2799:2784],prg07[2767:2752],prg07[2735:2720],prg07[2703:2688],prg07[2671:2656],prg07[2639:2624],prg07[2607:2592],prg07[2575:2560],
            prg07[2543:2528],prg07[2511:2496],prg07[2479:2464],prg07[2447:2432],prg07[2415:2400],prg07[2383:2368],prg07[2351:2336],prg07[2319:2304],
            prg07[2287:2272],prg07[2255:2240],prg07[2223:2208],prg07[2191:2176],prg07[2159:2144],prg07[2127:2112],prg07[2095:2080],prg07[2063:2048],
            prg07[2031:2016],prg07[1999:1984],prg07[1967:1952],prg07[1935:1920],prg07[1903:1888],prg07[1871:1856],prg07[1839:1824],prg07[1807:1792],
            prg07[1775:1760],prg07[1743:1728],prg07[1711:1696],prg07[1679:1664],prg07[1647:1632],prg07[1615:1600],prg07[1583:1568],prg07[1551:1536],
            prg07[1519:1504],prg07[1487:1472],prg07[1455:1440],prg07[1423:1408],prg07[1391:1376],prg07[1359:1344],prg07[1327:1312],prg07[1295:1280],
            prg07[1263:1248],prg07[1231:1216],prg07[1199:1184],prg07[1167:1152],prg07[1135:1120],prg07[1103:1088],prg07[1071:1056],prg07[1039:1024],
            prg07[1007: 992],prg07[ 975: 960],prg07[ 943: 928],prg07[ 911: 896],prg07[ 879: 864],prg07[ 847: 832],prg07[ 815: 800],prg07[ 783: 768],
            prg07[ 751: 736],prg07[ 719: 704],prg07[ 687: 672],prg07[ 655: 640],prg07[ 623: 608],prg07[ 591: 576],prg07[ 559: 544],prg07[ 527: 512],
            prg07[ 495: 480],prg07[ 463: 448],prg07[ 431: 416],prg07[ 399: 384],prg07[ 367: 352],prg07[ 335: 320],prg07[ 303: 288],prg07[ 271: 256],
            prg07[ 239: 224],prg07[ 207: 192],prg07[ 175: 160],prg07[ 143: 128],prg07[ 111:  96],prg07[  79:  64],prg07[  47:  32],prg07[  15:   0],
            prg06[4079:4064],prg06[4047:4032],prg06[4015:4000],prg06[3983:3968],prg06[3951:3936],prg06[3919:3904],prg06[3887:3872],prg06[3855:3840],
            prg06[3823:3808],prg06[3791:3776],prg06[3759:3744],prg06[3727:3712],prg06[3695:3680],prg06[3663:3648],prg06[3631:3616],prg06[3599:3584],
            prg06[3567:3552],prg06[3535:3520],prg06[3503:3488],prg06[3471:3456],prg06[3439:3424],prg06[3407:3392],prg06[3375:3360],prg06[3343:3328],
            prg06[3311:3296],prg06[3279:3264],prg06[3247:3232],prg06[3215:3200],prg06[3183:3168],prg06[3151:3136],prg06[3119:3104],prg06[3087:3072],
            prg06[3055:3040],prg06[3023:3008],prg06[2991:2976],prg06[2959:2944],prg06[2927:2912],prg06[2895:2880],prg06[2863:2848],prg06[2831:2816],
            prg06[2799:2784],prg06[2767:2752],prg06[2735:2720],prg06[2703:2688],prg06[2671:2656],prg06[2639:2624],prg06[2607:2592],prg06[2575:2560],
            prg06[2543:2528],prg06[2511:2496],prg06[2479:2464],prg06[2447:2432],prg06[2415:2400],prg06[2383:2368],prg06[2351:2336],prg06[2319:2304],
            prg06[2287:2272],prg06[2255:2240],prg06[2223:2208],prg06[2191:2176],prg06[2159:2144],prg06[2127:2112],prg06[2095:2080],prg06[2063:2048],
            prg06[2031:2016],prg06[1999:1984],prg06[1967:1952],prg06[1935:1920],prg06[1903:1888],prg06[1871:1856],prg06[1839:1824],prg06[1807:1792],
            prg06[1775:1760],prg06[1743:1728],prg06[1711:1696],prg06[1679:1664],prg06[1647:1632],prg06[1615:1600],prg06[1583:1568],prg06[1551:1536],
            prg06[1519:1504],prg06[1487:1472],prg06[1455:1440],prg06[1423:1408],prg06[1391:1376],prg06[1359:1344],prg06[1327:1312],prg06[1295:1280],
            prg06[1263:1248],prg06[1231:1216],prg06[1199:1184],prg06[1167:1152],prg06[1135:1120],prg06[1103:1088],prg06[1071:1056],prg06[1039:1024],
            prg06[1007: 992],prg06[ 975: 960],prg06[ 943: 928],prg06[ 911: 896],prg06[ 879: 864],prg06[ 847: 832],prg06[ 815: 800],prg06[ 783: 768],
            prg06[ 751: 736],prg06[ 719: 704],prg06[ 687: 672],prg06[ 655: 640],prg06[ 623: 608],prg06[ 591: 576],prg06[ 559: 544],prg06[ 527: 512],
            prg06[ 495: 480],prg06[ 463: 448],prg06[ 431: 416],prg06[ 399: 384],prg06[ 367: 352],prg06[ 335: 320],prg06[ 303: 288],prg06[ 271: 256],
            prg06[ 239: 224],prg06[ 207: 192],prg06[ 175: 160],prg06[ 143: 128],prg06[ 111:  96],prg06[  79:  64],prg06[  47:  32],prg06[  15:   0]};
   localparam [4095:0]
     pb2 = {prg05[4079:4064],prg05[4047:4032],prg05[4015:4000],prg05[3983:3968],prg05[3951:3936],prg05[3919:3904],prg05[3887:3872],prg05[3855:3840],
            prg05[3823:3808],prg05[3791:3776],prg05[3759:3744],prg05[3727:3712],prg05[3695:3680],prg05[3663:3648],prg05[3631:3616],prg05[3599:3584],
            prg05[3567:3552],prg05[3535:3520],prg05[3503:3488],prg05[3471:3456],prg05[3439:3424],prg05[3407:3392],prg05[3375:3360],prg05[3343:3328],
            prg05[3311:3296],prg05[3279:3264],prg05[3247:3232],prg05[3215:3200],prg05[3183:3168],prg05[3151:3136],prg05[3119:3104],prg05[3087:3072],
            prg05[3055:3040],prg05[3023:3008],prg05[2991:2976],prg05[2959:2944],prg05[2927:2912],prg05[2895:2880],prg05[2863:2848],prg05[2831:2816],
            prg05[2799:2784],prg05[2767:2752],prg05[2735:2720],prg05[2703:2688],prg05[2671:2656],prg05[2639:2624],prg05[2607:2592],prg05[2575:2560],
            prg05[2543:2528],prg05[2511:2496],prg05[2479:2464],prg05[2447:2432],prg05[2415:2400],prg05[2383:2368],prg05[2351:2336],prg05[2319:2304],
            prg05[2287:2272],prg05[2255:2240],prg05[2223:2208],prg05[2191:2176],prg05[2159:2144],prg05[2127:2112],prg05[2095:2080],prg05[2063:2048],
            prg05[2031:2016],prg05[1999:1984],prg05[1967:1952],prg05[1935:1920],prg05[1903:1888],prg05[1871:1856],prg05[1839:1824],prg05[1807:1792],
            prg05[1775:1760],prg05[1743:1728],prg05[1711:1696],prg05[1679:1664],prg05[1647:1632],prg05[1615:1600],prg05[1583:1568],prg05[1551:1536],
            prg05[1519:1504],prg05[1487:1472],prg05[1455:1440],prg05[1423:1408],prg05[1391:1376],prg05[1359:1344],prg05[1327:1312],prg05[1295:1280],
            prg05[1263:1248],prg05[1231:1216],prg05[1199:1184],prg05[1167:1152],prg05[1135:1120],prg05[1103:1088],prg05[1071:1056],prg05[1039:1024],
            prg05[1007: 992],prg05[ 975: 960],prg05[ 943: 928],prg05[ 911: 896],prg05[ 879: 864],prg05[ 847: 832],prg05[ 815: 800],prg05[ 783: 768],
            prg05[ 751: 736],prg05[ 719: 704],prg05[ 687: 672],prg05[ 655: 640],prg05[ 623: 608],prg05[ 591: 576],prg05[ 559: 544],prg05[ 527: 512],
            prg05[ 495: 480],prg05[ 463: 448],prg05[ 431: 416],prg05[ 399: 384],prg05[ 367: 352],prg05[ 335: 320],prg05[ 303: 288],prg05[ 271: 256],
            prg05[ 239: 224],prg05[ 207: 192],prg05[ 175: 160],prg05[ 143: 128],prg05[ 111:  96],prg05[  79:  64],prg05[  47:  32],prg05[  15:   0],
            prg04[4079:4064],prg04[4047:4032],prg04[4015:4000],prg04[3983:3968],prg04[3951:3936],prg04[3919:3904],prg04[3887:3872],prg04[3855:3840],
            prg04[3823:3808],prg04[3791:3776],prg04[3759:3744],prg04[3727:3712],prg04[3695:3680],prg04[3663:3648],prg04[3631:3616],prg04[3599:3584],
            prg04[3567:3552],prg04[3535:3520],prg04[3503:3488],prg04[3471:3456],prg04[3439:3424],prg04[3407:3392],prg04[3375:3360],prg04[3343:3328],
            prg04[3311:3296],prg04[3279:3264],prg04[3247:3232],prg04[3215:3200],prg04[3183:3168],prg04[3151:3136],prg04[3119:3104],prg04[3087:3072],
            prg04[3055:3040],prg04[3023:3008],prg04[2991:2976],prg04[2959:2944],prg04[2927:2912],prg04[2895:2880],prg04[2863:2848],prg04[2831:2816],
            prg04[2799:2784],prg04[2767:2752],prg04[2735:2720],prg04[2703:2688],prg04[2671:2656],prg04[2639:2624],prg04[2607:2592],prg04[2575:2560],
            prg04[2543:2528],prg04[2511:2496],prg04[2479:2464],prg04[2447:2432],prg04[2415:2400],prg04[2383:2368],prg04[2351:2336],prg04[2319:2304],
            prg04[2287:2272],prg04[2255:2240],prg04[2223:2208],prg04[2191:2176],prg04[2159:2144],prg04[2127:2112],prg04[2095:2080],prg04[2063:2048],
            prg04[2031:2016],prg04[1999:1984],prg04[1967:1952],prg04[1935:1920],prg04[1903:1888],prg04[1871:1856],prg04[1839:1824],prg04[1807:1792],
            prg04[1775:1760],prg04[1743:1728],prg04[1711:1696],prg04[1679:1664],prg04[1647:1632],prg04[1615:1600],prg04[1583:1568],prg04[1551:1536],
            prg04[1519:1504],prg04[1487:1472],prg04[1455:1440],prg04[1423:1408],prg04[1391:1376],prg04[1359:1344],prg04[1327:1312],prg04[1295:1280],
            prg04[1263:1248],prg04[1231:1216],prg04[1199:1184],prg04[1167:1152],prg04[1135:1120],prg04[1103:1088],prg04[1071:1056],prg04[1039:1024],
            prg04[1007: 992],prg04[ 975: 960],prg04[ 943: 928],prg04[ 911: 896],prg04[ 879: 864],prg04[ 847: 832],prg04[ 815: 800],prg04[ 783: 768],
            prg04[ 751: 736],prg04[ 719: 704],prg04[ 687: 672],prg04[ 655: 640],prg04[ 623: 608],prg04[ 591: 576],prg04[ 559: 544],prg04[ 527: 512],
            prg04[ 495: 480],prg04[ 463: 448],prg04[ 431: 416],prg04[ 399: 384],prg04[ 367: 352],prg04[ 335: 320],prg04[ 303: 288],prg04[ 271: 256],
            prg04[ 239: 224],prg04[ 207: 192],prg04[ 175: 160],prg04[ 143: 128],prg04[ 111:  96],prg04[  79:  64],prg04[  47:  32],prg04[  15:   0]};
   localparam [4095:0]
     pb1 = {prg03[4079:4064],prg03[4047:4032],prg03[4015:4000],prg03[3983:3968],prg03[3951:3936],prg03[3919:3904],prg03[3887:3872],prg03[3855:3840],
            prg03[3823:3808],prg03[3791:3776],prg03[3759:3744],prg03[3727:3712],prg03[3695:3680],prg03[3663:3648],prg03[3631:3616],prg03[3599:3584],
            prg03[3567:3552],prg03[3535:3520],prg03[3503:3488],prg03[3471:3456],prg03[3439:3424],prg03[3407:3392],prg03[3375:3360],prg03[3343:3328],
            prg03[3311:3296],prg03[3279:3264],prg03[3247:3232],prg03[3215:3200],prg03[3183:3168],prg03[3151:3136],prg03[3119:3104],prg03[3087:3072],
            prg03[3055:3040],prg03[3023:3008],prg03[2991:2976],prg03[2959:2944],prg03[2927:2912],prg03[2895:2880],prg03[2863:2848],prg03[2831:2816],
            prg03[2799:2784],prg03[2767:2752],prg03[2735:2720],prg03[2703:2688],prg03[2671:2656],prg03[2639:2624],prg03[2607:2592],prg03[2575:2560],
            prg03[2543:2528],prg03[2511:2496],prg03[2479:2464],prg03[2447:2432],prg03[2415:2400],prg03[2383:2368],prg03[2351:2336],prg03[2319:2304],
            prg03[2287:2272],prg03[2255:2240],prg03[2223:2208],prg03[2191:2176],prg03[2159:2144],prg03[2127:2112],prg03[2095:2080],prg03[2063:2048],
            prg03[2031:2016],prg03[1999:1984],prg03[1967:1952],prg03[1935:1920],prg03[1903:1888],prg03[1871:1856],prg03[1839:1824],prg03[1807:1792],
            prg03[1775:1760],prg03[1743:1728],prg03[1711:1696],prg03[1679:1664],prg03[1647:1632],prg03[1615:1600],prg03[1583:1568],prg03[1551:1536],
            prg03[1519:1504],prg03[1487:1472],prg03[1455:1440],prg03[1423:1408],prg03[1391:1376],prg03[1359:1344],prg03[1327:1312],prg03[1295:1280],
            prg03[1263:1248],prg03[1231:1216],prg03[1199:1184],prg03[1167:1152],prg03[1135:1120],prg03[1103:1088],prg03[1071:1056],prg03[1039:1024],
            prg03[1007: 992],prg03[ 975: 960],prg03[ 943: 928],prg03[ 911: 896],prg03[ 879: 864],prg03[ 847: 832],prg03[ 815: 800],prg03[ 783: 768],
            prg03[ 751: 736],prg03[ 719: 704],prg03[ 687: 672],prg03[ 655: 640],prg03[ 623: 608],prg03[ 591: 576],prg03[ 559: 544],prg03[ 527: 512],
            prg03[ 495: 480],prg03[ 463: 448],prg03[ 431: 416],prg03[ 399: 384],prg03[ 367: 352],prg03[ 335: 320],prg03[ 303: 288],prg03[ 271: 256],
            prg03[ 239: 224],prg03[ 207: 192],prg03[ 175: 160],prg03[ 143: 128],prg03[ 111:  96],prg03[  79:  64],prg03[  47:  32],prg03[  15:   0],
            prg02[4079:4064],prg02[4047:4032],prg02[4015:4000],prg02[3983:3968],prg02[3951:3936],prg02[3919:3904],prg02[3887:3872],prg02[3855:3840],
            prg02[3823:3808],prg02[3791:3776],prg02[3759:3744],prg02[3727:3712],prg02[3695:3680],prg02[3663:3648],prg02[3631:3616],prg02[3599:3584],
            prg02[3567:3552],prg02[3535:3520],prg02[3503:3488],prg02[3471:3456],prg02[3439:3424],prg02[3407:3392],prg02[3375:3360],prg02[3343:3328],
            prg02[3311:3296],prg02[3279:3264],prg02[3247:3232],prg02[3215:3200],prg02[3183:3168],prg02[3151:3136],prg02[3119:3104],prg02[3087:3072],
            prg02[3055:3040],prg02[3023:3008],prg02[2991:2976],prg02[2959:2944],prg02[2927:2912],prg02[2895:2880],prg02[2863:2848],prg02[2831:2816],
            prg02[2799:2784],prg02[2767:2752],prg02[2735:2720],prg02[2703:2688],prg02[2671:2656],prg02[2639:2624],prg02[2607:2592],prg02[2575:2560],
            prg02[2543:2528],prg02[2511:2496],prg02[2479:2464],prg02[2447:2432],prg02[2415:2400],prg02[2383:2368],prg02[2351:2336],prg02[2319:2304],
            prg02[2287:2272],prg02[2255:2240],prg02[2223:2208],prg02[2191:2176],prg02[2159:2144],prg02[2127:2112],prg02[2095:2080],prg02[2063:2048],
            prg02[2031:2016],prg02[1999:1984],prg02[1967:1952],prg02[1935:1920],prg02[1903:1888],prg02[1871:1856],prg02[1839:1824],prg02[1807:1792],
            prg02[1775:1760],prg02[1743:1728],prg02[1711:1696],prg02[1679:1664],prg02[1647:1632],prg02[1615:1600],prg02[1583:1568],prg02[1551:1536],
            prg02[1519:1504],prg02[1487:1472],prg02[1455:1440],prg02[1423:1408],prg02[1391:1376],prg02[1359:1344],prg02[1327:1312],prg02[1295:1280],
            prg02[1263:1248],prg02[1231:1216],prg02[1199:1184],prg02[1167:1152],prg02[1135:1120],prg02[1103:1088],prg02[1071:1056],prg02[1039:1024],
            prg02[1007: 992],prg02[ 975: 960],prg02[ 943: 928],prg02[ 911: 896],prg02[ 879: 864],prg02[ 847: 832],prg02[ 815: 800],prg02[ 783: 768],
            prg02[ 751: 736],prg02[ 719: 704],prg02[ 687: 672],prg02[ 655: 640],prg02[ 623: 608],prg02[ 591: 576],prg02[ 559: 544],prg02[ 527: 512],
            prg02[ 495: 480],prg02[ 463: 448],prg02[ 431: 416],prg02[ 399: 384],prg02[ 367: 352],prg02[ 335: 320],prg02[ 303: 288],prg02[ 271: 256],
            prg02[ 239: 224],prg02[ 207: 192],prg02[ 175: 160],prg02[ 143: 128],prg02[ 111:  96],prg02[  79:  64],prg02[  47:  32],prg02[  15:   0]};
   localparam [4095:0]
     pb0 = {prg01[4079:4064],prg01[4047:4032],prg01[4015:4000],prg01[3983:3968],prg01[3951:3936],prg01[3919:3904],prg01[3887:3872],prg01[3855:3840],
            prg01[3823:3808],prg01[3791:3776],prg01[3759:3744],prg01[3727:3712],prg01[3695:3680],prg01[3663:3648],prg01[3631:3616],prg01[3599:3584],
            prg01[3567:3552],prg01[3535:3520],prg01[3503:3488],prg01[3471:3456],prg01[3439:3424],prg01[3407:3392],prg01[3375:3360],prg01[3343:3328],
            prg01[3311:3296],prg01[3279:3264],prg01[3247:3232],prg01[3215:3200],prg01[3183:3168],prg01[3151:3136],prg01[3119:3104],prg01[3087:3072],
            prg01[3055:3040],prg01[3023:3008],prg01[2991:2976],prg01[2959:2944],prg01[2927:2912],prg01[2895:2880],prg01[2863:2848],prg01[2831:2816],
            prg01[2799:2784],prg01[2767:2752],prg01[2735:2720],prg01[2703:2688],prg01[2671:2656],prg01[2639:2624],prg01[2607:2592],prg01[2575:2560],
            prg01[2543:2528],prg01[2511:2496],prg01[2479:2464],prg01[2447:2432],prg01[2415:2400],prg01[2383:2368],prg01[2351:2336],prg01[2319:2304],
            prg01[2287:2272],prg01[2255:2240],prg01[2223:2208],prg01[2191:2176],prg01[2159:2144],prg01[2127:2112],prg01[2095:2080],prg01[2063:2048],
            prg01[2031:2016],prg01[1999:1984],prg01[1967:1952],prg01[1935:1920],prg01[1903:1888],prg01[1871:1856],prg01[1839:1824],prg01[1807:1792],
            prg01[1775:1760],prg01[1743:1728],prg01[1711:1696],prg01[1679:1664],prg01[1647:1632],prg01[1615:1600],prg01[1583:1568],prg01[1551:1536],
            prg01[1519:1504],prg01[1487:1472],prg01[1455:1440],prg01[1423:1408],prg01[1391:1376],prg01[1359:1344],prg01[1327:1312],prg01[1295:1280],
            prg01[1263:1248],prg01[1231:1216],prg01[1199:1184],prg01[1167:1152],prg01[1135:1120],prg01[1103:1088],prg01[1071:1056],prg01[1039:1024],
            prg01[1007: 992],prg01[ 975: 960],prg01[ 943: 928],prg01[ 911: 896],prg01[ 879: 864],prg01[ 847: 832],prg01[ 815: 800],prg01[ 783: 768],
            prg01[ 751: 736],prg01[ 719: 704],prg01[ 687: 672],prg01[ 655: 640],prg01[ 623: 608],prg01[ 591: 576],prg01[ 559: 544],prg01[ 527: 512],
            prg01[ 495: 480],prg01[ 463: 448],prg01[ 431: 416],prg01[ 399: 384],prg01[ 367: 352],prg01[ 335: 320],prg01[ 303: 288],prg01[ 271: 256],
            prg01[ 239: 224],prg01[ 207: 192],prg01[ 175: 160],prg01[ 143: 128],prg01[ 111:  96],prg01[  79:  64],prg01[  47:  32],prg01[  15:   0],
            prg00[4079:4064],prg00[4047:4032],prg00[4015:4000],prg00[3983:3968],prg00[3951:3936],prg00[3919:3904],prg00[3887:3872],prg00[3855:3840],
            prg00[3823:3808],prg00[3791:3776],prg00[3759:3744],prg00[3727:3712],prg00[3695:3680],prg00[3663:3648],prg00[3631:3616],prg00[3599:3584],
            prg00[3567:3552],prg00[3535:3520],prg00[3503:3488],prg00[3471:3456],prg00[3439:3424],prg00[3407:3392],prg00[3375:3360],prg00[3343:3328],
            prg00[3311:3296],prg00[3279:3264],prg00[3247:3232],prg00[3215:3200],prg00[3183:3168],prg00[3151:3136],prg00[3119:3104],prg00[3087:3072],
            prg00[3055:3040],prg00[3023:3008],prg00[2991:2976],prg00[2959:2944],prg00[2927:2912],prg00[2895:2880],prg00[2863:2848],prg00[2831:2816],
            prg00[2799:2784],prg00[2767:2752],prg00[2735:2720],prg00[2703:2688],prg00[2671:2656],prg00[2639:2624],prg00[2607:2592],prg00[2575:2560],
            prg00[2543:2528],prg00[2511:2496],prg00[2479:2464],prg00[2447:2432],prg00[2415:2400],prg00[2383:2368],prg00[2351:2336],prg00[2319:2304],
            prg00[2287:2272],prg00[2255:2240],prg00[2223:2208],prg00[2191:2176],prg00[2159:2144],prg00[2127:2112],prg00[2095:2080],prg00[2063:2048],
            prg00[2031:2016],prg00[1999:1984],prg00[1967:1952],prg00[1935:1920],prg00[1903:1888],prg00[1871:1856],prg00[1839:1824],prg00[1807:1792],
            prg00[1775:1760],prg00[1743:1728],prg00[1711:1696],prg00[1679:1664],prg00[1647:1632],prg00[1615:1600],prg00[1583:1568],prg00[1551:1536],
            prg00[1519:1504],prg00[1487:1472],prg00[1455:1440],prg00[1423:1408],prg00[1391:1376],prg00[1359:1344],prg00[1327:1312],prg00[1295:1280],
            prg00[1263:1248],prg00[1231:1216],prg00[1199:1184],prg00[1167:1152],prg00[1135:1120],prg00[1103:1088],prg00[1071:1056],prg00[1039:1024],
            prg00[1007: 992],prg00[ 975: 960],prg00[ 943: 928],prg00[ 911: 896],prg00[ 879: 864],prg00[ 847: 832],prg00[ 815: 800],prg00[ 783: 768],
            prg00[ 751: 736],prg00[ 719: 704],prg00[ 687: 672],prg00[ 655: 640],prg00[ 623: 608],prg00[ 591: 576],prg00[ 559: 544],prg00[ 527: 512],
            prg00[ 495: 480],prg00[ 463: 448],prg00[ 431: 416],prg00[ 399: 384],prg00[ 367: 352],prg00[ 335: 320],prg00[ 303: 288],prg00[ 271: 256],
            prg00[ 239: 224],prg00[ 207: 192],prg00[ 175: 160],prg00[ 143: 128],prg00[ 111:  96],prg00[  79:  64],prg00[  47:  32],prg00[  15:   0]};
   localparam [4095:0]
     ph7 = {prg0F[4095:4080],prg0F[4063:4048],prg0F[4031:4016],prg0F[3999:3984],prg0F[3967:3952],prg0F[3935:3920],prg0F[3903:3888],prg0F[3871:3856],
            prg0F[3839:3824],prg0F[3807:3792],prg0F[3775:3760],prg0F[3743:3728],prg0F[3711:3696],prg0F[3679:3664],prg0F[3647:3632],prg0F[3615:3600],
            prg0F[3583:3568],prg0F[3551:3536],prg0F[3519:3504],prg0F[3487:3472],prg0F[3455:3440],prg0F[3423:3408],prg0F[3391:3376],prg0F[3359:3344],
            prg0F[3327:3312],prg0F[3295:3280],prg0F[3263:3248],prg0F[3231:3216],prg0F[3199:3184],prg0F[3167:3152],prg0F[3135:3120],prg0F[3103:3088],
            prg0F[3071:3056],prg0F[3039:3024],prg0F[3007:2992],prg0F[2975:2960],prg0F[2943:2928],prg0F[2911:2896],prg0F[2879:2864],prg0F[2847:2832],
            prg0F[2815:2800],prg0F[2783:2768],prg0F[2751:2736],prg0F[2719:2704],prg0F[2687:2672],prg0F[2655:2640],prg0F[2623:2608],prg0F[2591:2576],
            prg0F[2559:2544],prg0F[2527:2512],prg0F[2495:2480],prg0F[2463:2448],prg0F[2431:2416],prg0F[2399:2384],prg0F[2367:2352],prg0F[2335:2320],
            prg0F[2303:2288],prg0F[2271:2256],prg0F[2239:2224],prg0F[2207:2192],prg0F[2175:2160],prg0F[2143:2128],prg0F[2111:2096],prg0F[2079:2064],
            prg0F[2047:2032],prg0F[2015:2000],prg0F[1983:1968],prg0F[1951:1936],prg0F[1919:1904],prg0F[1887:1872],prg0F[1855:1840],prg0F[1823:1808],
            prg0F[1791:1776],prg0F[1759:1744],prg0F[1727:1712],prg0F[1695:1680],prg0F[1663:1648],prg0F[1631:1616],prg0F[1599:1584],prg0F[1567:1552],
            prg0F[1535:1520],prg0F[1503:1488],prg0F[1471:1456],prg0F[1439:1424],prg0F[1407:1392],prg0F[1375:1360],prg0F[1343:1328],prg0F[1311:1296],
            prg0F[1279:1264],prg0F[1247:1232],prg0F[1215:1200],prg0F[1183:1168],prg0F[1151:1136],prg0F[1119:1104],prg0F[1087:1072],prg0F[1055:1040],
            prg0F[1023:1008],prg0F[ 991: 976],prg0F[ 959: 944],prg0F[ 927: 912],prg0F[ 895: 880],prg0F[ 863: 848],prg0F[ 831: 816],prg0F[ 799: 784],
            prg0F[ 767: 752],prg0F[ 735: 720],prg0F[ 703: 688],prg0F[ 671: 656],prg0F[ 639: 624],prg0F[ 607: 592],prg0F[ 575: 560],prg0F[ 543: 528],
            prg0F[ 511: 496],prg0F[ 479: 464],prg0F[ 447: 432],prg0F[ 415: 400],prg0F[ 383: 368],prg0F[ 351: 336],prg0F[ 319: 304],prg0F[ 287: 272],
            prg0F[ 255: 240],prg0F[ 223: 208],prg0F[ 191: 176],prg0F[ 159: 144],prg0F[ 127: 112],prg0F[  95:  80],prg0F[  63:  48],prg0F[  31:  16],
            prg0E[4095:4080],prg0E[4063:4048],prg0E[4031:4016],prg0E[3999:3984],prg0E[3967:3952],prg0E[3935:3920],prg0E[3903:3888],prg0E[3871:3856],
            prg0E[3839:3824],prg0E[3807:3792],prg0E[3775:3760],prg0E[3743:3728],prg0E[3711:3696],prg0E[3679:3664],prg0E[3647:3632],prg0E[3615:3600],
            prg0E[3583:3568],prg0E[3551:3536],prg0E[3519:3504],prg0E[3487:3472],prg0E[3455:3440],prg0E[3423:3408],prg0E[3391:3376],prg0E[3359:3344],
            prg0E[3327:3312],prg0E[3295:3280],prg0E[3263:3248],prg0E[3231:3216],prg0E[3199:3184],prg0E[3167:3152],prg0E[3135:3120],prg0E[3103:3088],
            prg0E[3071:3056],prg0E[3039:3024],prg0E[3007:2992],prg0E[2975:2960],prg0E[2943:2928],prg0E[2911:2896],prg0E[2879:2864],prg0E[2847:2832],
            prg0E[2815:2800],prg0E[2783:2768],prg0E[2751:2736],prg0E[2719:2704],prg0E[2687:2672],prg0E[2655:2640],prg0E[2623:2608],prg0E[2591:2576],
            prg0E[2559:2544],prg0E[2527:2512],prg0E[2495:2480],prg0E[2463:2448],prg0E[2431:2416],prg0E[2399:2384],prg0E[2367:2352],prg0E[2335:2320],
            prg0E[2303:2288],prg0E[2271:2256],prg0E[2239:2224],prg0E[2207:2192],prg0E[2175:2160],prg0E[2143:2128],prg0E[2111:2096],prg0E[2079:2064],
            prg0E[2047:2032],prg0E[2015:2000],prg0E[1983:1968],prg0E[1951:1936],prg0E[1919:1904],prg0E[1887:1872],prg0E[1855:1840],prg0E[1823:1808],
            prg0E[1791:1776],prg0E[1759:1744],prg0E[1727:1712],prg0E[1695:1680],prg0E[1663:1648],prg0E[1631:1616],prg0E[1599:1584],prg0E[1567:1552],
            prg0E[1535:1520],prg0E[1503:1488],prg0E[1471:1456],prg0E[1439:1424],prg0E[1407:1392],prg0E[1375:1360],prg0E[1343:1328],prg0E[1311:1296],
            prg0E[1279:1264],prg0E[1247:1232],prg0E[1215:1200],prg0E[1183:1168],prg0E[1151:1136],prg0E[1119:1104],prg0E[1087:1072],prg0E[1055:1040],
            prg0E[1023:1008],prg0E[ 991: 976],prg0E[ 959: 944],prg0E[ 927: 912],prg0E[ 895: 880],prg0E[ 863: 848],prg0E[ 831: 816],prg0E[ 799: 784],
            prg0E[ 767: 752],prg0E[ 735: 720],prg0E[ 703: 688],prg0E[ 671: 656],prg0E[ 639: 624],prg0E[ 607: 592],prg0E[ 575: 560],prg0E[ 543: 528],
            prg0E[ 511: 496],prg0E[ 479: 464],prg0E[ 447: 432],prg0E[ 415: 400],prg0E[ 383: 368],prg0E[ 351: 336],prg0E[ 319: 304],prg0E[ 287: 272],
            prg0E[ 255: 240],prg0E[ 223: 208],prg0E[ 191: 176],prg0E[ 159: 144],prg0E[ 127: 112],prg0E[  95:  80],prg0E[  63:  48],prg0E[  31:  16]};
   localparam [4095:0]
     ph6 = {prg0D[4095:4080],prg0D[4063:4048],prg0D[4031:4016],prg0D[3999:3984],prg0D[3967:3952],prg0D[3935:3920],prg0D[3903:3888],prg0D[3871:3856],
            prg0D[3839:3824],prg0D[3807:3792],prg0D[3775:3760],prg0D[3743:3728],prg0D[3711:3696],prg0D[3679:3664],prg0D[3647:3632],prg0D[3615:3600],
            prg0D[3583:3568],prg0D[3551:3536],prg0D[3519:3504],prg0D[3487:3472],prg0D[3455:3440],prg0D[3423:3408],prg0D[3391:3376],prg0D[3359:3344],
            prg0D[3327:3312],prg0D[3295:3280],prg0D[3263:3248],prg0D[3231:3216],prg0D[3199:3184],prg0D[3167:3152],prg0D[3135:3120],prg0D[3103:3088],
            prg0D[3071:3056],prg0D[3039:3024],prg0D[3007:2992],prg0D[2975:2960],prg0D[2943:2928],prg0D[2911:2896],prg0D[2879:2864],prg0D[2847:2832],
            prg0D[2815:2800],prg0D[2783:2768],prg0D[2751:2736],prg0D[2719:2704],prg0D[2687:2672],prg0D[2655:2640],prg0D[2623:2608],prg0D[2591:2576],
            prg0D[2559:2544],prg0D[2527:2512],prg0D[2495:2480],prg0D[2463:2448],prg0D[2431:2416],prg0D[2399:2384],prg0D[2367:2352],prg0D[2335:2320],
            prg0D[2303:2288],prg0D[2271:2256],prg0D[2239:2224],prg0D[2207:2192],prg0D[2175:2160],prg0D[2143:2128],prg0D[2111:2096],prg0D[2079:2064],
            prg0D[2047:2032],prg0D[2015:2000],prg0D[1983:1968],prg0D[1951:1936],prg0D[1919:1904],prg0D[1887:1872],prg0D[1855:1840],prg0D[1823:1808],
            prg0D[1791:1776],prg0D[1759:1744],prg0D[1727:1712],prg0D[1695:1680],prg0D[1663:1648],prg0D[1631:1616],prg0D[1599:1584],prg0D[1567:1552],
            prg0D[1535:1520],prg0D[1503:1488],prg0D[1471:1456],prg0D[1439:1424],prg0D[1407:1392],prg0D[1375:1360],prg0D[1343:1328],prg0D[1311:1296],
            prg0D[1279:1264],prg0D[1247:1232],prg0D[1215:1200],prg0D[1183:1168],prg0D[1151:1136],prg0D[1119:1104],prg0D[1087:1072],prg0D[1055:1040],
            prg0D[1023:1008],prg0D[ 991: 976],prg0D[ 959: 944],prg0D[ 927: 912],prg0D[ 895: 880],prg0D[ 863: 848],prg0D[ 831: 816],prg0D[ 799: 784],
            prg0D[ 767: 752],prg0D[ 735: 720],prg0D[ 703: 688],prg0D[ 671: 656],prg0D[ 639: 624],prg0D[ 607: 592],prg0D[ 575: 560],prg0D[ 543: 528],
            prg0D[ 511: 496],prg0D[ 479: 464],prg0D[ 447: 432],prg0D[ 415: 400],prg0D[ 383: 368],prg0D[ 351: 336],prg0D[ 319: 304],prg0D[ 287: 272],
            prg0D[ 255: 240],prg0D[ 223: 208],prg0D[ 191: 176],prg0D[ 159: 144],prg0D[ 127: 112],prg0D[  95:  80],prg0D[  63:  48],prg0D[  31:  16],
            prg0C[4095:4080],prg0C[4063:4048],prg0C[4031:4016],prg0C[3999:3984],prg0C[3967:3952],prg0C[3935:3920],prg0C[3903:3888],prg0C[3871:3856],
            prg0C[3839:3824],prg0C[3807:3792],prg0C[3775:3760],prg0C[3743:3728],prg0C[3711:3696],prg0C[3679:3664],prg0C[3647:3632],prg0C[3615:3600],
            prg0C[3583:3568],prg0C[3551:3536],prg0C[3519:3504],prg0C[3487:3472],prg0C[3455:3440],prg0C[3423:3408],prg0C[3391:3376],prg0C[3359:3344],
            prg0C[3327:3312],prg0C[3295:3280],prg0C[3263:3248],prg0C[3231:3216],prg0C[3199:3184],prg0C[3167:3152],prg0C[3135:3120],prg0C[3103:3088],
            prg0C[3071:3056],prg0C[3039:3024],prg0C[3007:2992],prg0C[2975:2960],prg0C[2943:2928],prg0C[2911:2896],prg0C[2879:2864],prg0C[2847:2832],
            prg0C[2815:2800],prg0C[2783:2768],prg0C[2751:2736],prg0C[2719:2704],prg0C[2687:2672],prg0C[2655:2640],prg0C[2623:2608],prg0C[2591:2576],
            prg0C[2559:2544],prg0C[2527:2512],prg0C[2495:2480],prg0C[2463:2448],prg0C[2431:2416],prg0C[2399:2384],prg0C[2367:2352],prg0C[2335:2320],
            prg0C[2303:2288],prg0C[2271:2256],prg0C[2239:2224],prg0C[2207:2192],prg0C[2175:2160],prg0C[2143:2128],prg0C[2111:2096],prg0C[2079:2064],
            prg0C[2047:2032],prg0C[2015:2000],prg0C[1983:1968],prg0C[1951:1936],prg0C[1919:1904],prg0C[1887:1872],prg0C[1855:1840],prg0C[1823:1808],
            prg0C[1791:1776],prg0C[1759:1744],prg0C[1727:1712],prg0C[1695:1680],prg0C[1663:1648],prg0C[1631:1616],prg0C[1599:1584],prg0C[1567:1552],
            prg0C[1535:1520],prg0C[1503:1488],prg0C[1471:1456],prg0C[1439:1424],prg0C[1407:1392],prg0C[1375:1360],prg0C[1343:1328],prg0C[1311:1296],
            prg0C[1279:1264],prg0C[1247:1232],prg0C[1215:1200],prg0C[1183:1168],prg0C[1151:1136],prg0C[1119:1104],prg0C[1087:1072],prg0C[1055:1040],
            prg0C[1023:1008],prg0C[ 991: 976],prg0C[ 959: 944],prg0C[ 927: 912],prg0C[ 895: 880],prg0C[ 863: 848],prg0C[ 831: 816],prg0C[ 799: 784],
            prg0C[ 767: 752],prg0C[ 735: 720],prg0C[ 703: 688],prg0C[ 671: 656],prg0C[ 639: 624],prg0C[ 607: 592],prg0C[ 575: 560],prg0C[ 543: 528],
            prg0C[ 511: 496],prg0C[ 479: 464],prg0C[ 447: 432],prg0C[ 415: 400],prg0C[ 383: 368],prg0C[ 351: 336],prg0C[ 319: 304],prg0C[ 287: 272],
            prg0C[ 255: 240],prg0C[ 223: 208],prg0C[ 191: 176],prg0C[ 159: 144],prg0C[ 127: 112],prg0C[  95:  80],prg0C[  63:  48],prg0C[  31:  16]};
   localparam [4095:0]
     ph5 = {prg0B[4095:4080],prg0B[4063:4048],prg0B[4031:4016],prg0B[3999:3984],prg0B[3967:3952],prg0B[3935:3920],prg0B[3903:3888],prg0B[3871:3856],
            prg0B[3839:3824],prg0B[3807:3792],prg0B[3775:3760],prg0B[3743:3728],prg0B[3711:3696],prg0B[3679:3664],prg0B[3647:3632],prg0B[3615:3600],
            prg0B[3583:3568],prg0B[3551:3536],prg0B[3519:3504],prg0B[3487:3472],prg0B[3455:3440],prg0B[3423:3408],prg0B[3391:3376],prg0B[3359:3344],
            prg0B[3327:3312],prg0B[3295:3280],prg0B[3263:3248],prg0B[3231:3216],prg0B[3199:3184],prg0B[3167:3152],prg0B[3135:3120],prg0B[3103:3088],
            prg0B[3071:3056],prg0B[3039:3024],prg0B[3007:2992],prg0B[2975:2960],prg0B[2943:2928],prg0B[2911:2896],prg0B[2879:2864],prg0B[2847:2832],
            prg0B[2815:2800],prg0B[2783:2768],prg0B[2751:2736],prg0B[2719:2704],prg0B[2687:2672],prg0B[2655:2640],prg0B[2623:2608],prg0B[2591:2576],
            prg0B[2559:2544],prg0B[2527:2512],prg0B[2495:2480],prg0B[2463:2448],prg0B[2431:2416],prg0B[2399:2384],prg0B[2367:2352],prg0B[2335:2320],
            prg0B[2303:2288],prg0B[2271:2256],prg0B[2239:2224],prg0B[2207:2192],prg0B[2175:2160],prg0B[2143:2128],prg0B[2111:2096],prg0B[2079:2064],
            prg0B[2047:2032],prg0B[2015:2000],prg0B[1983:1968],prg0B[1951:1936],prg0B[1919:1904],prg0B[1887:1872],prg0B[1855:1840],prg0B[1823:1808],
            prg0B[1791:1776],prg0B[1759:1744],prg0B[1727:1712],prg0B[1695:1680],prg0B[1663:1648],prg0B[1631:1616],prg0B[1599:1584],prg0B[1567:1552],
            prg0B[1535:1520],prg0B[1503:1488],prg0B[1471:1456],prg0B[1439:1424],prg0B[1407:1392],prg0B[1375:1360],prg0B[1343:1328],prg0B[1311:1296],
            prg0B[1279:1264],prg0B[1247:1232],prg0B[1215:1200],prg0B[1183:1168],prg0B[1151:1136],prg0B[1119:1104],prg0B[1087:1072],prg0B[1055:1040],
            prg0B[1023:1008],prg0B[ 991: 976],prg0B[ 959: 944],prg0B[ 927: 912],prg0B[ 895: 880],prg0B[ 863: 848],prg0B[ 831: 816],prg0B[ 799: 784],
            prg0B[ 767: 752],prg0B[ 735: 720],prg0B[ 703: 688],prg0B[ 671: 656],prg0B[ 639: 624],prg0B[ 607: 592],prg0B[ 575: 560],prg0B[ 543: 528],
            prg0B[ 511: 496],prg0B[ 479: 464],prg0B[ 447: 432],prg0B[ 415: 400],prg0B[ 383: 368],prg0B[ 351: 336],prg0B[ 319: 304],prg0B[ 287: 272],
            prg0B[ 255: 240],prg0B[ 223: 208],prg0B[ 191: 176],prg0B[ 159: 144],prg0B[ 127: 112],prg0B[  95:  80],prg0B[  63:  48],prg0B[  31:  16],
            prg0A[4095:4080],prg0A[4063:4048],prg0A[4031:4016],prg0A[3999:3984],prg0A[3967:3952],prg0A[3935:3920],prg0A[3903:3888],prg0A[3871:3856],
            prg0A[3839:3824],prg0A[3807:3792],prg0A[3775:3760],prg0A[3743:3728],prg0A[3711:3696],prg0A[3679:3664],prg0A[3647:3632],prg0A[3615:3600],
            prg0A[3583:3568],prg0A[3551:3536],prg0A[3519:3504],prg0A[3487:3472],prg0A[3455:3440],prg0A[3423:3408],prg0A[3391:3376],prg0A[3359:3344],
            prg0A[3327:3312],prg0A[3295:3280],prg0A[3263:3248],prg0A[3231:3216],prg0A[3199:3184],prg0A[3167:3152],prg0A[3135:3120],prg0A[3103:3088],
            prg0A[3071:3056],prg0A[3039:3024],prg0A[3007:2992],prg0A[2975:2960],prg0A[2943:2928],prg0A[2911:2896],prg0A[2879:2864],prg0A[2847:2832],
            prg0A[2815:2800],prg0A[2783:2768],prg0A[2751:2736],prg0A[2719:2704],prg0A[2687:2672],prg0A[2655:2640],prg0A[2623:2608],prg0A[2591:2576],
            prg0A[2559:2544],prg0A[2527:2512],prg0A[2495:2480],prg0A[2463:2448],prg0A[2431:2416],prg0A[2399:2384],prg0A[2367:2352],prg0A[2335:2320],
            prg0A[2303:2288],prg0A[2271:2256],prg0A[2239:2224],prg0A[2207:2192],prg0A[2175:2160],prg0A[2143:2128],prg0A[2111:2096],prg0A[2079:2064],
            prg0A[2047:2032],prg0A[2015:2000],prg0A[1983:1968],prg0A[1951:1936],prg0A[1919:1904],prg0A[1887:1872],prg0A[1855:1840],prg0A[1823:1808],
            prg0A[1791:1776],prg0A[1759:1744],prg0A[1727:1712],prg0A[1695:1680],prg0A[1663:1648],prg0A[1631:1616],prg0A[1599:1584],prg0A[1567:1552],
            prg0A[1535:1520],prg0A[1503:1488],prg0A[1471:1456],prg0A[1439:1424],prg0A[1407:1392],prg0A[1375:1360],prg0A[1343:1328],prg0A[1311:1296],
            prg0A[1279:1264],prg0A[1247:1232],prg0A[1215:1200],prg0A[1183:1168],prg0A[1151:1136],prg0A[1119:1104],prg0A[1087:1072],prg0A[1055:1040],
            prg0A[1023:1008],prg0A[ 991: 976],prg0A[ 959: 944],prg0A[ 927: 912],prg0A[ 895: 880],prg0A[ 863: 848],prg0A[ 831: 816],prg0A[ 799: 784],
            prg0A[ 767: 752],prg0A[ 735: 720],prg0A[ 703: 688],prg0A[ 671: 656],prg0A[ 639: 624],prg0A[ 607: 592],prg0A[ 575: 560],prg0A[ 543: 528],
            prg0A[ 511: 496],prg0A[ 479: 464],prg0A[ 447: 432],prg0A[ 415: 400],prg0A[ 383: 368],prg0A[ 351: 336],prg0A[ 319: 304],prg0A[ 287: 272],
            prg0A[ 255: 240],prg0A[ 223: 208],prg0A[ 191: 176],prg0A[ 159: 144],prg0A[ 127: 112],prg0A[  95:  80],prg0A[  63:  48],prg0A[  31:  16]};
   localparam [4095:0]
     ph4 = {prg09[4095:4080],prg09[4063:4048],prg09[4031:4016],prg09[3999:3984],prg09[3967:3952],prg09[3935:3920],prg09[3903:3888],prg09[3871:3856],
            prg09[3839:3824],prg09[3807:3792],prg09[3775:3760],prg09[3743:3728],prg09[3711:3696],prg09[3679:3664],prg09[3647:3632],prg09[3615:3600],
            prg09[3583:3568],prg09[3551:3536],prg09[3519:3504],prg09[3487:3472],prg09[3455:3440],prg09[3423:3408],prg09[3391:3376],prg09[3359:3344],
            prg09[3327:3312],prg09[3295:3280],prg09[3263:3248],prg09[3231:3216],prg09[3199:3184],prg09[3167:3152],prg09[3135:3120],prg09[3103:3088],
            prg09[3071:3056],prg09[3039:3024],prg09[3007:2992],prg09[2975:2960],prg09[2943:2928],prg09[2911:2896],prg09[2879:2864],prg09[2847:2832],
            prg09[2815:2800],prg09[2783:2768],prg09[2751:2736],prg09[2719:2704],prg09[2687:2672],prg09[2655:2640],prg09[2623:2608],prg09[2591:2576],
            prg09[2559:2544],prg09[2527:2512],prg09[2495:2480],prg09[2463:2448],prg09[2431:2416],prg09[2399:2384],prg09[2367:2352],prg09[2335:2320],
            prg09[2303:2288],prg09[2271:2256],prg09[2239:2224],prg09[2207:2192],prg09[2175:2160],prg09[2143:2128],prg09[2111:2096],prg09[2079:2064],
            prg09[2047:2032],prg09[2015:2000],prg09[1983:1968],prg09[1951:1936],prg09[1919:1904],prg09[1887:1872],prg09[1855:1840],prg09[1823:1808],
            prg09[1791:1776],prg09[1759:1744],prg09[1727:1712],prg09[1695:1680],prg09[1663:1648],prg09[1631:1616],prg09[1599:1584],prg09[1567:1552],
            prg09[1535:1520],prg09[1503:1488],prg09[1471:1456],prg09[1439:1424],prg09[1407:1392],prg09[1375:1360],prg09[1343:1328],prg09[1311:1296],
            prg09[1279:1264],prg09[1247:1232],prg09[1215:1200],prg09[1183:1168],prg09[1151:1136],prg09[1119:1104],prg09[1087:1072],prg09[1055:1040],
            prg09[1023:1008],prg09[ 991: 976],prg09[ 959: 944],prg09[ 927: 912],prg09[ 895: 880],prg09[ 863: 848],prg09[ 831: 816],prg09[ 799: 784],
            prg09[ 767: 752],prg09[ 735: 720],prg09[ 703: 688],prg09[ 671: 656],prg09[ 639: 624],prg09[ 607: 592],prg09[ 575: 560],prg09[ 543: 528],
            prg09[ 511: 496],prg09[ 479: 464],prg09[ 447: 432],prg09[ 415: 400],prg09[ 383: 368],prg09[ 351: 336],prg09[ 319: 304],prg09[ 287: 272],
            prg09[ 255: 240],prg09[ 223: 208],prg09[ 191: 176],prg09[ 159: 144],prg09[ 127: 112],prg09[  95:  80],prg09[  63:  48],prg09[  31:  16],
            prg08[4095:4080],prg08[4063:4048],prg08[4031:4016],prg08[3999:3984],prg08[3967:3952],prg08[3935:3920],prg08[3903:3888],prg08[3871:3856],
            prg08[3839:3824],prg08[3807:3792],prg08[3775:3760],prg08[3743:3728],prg08[3711:3696],prg08[3679:3664],prg08[3647:3632],prg08[3615:3600],
            prg08[3583:3568],prg08[3551:3536],prg08[3519:3504],prg08[3487:3472],prg08[3455:3440],prg08[3423:3408],prg08[3391:3376],prg08[3359:3344],
            prg08[3327:3312],prg08[3295:3280],prg08[3263:3248],prg08[3231:3216],prg08[3199:3184],prg08[3167:3152],prg08[3135:3120],prg08[3103:3088],
            prg08[3071:3056],prg08[3039:3024],prg08[3007:2992],prg08[2975:2960],prg08[2943:2928],prg08[2911:2896],prg08[2879:2864],prg08[2847:2832],
            prg08[2815:2800],prg08[2783:2768],prg08[2751:2736],prg08[2719:2704],prg08[2687:2672],prg08[2655:2640],prg08[2623:2608],prg08[2591:2576],
            prg08[2559:2544],prg08[2527:2512],prg08[2495:2480],prg08[2463:2448],prg08[2431:2416],prg08[2399:2384],prg08[2367:2352],prg08[2335:2320],
            prg08[2303:2288],prg08[2271:2256],prg08[2239:2224],prg08[2207:2192],prg08[2175:2160],prg08[2143:2128],prg08[2111:2096],prg08[2079:2064],
            prg08[2047:2032],prg08[2015:2000],prg08[1983:1968],prg08[1951:1936],prg08[1919:1904],prg08[1887:1872],prg08[1855:1840],prg08[1823:1808],
            prg08[1791:1776],prg08[1759:1744],prg08[1727:1712],prg08[1695:1680],prg08[1663:1648],prg08[1631:1616],prg08[1599:1584],prg08[1567:1552],
            prg08[1535:1520],prg08[1503:1488],prg08[1471:1456],prg08[1439:1424],prg08[1407:1392],prg08[1375:1360],prg08[1343:1328],prg08[1311:1296],
            prg08[1279:1264],prg08[1247:1232],prg08[1215:1200],prg08[1183:1168],prg08[1151:1136],prg08[1119:1104],prg08[1087:1072],prg08[1055:1040],
            prg08[1023:1008],prg08[ 991: 976],prg08[ 959: 944],prg08[ 927: 912],prg08[ 895: 880],prg08[ 863: 848],prg08[ 831: 816],prg08[ 799: 784],
            prg08[ 767: 752],prg08[ 735: 720],prg08[ 703: 688],prg08[ 671: 656],prg08[ 639: 624],prg08[ 607: 592],prg08[ 575: 560],prg08[ 543: 528],
            prg08[ 511: 496],prg08[ 479: 464],prg08[ 447: 432],prg08[ 415: 400],prg08[ 383: 368],prg08[ 351: 336],prg08[ 319: 304],prg08[ 287: 272],
            prg08[ 255: 240],prg08[ 223: 208],prg08[ 191: 176],prg08[ 159: 144],prg08[ 127: 112],prg08[  95:  80],prg08[  63:  48],prg08[  31:  16]};
   localparam [4095:0]
     ph3 = {prg07[4095:4080],prg07[4063:4048],prg07[4031:4016],prg07[3999:3984],prg07[3967:3952],prg07[3935:3920],prg07[3903:3888],prg07[3871:3856],
            prg07[3839:3824],prg07[3807:3792],prg07[3775:3760],prg07[3743:3728],prg07[3711:3696],prg07[3679:3664],prg07[3647:3632],prg07[3615:3600],
            prg07[3583:3568],prg07[3551:3536],prg07[3519:3504],prg07[3487:3472],prg07[3455:3440],prg07[3423:3408],prg07[3391:3376],prg07[3359:3344],
            prg07[3327:3312],prg07[3295:3280],prg07[3263:3248],prg07[3231:3216],prg07[3199:3184],prg07[3167:3152],prg07[3135:3120],prg07[3103:3088],
            prg07[3071:3056],prg07[3039:3024],prg07[3007:2992],prg07[2975:2960],prg07[2943:2928],prg07[2911:2896],prg07[2879:2864],prg07[2847:2832],
            prg07[2815:2800],prg07[2783:2768],prg07[2751:2736],prg07[2719:2704],prg07[2687:2672],prg07[2655:2640],prg07[2623:2608],prg07[2591:2576],
            prg07[2559:2544],prg07[2527:2512],prg07[2495:2480],prg07[2463:2448],prg07[2431:2416],prg07[2399:2384],prg07[2367:2352],prg07[2335:2320],
            prg07[2303:2288],prg07[2271:2256],prg07[2239:2224],prg07[2207:2192],prg07[2175:2160],prg07[2143:2128],prg07[2111:2096],prg07[2079:2064],
            prg07[2047:2032],prg07[2015:2000],prg07[1983:1968],prg07[1951:1936],prg07[1919:1904],prg07[1887:1872],prg07[1855:1840],prg07[1823:1808],
            prg07[1791:1776],prg07[1759:1744],prg07[1727:1712],prg07[1695:1680],prg07[1663:1648],prg07[1631:1616],prg07[1599:1584],prg07[1567:1552],
            prg07[1535:1520],prg07[1503:1488],prg07[1471:1456],prg07[1439:1424],prg07[1407:1392],prg07[1375:1360],prg07[1343:1328],prg07[1311:1296],
            prg07[1279:1264],prg07[1247:1232],prg07[1215:1200],prg07[1183:1168],prg07[1151:1136],prg07[1119:1104],prg07[1087:1072],prg07[1055:1040],
            prg07[1023:1008],prg07[ 991: 976],prg07[ 959: 944],prg07[ 927: 912],prg07[ 895: 880],prg07[ 863: 848],prg07[ 831: 816],prg07[ 799: 784],
            prg07[ 767: 752],prg07[ 735: 720],prg07[ 703: 688],prg07[ 671: 656],prg07[ 639: 624],prg07[ 607: 592],prg07[ 575: 560],prg07[ 543: 528],
            prg07[ 511: 496],prg07[ 479: 464],prg07[ 447: 432],prg07[ 415: 400],prg07[ 383: 368],prg07[ 351: 336],prg07[ 319: 304],prg07[ 287: 272],
            prg07[ 255: 240],prg07[ 223: 208],prg07[ 191: 176],prg07[ 159: 144],prg07[ 127: 112],prg07[  95:  80],prg07[  63:  48],prg07[  31:  16],
            prg06[4095:4080],prg06[4063:4048],prg06[4031:4016],prg06[3999:3984],prg06[3967:3952],prg06[3935:3920],prg06[3903:3888],prg06[3871:3856],
            prg06[3839:3824],prg06[3807:3792],prg06[3775:3760],prg06[3743:3728],prg06[3711:3696],prg06[3679:3664],prg06[3647:3632],prg06[3615:3600],
            prg06[3583:3568],prg06[3551:3536],prg06[3519:3504],prg06[3487:3472],prg06[3455:3440],prg06[3423:3408],prg06[3391:3376],prg06[3359:3344],
            prg06[3327:3312],prg06[3295:3280],prg06[3263:3248],prg06[3231:3216],prg06[3199:3184],prg06[3167:3152],prg06[3135:3120],prg06[3103:3088],
            prg06[3071:3056],prg06[3039:3024],prg06[3007:2992],prg06[2975:2960],prg06[2943:2928],prg06[2911:2896],prg06[2879:2864],prg06[2847:2832],
            prg06[2815:2800],prg06[2783:2768],prg06[2751:2736],prg06[2719:2704],prg06[2687:2672],prg06[2655:2640],prg06[2623:2608],prg06[2591:2576],
            prg06[2559:2544],prg06[2527:2512],prg06[2495:2480],prg06[2463:2448],prg06[2431:2416],prg06[2399:2384],prg06[2367:2352],prg06[2335:2320],
            prg06[2303:2288],prg06[2271:2256],prg06[2239:2224],prg06[2207:2192],prg06[2175:2160],prg06[2143:2128],prg06[2111:2096],prg06[2079:2064],
            prg06[2047:2032],prg06[2015:2000],prg06[1983:1968],prg06[1951:1936],prg06[1919:1904],prg06[1887:1872],prg06[1855:1840],prg06[1823:1808],
            prg06[1791:1776],prg06[1759:1744],prg06[1727:1712],prg06[1695:1680],prg06[1663:1648],prg06[1631:1616],prg06[1599:1584],prg06[1567:1552],
            prg06[1535:1520],prg06[1503:1488],prg06[1471:1456],prg06[1439:1424],prg06[1407:1392],prg06[1375:1360],prg06[1343:1328],prg06[1311:1296],
            prg06[1279:1264],prg06[1247:1232],prg06[1215:1200],prg06[1183:1168],prg06[1151:1136],prg06[1119:1104],prg06[1087:1072],prg06[1055:1040],
            prg06[1023:1008],prg06[ 991: 976],prg06[ 959: 944],prg06[ 927: 912],prg06[ 895: 880],prg06[ 863: 848],prg06[ 831: 816],prg06[ 799: 784],
            prg06[ 767: 752],prg06[ 735: 720],prg06[ 703: 688],prg06[ 671: 656],prg06[ 639: 624],prg06[ 607: 592],prg06[ 575: 560],prg06[ 543: 528],
            prg06[ 511: 496],prg06[ 479: 464],prg06[ 447: 432],prg06[ 415: 400],prg06[ 383: 368],prg06[ 351: 336],prg06[ 319: 304],prg06[ 287: 272],
            prg06[ 255: 240],prg06[ 223: 208],prg06[ 191: 176],prg06[ 159: 144],prg06[ 127: 112],prg06[  95:  80],prg06[  63:  48],prg06[  31:  16]};
   localparam [4095:0]
     ph2 = {prg05[4095:4080],prg05[4063:4048],prg05[4031:4016],prg05[3999:3984],prg05[3967:3952],prg05[3935:3920],prg05[3903:3888],prg05[3871:3856],
            prg05[3839:3824],prg05[3807:3792],prg05[3775:3760],prg05[3743:3728],prg05[3711:3696],prg05[3679:3664],prg05[3647:3632],prg05[3615:3600],
            prg05[3583:3568],prg05[3551:3536],prg05[3519:3504],prg05[3487:3472],prg05[3455:3440],prg05[3423:3408],prg05[3391:3376],prg05[3359:3344],
            prg05[3327:3312],prg05[3295:3280],prg05[3263:3248],prg05[3231:3216],prg05[3199:3184],prg05[3167:3152],prg05[3135:3120],prg05[3103:3088],
            prg05[3071:3056],prg05[3039:3024],prg05[3007:2992],prg05[2975:2960],prg05[2943:2928],prg05[2911:2896],prg05[2879:2864],prg05[2847:2832],
            prg05[2815:2800],prg05[2783:2768],prg05[2751:2736],prg05[2719:2704],prg05[2687:2672],prg05[2655:2640],prg05[2623:2608],prg05[2591:2576],
            prg05[2559:2544],prg05[2527:2512],prg05[2495:2480],prg05[2463:2448],prg05[2431:2416],prg05[2399:2384],prg05[2367:2352],prg05[2335:2320],
            prg05[2303:2288],prg05[2271:2256],prg05[2239:2224],prg05[2207:2192],prg05[2175:2160],prg05[2143:2128],prg05[2111:2096],prg05[2079:2064],
            prg05[2047:2032],prg05[2015:2000],prg05[1983:1968],prg05[1951:1936],prg05[1919:1904],prg05[1887:1872],prg05[1855:1840],prg05[1823:1808],
            prg05[1791:1776],prg05[1759:1744],prg05[1727:1712],prg05[1695:1680],prg05[1663:1648],prg05[1631:1616],prg05[1599:1584],prg05[1567:1552],
            prg05[1535:1520],prg05[1503:1488],prg05[1471:1456],prg05[1439:1424],prg05[1407:1392],prg05[1375:1360],prg05[1343:1328],prg05[1311:1296],
            prg05[1279:1264],prg05[1247:1232],prg05[1215:1200],prg05[1183:1168],prg05[1151:1136],prg05[1119:1104],prg05[1087:1072],prg05[1055:1040],
            prg05[1023:1008],prg05[ 991: 976],prg05[ 959: 944],prg05[ 927: 912],prg05[ 895: 880],prg05[ 863: 848],prg05[ 831: 816],prg05[ 799: 784],
            prg05[ 767: 752],prg05[ 735: 720],prg05[ 703: 688],prg05[ 671: 656],prg05[ 639: 624],prg05[ 607: 592],prg05[ 575: 560],prg05[ 543: 528],
            prg05[ 511: 496],prg05[ 479: 464],prg05[ 447: 432],prg05[ 415: 400],prg05[ 383: 368],prg05[ 351: 336],prg05[ 319: 304],prg05[ 287: 272],
            prg05[ 255: 240],prg05[ 223: 208],prg05[ 191: 176],prg05[ 159: 144],prg05[ 127: 112],prg05[  95:  80],prg05[  63:  48],prg05[  31:  16],
            prg04[4095:4080],prg04[4063:4048],prg04[4031:4016],prg04[3999:3984],prg04[3967:3952],prg04[3935:3920],prg04[3903:3888],prg04[3871:3856],
            prg04[3839:3824],prg04[3807:3792],prg04[3775:3760],prg04[3743:3728],prg04[3711:3696],prg04[3679:3664],prg04[3647:3632],prg04[3615:3600],
            prg04[3583:3568],prg04[3551:3536],prg04[3519:3504],prg04[3487:3472],prg04[3455:3440],prg04[3423:3408],prg04[3391:3376],prg04[3359:3344],
            prg04[3327:3312],prg04[3295:3280],prg04[3263:3248],prg04[3231:3216],prg04[3199:3184],prg04[3167:3152],prg04[3135:3120],prg04[3103:3088],
            prg04[3071:3056],prg04[3039:3024],prg04[3007:2992],prg04[2975:2960],prg04[2943:2928],prg04[2911:2896],prg04[2879:2864],prg04[2847:2832],
            prg04[2815:2800],prg04[2783:2768],prg04[2751:2736],prg04[2719:2704],prg04[2687:2672],prg04[2655:2640],prg04[2623:2608],prg04[2591:2576],
            prg04[2559:2544],prg04[2527:2512],prg04[2495:2480],prg04[2463:2448],prg04[2431:2416],prg04[2399:2384],prg04[2367:2352],prg04[2335:2320],
            prg04[2303:2288],prg04[2271:2256],prg04[2239:2224],prg04[2207:2192],prg04[2175:2160],prg04[2143:2128],prg04[2111:2096],prg04[2079:2064],
            prg04[2047:2032],prg04[2015:2000],prg04[1983:1968],prg04[1951:1936],prg04[1919:1904],prg04[1887:1872],prg04[1855:1840],prg04[1823:1808],
            prg04[1791:1776],prg04[1759:1744],prg04[1727:1712],prg04[1695:1680],prg04[1663:1648],prg04[1631:1616],prg04[1599:1584],prg04[1567:1552],
            prg04[1535:1520],prg04[1503:1488],prg04[1471:1456],prg04[1439:1424],prg04[1407:1392],prg04[1375:1360],prg04[1343:1328],prg04[1311:1296],
            prg04[1279:1264],prg04[1247:1232],prg04[1215:1200],prg04[1183:1168],prg04[1151:1136],prg04[1119:1104],prg04[1087:1072],prg04[1055:1040],
            prg04[1023:1008],prg04[ 991: 976],prg04[ 959: 944],prg04[ 927: 912],prg04[ 895: 880],prg04[ 863: 848],prg04[ 831: 816],prg04[ 799: 784],
            prg04[ 767: 752],prg04[ 735: 720],prg04[ 703: 688],prg04[ 671: 656],prg04[ 639: 624],prg04[ 607: 592],prg04[ 575: 560],prg04[ 543: 528],
            prg04[ 511: 496],prg04[ 479: 464],prg04[ 447: 432],prg04[ 415: 400],prg04[ 383: 368],prg04[ 351: 336],prg04[ 319: 304],prg04[ 287: 272],
            prg04[ 255: 240],prg04[ 223: 208],prg04[ 191: 176],prg04[ 159: 144],prg04[ 127: 112],prg04[  95:  80],prg04[  63:  48],prg04[  31:  16]};
   localparam [4095:0]
     ph1 = {prg03[4095:4080],prg03[4063:4048],prg03[4031:4016],prg03[3999:3984],prg03[3967:3952],prg03[3935:3920],prg03[3903:3888],prg03[3871:3856],
            prg03[3839:3824],prg03[3807:3792],prg03[3775:3760],prg03[3743:3728],prg03[3711:3696],prg03[3679:3664],prg03[3647:3632],prg03[3615:3600],
            prg03[3583:3568],prg03[3551:3536],prg03[3519:3504],prg03[3487:3472],prg03[3455:3440],prg03[3423:3408],prg03[3391:3376],prg03[3359:3344],
            prg03[3327:3312],prg03[3295:3280],prg03[3263:3248],prg03[3231:3216],prg03[3199:3184],prg03[3167:3152],prg03[3135:3120],prg03[3103:3088],
            prg03[3071:3056],prg03[3039:3024],prg03[3007:2992],prg03[2975:2960],prg03[2943:2928],prg03[2911:2896],prg03[2879:2864],prg03[2847:2832],
            prg03[2815:2800],prg03[2783:2768],prg03[2751:2736],prg03[2719:2704],prg03[2687:2672],prg03[2655:2640],prg03[2623:2608],prg03[2591:2576],
            prg03[2559:2544],prg03[2527:2512],prg03[2495:2480],prg03[2463:2448],prg03[2431:2416],prg03[2399:2384],prg03[2367:2352],prg03[2335:2320],
            prg03[2303:2288],prg03[2271:2256],prg03[2239:2224],prg03[2207:2192],prg03[2175:2160],prg03[2143:2128],prg03[2111:2096],prg03[2079:2064],
            prg03[2047:2032],prg03[2015:2000],prg03[1983:1968],prg03[1951:1936],prg03[1919:1904],prg03[1887:1872],prg03[1855:1840],prg03[1823:1808],
            prg03[1791:1776],prg03[1759:1744],prg03[1727:1712],prg03[1695:1680],prg03[1663:1648],prg03[1631:1616],prg03[1599:1584],prg03[1567:1552],
            prg03[1535:1520],prg03[1503:1488],prg03[1471:1456],prg03[1439:1424],prg03[1407:1392],prg03[1375:1360],prg03[1343:1328],prg03[1311:1296],
            prg03[1279:1264],prg03[1247:1232],prg03[1215:1200],prg03[1183:1168],prg03[1151:1136],prg03[1119:1104],prg03[1087:1072],prg03[1055:1040],
            prg03[1023:1008],prg03[ 991: 976],prg03[ 959: 944],prg03[ 927: 912],prg03[ 895: 880],prg03[ 863: 848],prg03[ 831: 816],prg03[ 799: 784],
            prg03[ 767: 752],prg03[ 735: 720],prg03[ 703: 688],prg03[ 671: 656],prg03[ 639: 624],prg03[ 607: 592],prg03[ 575: 560],prg03[ 543: 528],
            prg03[ 511: 496],prg03[ 479: 464],prg03[ 447: 432],prg03[ 415: 400],prg03[ 383: 368],prg03[ 351: 336],prg03[ 319: 304],prg03[ 287: 272],
            prg03[ 255: 240],prg03[ 223: 208],prg03[ 191: 176],prg03[ 159: 144],prg03[ 127: 112],prg03[  95:  80],prg03[  63:  48],prg03[  31:  16],
            prg02[4095:4080],prg02[4063:4048],prg02[4031:4016],prg02[3999:3984],prg02[3967:3952],prg02[3935:3920],prg02[3903:3888],prg02[3871:3856],
            prg02[3839:3824],prg02[3807:3792],prg02[3775:3760],prg02[3743:3728],prg02[3711:3696],prg02[3679:3664],prg02[3647:3632],prg02[3615:3600],
            prg02[3583:3568],prg02[3551:3536],prg02[3519:3504],prg02[3487:3472],prg02[3455:3440],prg02[3423:3408],prg02[3391:3376],prg02[3359:3344],
            prg02[3327:3312],prg02[3295:3280],prg02[3263:3248],prg02[3231:3216],prg02[3199:3184],prg02[3167:3152],prg02[3135:3120],prg02[3103:3088],
            prg02[3071:3056],prg02[3039:3024],prg02[3007:2992],prg02[2975:2960],prg02[2943:2928],prg02[2911:2896],prg02[2879:2864],prg02[2847:2832],
            prg02[2815:2800],prg02[2783:2768],prg02[2751:2736],prg02[2719:2704],prg02[2687:2672],prg02[2655:2640],prg02[2623:2608],prg02[2591:2576],
            prg02[2559:2544],prg02[2527:2512],prg02[2495:2480],prg02[2463:2448],prg02[2431:2416],prg02[2399:2384],prg02[2367:2352],prg02[2335:2320],
            prg02[2303:2288],prg02[2271:2256],prg02[2239:2224],prg02[2207:2192],prg02[2175:2160],prg02[2143:2128],prg02[2111:2096],prg02[2079:2064],
            prg02[2047:2032],prg02[2015:2000],prg02[1983:1968],prg02[1951:1936],prg02[1919:1904],prg02[1887:1872],prg02[1855:1840],prg02[1823:1808],
            prg02[1791:1776],prg02[1759:1744],prg02[1727:1712],prg02[1695:1680],prg02[1663:1648],prg02[1631:1616],prg02[1599:1584],prg02[1567:1552],
            prg02[1535:1520],prg02[1503:1488],prg02[1471:1456],prg02[1439:1424],prg02[1407:1392],prg02[1375:1360],prg02[1343:1328],prg02[1311:1296],
            prg02[1279:1264],prg02[1247:1232],prg02[1215:1200],prg02[1183:1168],prg02[1151:1136],prg02[1119:1104],prg02[1087:1072],prg02[1055:1040],
            prg02[1023:1008],prg02[ 991: 976],prg02[ 959: 944],prg02[ 927: 912],prg02[ 895: 880],prg02[ 863: 848],prg02[ 831: 816],prg02[ 799: 784],
            prg02[ 767: 752],prg02[ 735: 720],prg02[ 703: 688],prg02[ 671: 656],prg02[ 639: 624],prg02[ 607: 592],prg02[ 575: 560],prg02[ 543: 528],
            prg02[ 511: 496],prg02[ 479: 464],prg02[ 447: 432],prg02[ 415: 400],prg02[ 383: 368],prg02[ 351: 336],prg02[ 319: 304],prg02[ 287: 272],
            prg02[ 255: 240],prg02[ 223: 208],prg02[ 191: 176],prg02[ 159: 144],prg02[ 127: 112],prg02[  95:  80],prg02[  63:  48],prg02[  31:  16]};
   localparam [4095:0]
     ph0 = {prg01[4095:4080],prg01[4063:4048],prg01[4031:4016],prg01[3999:3984],prg01[3967:3952],prg01[3935:3920],prg01[3903:3888],prg01[3871:3856],
            prg01[3839:3824],prg01[3807:3792],prg01[3775:3760],prg01[3743:3728],prg01[3711:3696],prg01[3679:3664],prg01[3647:3632],prg01[3615:3600],
            prg01[3583:3568],prg01[3551:3536],prg01[3519:3504],prg01[3487:3472],prg01[3455:3440],prg01[3423:3408],prg01[3391:3376],prg01[3359:3344],
            prg01[3327:3312],prg01[3295:3280],prg01[3263:3248],prg01[3231:3216],prg01[3199:3184],prg01[3167:3152],prg01[3135:3120],prg01[3103:3088],
            prg01[3071:3056],prg01[3039:3024],prg01[3007:2992],prg01[2975:2960],prg01[2943:2928],prg01[2911:2896],prg01[2879:2864],prg01[2847:2832],
            prg01[2815:2800],prg01[2783:2768],prg01[2751:2736],prg01[2719:2704],prg01[2687:2672],prg01[2655:2640],prg01[2623:2608],prg01[2591:2576],
            prg01[2559:2544],prg01[2527:2512],prg01[2495:2480],prg01[2463:2448],prg01[2431:2416],prg01[2399:2384],prg01[2367:2352],prg01[2335:2320],
            prg01[2303:2288],prg01[2271:2256],prg01[2239:2224],prg01[2207:2192],prg01[2175:2160],prg01[2143:2128],prg01[2111:2096],prg01[2079:2064],
            prg01[2047:2032],prg01[2015:2000],prg01[1983:1968],prg01[1951:1936],prg01[1919:1904],prg01[1887:1872],prg01[1855:1840],prg01[1823:1808],
            prg01[1791:1776],prg01[1759:1744],prg01[1727:1712],prg01[1695:1680],prg01[1663:1648],prg01[1631:1616],prg01[1599:1584],prg01[1567:1552],
            prg01[1535:1520],prg01[1503:1488],prg01[1471:1456],prg01[1439:1424],prg01[1407:1392],prg01[1375:1360],prg01[1343:1328],prg01[1311:1296],
            prg01[1279:1264],prg01[1247:1232],prg01[1215:1200],prg01[1183:1168],prg01[1151:1136],prg01[1119:1104],prg01[1087:1072],prg01[1055:1040],
            prg01[1023:1008],prg01[ 991: 976],prg01[ 959: 944],prg01[ 927: 912],prg01[ 895: 880],prg01[ 863: 848],prg01[ 831: 816],prg01[ 799: 784],
            prg01[ 767: 752],prg01[ 735: 720],prg01[ 703: 688],prg01[ 671: 656],prg01[ 639: 624],prg01[ 607: 592],prg01[ 575: 560],prg01[ 543: 528],
            prg01[ 511: 496],prg01[ 479: 464],prg01[ 447: 432],prg01[ 415: 400],prg01[ 383: 368],prg01[ 351: 336],prg01[ 319: 304],prg01[ 287: 272],
            prg01[ 255: 240],prg01[ 223: 208],prg01[ 191: 176],prg01[ 159: 144],prg01[ 127: 112],prg01[  95:  80],prg01[  63:  48],prg01[  31:  16],
            prg00[4095:4080],prg00[4063:4048],prg00[4031:4016],prg00[3999:3984],prg00[3967:3952],prg00[3935:3920],prg00[3903:3888],prg00[3871:3856],
            prg00[3839:3824],prg00[3807:3792],prg00[3775:3760],prg00[3743:3728],prg00[3711:3696],prg00[3679:3664],prg00[3647:3632],prg00[3615:3600],
            prg00[3583:3568],prg00[3551:3536],prg00[3519:3504],prg00[3487:3472],prg00[3455:3440],prg00[3423:3408],prg00[3391:3376],prg00[3359:3344],
            prg00[3327:3312],prg00[3295:3280],prg00[3263:3248],prg00[3231:3216],prg00[3199:3184],prg00[3167:3152],prg00[3135:3120],prg00[3103:3088],
            prg00[3071:3056],prg00[3039:3024],prg00[3007:2992],prg00[2975:2960],prg00[2943:2928],prg00[2911:2896],prg00[2879:2864],prg00[2847:2832],
            prg00[2815:2800],prg00[2783:2768],prg00[2751:2736],prg00[2719:2704],prg00[2687:2672],prg00[2655:2640],prg00[2623:2608],prg00[2591:2576],
            prg00[2559:2544],prg00[2527:2512],prg00[2495:2480],prg00[2463:2448],prg00[2431:2416],prg00[2399:2384],prg00[2367:2352],prg00[2335:2320],
            prg00[2303:2288],prg00[2271:2256],prg00[2239:2224],prg00[2207:2192],prg00[2175:2160],prg00[2143:2128],prg00[2111:2096],prg00[2079:2064],
            prg00[2047:2032],prg00[2015:2000],prg00[1983:1968],prg00[1951:1936],prg00[1919:1904],prg00[1887:1872],prg00[1855:1840],prg00[1823:1808],
            prg00[1791:1776],prg00[1759:1744],prg00[1727:1712],prg00[1695:1680],prg00[1663:1648],prg00[1631:1616],prg00[1599:1584],prg00[1567:1552],
            prg00[1535:1520],prg00[1503:1488],prg00[1471:1456],prg00[1439:1424],prg00[1407:1392],prg00[1375:1360],prg00[1343:1328],prg00[1311:1296],
            prg00[1279:1264],prg00[1247:1232],prg00[1215:1200],prg00[1183:1168],prg00[1151:1136],prg00[1119:1104],prg00[1087:1072],prg00[1055:1040],
            prg00[1023:1008],prg00[ 991: 976],prg00[ 959: 944],prg00[ 927: 912],prg00[ 895: 880],prg00[ 863: 848],prg00[ 831: 816],prg00[ 799: 784],
            prg00[ 767: 752],prg00[ 735: 720],prg00[ 703: 688],prg00[ 671: 656],prg00[ 639: 624],prg00[ 607: 592],prg00[ 575: 560],prg00[ 543: 528],
            prg00[ 511: 496],prg00[ 479: 464],prg00[ 447: 432],prg00[ 415: 400],prg00[ 383: 368],prg00[ 351: 336],prg00[ 319: 304],prg00[ 287: 272],
            prg00[ 255: 240],prg00[ 223: 208],prg00[ 191: 176],prg00[ 159: 144],prg00[ 127: 112],prg00[  95:  80],prg00[  63:  48],prg00[  31:  16]};

   m_ebr_w16 #(.EBRADRWIDTH(EBRADRWIDTH),
               .prg0(pb0), .prg1(pb1), .prg2(pb2), .prg3(pb3), .prg4(pb4), .prg5(pb5), .prg6(pb6), .prg7(pb7) )
   ebrb 
     (/*AUTOINST*/
      // Outputs
      .DAT_O                            (eDAT_O[15:0]),
      // Inputs
      .B                                (B[15:0]),
      .Rai                              (Rai[EBRADRWIDTH-1:0]),
      .Wai                              (Wai[EBRADRWIDTH-1:0]),
      .clk                              (clk),
      .bmask                            (bmask[1:0]),
      .iwe                              (iwe));
   
   m_ebr_w16 #(.EBRADRWIDTH(EBRADRWIDTH),
               .prg0(ph0), .prg1(ph1), .prg2(ph2), .prg3(ph3), .prg4(ph4), .prg5(ph5), .prg6(ph6), .prg7(ph7) )
   ebrh
     (
      // Outputs
      .DAT_O                            (eDAT_O[31:16]),
      // Inputs
      .B                                (B[31:16]),
      .bmask                            (bmask[3:2]),
      /*AUTOINST*/
      // Inputs
      .Rai                              (Rai[EBRADRWIDTH-1:0]),
      .Wai                              (Wai[EBRADRWIDTH-1:0]),
      .clk                              (clk),
      .iwe                              (iwe));
   
endmodule
//MODE	DATA Width  Used WDATA/RDATA Bits
//0	16	    15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
//1	8	    14, 12, 10, 8, 6, 4, 2, 0
//2	4	    13, 9, 5, 1
//3	2	    11, 3

/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * EBR program memory is split into 16-bit wide memory specified here.
 * The memory is up to 4 KiB large
 */
module m_ebr_w16
  # ( parameter EBRADRWIDTH = 8,
      parameter [4095:0] prg0 = 4096'h0,
      parameter [4095:0] prg1 = 4096'h0,
      parameter [4095:0] prg2 = 4096'h0,
      parameter [4095:0] prg3 = 4096'h0,
      parameter [4095:0] prg4 = 4096'h0,
      parameter [4095:0] prg5 = 4096'h0,
      parameter [4095:0] prg6 = 4096'h0,
      parameter [4095:0] prg7 = 4096'h0
      )
   (
    input [15:0]            B, //     Output from ALU
    input [EBRADRWIDTH-1:0] Rai, //   Read adddress
    input [EBRADRWIDTH-1:0] Wai, //   Write adddress
    input                   clk, //   System clock
    input [1:0]             bmask, // Byte masks for write, active LUW
    input                   iwe, //   Write enable
    output [15:0]           DAT_O //  Registered output
    );
   
   localparam NrRamsHere = (1<<(EBRADRWIDTH-8));
   
   generate
      
      if ( NrRamsHere == 1 ) begin
         SB_RAM40_4K 
           #(.INIT_0(prg0[ 255:   0]),
             .INIT_1(prg0[ 511: 256]),
             .INIT_2(prg0[ 767: 512]),
             .INIT_3(prg0[1023: 768]),
             .INIT_4(prg0[1279:1024]),
             .INIT_5(prg0[1535:1280]),
             .INIT_6(prg0[1791:1536]),
             .INIT_7(prg0[2047:1792]),
             .INIT_8(prg0[2303:2048]),
             .INIT_9(prg0[2559:2304]),
             .INIT_A(prg0[2815:2560]),
             .INIT_B(prg0[3071:2816]),
             .INIT_C(prg0[3327:3072]),
             .INIT_D(prg0[3583:3328]),
             .INIT_E(prg0[3839:3584]),
             .INIT_F(prg0[4095:3840]))
         mem
           (// Outputs
            .RDATA  ( DAT_O                         ),
            // Input
            .MASK   ( {{8{bmask[1]}},{8{bmask[0]}}} ),
            .WDATA  ( B                             ),
            .WADDR  ( {3'b0,Wai}                    ),
            .RADDR  ( {3'b0,Rai}                    ),
            .RE     ( 1'b1                          ),
            .WE     ( 1'b1                          ),
            .WCLK   ( clk                           ),
            .RCLK   ( clk                           ),
            .RCLKE  ( 1'b1                          ),
            .WCLKE  ( iwe                           )
            /*AUTOINST*/);
         
      end else begin
         /* Split the up to 4 KiB memory into low and high bytes
          */
         localparam [4095:0]
           pb3 = {prg7[4087:4080],prg7[4071:4064],prg7[4055:4048],prg7[4039:4032],prg7[4023:4016],prg7[4007:4000],prg7[3991:3984],prg7[3975:3968],
                  prg7[3959:3952],prg7[3943:3936],prg7[3927:3920],prg7[3911:3904],prg7[3895:3888],prg7[3879:3872],prg7[3863:3856],prg7[3847:3840],
                  prg7[3831:3824],prg7[3815:3808],prg7[3799:3792],prg7[3783:3776],prg7[3767:3760],prg7[3751:3744],prg7[3735:3728],prg7[3719:3712],
                  prg7[3703:3696],prg7[3687:3680],prg7[3671:3664],prg7[3655:3648],prg7[3639:3632],prg7[3623:3616],prg7[3607:3600],prg7[3591:3584],
                  prg7[3575:3568],prg7[3559:3552],prg7[3543:3536],prg7[3527:3520],prg7[3511:3504],prg7[3495:3488],prg7[3479:3472],prg7[3463:3456],
                  prg7[3447:3440],prg7[3431:3424],prg7[3415:3408],prg7[3399:3392],prg7[3383:3376],prg7[3367:3360],prg7[3351:3344],prg7[3335:3328],
                  prg7[3319:3312],prg7[3303:3296],prg7[3287:3280],prg7[3271:3264],prg7[3255:3248],prg7[3239:3232],prg7[3223:3216],prg7[3207:3200],
                  prg7[3191:3184],prg7[3175:3168],prg7[3159:3152],prg7[3143:3136],prg7[3127:3120],prg7[3111:3104],prg7[3095:3088],prg7[3079:3072],
                  prg7[3063:3056],prg7[3047:3040],prg7[3031:3024],prg7[3015:3008],prg7[2999:2992],prg7[2983:2976],prg7[2967:2960],prg7[2951:2944],
                  prg7[2935:2928],prg7[2919:2912],prg7[2903:2896],prg7[2887:2880],prg7[2871:2864],prg7[2855:2848],prg7[2839:2832],prg7[2823:2816],
                  prg7[2807:2800],prg7[2791:2784],prg7[2775:2768],prg7[2759:2752],prg7[2743:2736],prg7[2727:2720],prg7[2711:2704],prg7[2695:2688],
                  prg7[2679:2672],prg7[2663:2656],prg7[2647:2640],prg7[2631:2624],prg7[2615:2608],prg7[2599:2592],prg7[2583:2576],prg7[2567:2560],
                  prg7[2551:2544],prg7[2535:2528],prg7[2519:2512],prg7[2503:2496],prg7[2487:2480],prg7[2471:2464],prg7[2455:2448],prg7[2439:2432],
                  prg7[2423:2416],prg7[2407:2400],prg7[2391:2384],prg7[2375:2368],prg7[2359:2352],prg7[2343:2336],prg7[2327:2320],prg7[2311:2304],
                  prg7[2295:2288],prg7[2279:2272],prg7[2263:2256],prg7[2247:2240],prg7[2231:2224],prg7[2215:2208],prg7[2199:2192],prg7[2183:2176],
                  prg7[2167:2160],prg7[2151:2144],prg7[2135:2128],prg7[2119:2112],prg7[2103:2096],prg7[2087:2080],prg7[2071:2064],prg7[2055:2048],
                  prg7[2039:2032],prg7[2023:2016],prg7[2007:2000],prg7[1991:1984],prg7[1975:1968],prg7[1959:1952],prg7[1943:1936],prg7[1927:1920],
                  prg7[1911:1904],prg7[1895:1888],prg7[1879:1872],prg7[1863:1856],prg7[1847:1840],prg7[1831:1824],prg7[1815:1808],prg7[1799:1792],
                  prg7[1783:1776],prg7[1767:1760],prg7[1751:1744],prg7[1735:1728],prg7[1719:1712],prg7[1703:1696],prg7[1687:1680],prg7[1671:1664],
                  prg7[1655:1648],prg7[1639:1632],prg7[1623:1616],prg7[1607:1600],prg7[1591:1584],prg7[1575:1568],prg7[1559:1552],prg7[1543:1536],
                  prg7[1527:1520],prg7[1511:1504],prg7[1495:1488],prg7[1479:1472],prg7[1463:1456],prg7[1447:1440],prg7[1431:1424],prg7[1415:1408],
                  prg7[1399:1392],prg7[1383:1376],prg7[1367:1360],prg7[1351:1344],prg7[1335:1328],prg7[1319:1312],prg7[1303:1296],prg7[1287:1280],
                  prg7[1271:1264],prg7[1255:1248],prg7[1239:1232],prg7[1223:1216],prg7[1207:1200],prg7[1191:1184],prg7[1175:1168],prg7[1159:1152],
                  prg7[1143:1136],prg7[1127:1120],prg7[1111:1104],prg7[1095:1088],prg7[1079:1072],prg7[1063:1056],prg7[1047:1040],prg7[1031:1024],
                  prg7[1015:1008],prg7[ 999: 992],prg7[ 983: 976],prg7[ 967: 960],prg7[ 951: 944],prg7[ 935: 928],prg7[ 919: 912],prg7[ 903: 896],
                  prg7[ 887: 880],prg7[ 871: 864],prg7[ 855: 848],prg7[ 839: 832],prg7[ 823: 816],prg7[ 807: 800],prg7[ 791: 784],prg7[ 775: 768],
                  prg7[ 759: 752],prg7[ 743: 736],prg7[ 727: 720],prg7[ 711: 704],prg7[ 695: 688],prg7[ 679: 672],prg7[ 663: 656],prg7[ 647: 640],
                  prg7[ 631: 624],prg7[ 615: 608],prg7[ 599: 592],prg7[ 583: 576],prg7[ 567: 560],prg7[ 551: 544],prg7[ 535: 528],prg7[ 519: 512],
                  prg7[ 503: 496],prg7[ 487: 480],prg7[ 471: 464],prg7[ 455: 448],prg7[ 439: 432],prg7[ 423: 416],prg7[ 407: 400],prg7[ 391: 384],
                  prg7[ 375: 368],prg7[ 359: 352],prg7[ 343: 336],prg7[ 327: 320],prg7[ 311: 304],prg7[ 295: 288],prg7[ 279: 272],prg7[ 263: 256],
                  prg7[ 247: 240],prg7[ 231: 224],prg7[ 215: 208],prg7[ 199: 192],prg7[ 183: 176],prg7[ 167: 160],prg7[ 151: 144],prg7[ 135: 128],
                  prg7[ 119: 112],prg7[ 103:  96],prg7[  87:  80],prg7[  71:  64],prg7[  55:  48],prg7[  39:  32],prg7[  23:  16],prg7[   7:   0],
                  prg6[4087:4080],prg6[4071:4064],prg6[4055:4048],prg6[4039:4032],prg6[4023:4016],prg6[4007:4000],prg6[3991:3984],prg6[3975:3968],
                  prg6[3959:3952],prg6[3943:3936],prg6[3927:3920],prg6[3911:3904],prg6[3895:3888],prg6[3879:3872],prg6[3863:3856],prg6[3847:3840],
                  prg6[3831:3824],prg6[3815:3808],prg6[3799:3792],prg6[3783:3776],prg6[3767:3760],prg6[3751:3744],prg6[3735:3728],prg6[3719:3712],
                  prg6[3703:3696],prg6[3687:3680],prg6[3671:3664],prg6[3655:3648],prg6[3639:3632],prg6[3623:3616],prg6[3607:3600],prg6[3591:3584],
                  prg6[3575:3568],prg6[3559:3552],prg6[3543:3536],prg6[3527:3520],prg6[3511:3504],prg6[3495:3488],prg6[3479:3472],prg6[3463:3456],
                  prg6[3447:3440],prg6[3431:3424],prg6[3415:3408],prg6[3399:3392],prg6[3383:3376],prg6[3367:3360],prg6[3351:3344],prg6[3335:3328],
                  prg6[3319:3312],prg6[3303:3296],prg6[3287:3280],prg6[3271:3264],prg6[3255:3248],prg6[3239:3232],prg6[3223:3216],prg6[3207:3200],
                  prg6[3191:3184],prg6[3175:3168],prg6[3159:3152],prg6[3143:3136],prg6[3127:3120],prg6[3111:3104],prg6[3095:3088],prg6[3079:3072],
                  prg6[3063:3056],prg6[3047:3040],prg6[3031:3024],prg6[3015:3008],prg6[2999:2992],prg6[2983:2976],prg6[2967:2960],prg6[2951:2944],
                  prg6[2935:2928],prg6[2919:2912],prg6[2903:2896],prg6[2887:2880],prg6[2871:2864],prg6[2855:2848],prg6[2839:2832],prg6[2823:2816],
                  prg6[2807:2800],prg6[2791:2784],prg6[2775:2768],prg6[2759:2752],prg6[2743:2736],prg6[2727:2720],prg6[2711:2704],prg6[2695:2688],
                  prg6[2679:2672],prg6[2663:2656],prg6[2647:2640],prg6[2631:2624],prg6[2615:2608],prg6[2599:2592],prg6[2583:2576],prg6[2567:2560],
                  prg6[2551:2544],prg6[2535:2528],prg6[2519:2512],prg6[2503:2496],prg6[2487:2480],prg6[2471:2464],prg6[2455:2448],prg6[2439:2432],
                  prg6[2423:2416],prg6[2407:2400],prg6[2391:2384],prg6[2375:2368],prg6[2359:2352],prg6[2343:2336],prg6[2327:2320],prg6[2311:2304],
                  prg6[2295:2288],prg6[2279:2272],prg6[2263:2256],prg6[2247:2240],prg6[2231:2224],prg6[2215:2208],prg6[2199:2192],prg6[2183:2176],
                  prg6[2167:2160],prg6[2151:2144],prg6[2135:2128],prg6[2119:2112],prg6[2103:2096],prg6[2087:2080],prg6[2071:2064],prg6[2055:2048],
                  prg6[2039:2032],prg6[2023:2016],prg6[2007:2000],prg6[1991:1984],prg6[1975:1968],prg6[1959:1952],prg6[1943:1936],prg6[1927:1920],
                  prg6[1911:1904],prg6[1895:1888],prg6[1879:1872],prg6[1863:1856],prg6[1847:1840],prg6[1831:1824],prg6[1815:1808],prg6[1799:1792],
                  prg6[1783:1776],prg6[1767:1760],prg6[1751:1744],prg6[1735:1728],prg6[1719:1712],prg6[1703:1696],prg6[1687:1680],prg6[1671:1664],
                  prg6[1655:1648],prg6[1639:1632],prg6[1623:1616],prg6[1607:1600],prg6[1591:1584],prg6[1575:1568],prg6[1559:1552],prg6[1543:1536],
                  prg6[1527:1520],prg6[1511:1504],prg6[1495:1488],prg6[1479:1472],prg6[1463:1456],prg6[1447:1440],prg6[1431:1424],prg6[1415:1408],
                  prg6[1399:1392],prg6[1383:1376],prg6[1367:1360],prg6[1351:1344],prg6[1335:1328],prg6[1319:1312],prg6[1303:1296],prg6[1287:1280],
                  prg6[1271:1264],prg6[1255:1248],prg6[1239:1232],prg6[1223:1216],prg6[1207:1200],prg6[1191:1184],prg6[1175:1168],prg6[1159:1152],
                  prg6[1143:1136],prg6[1127:1120],prg6[1111:1104],prg6[1095:1088],prg6[1079:1072],prg6[1063:1056],prg6[1047:1040],prg6[1031:1024],
                  prg6[1015:1008],prg6[ 999: 992],prg6[ 983: 976],prg6[ 967: 960],prg6[ 951: 944],prg6[ 935: 928],prg6[ 919: 912],prg6[ 903: 896],
                  prg6[ 887: 880],prg6[ 871: 864],prg6[ 855: 848],prg6[ 839: 832],prg6[ 823: 816],prg6[ 807: 800],prg6[ 791: 784],prg6[ 775: 768],
                  prg6[ 759: 752],prg6[ 743: 736],prg6[ 727: 720],prg6[ 711: 704],prg6[ 695: 688],prg6[ 679: 672],prg6[ 663: 656],prg6[ 647: 640],
                  prg6[ 631: 624],prg6[ 615: 608],prg6[ 599: 592],prg6[ 583: 576],prg6[ 567: 560],prg6[ 551: 544],prg6[ 535: 528],prg6[ 519: 512],
                  prg6[ 503: 496],prg6[ 487: 480],prg6[ 471: 464],prg6[ 455: 448],prg6[ 439: 432],prg6[ 423: 416],prg6[ 407: 400],prg6[ 391: 384],
                  prg6[ 375: 368],prg6[ 359: 352],prg6[ 343: 336],prg6[ 327: 320],prg6[ 311: 304],prg6[ 295: 288],prg6[ 279: 272],prg6[ 263: 256],
                  prg6[ 247: 240],prg6[ 231: 224],prg6[ 215: 208],prg6[ 199: 192],prg6[ 183: 176],prg6[ 167: 160],prg6[ 151: 144],prg6[ 135: 128],
                  prg6[ 119: 112],prg6[ 103:  96],prg6[  87:  80],prg6[  71:  64],prg6[  55:  48],prg6[  39:  32],prg6[  23:  16],prg6[   7:   0]};
         localparam [4095:0]
           pb2 = {prg5[4087:4080],prg5[4071:4064],prg5[4055:4048],prg5[4039:4032],prg5[4023:4016],prg5[4007:4000],prg5[3991:3984],prg5[3975:3968],
                  prg5[3959:3952],prg5[3943:3936],prg5[3927:3920],prg5[3911:3904],prg5[3895:3888],prg5[3879:3872],prg5[3863:3856],prg5[3847:3840],
                  prg5[3831:3824],prg5[3815:3808],prg5[3799:3792],prg5[3783:3776],prg5[3767:3760],prg5[3751:3744],prg5[3735:3728],prg5[3719:3712],
                  prg5[3703:3696],prg5[3687:3680],prg5[3671:3664],prg5[3655:3648],prg5[3639:3632],prg5[3623:3616],prg5[3607:3600],prg5[3591:3584],
                  prg5[3575:3568],prg5[3559:3552],prg5[3543:3536],prg5[3527:3520],prg5[3511:3504],prg5[3495:3488],prg5[3479:3472],prg5[3463:3456],
                  prg5[3447:3440],prg5[3431:3424],prg5[3415:3408],prg5[3399:3392],prg5[3383:3376],prg5[3367:3360],prg5[3351:3344],prg5[3335:3328],
                  prg5[3319:3312],prg5[3303:3296],prg5[3287:3280],prg5[3271:3264],prg5[3255:3248],prg5[3239:3232],prg5[3223:3216],prg5[3207:3200],
                  prg5[3191:3184],prg5[3175:3168],prg5[3159:3152],prg5[3143:3136],prg5[3127:3120],prg5[3111:3104],prg5[3095:3088],prg5[3079:3072],
                  prg5[3063:3056],prg5[3047:3040],prg5[3031:3024],prg5[3015:3008],prg5[2999:2992],prg5[2983:2976],prg5[2967:2960],prg5[2951:2944],
                  prg5[2935:2928],prg5[2919:2912],prg5[2903:2896],prg5[2887:2880],prg5[2871:2864],prg5[2855:2848],prg5[2839:2832],prg5[2823:2816],
                  prg5[2807:2800],prg5[2791:2784],prg5[2775:2768],prg5[2759:2752],prg5[2743:2736],prg5[2727:2720],prg5[2711:2704],prg5[2695:2688],
                  prg5[2679:2672],prg5[2663:2656],prg5[2647:2640],prg5[2631:2624],prg5[2615:2608],prg5[2599:2592],prg5[2583:2576],prg5[2567:2560],
                  prg5[2551:2544],prg5[2535:2528],prg5[2519:2512],prg5[2503:2496],prg5[2487:2480],prg5[2471:2464],prg5[2455:2448],prg5[2439:2432],
                  prg5[2423:2416],prg5[2407:2400],prg5[2391:2384],prg5[2375:2368],prg5[2359:2352],prg5[2343:2336],prg5[2327:2320],prg5[2311:2304],
                  prg5[2295:2288],prg5[2279:2272],prg5[2263:2256],prg5[2247:2240],prg5[2231:2224],prg5[2215:2208],prg5[2199:2192],prg5[2183:2176],
                  prg5[2167:2160],prg5[2151:2144],prg5[2135:2128],prg5[2119:2112],prg5[2103:2096],prg5[2087:2080],prg5[2071:2064],prg5[2055:2048],
                  prg5[2039:2032],prg5[2023:2016],prg5[2007:2000],prg5[1991:1984],prg5[1975:1968],prg5[1959:1952],prg5[1943:1936],prg5[1927:1920],
                  prg5[1911:1904],prg5[1895:1888],prg5[1879:1872],prg5[1863:1856],prg5[1847:1840],prg5[1831:1824],prg5[1815:1808],prg5[1799:1792],
                  prg5[1783:1776],prg5[1767:1760],prg5[1751:1744],prg5[1735:1728],prg5[1719:1712],prg5[1703:1696],prg5[1687:1680],prg5[1671:1664],
                  prg5[1655:1648],prg5[1639:1632],prg5[1623:1616],prg5[1607:1600],prg5[1591:1584],prg5[1575:1568],prg5[1559:1552],prg5[1543:1536],
                  prg5[1527:1520],prg5[1511:1504],prg5[1495:1488],prg5[1479:1472],prg5[1463:1456],prg5[1447:1440],prg5[1431:1424],prg5[1415:1408],
                  prg5[1399:1392],prg5[1383:1376],prg5[1367:1360],prg5[1351:1344],prg5[1335:1328],prg5[1319:1312],prg5[1303:1296],prg5[1287:1280],
                  prg5[1271:1264],prg5[1255:1248],prg5[1239:1232],prg5[1223:1216],prg5[1207:1200],prg5[1191:1184],prg5[1175:1168],prg5[1159:1152],
                  prg5[1143:1136],prg5[1127:1120],prg5[1111:1104],prg5[1095:1088],prg5[1079:1072],prg5[1063:1056],prg5[1047:1040],prg5[1031:1024],
                  prg5[1015:1008],prg5[ 999: 992],prg5[ 983: 976],prg5[ 967: 960],prg5[ 951: 944],prg5[ 935: 928],prg5[ 919: 912],prg5[ 903: 896],
                  prg5[ 887: 880],prg5[ 871: 864],prg5[ 855: 848],prg5[ 839: 832],prg5[ 823: 816],prg5[ 807: 800],prg5[ 791: 784],prg5[ 775: 768],
                  prg5[ 759: 752],prg5[ 743: 736],prg5[ 727: 720],prg5[ 711: 704],prg5[ 695: 688],prg5[ 679: 672],prg5[ 663: 656],prg5[ 647: 640],
                  prg5[ 631: 624],prg5[ 615: 608],prg5[ 599: 592],prg5[ 583: 576],prg5[ 567: 560],prg5[ 551: 544],prg5[ 535: 528],prg5[ 519: 512],
                  prg5[ 503: 496],prg5[ 487: 480],prg5[ 471: 464],prg5[ 455: 448],prg5[ 439: 432],prg5[ 423: 416],prg5[ 407: 400],prg5[ 391: 384],
                  prg5[ 375: 368],prg5[ 359: 352],prg5[ 343: 336],prg5[ 327: 320],prg5[ 311: 304],prg5[ 295: 288],prg5[ 279: 272],prg5[ 263: 256],
                  prg5[ 247: 240],prg5[ 231: 224],prg5[ 215: 208],prg5[ 199: 192],prg5[ 183: 176],prg5[ 167: 160],prg5[ 151: 144],prg5[ 135: 128],
                  prg5[ 119: 112],prg5[ 103:  96],prg5[  87:  80],prg5[  71:  64],prg5[  55:  48],prg5[  39:  32],prg5[  23:  16],prg5[   7:   0],
                  prg4[4087:4080],prg4[4071:4064],prg4[4055:4048],prg4[4039:4032],prg4[4023:4016],prg4[4007:4000],prg4[3991:3984],prg4[3975:3968],
                  prg4[3959:3952],prg4[3943:3936],prg4[3927:3920],prg4[3911:3904],prg4[3895:3888],prg4[3879:3872],prg4[3863:3856],prg4[3847:3840],
                  prg4[3831:3824],prg4[3815:3808],prg4[3799:3792],prg4[3783:3776],prg4[3767:3760],prg4[3751:3744],prg4[3735:3728],prg4[3719:3712],
                  prg4[3703:3696],prg4[3687:3680],prg4[3671:3664],prg4[3655:3648],prg4[3639:3632],prg4[3623:3616],prg4[3607:3600],prg4[3591:3584],
                  prg4[3575:3568],prg4[3559:3552],prg4[3543:3536],prg4[3527:3520],prg4[3511:3504],prg4[3495:3488],prg4[3479:3472],prg4[3463:3456],
                  prg4[3447:3440],prg4[3431:3424],prg4[3415:3408],prg4[3399:3392],prg4[3383:3376],prg4[3367:3360],prg4[3351:3344],prg4[3335:3328],
                  prg4[3319:3312],prg4[3303:3296],prg4[3287:3280],prg4[3271:3264],prg4[3255:3248],prg4[3239:3232],prg4[3223:3216],prg4[3207:3200],
                  prg4[3191:3184],prg4[3175:3168],prg4[3159:3152],prg4[3143:3136],prg4[3127:3120],prg4[3111:3104],prg4[3095:3088],prg4[3079:3072],
                  prg4[3063:3056],prg4[3047:3040],prg4[3031:3024],prg4[3015:3008],prg4[2999:2992],prg4[2983:2976],prg4[2967:2960],prg4[2951:2944],
                  prg4[2935:2928],prg4[2919:2912],prg4[2903:2896],prg4[2887:2880],prg4[2871:2864],prg4[2855:2848],prg4[2839:2832],prg4[2823:2816],
                  prg4[2807:2800],prg4[2791:2784],prg4[2775:2768],prg4[2759:2752],prg4[2743:2736],prg4[2727:2720],prg4[2711:2704],prg4[2695:2688],
                  prg4[2679:2672],prg4[2663:2656],prg4[2647:2640],prg4[2631:2624],prg4[2615:2608],prg4[2599:2592],prg4[2583:2576],prg4[2567:2560],
                  prg4[2551:2544],prg4[2535:2528],prg4[2519:2512],prg4[2503:2496],prg4[2487:2480],prg4[2471:2464],prg4[2455:2448],prg4[2439:2432],
                  prg4[2423:2416],prg4[2407:2400],prg4[2391:2384],prg4[2375:2368],prg4[2359:2352],prg4[2343:2336],prg4[2327:2320],prg4[2311:2304],
                  prg4[2295:2288],prg4[2279:2272],prg4[2263:2256],prg4[2247:2240],prg4[2231:2224],prg4[2215:2208],prg4[2199:2192],prg4[2183:2176],
                  prg4[2167:2160],prg4[2151:2144],prg4[2135:2128],prg4[2119:2112],prg4[2103:2096],prg4[2087:2080],prg4[2071:2064],prg4[2055:2048],
                  prg4[2039:2032],prg4[2023:2016],prg4[2007:2000],prg4[1991:1984],prg4[1975:1968],prg4[1959:1952],prg4[1943:1936],prg4[1927:1920],
                  prg4[1911:1904],prg4[1895:1888],prg4[1879:1872],prg4[1863:1856],prg4[1847:1840],prg4[1831:1824],prg4[1815:1808],prg4[1799:1792],
                  prg4[1783:1776],prg4[1767:1760],prg4[1751:1744],prg4[1735:1728],prg4[1719:1712],prg4[1703:1696],prg4[1687:1680],prg4[1671:1664],
                  prg4[1655:1648],prg4[1639:1632],prg4[1623:1616],prg4[1607:1600],prg4[1591:1584],prg4[1575:1568],prg4[1559:1552],prg4[1543:1536],
                  prg4[1527:1520],prg4[1511:1504],prg4[1495:1488],prg4[1479:1472],prg4[1463:1456],prg4[1447:1440],prg4[1431:1424],prg4[1415:1408],
                  prg4[1399:1392],prg4[1383:1376],prg4[1367:1360],prg4[1351:1344],prg4[1335:1328],prg4[1319:1312],prg4[1303:1296],prg4[1287:1280],
                  prg4[1271:1264],prg4[1255:1248],prg4[1239:1232],prg4[1223:1216],prg4[1207:1200],prg4[1191:1184],prg4[1175:1168],prg4[1159:1152],
                  prg4[1143:1136],prg4[1127:1120],prg4[1111:1104],prg4[1095:1088],prg4[1079:1072],prg4[1063:1056],prg4[1047:1040],prg4[1031:1024],
                  prg4[1015:1008],prg4[ 999: 992],prg4[ 983: 976],prg4[ 967: 960],prg4[ 951: 944],prg4[ 935: 928],prg4[ 919: 912],prg4[ 903: 896],
                  prg4[ 887: 880],prg4[ 871: 864],prg4[ 855: 848],prg4[ 839: 832],prg4[ 823: 816],prg4[ 807: 800],prg4[ 791: 784],prg4[ 775: 768],
                  prg4[ 759: 752],prg4[ 743: 736],prg4[ 727: 720],prg4[ 711: 704],prg4[ 695: 688],prg4[ 679: 672],prg4[ 663: 656],prg4[ 647: 640],
                  prg4[ 631: 624],prg4[ 615: 608],prg4[ 599: 592],prg4[ 583: 576],prg4[ 567: 560],prg4[ 551: 544],prg4[ 535: 528],prg4[ 519: 512],
                  prg4[ 503: 496],prg4[ 487: 480],prg4[ 471: 464],prg4[ 455: 448],prg4[ 439: 432],prg4[ 423: 416],prg4[ 407: 400],prg4[ 391: 384],
                  prg4[ 375: 368],prg4[ 359: 352],prg4[ 343: 336],prg4[ 327: 320],prg4[ 311: 304],prg4[ 295: 288],prg4[ 279: 272],prg4[ 263: 256],
                  prg4[ 247: 240],prg4[ 231: 224],prg4[ 215: 208],prg4[ 199: 192],prg4[ 183: 176],prg4[ 167: 160],prg4[ 151: 144],prg4[ 135: 128],
                  prg4[ 119: 112],prg4[ 103:  96],prg4[  87:  80],prg4[  71:  64],prg4[  55:  48],prg4[  39:  32],prg4[  23:  16],prg4[   7:   0]};
         localparam [4095:0]
           pb1 = {prg3[4087:4080],prg3[4071:4064],prg3[4055:4048],prg3[4039:4032],prg3[4023:4016],prg3[4007:4000],prg3[3991:3984],prg3[3975:3968],
                  prg3[3959:3952],prg3[3943:3936],prg3[3927:3920],prg3[3911:3904],prg3[3895:3888],prg3[3879:3872],prg3[3863:3856],prg3[3847:3840],
                  prg3[3831:3824],prg3[3815:3808],prg3[3799:3792],prg3[3783:3776],prg3[3767:3760],prg3[3751:3744],prg3[3735:3728],prg3[3719:3712],
                  prg3[3703:3696],prg3[3687:3680],prg3[3671:3664],prg3[3655:3648],prg3[3639:3632],prg3[3623:3616],prg3[3607:3600],prg3[3591:3584],
                  prg3[3575:3568],prg3[3559:3552],prg3[3543:3536],prg3[3527:3520],prg3[3511:3504],prg3[3495:3488],prg3[3479:3472],prg3[3463:3456],
                  prg3[3447:3440],prg3[3431:3424],prg3[3415:3408],prg3[3399:3392],prg3[3383:3376],prg3[3367:3360],prg3[3351:3344],prg3[3335:3328],
                  prg3[3319:3312],prg3[3303:3296],prg3[3287:3280],prg3[3271:3264],prg3[3255:3248],prg3[3239:3232],prg3[3223:3216],prg3[3207:3200],
                  prg3[3191:3184],prg3[3175:3168],prg3[3159:3152],prg3[3143:3136],prg3[3127:3120],prg3[3111:3104],prg3[3095:3088],prg3[3079:3072],
                  prg3[3063:3056],prg3[3047:3040],prg3[3031:3024],prg3[3015:3008],prg3[2999:2992],prg3[2983:2976],prg3[2967:2960],prg3[2951:2944],
                  prg3[2935:2928],prg3[2919:2912],prg3[2903:2896],prg3[2887:2880],prg3[2871:2864],prg3[2855:2848],prg3[2839:2832],prg3[2823:2816],
                  prg3[2807:2800],prg3[2791:2784],prg3[2775:2768],prg3[2759:2752],prg3[2743:2736],prg3[2727:2720],prg3[2711:2704],prg3[2695:2688],
                  prg3[2679:2672],prg3[2663:2656],prg3[2647:2640],prg3[2631:2624],prg3[2615:2608],prg3[2599:2592],prg3[2583:2576],prg3[2567:2560],
                  prg3[2551:2544],prg3[2535:2528],prg3[2519:2512],prg3[2503:2496],prg3[2487:2480],prg3[2471:2464],prg3[2455:2448],prg3[2439:2432],
                  prg3[2423:2416],prg3[2407:2400],prg3[2391:2384],prg3[2375:2368],prg3[2359:2352],prg3[2343:2336],prg3[2327:2320],prg3[2311:2304],
                  prg3[2295:2288],prg3[2279:2272],prg3[2263:2256],prg3[2247:2240],prg3[2231:2224],prg3[2215:2208],prg3[2199:2192],prg3[2183:2176],
                  prg3[2167:2160],prg3[2151:2144],prg3[2135:2128],prg3[2119:2112],prg3[2103:2096],prg3[2087:2080],prg3[2071:2064],prg3[2055:2048],
                  prg3[2039:2032],prg3[2023:2016],prg3[2007:2000],prg3[1991:1984],prg3[1975:1968],prg3[1959:1952],prg3[1943:1936],prg3[1927:1920],
                  prg3[1911:1904],prg3[1895:1888],prg3[1879:1872],prg3[1863:1856],prg3[1847:1840],prg3[1831:1824],prg3[1815:1808],prg3[1799:1792],
                  prg3[1783:1776],prg3[1767:1760],prg3[1751:1744],prg3[1735:1728],prg3[1719:1712],prg3[1703:1696],prg3[1687:1680],prg3[1671:1664],
                  prg3[1655:1648],prg3[1639:1632],prg3[1623:1616],prg3[1607:1600],prg3[1591:1584],prg3[1575:1568],prg3[1559:1552],prg3[1543:1536],
                  prg3[1527:1520],prg3[1511:1504],prg3[1495:1488],prg3[1479:1472],prg3[1463:1456],prg3[1447:1440],prg3[1431:1424],prg3[1415:1408],
                  prg3[1399:1392],prg3[1383:1376],prg3[1367:1360],prg3[1351:1344],prg3[1335:1328],prg3[1319:1312],prg3[1303:1296],prg3[1287:1280],
                  prg3[1271:1264],prg3[1255:1248],prg3[1239:1232],prg3[1223:1216],prg3[1207:1200],prg3[1191:1184],prg3[1175:1168],prg3[1159:1152],
                  prg3[1143:1136],prg3[1127:1120],prg3[1111:1104],prg3[1095:1088],prg3[1079:1072],prg3[1063:1056],prg3[1047:1040],prg3[1031:1024],
                  prg3[1015:1008],prg3[ 999: 992],prg3[ 983: 976],prg3[ 967: 960],prg3[ 951: 944],prg3[ 935: 928],prg3[ 919: 912],prg3[ 903: 896],
                  prg3[ 887: 880],prg3[ 871: 864],prg3[ 855: 848],prg3[ 839: 832],prg3[ 823: 816],prg3[ 807: 800],prg3[ 791: 784],prg3[ 775: 768],
                  prg3[ 759: 752],prg3[ 743: 736],prg3[ 727: 720],prg3[ 711: 704],prg3[ 695: 688],prg3[ 679: 672],prg3[ 663: 656],prg3[ 647: 640],
                  prg3[ 631: 624],prg3[ 615: 608],prg3[ 599: 592],prg3[ 583: 576],prg3[ 567: 560],prg3[ 551: 544],prg3[ 535: 528],prg3[ 519: 512],
                  prg3[ 503: 496],prg3[ 487: 480],prg3[ 471: 464],prg3[ 455: 448],prg3[ 439: 432],prg3[ 423: 416],prg3[ 407: 400],prg3[ 391: 384],
                  prg3[ 375: 368],prg3[ 359: 352],prg3[ 343: 336],prg3[ 327: 320],prg3[ 311: 304],prg3[ 295: 288],prg3[ 279: 272],prg3[ 263: 256],
                  prg3[ 247: 240],prg3[ 231: 224],prg3[ 215: 208],prg3[ 199: 192],prg3[ 183: 176],prg3[ 167: 160],prg3[ 151: 144],prg3[ 135: 128],
                  prg3[ 119: 112],prg3[ 103:  96],prg3[  87:  80],prg3[  71:  64],prg3[  55:  48],prg3[  39:  32],prg3[  23:  16],prg3[   7:   0],
                  prg2[4087:4080],prg2[4071:4064],prg2[4055:4048],prg2[4039:4032],prg2[4023:4016],prg2[4007:4000],prg2[3991:3984],prg2[3975:3968],
                  prg2[3959:3952],prg2[3943:3936],prg2[3927:3920],prg2[3911:3904],prg2[3895:3888],prg2[3879:3872],prg2[3863:3856],prg2[3847:3840],
                  prg2[3831:3824],prg2[3815:3808],prg2[3799:3792],prg2[3783:3776],prg2[3767:3760],prg2[3751:3744],prg2[3735:3728],prg2[3719:3712],
                  prg2[3703:3696],prg2[3687:3680],prg2[3671:3664],prg2[3655:3648],prg2[3639:3632],prg2[3623:3616],prg2[3607:3600],prg2[3591:3584],
                  prg2[3575:3568],prg2[3559:3552],prg2[3543:3536],prg2[3527:3520],prg2[3511:3504],prg2[3495:3488],prg2[3479:3472],prg2[3463:3456],
                  prg2[3447:3440],prg2[3431:3424],prg2[3415:3408],prg2[3399:3392],prg2[3383:3376],prg2[3367:3360],prg2[3351:3344],prg2[3335:3328],
                  prg2[3319:3312],prg2[3303:3296],prg2[3287:3280],prg2[3271:3264],prg2[3255:3248],prg2[3239:3232],prg2[3223:3216],prg2[3207:3200],
                  prg2[3191:3184],prg2[3175:3168],prg2[3159:3152],prg2[3143:3136],prg2[3127:3120],prg2[3111:3104],prg2[3095:3088],prg2[3079:3072],
                  prg2[3063:3056],prg2[3047:3040],prg2[3031:3024],prg2[3015:3008],prg2[2999:2992],prg2[2983:2976],prg2[2967:2960],prg2[2951:2944],
                  prg2[2935:2928],prg2[2919:2912],prg2[2903:2896],prg2[2887:2880],prg2[2871:2864],prg2[2855:2848],prg2[2839:2832],prg2[2823:2816],
                  prg2[2807:2800],prg2[2791:2784],prg2[2775:2768],prg2[2759:2752],prg2[2743:2736],prg2[2727:2720],prg2[2711:2704],prg2[2695:2688],
                  prg2[2679:2672],prg2[2663:2656],prg2[2647:2640],prg2[2631:2624],prg2[2615:2608],prg2[2599:2592],prg2[2583:2576],prg2[2567:2560],
                  prg2[2551:2544],prg2[2535:2528],prg2[2519:2512],prg2[2503:2496],prg2[2487:2480],prg2[2471:2464],prg2[2455:2448],prg2[2439:2432],
                  prg2[2423:2416],prg2[2407:2400],prg2[2391:2384],prg2[2375:2368],prg2[2359:2352],prg2[2343:2336],prg2[2327:2320],prg2[2311:2304],
                  prg2[2295:2288],prg2[2279:2272],prg2[2263:2256],prg2[2247:2240],prg2[2231:2224],prg2[2215:2208],prg2[2199:2192],prg2[2183:2176],
                  prg2[2167:2160],prg2[2151:2144],prg2[2135:2128],prg2[2119:2112],prg2[2103:2096],prg2[2087:2080],prg2[2071:2064],prg2[2055:2048],
                  prg2[2039:2032],prg2[2023:2016],prg2[2007:2000],prg2[1991:1984],prg2[1975:1968],prg2[1959:1952],prg2[1943:1936],prg2[1927:1920],
                  prg2[1911:1904],prg2[1895:1888],prg2[1879:1872],prg2[1863:1856],prg2[1847:1840],prg2[1831:1824],prg2[1815:1808],prg2[1799:1792],
                  prg2[1783:1776],prg2[1767:1760],prg2[1751:1744],prg2[1735:1728],prg2[1719:1712],prg2[1703:1696],prg2[1687:1680],prg2[1671:1664],
                  prg2[1655:1648],prg2[1639:1632],prg2[1623:1616],prg2[1607:1600],prg2[1591:1584],prg2[1575:1568],prg2[1559:1552],prg2[1543:1536],
                  prg2[1527:1520],prg2[1511:1504],prg2[1495:1488],prg2[1479:1472],prg2[1463:1456],prg2[1447:1440],prg2[1431:1424],prg2[1415:1408],
                  prg2[1399:1392],prg2[1383:1376],prg2[1367:1360],prg2[1351:1344],prg2[1335:1328],prg2[1319:1312],prg2[1303:1296],prg2[1287:1280],
                  prg2[1271:1264],prg2[1255:1248],prg2[1239:1232],prg2[1223:1216],prg2[1207:1200],prg2[1191:1184],prg2[1175:1168],prg2[1159:1152],
                  prg2[1143:1136],prg2[1127:1120],prg2[1111:1104],prg2[1095:1088],prg2[1079:1072],prg2[1063:1056],prg2[1047:1040],prg2[1031:1024],
                  prg2[1015:1008],prg2[ 999: 992],prg2[ 983: 976],prg2[ 967: 960],prg2[ 951: 944],prg2[ 935: 928],prg2[ 919: 912],prg2[ 903: 896],
                  prg2[ 887: 880],prg2[ 871: 864],prg2[ 855: 848],prg2[ 839: 832],prg2[ 823: 816],prg2[ 807: 800],prg2[ 791: 784],prg2[ 775: 768],
                  prg2[ 759: 752],prg2[ 743: 736],prg2[ 727: 720],prg2[ 711: 704],prg2[ 695: 688],prg2[ 679: 672],prg2[ 663: 656],prg2[ 647: 640],
                  prg2[ 631: 624],prg2[ 615: 608],prg2[ 599: 592],prg2[ 583: 576],prg2[ 567: 560],prg2[ 551: 544],prg2[ 535: 528],prg2[ 519: 512],
                  prg2[ 503: 496],prg2[ 487: 480],prg2[ 471: 464],prg2[ 455: 448],prg2[ 439: 432],prg2[ 423: 416],prg2[ 407: 400],prg2[ 391: 384],
                  prg2[ 375: 368],prg2[ 359: 352],prg2[ 343: 336],prg2[ 327: 320],prg2[ 311: 304],prg2[ 295: 288],prg2[ 279: 272],prg2[ 263: 256],
                  prg2[ 247: 240],prg2[ 231: 224],prg2[ 215: 208],prg2[ 199: 192],prg2[ 183: 176],prg2[ 167: 160],prg2[ 151: 144],prg2[ 135: 128],
                  prg2[ 119: 112],prg2[ 103:  96],prg2[  87:  80],prg2[  71:  64],prg2[  55:  48],prg2[  39:  32],prg2[  23:  16],prg2[   7:   0]};
         localparam [4095:0]
           pb0 = {prg1[4087:4080],prg1[4071:4064],prg1[4055:4048],prg1[4039:4032],prg1[4023:4016],prg1[4007:4000],prg1[3991:3984],prg1[3975:3968],
                  prg1[3959:3952],prg1[3943:3936],prg1[3927:3920],prg1[3911:3904],prg1[3895:3888],prg1[3879:3872],prg1[3863:3856],prg1[3847:3840],
                  prg1[3831:3824],prg1[3815:3808],prg1[3799:3792],prg1[3783:3776],prg1[3767:3760],prg1[3751:3744],prg1[3735:3728],prg1[3719:3712],
                  prg1[3703:3696],prg1[3687:3680],prg1[3671:3664],prg1[3655:3648],prg1[3639:3632],prg1[3623:3616],prg1[3607:3600],prg1[3591:3584],
                  prg1[3575:3568],prg1[3559:3552],prg1[3543:3536],prg1[3527:3520],prg1[3511:3504],prg1[3495:3488],prg1[3479:3472],prg1[3463:3456],
                  prg1[3447:3440],prg1[3431:3424],prg1[3415:3408],prg1[3399:3392],prg1[3383:3376],prg1[3367:3360],prg1[3351:3344],prg1[3335:3328],
                  prg1[3319:3312],prg1[3303:3296],prg1[3287:3280],prg1[3271:3264],prg1[3255:3248],prg1[3239:3232],prg1[3223:3216],prg1[3207:3200],
                  prg1[3191:3184],prg1[3175:3168],prg1[3159:3152],prg1[3143:3136],prg1[3127:3120],prg1[3111:3104],prg1[3095:3088],prg1[3079:3072],
                  prg1[3063:3056],prg1[3047:3040],prg1[3031:3024],prg1[3015:3008],prg1[2999:2992],prg1[2983:2976],prg1[2967:2960],prg1[2951:2944],
                  prg1[2935:2928],prg1[2919:2912],prg1[2903:2896],prg1[2887:2880],prg1[2871:2864],prg1[2855:2848],prg1[2839:2832],prg1[2823:2816],
                  prg1[2807:2800],prg1[2791:2784],prg1[2775:2768],prg1[2759:2752],prg1[2743:2736],prg1[2727:2720],prg1[2711:2704],prg1[2695:2688],
                  prg1[2679:2672],prg1[2663:2656],prg1[2647:2640],prg1[2631:2624],prg1[2615:2608],prg1[2599:2592],prg1[2583:2576],prg1[2567:2560],
                  prg1[2551:2544],prg1[2535:2528],prg1[2519:2512],prg1[2503:2496],prg1[2487:2480],prg1[2471:2464],prg1[2455:2448],prg1[2439:2432],
                  prg1[2423:2416],prg1[2407:2400],prg1[2391:2384],prg1[2375:2368],prg1[2359:2352],prg1[2343:2336],prg1[2327:2320],prg1[2311:2304],
                  prg1[2295:2288],prg1[2279:2272],prg1[2263:2256],prg1[2247:2240],prg1[2231:2224],prg1[2215:2208],prg1[2199:2192],prg1[2183:2176],
                  prg1[2167:2160],prg1[2151:2144],prg1[2135:2128],prg1[2119:2112],prg1[2103:2096],prg1[2087:2080],prg1[2071:2064],prg1[2055:2048],
                  prg1[2039:2032],prg1[2023:2016],prg1[2007:2000],prg1[1991:1984],prg1[1975:1968],prg1[1959:1952],prg1[1943:1936],prg1[1927:1920],
                  prg1[1911:1904],prg1[1895:1888],prg1[1879:1872],prg1[1863:1856],prg1[1847:1840],prg1[1831:1824],prg1[1815:1808],prg1[1799:1792],
                  prg1[1783:1776],prg1[1767:1760],prg1[1751:1744],prg1[1735:1728],prg1[1719:1712],prg1[1703:1696],prg1[1687:1680],prg1[1671:1664],
                  prg1[1655:1648],prg1[1639:1632],prg1[1623:1616],prg1[1607:1600],prg1[1591:1584],prg1[1575:1568],prg1[1559:1552],prg1[1543:1536],
                  prg1[1527:1520],prg1[1511:1504],prg1[1495:1488],prg1[1479:1472],prg1[1463:1456],prg1[1447:1440],prg1[1431:1424],prg1[1415:1408],
                  prg1[1399:1392],prg1[1383:1376],prg1[1367:1360],prg1[1351:1344],prg1[1335:1328],prg1[1319:1312],prg1[1303:1296],prg1[1287:1280],
                  prg1[1271:1264],prg1[1255:1248],prg1[1239:1232],prg1[1223:1216],prg1[1207:1200],prg1[1191:1184],prg1[1175:1168],prg1[1159:1152],
                  prg1[1143:1136],prg1[1127:1120],prg1[1111:1104],prg1[1095:1088],prg1[1079:1072],prg1[1063:1056],prg1[1047:1040],prg1[1031:1024],
                  prg1[1015:1008],prg1[ 999: 992],prg1[ 983: 976],prg1[ 967: 960],prg1[ 951: 944],prg1[ 935: 928],prg1[ 919: 912],prg1[ 903: 896],
                  prg1[ 887: 880],prg1[ 871: 864],prg1[ 855: 848],prg1[ 839: 832],prg1[ 823: 816],prg1[ 807: 800],prg1[ 791: 784],prg1[ 775: 768],
                  prg1[ 759: 752],prg1[ 743: 736],prg1[ 727: 720],prg1[ 711: 704],prg1[ 695: 688],prg1[ 679: 672],prg1[ 663: 656],prg1[ 647: 640],
                  prg1[ 631: 624],prg1[ 615: 608],prg1[ 599: 592],prg1[ 583: 576],prg1[ 567: 560],prg1[ 551: 544],prg1[ 535: 528],prg1[ 519: 512],
                  prg1[ 503: 496],prg1[ 487: 480],prg1[ 471: 464],prg1[ 455: 448],prg1[ 439: 432],prg1[ 423: 416],prg1[ 407: 400],prg1[ 391: 384],
                  prg1[ 375: 368],prg1[ 359: 352],prg1[ 343: 336],prg1[ 327: 320],prg1[ 311: 304],prg1[ 295: 288],prg1[ 279: 272],prg1[ 263: 256],
                  prg1[ 247: 240],prg1[ 231: 224],prg1[ 215: 208],prg1[ 199: 192],prg1[ 183: 176],prg1[ 167: 160],prg1[ 151: 144],prg1[ 135: 128],
                  prg1[ 119: 112],prg1[ 103:  96],prg1[  87:  80],prg1[  71:  64],prg1[  55:  48],prg1[  39:  32],prg1[  23:  16],prg1[   7:   0],
                  prg0[4087:4080],prg0[4071:4064],prg0[4055:4048],prg0[4039:4032],prg0[4023:4016],prg0[4007:4000],prg0[3991:3984],prg0[3975:3968],
                  prg0[3959:3952],prg0[3943:3936],prg0[3927:3920],prg0[3911:3904],prg0[3895:3888],prg0[3879:3872],prg0[3863:3856],prg0[3847:3840],
                  prg0[3831:3824],prg0[3815:3808],prg0[3799:3792],prg0[3783:3776],prg0[3767:3760],prg0[3751:3744],prg0[3735:3728],prg0[3719:3712],
                  prg0[3703:3696],prg0[3687:3680],prg0[3671:3664],prg0[3655:3648],prg0[3639:3632],prg0[3623:3616],prg0[3607:3600],prg0[3591:3584],
                  prg0[3575:3568],prg0[3559:3552],prg0[3543:3536],prg0[3527:3520],prg0[3511:3504],prg0[3495:3488],prg0[3479:3472],prg0[3463:3456],
                  prg0[3447:3440],prg0[3431:3424],prg0[3415:3408],prg0[3399:3392],prg0[3383:3376],prg0[3367:3360],prg0[3351:3344],prg0[3335:3328],
                  prg0[3319:3312],prg0[3303:3296],prg0[3287:3280],prg0[3271:3264],prg0[3255:3248],prg0[3239:3232],prg0[3223:3216],prg0[3207:3200],
                  prg0[3191:3184],prg0[3175:3168],prg0[3159:3152],prg0[3143:3136],prg0[3127:3120],prg0[3111:3104],prg0[3095:3088],prg0[3079:3072],
                  prg0[3063:3056],prg0[3047:3040],prg0[3031:3024],prg0[3015:3008],prg0[2999:2992],prg0[2983:2976],prg0[2967:2960],prg0[2951:2944],
                  prg0[2935:2928],prg0[2919:2912],prg0[2903:2896],prg0[2887:2880],prg0[2871:2864],prg0[2855:2848],prg0[2839:2832],prg0[2823:2816],
                  prg0[2807:2800],prg0[2791:2784],prg0[2775:2768],prg0[2759:2752],prg0[2743:2736],prg0[2727:2720],prg0[2711:2704],prg0[2695:2688],
                  prg0[2679:2672],prg0[2663:2656],prg0[2647:2640],prg0[2631:2624],prg0[2615:2608],prg0[2599:2592],prg0[2583:2576],prg0[2567:2560],
                  prg0[2551:2544],prg0[2535:2528],prg0[2519:2512],prg0[2503:2496],prg0[2487:2480],prg0[2471:2464],prg0[2455:2448],prg0[2439:2432],
                  prg0[2423:2416],prg0[2407:2400],prg0[2391:2384],prg0[2375:2368],prg0[2359:2352],prg0[2343:2336],prg0[2327:2320],prg0[2311:2304],
                  prg0[2295:2288],prg0[2279:2272],prg0[2263:2256],prg0[2247:2240],prg0[2231:2224],prg0[2215:2208],prg0[2199:2192],prg0[2183:2176],
                  prg0[2167:2160],prg0[2151:2144],prg0[2135:2128],prg0[2119:2112],prg0[2103:2096],prg0[2087:2080],prg0[2071:2064],prg0[2055:2048],
                  prg0[2039:2032],prg0[2023:2016],prg0[2007:2000],prg0[1991:1984],prg0[1975:1968],prg0[1959:1952],prg0[1943:1936],prg0[1927:1920],
                  prg0[1911:1904],prg0[1895:1888],prg0[1879:1872],prg0[1863:1856],prg0[1847:1840],prg0[1831:1824],prg0[1815:1808],prg0[1799:1792],
                  prg0[1783:1776],prg0[1767:1760],prg0[1751:1744],prg0[1735:1728],prg0[1719:1712],prg0[1703:1696],prg0[1687:1680],prg0[1671:1664],
                  prg0[1655:1648],prg0[1639:1632],prg0[1623:1616],prg0[1607:1600],prg0[1591:1584],prg0[1575:1568],prg0[1559:1552],prg0[1543:1536],
                  prg0[1527:1520],prg0[1511:1504],prg0[1495:1488],prg0[1479:1472],prg0[1463:1456],prg0[1447:1440],prg0[1431:1424],prg0[1415:1408],
                  prg0[1399:1392],prg0[1383:1376],prg0[1367:1360],prg0[1351:1344],prg0[1335:1328],prg0[1319:1312],prg0[1303:1296],prg0[1287:1280],
                  prg0[1271:1264],prg0[1255:1248],prg0[1239:1232],prg0[1223:1216],prg0[1207:1200],prg0[1191:1184],prg0[1175:1168],prg0[1159:1152],
                  prg0[1143:1136],prg0[1127:1120],prg0[1111:1104],prg0[1095:1088],prg0[1079:1072],prg0[1063:1056],prg0[1047:1040],prg0[1031:1024],
                  prg0[1015:1008],prg0[ 999: 992],prg0[ 983: 976],prg0[ 967: 960],prg0[ 951: 944],prg0[ 935: 928],prg0[ 919: 912],prg0[ 903: 896],
                  prg0[ 887: 880],prg0[ 871: 864],prg0[ 855: 848],prg0[ 839: 832],prg0[ 823: 816],prg0[ 807: 800],prg0[ 791: 784],prg0[ 775: 768],
                  prg0[ 759: 752],prg0[ 743: 736],prg0[ 727: 720],prg0[ 711: 704],prg0[ 695: 688],prg0[ 679: 672],prg0[ 663: 656],prg0[ 647: 640],
                  prg0[ 631: 624],prg0[ 615: 608],prg0[ 599: 592],prg0[ 583: 576],prg0[ 567: 560],prg0[ 551: 544],prg0[ 535: 528],prg0[ 519: 512],
                  prg0[ 503: 496],prg0[ 487: 480],prg0[ 471: 464],prg0[ 455: 448],prg0[ 439: 432],prg0[ 423: 416],prg0[ 407: 400],prg0[ 391: 384],
                  prg0[ 375: 368],prg0[ 359: 352],prg0[ 343: 336],prg0[ 327: 320],prg0[ 311: 304],prg0[ 295: 288],prg0[ 279: 272],prg0[ 263: 256],
                  prg0[ 247: 240],prg0[ 231: 224],prg0[ 215: 208],prg0[ 199: 192],prg0[ 183: 176],prg0[ 167: 160],prg0[ 151: 144],prg0[ 135: 128],
                  prg0[ 119: 112],prg0[ 103:  96],prg0[  87:  80],prg0[  71:  64],prg0[  55:  48],prg0[  39:  32],prg0[  23:  16],prg0[   7:   0]};
         localparam [4095:0]
           ph3 = {prg7[4095:4088],prg7[4079:4072],prg7[4063:4056],prg7[4047:4040],prg7[4031:4024],prg7[4015:4008],prg7[3999:3992],prg7[3983:3976],
                  prg7[3967:3960],prg7[3951:3944],prg7[3935:3928],prg7[3919:3912],prg7[3903:3896],prg7[3887:3880],prg7[3871:3864],prg7[3855:3848],
                  prg7[3839:3832],prg7[3823:3816],prg7[3807:3800],prg7[3791:3784],prg7[3775:3768],prg7[3759:3752],prg7[3743:3736],prg7[3727:3720],
                  prg7[3711:3704],prg7[3695:3688],prg7[3679:3672],prg7[3663:3656],prg7[3647:3640],prg7[3631:3624],prg7[3615:3608],prg7[3599:3592],
                  prg7[3583:3576],prg7[3567:3560],prg7[3551:3544],prg7[3535:3528],prg7[3519:3512],prg7[3503:3496],prg7[3487:3480],prg7[3471:3464],
                  prg7[3455:3448],prg7[3439:3432],prg7[3423:3416],prg7[3407:3400],prg7[3391:3384],prg7[3375:3368],prg7[3359:3352],prg7[3343:3336],
                  prg7[3327:3320],prg7[3311:3304],prg7[3295:3288],prg7[3279:3272],prg7[3263:3256],prg7[3247:3240],prg7[3231:3224],prg7[3215:3208],
                  prg7[3199:3192],prg7[3183:3176],prg7[3167:3160],prg7[3151:3144],prg7[3135:3128],prg7[3119:3112],prg7[3103:3096],prg7[3087:3080],
                  prg7[3071:3064],prg7[3055:3048],prg7[3039:3032],prg7[3023:3016],prg7[3007:3000],prg7[2991:2984],prg7[2975:2968],prg7[2959:2952],
                  prg7[2943:2936],prg7[2927:2920],prg7[2911:2904],prg7[2895:2888],prg7[2879:2872],prg7[2863:2856],prg7[2847:2840],prg7[2831:2824],
                  prg7[2815:2808],prg7[2799:2792],prg7[2783:2776],prg7[2767:2760],prg7[2751:2744],prg7[2735:2728],prg7[2719:2712],prg7[2703:2696],
                  prg7[2687:2680],prg7[2671:2664],prg7[2655:2648],prg7[2639:2632],prg7[2623:2616],prg7[2607:2600],prg7[2591:2584],prg7[2575:2568],
                  prg7[2559:2552],prg7[2543:2536],prg7[2527:2520],prg7[2511:2504],prg7[2495:2488],prg7[2479:2472],prg7[2463:2456],prg7[2447:2440],
                  prg7[2431:2424],prg7[2415:2408],prg7[2399:2392],prg7[2383:2376],prg7[2367:2360],prg7[2351:2344],prg7[2335:2328],prg7[2319:2312],
                  prg7[2303:2296],prg7[2287:2280],prg7[2271:2264],prg7[2255:2248],prg7[2239:2232],prg7[2223:2216],prg7[2207:2200],prg7[2191:2184],
                  prg7[2175:2168],prg7[2159:2152],prg7[2143:2136],prg7[2127:2120],prg7[2111:2104],prg7[2095:2088],prg7[2079:2072],prg7[2063:2056],
                  prg7[2047:2040],prg7[2031:2024],prg7[2015:2008],prg7[1999:1992],prg7[1983:1976],prg7[1967:1960],prg7[1951:1944],prg7[1935:1928],
                  prg7[1919:1912],prg7[1903:1896],prg7[1887:1880],prg7[1871:1864],prg7[1855:1848],prg7[1839:1832],prg7[1823:1816],prg7[1807:1800],
                  prg7[1791:1784],prg7[1775:1768],prg7[1759:1752],prg7[1743:1736],prg7[1727:1720],prg7[1711:1704],prg7[1695:1688],prg7[1679:1672],
                  prg7[1663:1656],prg7[1647:1640],prg7[1631:1624],prg7[1615:1608],prg7[1599:1592],prg7[1583:1576],prg7[1567:1560],prg7[1551:1544],
                  prg7[1535:1528],prg7[1519:1512],prg7[1503:1496],prg7[1487:1480],prg7[1471:1464],prg7[1455:1448],prg7[1439:1432],prg7[1423:1416],
                  prg7[1407:1400],prg7[1391:1384],prg7[1375:1368],prg7[1359:1352],prg7[1343:1336],prg7[1327:1320],prg7[1311:1304],prg7[1295:1288],
                  prg7[1279:1272],prg7[1263:1256],prg7[1247:1240],prg7[1231:1224],prg7[1215:1208],prg7[1199:1192],prg7[1183:1176],prg7[1167:1160],
                  prg7[1151:1144],prg7[1135:1128],prg7[1119:1112],prg7[1103:1096],prg7[1087:1080],prg7[1071:1064],prg7[1055:1048],prg7[1039:1032],
                  prg7[1023:1016],prg7[1007:1000],prg7[ 991: 984],prg7[ 975: 968],prg7[ 959: 952],prg7[ 943: 936],prg7[ 927: 920],prg7[ 911: 904],
                  prg7[ 895: 888],prg7[ 879: 872],prg7[ 863: 856],prg7[ 847: 840],prg7[ 831: 824],prg7[ 815: 808],prg7[ 799: 792],prg7[ 783: 776],
                  prg7[ 767: 760],prg7[ 751: 744],prg7[ 735: 728],prg7[ 719: 712],prg7[ 703: 696],prg7[ 687: 680],prg7[ 671: 664],prg7[ 655: 648],
                  prg7[ 639: 632],prg7[ 623: 616],prg7[ 607: 600],prg7[ 591: 584],prg7[ 575: 568],prg7[ 559: 552],prg7[ 543: 536],prg7[ 527: 520],
                  prg7[ 511: 504],prg7[ 495: 488],prg7[ 479: 472],prg7[ 463: 456],prg7[ 447: 440],prg7[ 431: 424],prg7[ 415: 408],prg7[ 399: 392],
                  prg7[ 383: 376],prg7[ 367: 360],prg7[ 351: 344],prg7[ 335: 328],prg7[ 319: 312],prg7[ 303: 296],prg7[ 287: 280],prg7[ 271: 264],
                  prg7[ 255: 248],prg7[ 239: 232],prg7[ 223: 216],prg7[ 207: 200],prg7[ 191: 184],prg7[ 175: 168],prg7[ 159: 152],prg7[ 143: 136],
                  prg7[ 127: 120],prg7[ 111: 104],prg7[  95:  88],prg7[  79:  72],prg7[  63:  56],prg7[  47:  40],prg7[  31:  24],prg7[  15:   8],
                  prg6[4095:4088],prg6[4079:4072],prg6[4063:4056],prg6[4047:4040],prg6[4031:4024],prg6[4015:4008],prg6[3999:3992],prg6[3983:3976],
                  prg6[3967:3960],prg6[3951:3944],prg6[3935:3928],prg6[3919:3912],prg6[3903:3896],prg6[3887:3880],prg6[3871:3864],prg6[3855:3848],
                  prg6[3839:3832],prg6[3823:3816],prg6[3807:3800],prg6[3791:3784],prg6[3775:3768],prg6[3759:3752],prg6[3743:3736],prg6[3727:3720],
                  prg6[3711:3704],prg6[3695:3688],prg6[3679:3672],prg6[3663:3656],prg6[3647:3640],prg6[3631:3624],prg6[3615:3608],prg6[3599:3592],
                  prg6[3583:3576],prg6[3567:3560],prg6[3551:3544],prg6[3535:3528],prg6[3519:3512],prg6[3503:3496],prg6[3487:3480],prg6[3471:3464],
                  prg6[3455:3448],prg6[3439:3432],prg6[3423:3416],prg6[3407:3400],prg6[3391:3384],prg6[3375:3368],prg6[3359:3352],prg6[3343:3336],
                  prg6[3327:3320],prg6[3311:3304],prg6[3295:3288],prg6[3279:3272],prg6[3263:3256],prg6[3247:3240],prg6[3231:3224],prg6[3215:3208],
                  prg6[3199:3192],prg6[3183:3176],prg6[3167:3160],prg6[3151:3144],prg6[3135:3128],prg6[3119:3112],prg6[3103:3096],prg6[3087:3080],
                  prg6[3071:3064],prg6[3055:3048],prg6[3039:3032],prg6[3023:3016],prg6[3007:3000],prg6[2991:2984],prg6[2975:2968],prg6[2959:2952],
                  prg6[2943:2936],prg6[2927:2920],prg6[2911:2904],prg6[2895:2888],prg6[2879:2872],prg6[2863:2856],prg6[2847:2840],prg6[2831:2824],
                  prg6[2815:2808],prg6[2799:2792],prg6[2783:2776],prg6[2767:2760],prg6[2751:2744],prg6[2735:2728],prg6[2719:2712],prg6[2703:2696],
                  prg6[2687:2680],prg6[2671:2664],prg6[2655:2648],prg6[2639:2632],prg6[2623:2616],prg6[2607:2600],prg6[2591:2584],prg6[2575:2568],
                  prg6[2559:2552],prg6[2543:2536],prg6[2527:2520],prg6[2511:2504],prg6[2495:2488],prg6[2479:2472],prg6[2463:2456],prg6[2447:2440],
                  prg6[2431:2424],prg6[2415:2408],prg6[2399:2392],prg6[2383:2376],prg6[2367:2360],prg6[2351:2344],prg6[2335:2328],prg6[2319:2312],
                  prg6[2303:2296],prg6[2287:2280],prg6[2271:2264],prg6[2255:2248],prg6[2239:2232],prg6[2223:2216],prg6[2207:2200],prg6[2191:2184],
                  prg6[2175:2168],prg6[2159:2152],prg6[2143:2136],prg6[2127:2120],prg6[2111:2104],prg6[2095:2088],prg6[2079:2072],prg6[2063:2056],
                  prg6[2047:2040],prg6[2031:2024],prg6[2015:2008],prg6[1999:1992],prg6[1983:1976],prg6[1967:1960],prg6[1951:1944],prg6[1935:1928],
                  prg6[1919:1912],prg6[1903:1896],prg6[1887:1880],prg6[1871:1864],prg6[1855:1848],prg6[1839:1832],prg6[1823:1816],prg6[1807:1800],
                  prg6[1791:1784],prg6[1775:1768],prg6[1759:1752],prg6[1743:1736],prg6[1727:1720],prg6[1711:1704],prg6[1695:1688],prg6[1679:1672],
                  prg6[1663:1656],prg6[1647:1640],prg6[1631:1624],prg6[1615:1608],prg6[1599:1592],prg6[1583:1576],prg6[1567:1560],prg6[1551:1544],
                  prg6[1535:1528],prg6[1519:1512],prg6[1503:1496],prg6[1487:1480],prg6[1471:1464],prg6[1455:1448],prg6[1439:1432],prg6[1423:1416],
                  prg6[1407:1400],prg6[1391:1384],prg6[1375:1368],prg6[1359:1352],prg6[1343:1336],prg6[1327:1320],prg6[1311:1304],prg6[1295:1288],
                  prg6[1279:1272],prg6[1263:1256],prg6[1247:1240],prg6[1231:1224],prg6[1215:1208],prg6[1199:1192],prg6[1183:1176],prg6[1167:1160],
                  prg6[1151:1144],prg6[1135:1128],prg6[1119:1112],prg6[1103:1096],prg6[1087:1080],prg6[1071:1064],prg6[1055:1048],prg6[1039:1032],
                  prg6[1023:1016],prg6[1007:1000],prg6[ 991: 984],prg6[ 975: 968],prg6[ 959: 952],prg6[ 943: 936],prg6[ 927: 920],prg6[ 911: 904],
                  prg6[ 895: 888],prg6[ 879: 872],prg6[ 863: 856],prg6[ 847: 840],prg6[ 831: 824],prg6[ 815: 808],prg6[ 799: 792],prg6[ 783: 776],
                  prg6[ 767: 760],prg6[ 751: 744],prg6[ 735: 728],prg6[ 719: 712],prg6[ 703: 696],prg6[ 687: 680],prg6[ 671: 664],prg6[ 655: 648],
                  prg6[ 639: 632],prg6[ 623: 616],prg6[ 607: 600],prg6[ 591: 584],prg6[ 575: 568],prg6[ 559: 552],prg6[ 543: 536],prg6[ 527: 520],
                  prg6[ 511: 504],prg6[ 495: 488],prg6[ 479: 472],prg6[ 463: 456],prg6[ 447: 440],prg6[ 431: 424],prg6[ 415: 408],prg6[ 399: 392],
                  prg6[ 383: 376],prg6[ 367: 360],prg6[ 351: 344],prg6[ 335: 328],prg6[ 319: 312],prg6[ 303: 296],prg6[ 287: 280],prg6[ 271: 264],
                  prg6[ 255: 248],prg6[ 239: 232],prg6[ 223: 216],prg6[ 207: 200],prg6[ 191: 184],prg6[ 175: 168],prg6[ 159: 152],prg6[ 143: 136],
                  prg6[ 127: 120],prg6[ 111: 104],prg6[  95:  88],prg6[  79:  72],prg6[  63:  56],prg6[  47:  40],prg6[  31:  24],prg6[  15:   8]};
         localparam [4095:0]
           ph2 = {prg5[4095:4088],prg5[4079:4072],prg5[4063:4056],prg5[4047:4040],prg5[4031:4024],prg5[4015:4008],prg5[3999:3992],prg5[3983:3976],
                  prg5[3967:3960],prg5[3951:3944],prg5[3935:3928],prg5[3919:3912],prg5[3903:3896],prg5[3887:3880],prg5[3871:3864],prg5[3855:3848],
                  prg5[3839:3832],prg5[3823:3816],prg5[3807:3800],prg5[3791:3784],prg5[3775:3768],prg5[3759:3752],prg5[3743:3736],prg5[3727:3720],
                  prg5[3711:3704],prg5[3695:3688],prg5[3679:3672],prg5[3663:3656],prg5[3647:3640],prg5[3631:3624],prg5[3615:3608],prg5[3599:3592],
                  prg5[3583:3576],prg5[3567:3560],prg5[3551:3544],prg5[3535:3528],prg5[3519:3512],prg5[3503:3496],prg5[3487:3480],prg5[3471:3464],
                  prg5[3455:3448],prg5[3439:3432],prg5[3423:3416],prg5[3407:3400],prg5[3391:3384],prg5[3375:3368],prg5[3359:3352],prg5[3343:3336],
                  prg5[3327:3320],prg5[3311:3304],prg5[3295:3288],prg5[3279:3272],prg5[3263:3256],prg5[3247:3240],prg5[3231:3224],prg5[3215:3208],
                  prg5[3199:3192],prg5[3183:3176],prg5[3167:3160],prg5[3151:3144],prg5[3135:3128],prg5[3119:3112],prg5[3103:3096],prg5[3087:3080],
                  prg5[3071:3064],prg5[3055:3048],prg5[3039:3032],prg5[3023:3016],prg5[3007:3000],prg5[2991:2984],prg5[2975:2968],prg5[2959:2952],
                  prg5[2943:2936],prg5[2927:2920],prg5[2911:2904],prg5[2895:2888],prg5[2879:2872],prg5[2863:2856],prg5[2847:2840],prg5[2831:2824],
                  prg5[2815:2808],prg5[2799:2792],prg5[2783:2776],prg5[2767:2760],prg5[2751:2744],prg5[2735:2728],prg5[2719:2712],prg5[2703:2696],
                  prg5[2687:2680],prg5[2671:2664],prg5[2655:2648],prg5[2639:2632],prg5[2623:2616],prg5[2607:2600],prg5[2591:2584],prg5[2575:2568],
                  prg5[2559:2552],prg5[2543:2536],prg5[2527:2520],prg5[2511:2504],prg5[2495:2488],prg5[2479:2472],prg5[2463:2456],prg5[2447:2440],
                  prg5[2431:2424],prg5[2415:2408],prg5[2399:2392],prg5[2383:2376],prg5[2367:2360],prg5[2351:2344],prg5[2335:2328],prg5[2319:2312],
                  prg5[2303:2296],prg5[2287:2280],prg5[2271:2264],prg5[2255:2248],prg5[2239:2232],prg5[2223:2216],prg5[2207:2200],prg5[2191:2184],
                  prg5[2175:2168],prg5[2159:2152],prg5[2143:2136],prg5[2127:2120],prg5[2111:2104],prg5[2095:2088],prg5[2079:2072],prg5[2063:2056],
                  prg5[2047:2040],prg5[2031:2024],prg5[2015:2008],prg5[1999:1992],prg5[1983:1976],prg5[1967:1960],prg5[1951:1944],prg5[1935:1928],
                  prg5[1919:1912],prg5[1903:1896],prg5[1887:1880],prg5[1871:1864],prg5[1855:1848],prg5[1839:1832],prg5[1823:1816],prg5[1807:1800],
                  prg5[1791:1784],prg5[1775:1768],prg5[1759:1752],prg5[1743:1736],prg5[1727:1720],prg5[1711:1704],prg5[1695:1688],prg5[1679:1672],
                  prg5[1663:1656],prg5[1647:1640],prg5[1631:1624],prg5[1615:1608],prg5[1599:1592],prg5[1583:1576],prg5[1567:1560],prg5[1551:1544],
                  prg5[1535:1528],prg5[1519:1512],prg5[1503:1496],prg5[1487:1480],prg5[1471:1464],prg5[1455:1448],prg5[1439:1432],prg5[1423:1416],
                  prg5[1407:1400],prg5[1391:1384],prg5[1375:1368],prg5[1359:1352],prg5[1343:1336],prg5[1327:1320],prg5[1311:1304],prg5[1295:1288],
                  prg5[1279:1272],prg5[1263:1256],prg5[1247:1240],prg5[1231:1224],prg5[1215:1208],prg5[1199:1192],prg5[1183:1176],prg5[1167:1160],
                  prg5[1151:1144],prg5[1135:1128],prg5[1119:1112],prg5[1103:1096],prg5[1087:1080],prg5[1071:1064],prg5[1055:1048],prg5[1039:1032],
                  prg5[1023:1016],prg5[1007:1000],prg5[ 991: 984],prg5[ 975: 968],prg5[ 959: 952],prg5[ 943: 936],prg5[ 927: 920],prg5[ 911: 904],
                  prg5[ 895: 888],prg5[ 879: 872],prg5[ 863: 856],prg5[ 847: 840],prg5[ 831: 824],prg5[ 815: 808],prg5[ 799: 792],prg5[ 783: 776],
                  prg5[ 767: 760],prg5[ 751: 744],prg5[ 735: 728],prg5[ 719: 712],prg5[ 703: 696],prg5[ 687: 680],prg5[ 671: 664],prg5[ 655: 648],
                  prg5[ 639: 632],prg5[ 623: 616],prg5[ 607: 600],prg5[ 591: 584],prg5[ 575: 568],prg5[ 559: 552],prg5[ 543: 536],prg5[ 527: 520],
                  prg5[ 511: 504],prg5[ 495: 488],prg5[ 479: 472],prg5[ 463: 456],prg5[ 447: 440],prg5[ 431: 424],prg5[ 415: 408],prg5[ 399: 392],
                  prg5[ 383: 376],prg5[ 367: 360],prg5[ 351: 344],prg5[ 335: 328],prg5[ 319: 312],prg5[ 303: 296],prg5[ 287: 280],prg5[ 271: 264],
                  prg5[ 255: 248],prg5[ 239: 232],prg5[ 223: 216],prg5[ 207: 200],prg5[ 191: 184],prg5[ 175: 168],prg5[ 159: 152],prg5[ 143: 136],
                  prg5[ 127: 120],prg5[ 111: 104],prg5[  95:  88],prg5[  79:  72],prg5[  63:  56],prg5[  47:  40],prg5[  31:  24],prg5[  15:   8],
                  prg4[4095:4088],prg4[4079:4072],prg4[4063:4056],prg4[4047:4040],prg4[4031:4024],prg4[4015:4008],prg4[3999:3992],prg4[3983:3976],
                  prg4[3967:3960],prg4[3951:3944],prg4[3935:3928],prg4[3919:3912],prg4[3903:3896],prg4[3887:3880],prg4[3871:3864],prg4[3855:3848],
                  prg4[3839:3832],prg4[3823:3816],prg4[3807:3800],prg4[3791:3784],prg4[3775:3768],prg4[3759:3752],prg4[3743:3736],prg4[3727:3720],
                  prg4[3711:3704],prg4[3695:3688],prg4[3679:3672],prg4[3663:3656],prg4[3647:3640],prg4[3631:3624],prg4[3615:3608],prg4[3599:3592],
                  prg4[3583:3576],prg4[3567:3560],prg4[3551:3544],prg4[3535:3528],prg4[3519:3512],prg4[3503:3496],prg4[3487:3480],prg4[3471:3464],
                  prg4[3455:3448],prg4[3439:3432],prg4[3423:3416],prg4[3407:3400],prg4[3391:3384],prg4[3375:3368],prg4[3359:3352],prg4[3343:3336],
                  prg4[3327:3320],prg4[3311:3304],prg4[3295:3288],prg4[3279:3272],prg4[3263:3256],prg4[3247:3240],prg4[3231:3224],prg4[3215:3208],
                  prg4[3199:3192],prg4[3183:3176],prg4[3167:3160],prg4[3151:3144],prg4[3135:3128],prg4[3119:3112],prg4[3103:3096],prg4[3087:3080],
                  prg4[3071:3064],prg4[3055:3048],prg4[3039:3032],prg4[3023:3016],prg4[3007:3000],prg4[2991:2984],prg4[2975:2968],prg4[2959:2952],
                  prg4[2943:2936],prg4[2927:2920],prg4[2911:2904],prg4[2895:2888],prg4[2879:2872],prg4[2863:2856],prg4[2847:2840],prg4[2831:2824],
                  prg4[2815:2808],prg4[2799:2792],prg4[2783:2776],prg4[2767:2760],prg4[2751:2744],prg4[2735:2728],prg4[2719:2712],prg4[2703:2696],
                  prg4[2687:2680],prg4[2671:2664],prg4[2655:2648],prg4[2639:2632],prg4[2623:2616],prg4[2607:2600],prg4[2591:2584],prg4[2575:2568],
                  prg4[2559:2552],prg4[2543:2536],prg4[2527:2520],prg4[2511:2504],prg4[2495:2488],prg4[2479:2472],prg4[2463:2456],prg4[2447:2440],
                  prg4[2431:2424],prg4[2415:2408],prg4[2399:2392],prg4[2383:2376],prg4[2367:2360],prg4[2351:2344],prg4[2335:2328],prg4[2319:2312],
                  prg4[2303:2296],prg4[2287:2280],prg4[2271:2264],prg4[2255:2248],prg4[2239:2232],prg4[2223:2216],prg4[2207:2200],prg4[2191:2184],
                  prg4[2175:2168],prg4[2159:2152],prg4[2143:2136],prg4[2127:2120],prg4[2111:2104],prg4[2095:2088],prg4[2079:2072],prg4[2063:2056],
                  prg4[2047:2040],prg4[2031:2024],prg4[2015:2008],prg4[1999:1992],prg4[1983:1976],prg4[1967:1960],prg4[1951:1944],prg4[1935:1928],
                  prg4[1919:1912],prg4[1903:1896],prg4[1887:1880],prg4[1871:1864],prg4[1855:1848],prg4[1839:1832],prg4[1823:1816],prg4[1807:1800],
                  prg4[1791:1784],prg4[1775:1768],prg4[1759:1752],prg4[1743:1736],prg4[1727:1720],prg4[1711:1704],prg4[1695:1688],prg4[1679:1672],
                  prg4[1663:1656],prg4[1647:1640],prg4[1631:1624],prg4[1615:1608],prg4[1599:1592],prg4[1583:1576],prg4[1567:1560],prg4[1551:1544],
                  prg4[1535:1528],prg4[1519:1512],prg4[1503:1496],prg4[1487:1480],prg4[1471:1464],prg4[1455:1448],prg4[1439:1432],prg4[1423:1416],
                  prg4[1407:1400],prg4[1391:1384],prg4[1375:1368],prg4[1359:1352],prg4[1343:1336],prg4[1327:1320],prg4[1311:1304],prg4[1295:1288],
                  prg4[1279:1272],prg4[1263:1256],prg4[1247:1240],prg4[1231:1224],prg4[1215:1208],prg4[1199:1192],prg4[1183:1176],prg4[1167:1160],
                  prg4[1151:1144],prg4[1135:1128],prg4[1119:1112],prg4[1103:1096],prg4[1087:1080],prg4[1071:1064],prg4[1055:1048],prg4[1039:1032],
                  prg4[1023:1016],prg4[1007:1000],prg4[ 991: 984],prg4[ 975: 968],prg4[ 959: 952],prg4[ 943: 936],prg4[ 927: 920],prg4[ 911: 904],
                  prg4[ 895: 888],prg4[ 879: 872],prg4[ 863: 856],prg4[ 847: 840],prg4[ 831: 824],prg4[ 815: 808],prg4[ 799: 792],prg4[ 783: 776],
                  prg4[ 767: 760],prg4[ 751: 744],prg4[ 735: 728],prg4[ 719: 712],prg4[ 703: 696],prg4[ 687: 680],prg4[ 671: 664],prg4[ 655: 648],
                  prg4[ 639: 632],prg4[ 623: 616],prg4[ 607: 600],prg4[ 591: 584],prg4[ 575: 568],prg4[ 559: 552],prg4[ 543: 536],prg4[ 527: 520],
                  prg4[ 511: 504],prg4[ 495: 488],prg4[ 479: 472],prg4[ 463: 456],prg4[ 447: 440],prg4[ 431: 424],prg4[ 415: 408],prg4[ 399: 392],
                  prg4[ 383: 376],prg4[ 367: 360],prg4[ 351: 344],prg4[ 335: 328],prg4[ 319: 312],prg4[ 303: 296],prg4[ 287: 280],prg4[ 271: 264],
                  prg4[ 255: 248],prg4[ 239: 232],prg4[ 223: 216],prg4[ 207: 200],prg4[ 191: 184],prg4[ 175: 168],prg4[ 159: 152],prg4[ 143: 136],
                  prg4[ 127: 120],prg4[ 111: 104],prg4[  95:  88],prg4[  79:  72],prg4[  63:  56],prg4[  47:  40],prg4[  31:  24],prg4[  15:   8]};
         localparam [4095:0]
           ph1 = {prg3[4095:4088],prg3[4079:4072],prg3[4063:4056],prg3[4047:4040],prg3[4031:4024],prg3[4015:4008],prg3[3999:3992],prg3[3983:3976],
                  prg3[3967:3960],prg3[3951:3944],prg3[3935:3928],prg3[3919:3912],prg3[3903:3896],prg3[3887:3880],prg3[3871:3864],prg3[3855:3848],
                  prg3[3839:3832],prg3[3823:3816],prg3[3807:3800],prg3[3791:3784],prg3[3775:3768],prg3[3759:3752],prg3[3743:3736],prg3[3727:3720],
                  prg3[3711:3704],prg3[3695:3688],prg3[3679:3672],prg3[3663:3656],prg3[3647:3640],prg3[3631:3624],prg3[3615:3608],prg3[3599:3592],
                  prg3[3583:3576],prg3[3567:3560],prg3[3551:3544],prg3[3535:3528],prg3[3519:3512],prg3[3503:3496],prg3[3487:3480],prg3[3471:3464],
                  prg3[3455:3448],prg3[3439:3432],prg3[3423:3416],prg3[3407:3400],prg3[3391:3384],prg3[3375:3368],prg3[3359:3352],prg3[3343:3336],
                  prg3[3327:3320],prg3[3311:3304],prg3[3295:3288],prg3[3279:3272],prg3[3263:3256],prg3[3247:3240],prg3[3231:3224],prg3[3215:3208],
                  prg3[3199:3192],prg3[3183:3176],prg3[3167:3160],prg3[3151:3144],prg3[3135:3128],prg3[3119:3112],prg3[3103:3096],prg3[3087:3080],
                  prg3[3071:3064],prg3[3055:3048],prg3[3039:3032],prg3[3023:3016],prg3[3007:3000],prg3[2991:2984],prg3[2975:2968],prg3[2959:2952],
                  prg3[2943:2936],prg3[2927:2920],prg3[2911:2904],prg3[2895:2888],prg3[2879:2872],prg3[2863:2856],prg3[2847:2840],prg3[2831:2824],
                  prg3[2815:2808],prg3[2799:2792],prg3[2783:2776],prg3[2767:2760],prg3[2751:2744],prg3[2735:2728],prg3[2719:2712],prg3[2703:2696],
                  prg3[2687:2680],prg3[2671:2664],prg3[2655:2648],prg3[2639:2632],prg3[2623:2616],prg3[2607:2600],prg3[2591:2584],prg3[2575:2568],
                  prg3[2559:2552],prg3[2543:2536],prg3[2527:2520],prg3[2511:2504],prg3[2495:2488],prg3[2479:2472],prg3[2463:2456],prg3[2447:2440],
                  prg3[2431:2424],prg3[2415:2408],prg3[2399:2392],prg3[2383:2376],prg3[2367:2360],prg3[2351:2344],prg3[2335:2328],prg3[2319:2312],
                  prg3[2303:2296],prg3[2287:2280],prg3[2271:2264],prg3[2255:2248],prg3[2239:2232],prg3[2223:2216],prg3[2207:2200],prg3[2191:2184],
                  prg3[2175:2168],prg3[2159:2152],prg3[2143:2136],prg3[2127:2120],prg3[2111:2104],prg3[2095:2088],prg3[2079:2072],prg3[2063:2056],
                  prg3[2047:2040],prg3[2031:2024],prg3[2015:2008],prg3[1999:1992],prg3[1983:1976],prg3[1967:1960],prg3[1951:1944],prg3[1935:1928],
                  prg3[1919:1912],prg3[1903:1896],prg3[1887:1880],prg3[1871:1864],prg3[1855:1848],prg3[1839:1832],prg3[1823:1816],prg3[1807:1800],
                  prg3[1791:1784],prg3[1775:1768],prg3[1759:1752],prg3[1743:1736],prg3[1727:1720],prg3[1711:1704],prg3[1695:1688],prg3[1679:1672],
                  prg3[1663:1656],prg3[1647:1640],prg3[1631:1624],prg3[1615:1608],prg3[1599:1592],prg3[1583:1576],prg3[1567:1560],prg3[1551:1544],
                  prg3[1535:1528],prg3[1519:1512],prg3[1503:1496],prg3[1487:1480],prg3[1471:1464],prg3[1455:1448],prg3[1439:1432],prg3[1423:1416],
                  prg3[1407:1400],prg3[1391:1384],prg3[1375:1368],prg3[1359:1352],prg3[1343:1336],prg3[1327:1320],prg3[1311:1304],prg3[1295:1288],
                  prg3[1279:1272],prg3[1263:1256],prg3[1247:1240],prg3[1231:1224],prg3[1215:1208],prg3[1199:1192],prg3[1183:1176],prg3[1167:1160],
                  prg3[1151:1144],prg3[1135:1128],prg3[1119:1112],prg3[1103:1096],prg3[1087:1080],prg3[1071:1064],prg3[1055:1048],prg3[1039:1032],
                  prg3[1023:1016],prg3[1007:1000],prg3[ 991: 984],prg3[ 975: 968],prg3[ 959: 952],prg3[ 943: 936],prg3[ 927: 920],prg3[ 911: 904],
                  prg3[ 895: 888],prg3[ 879: 872],prg3[ 863: 856],prg3[ 847: 840],prg3[ 831: 824],prg3[ 815: 808],prg3[ 799: 792],prg3[ 783: 776],
                  prg3[ 767: 760],prg3[ 751: 744],prg3[ 735: 728],prg3[ 719: 712],prg3[ 703: 696],prg3[ 687: 680],prg3[ 671: 664],prg3[ 655: 648],
                  prg3[ 639: 632],prg3[ 623: 616],prg3[ 607: 600],prg3[ 591: 584],prg3[ 575: 568],prg3[ 559: 552],prg3[ 543: 536],prg3[ 527: 520],
                  prg3[ 511: 504],prg3[ 495: 488],prg3[ 479: 472],prg3[ 463: 456],prg3[ 447: 440],prg3[ 431: 424],prg3[ 415: 408],prg3[ 399: 392],
                  prg3[ 383: 376],prg3[ 367: 360],prg3[ 351: 344],prg3[ 335: 328],prg3[ 319: 312],prg3[ 303: 296],prg3[ 287: 280],prg3[ 271: 264],
                  prg3[ 255: 248],prg3[ 239: 232],prg3[ 223: 216],prg3[ 207: 200],prg3[ 191: 184],prg3[ 175: 168],prg3[ 159: 152],prg3[ 143: 136],
                  prg3[ 127: 120],prg3[ 111: 104],prg3[  95:  88],prg3[  79:  72],prg3[  63:  56],prg3[  47:  40],prg3[  31:  24],prg3[  15:   8],
                  prg2[4095:4088],prg2[4079:4072],prg2[4063:4056],prg2[4047:4040],prg2[4031:4024],prg2[4015:4008],prg2[3999:3992],prg2[3983:3976],
                  prg2[3967:3960],prg2[3951:3944],prg2[3935:3928],prg2[3919:3912],prg2[3903:3896],prg2[3887:3880],prg2[3871:3864],prg2[3855:3848],
                  prg2[3839:3832],prg2[3823:3816],prg2[3807:3800],prg2[3791:3784],prg2[3775:3768],prg2[3759:3752],prg2[3743:3736],prg2[3727:3720],
                  prg2[3711:3704],prg2[3695:3688],prg2[3679:3672],prg2[3663:3656],prg2[3647:3640],prg2[3631:3624],prg2[3615:3608],prg2[3599:3592],
                  prg2[3583:3576],prg2[3567:3560],prg2[3551:3544],prg2[3535:3528],prg2[3519:3512],prg2[3503:3496],prg2[3487:3480],prg2[3471:3464],
                  prg2[3455:3448],prg2[3439:3432],prg2[3423:3416],prg2[3407:3400],prg2[3391:3384],prg2[3375:3368],prg2[3359:3352],prg2[3343:3336],
                  prg2[3327:3320],prg2[3311:3304],prg2[3295:3288],prg2[3279:3272],prg2[3263:3256],prg2[3247:3240],prg2[3231:3224],prg2[3215:3208],
                  prg2[3199:3192],prg2[3183:3176],prg2[3167:3160],prg2[3151:3144],prg2[3135:3128],prg2[3119:3112],prg2[3103:3096],prg2[3087:3080],
                  prg2[3071:3064],prg2[3055:3048],prg2[3039:3032],prg2[3023:3016],prg2[3007:3000],prg2[2991:2984],prg2[2975:2968],prg2[2959:2952],
                  prg2[2943:2936],prg2[2927:2920],prg2[2911:2904],prg2[2895:2888],prg2[2879:2872],prg2[2863:2856],prg2[2847:2840],prg2[2831:2824],
                  prg2[2815:2808],prg2[2799:2792],prg2[2783:2776],prg2[2767:2760],prg2[2751:2744],prg2[2735:2728],prg2[2719:2712],prg2[2703:2696],
                  prg2[2687:2680],prg2[2671:2664],prg2[2655:2648],prg2[2639:2632],prg2[2623:2616],prg2[2607:2600],prg2[2591:2584],prg2[2575:2568],
                  prg2[2559:2552],prg2[2543:2536],prg2[2527:2520],prg2[2511:2504],prg2[2495:2488],prg2[2479:2472],prg2[2463:2456],prg2[2447:2440],
                  prg2[2431:2424],prg2[2415:2408],prg2[2399:2392],prg2[2383:2376],prg2[2367:2360],prg2[2351:2344],prg2[2335:2328],prg2[2319:2312],
                  prg2[2303:2296],prg2[2287:2280],prg2[2271:2264],prg2[2255:2248],prg2[2239:2232],prg2[2223:2216],prg2[2207:2200],prg2[2191:2184],
                  prg2[2175:2168],prg2[2159:2152],prg2[2143:2136],prg2[2127:2120],prg2[2111:2104],prg2[2095:2088],prg2[2079:2072],prg2[2063:2056],
                  prg2[2047:2040],prg2[2031:2024],prg2[2015:2008],prg2[1999:1992],prg2[1983:1976],prg2[1967:1960],prg2[1951:1944],prg2[1935:1928],
                  prg2[1919:1912],prg2[1903:1896],prg2[1887:1880],prg2[1871:1864],prg2[1855:1848],prg2[1839:1832],prg2[1823:1816],prg2[1807:1800],
                  prg2[1791:1784],prg2[1775:1768],prg2[1759:1752],prg2[1743:1736],prg2[1727:1720],prg2[1711:1704],prg2[1695:1688],prg2[1679:1672],
                  prg2[1663:1656],prg2[1647:1640],prg2[1631:1624],prg2[1615:1608],prg2[1599:1592],prg2[1583:1576],prg2[1567:1560],prg2[1551:1544],
                  prg2[1535:1528],prg2[1519:1512],prg2[1503:1496],prg2[1487:1480],prg2[1471:1464],prg2[1455:1448],prg2[1439:1432],prg2[1423:1416],
                  prg2[1407:1400],prg2[1391:1384],prg2[1375:1368],prg2[1359:1352],prg2[1343:1336],prg2[1327:1320],prg2[1311:1304],prg2[1295:1288],
                  prg2[1279:1272],prg2[1263:1256],prg2[1247:1240],prg2[1231:1224],prg2[1215:1208],prg2[1199:1192],prg2[1183:1176],prg2[1167:1160],
                  prg2[1151:1144],prg2[1135:1128],prg2[1119:1112],prg2[1103:1096],prg2[1087:1080],prg2[1071:1064],prg2[1055:1048],prg2[1039:1032],
                  prg2[1023:1016],prg2[1007:1000],prg2[ 991: 984],prg2[ 975: 968],prg2[ 959: 952],prg2[ 943: 936],prg2[ 927: 920],prg2[ 911: 904],
                  prg2[ 895: 888],prg2[ 879: 872],prg2[ 863: 856],prg2[ 847: 840],prg2[ 831: 824],prg2[ 815: 808],prg2[ 799: 792],prg2[ 783: 776],
                  prg2[ 767: 760],prg2[ 751: 744],prg2[ 735: 728],prg2[ 719: 712],prg2[ 703: 696],prg2[ 687: 680],prg2[ 671: 664],prg2[ 655: 648],
                  prg2[ 639: 632],prg2[ 623: 616],prg2[ 607: 600],prg2[ 591: 584],prg2[ 575: 568],prg2[ 559: 552],prg2[ 543: 536],prg2[ 527: 520],
                  prg2[ 511: 504],prg2[ 495: 488],prg2[ 479: 472],prg2[ 463: 456],prg2[ 447: 440],prg2[ 431: 424],prg2[ 415: 408],prg2[ 399: 392],
                  prg2[ 383: 376],prg2[ 367: 360],prg2[ 351: 344],prg2[ 335: 328],prg2[ 319: 312],prg2[ 303: 296],prg2[ 287: 280],prg2[ 271: 264],
                  prg2[ 255: 248],prg2[ 239: 232],prg2[ 223: 216],prg2[ 207: 200],prg2[ 191: 184],prg2[ 175: 168],prg2[ 159: 152],prg2[ 143: 136],
                  prg2[ 127: 120],prg2[ 111: 104],prg2[  95:  88],prg2[  79:  72],prg2[  63:  56],prg2[  47:  40],prg2[  31:  24],prg2[  15:   8]};
         localparam [4095:0]
           ph0 = {prg1[4095:4088],prg1[4079:4072],prg1[4063:4056],prg1[4047:4040],prg1[4031:4024],prg1[4015:4008],prg1[3999:3992],prg1[3983:3976],
                  prg1[3967:3960],prg1[3951:3944],prg1[3935:3928],prg1[3919:3912],prg1[3903:3896],prg1[3887:3880],prg1[3871:3864],prg1[3855:3848],
                  prg1[3839:3832],prg1[3823:3816],prg1[3807:3800],prg1[3791:3784],prg1[3775:3768],prg1[3759:3752],prg1[3743:3736],prg1[3727:3720],
                  prg1[3711:3704],prg1[3695:3688],prg1[3679:3672],prg1[3663:3656],prg1[3647:3640],prg1[3631:3624],prg1[3615:3608],prg1[3599:3592],
                  prg1[3583:3576],prg1[3567:3560],prg1[3551:3544],prg1[3535:3528],prg1[3519:3512],prg1[3503:3496],prg1[3487:3480],prg1[3471:3464],
                  prg1[3455:3448],prg1[3439:3432],prg1[3423:3416],prg1[3407:3400],prg1[3391:3384],prg1[3375:3368],prg1[3359:3352],prg1[3343:3336],
                  prg1[3327:3320],prg1[3311:3304],prg1[3295:3288],prg1[3279:3272],prg1[3263:3256],prg1[3247:3240],prg1[3231:3224],prg1[3215:3208],
                  prg1[3199:3192],prg1[3183:3176],prg1[3167:3160],prg1[3151:3144],prg1[3135:3128],prg1[3119:3112],prg1[3103:3096],prg1[3087:3080],
                  prg1[3071:3064],prg1[3055:3048],prg1[3039:3032],prg1[3023:3016],prg1[3007:3000],prg1[2991:2984],prg1[2975:2968],prg1[2959:2952],
                  prg1[2943:2936],prg1[2927:2920],prg1[2911:2904],prg1[2895:2888],prg1[2879:2872],prg1[2863:2856],prg1[2847:2840],prg1[2831:2824],
                  prg1[2815:2808],prg1[2799:2792],prg1[2783:2776],prg1[2767:2760],prg1[2751:2744],prg1[2735:2728],prg1[2719:2712],prg1[2703:2696],
                  prg1[2687:2680],prg1[2671:2664],prg1[2655:2648],prg1[2639:2632],prg1[2623:2616],prg1[2607:2600],prg1[2591:2584],prg1[2575:2568],
                  prg1[2559:2552],prg1[2543:2536],prg1[2527:2520],prg1[2511:2504],prg1[2495:2488],prg1[2479:2472],prg1[2463:2456],prg1[2447:2440],
                  prg1[2431:2424],prg1[2415:2408],prg1[2399:2392],prg1[2383:2376],prg1[2367:2360],prg1[2351:2344],prg1[2335:2328],prg1[2319:2312],
                  prg1[2303:2296],prg1[2287:2280],prg1[2271:2264],prg1[2255:2248],prg1[2239:2232],prg1[2223:2216],prg1[2207:2200],prg1[2191:2184],
                  prg1[2175:2168],prg1[2159:2152],prg1[2143:2136],prg1[2127:2120],prg1[2111:2104],prg1[2095:2088],prg1[2079:2072],prg1[2063:2056],
                  prg1[2047:2040],prg1[2031:2024],prg1[2015:2008],prg1[1999:1992],prg1[1983:1976],prg1[1967:1960],prg1[1951:1944],prg1[1935:1928],
                  prg1[1919:1912],prg1[1903:1896],prg1[1887:1880],prg1[1871:1864],prg1[1855:1848],prg1[1839:1832],prg1[1823:1816],prg1[1807:1800],
                  prg1[1791:1784],prg1[1775:1768],prg1[1759:1752],prg1[1743:1736],prg1[1727:1720],prg1[1711:1704],prg1[1695:1688],prg1[1679:1672],
                  prg1[1663:1656],prg1[1647:1640],prg1[1631:1624],prg1[1615:1608],prg1[1599:1592],prg1[1583:1576],prg1[1567:1560],prg1[1551:1544],
                  prg1[1535:1528],prg1[1519:1512],prg1[1503:1496],prg1[1487:1480],prg1[1471:1464],prg1[1455:1448],prg1[1439:1432],prg1[1423:1416],
                  prg1[1407:1400],prg1[1391:1384],prg1[1375:1368],prg1[1359:1352],prg1[1343:1336],prg1[1327:1320],prg1[1311:1304],prg1[1295:1288],
                  prg1[1279:1272],prg1[1263:1256],prg1[1247:1240],prg1[1231:1224],prg1[1215:1208],prg1[1199:1192],prg1[1183:1176],prg1[1167:1160],
                  prg1[1151:1144],prg1[1135:1128],prg1[1119:1112],prg1[1103:1096],prg1[1087:1080],prg1[1071:1064],prg1[1055:1048],prg1[1039:1032],
                  prg1[1023:1016],prg1[1007:1000],prg1[ 991: 984],prg1[ 975: 968],prg1[ 959: 952],prg1[ 943: 936],prg1[ 927: 920],prg1[ 911: 904],
                  prg1[ 895: 888],prg1[ 879: 872],prg1[ 863: 856],prg1[ 847: 840],prg1[ 831: 824],prg1[ 815: 808],prg1[ 799: 792],prg1[ 783: 776],
                  prg1[ 767: 760],prg1[ 751: 744],prg1[ 735: 728],prg1[ 719: 712],prg1[ 703: 696],prg1[ 687: 680],prg1[ 671: 664],prg1[ 655: 648],
                  prg1[ 639: 632],prg1[ 623: 616],prg1[ 607: 600],prg1[ 591: 584],prg1[ 575: 568],prg1[ 559: 552],prg1[ 543: 536],prg1[ 527: 520],
                  prg1[ 511: 504],prg1[ 495: 488],prg1[ 479: 472],prg1[ 463: 456],prg1[ 447: 440],prg1[ 431: 424],prg1[ 415: 408],prg1[ 399: 392],
                  prg1[ 383: 376],prg1[ 367: 360],prg1[ 351: 344],prg1[ 335: 328],prg1[ 319: 312],prg1[ 303: 296],prg1[ 287: 280],prg1[ 271: 264],
                  prg1[ 255: 248],prg1[ 239: 232],prg1[ 223: 216],prg1[ 207: 200],prg1[ 191: 184],prg1[ 175: 168],prg1[ 159: 152],prg1[ 143: 136],
                  prg1[ 127: 120],prg1[ 111: 104],prg1[  95:  88],prg1[  79:  72],prg1[  63:  56],prg1[  47:  40],prg1[  31:  24],prg1[  15:   8],
                  prg0[4095:4088],prg0[4079:4072],prg0[4063:4056],prg0[4047:4040],prg0[4031:4024],prg0[4015:4008],prg0[3999:3992],prg0[3983:3976],
                  prg0[3967:3960],prg0[3951:3944],prg0[3935:3928],prg0[3919:3912],prg0[3903:3896],prg0[3887:3880],prg0[3871:3864],prg0[3855:3848],
                  prg0[3839:3832],prg0[3823:3816],prg0[3807:3800],prg0[3791:3784],prg0[3775:3768],prg0[3759:3752],prg0[3743:3736],prg0[3727:3720],
                  prg0[3711:3704],prg0[3695:3688],prg0[3679:3672],prg0[3663:3656],prg0[3647:3640],prg0[3631:3624],prg0[3615:3608],prg0[3599:3592],
                  prg0[3583:3576],prg0[3567:3560],prg0[3551:3544],prg0[3535:3528],prg0[3519:3512],prg0[3503:3496],prg0[3487:3480],prg0[3471:3464],
                  prg0[3455:3448],prg0[3439:3432],prg0[3423:3416],prg0[3407:3400],prg0[3391:3384],prg0[3375:3368],prg0[3359:3352],prg0[3343:3336],
                  prg0[3327:3320],prg0[3311:3304],prg0[3295:3288],prg0[3279:3272],prg0[3263:3256],prg0[3247:3240],prg0[3231:3224],prg0[3215:3208],
                  prg0[3199:3192],prg0[3183:3176],prg0[3167:3160],prg0[3151:3144],prg0[3135:3128],prg0[3119:3112],prg0[3103:3096],prg0[3087:3080],
                  prg0[3071:3064],prg0[3055:3048],prg0[3039:3032],prg0[3023:3016],prg0[3007:3000],prg0[2991:2984],prg0[2975:2968],prg0[2959:2952],
                  prg0[2943:2936],prg0[2927:2920],prg0[2911:2904],prg0[2895:2888],prg0[2879:2872],prg0[2863:2856],prg0[2847:2840],prg0[2831:2824],
                  prg0[2815:2808],prg0[2799:2792],prg0[2783:2776],prg0[2767:2760],prg0[2751:2744],prg0[2735:2728],prg0[2719:2712],prg0[2703:2696],
                  prg0[2687:2680],prg0[2671:2664],prg0[2655:2648],prg0[2639:2632],prg0[2623:2616],prg0[2607:2600],prg0[2591:2584],prg0[2575:2568],
                  prg0[2559:2552],prg0[2543:2536],prg0[2527:2520],prg0[2511:2504],prg0[2495:2488],prg0[2479:2472],prg0[2463:2456],prg0[2447:2440],
                  prg0[2431:2424],prg0[2415:2408],prg0[2399:2392],prg0[2383:2376],prg0[2367:2360],prg0[2351:2344],prg0[2335:2328],prg0[2319:2312],
                  prg0[2303:2296],prg0[2287:2280],prg0[2271:2264],prg0[2255:2248],prg0[2239:2232],prg0[2223:2216],prg0[2207:2200],prg0[2191:2184],
                  prg0[2175:2168],prg0[2159:2152],prg0[2143:2136],prg0[2127:2120],prg0[2111:2104],prg0[2095:2088],prg0[2079:2072],prg0[2063:2056],
                  prg0[2047:2040],prg0[2031:2024],prg0[2015:2008],prg0[1999:1992],prg0[1983:1976],prg0[1967:1960],prg0[1951:1944],prg0[1935:1928],
                  prg0[1919:1912],prg0[1903:1896],prg0[1887:1880],prg0[1871:1864],prg0[1855:1848],prg0[1839:1832],prg0[1823:1816],prg0[1807:1800],
                  prg0[1791:1784],prg0[1775:1768],prg0[1759:1752],prg0[1743:1736],prg0[1727:1720],prg0[1711:1704],prg0[1695:1688],prg0[1679:1672],
                  prg0[1663:1656],prg0[1647:1640],prg0[1631:1624],prg0[1615:1608],prg0[1599:1592],prg0[1583:1576],prg0[1567:1560],prg0[1551:1544],
                  prg0[1535:1528],prg0[1519:1512],prg0[1503:1496],prg0[1487:1480],prg0[1471:1464],prg0[1455:1448],prg0[1439:1432],prg0[1423:1416],
                  prg0[1407:1400],prg0[1391:1384],prg0[1375:1368],prg0[1359:1352],prg0[1343:1336],prg0[1327:1320],prg0[1311:1304],prg0[1295:1288],
                  prg0[1279:1272],prg0[1263:1256],prg0[1247:1240],prg0[1231:1224],prg0[1215:1208],prg0[1199:1192],prg0[1183:1176],prg0[1167:1160],
                  prg0[1151:1144],prg0[1135:1128],prg0[1119:1112],prg0[1103:1096],prg0[1087:1080],prg0[1071:1064],prg0[1055:1048],prg0[1039:1032],
                  prg0[1023:1016],prg0[1007:1000],prg0[ 991: 984],prg0[ 975: 968],prg0[ 959: 952],prg0[ 943: 936],prg0[ 927: 920],prg0[ 911: 904],
                  prg0[ 895: 888],prg0[ 879: 872],prg0[ 863: 856],prg0[ 847: 840],prg0[ 831: 824],prg0[ 815: 808],prg0[ 799: 792],prg0[ 783: 776],
                  prg0[ 767: 760],prg0[ 751: 744],prg0[ 735: 728],prg0[ 719: 712],prg0[ 703: 696],prg0[ 687: 680],prg0[ 671: 664],prg0[ 655: 648],
                  prg0[ 639: 632],prg0[ 623: 616],prg0[ 607: 600],prg0[ 591: 584],prg0[ 575: 568],prg0[ 559: 552],prg0[ 543: 536],prg0[ 527: 520],
                  prg0[ 511: 504],prg0[ 495: 488],prg0[ 479: 472],prg0[ 463: 456],prg0[ 447: 440],prg0[ 431: 424],prg0[ 415: 408],prg0[ 399: 392],
                  prg0[ 383: 376],prg0[ 367: 360],prg0[ 351: 344],prg0[ 335: 328],prg0[ 319: 312],prg0[ 303: 296],prg0[ 287: 280],prg0[ 271: 264],
                  prg0[ 255: 248],prg0[ 239: 232],prg0[ 223: 216],prg0[ 207: 200],prg0[ 191: 184],prg0[ 175: 168],prg0[ 159: 152],prg0[ 143: 136],
                  prg0[ 127: 120],prg0[ 111: 104],prg0[  95:  88],prg0[  79:  72],prg0[  63:  56],prg0[  47:  40],prg0[  31:  24],prg0[  15:   8]};

         m_ebr_w8 #(.EBRADRWIDTH(EBRADRWIDTH),
                    .prg0(pb0), .prg1(pb1), .prg2(pb2), .prg3(pb3))
         ebrb 
           (// Inputs
            .bmask                      (bmask[0]),
            /*AUTOINST*/
            // Outputs
            .DAT_O                      (DAT_O[7:0]),
            // Inputs
            .B                          (B[7:0]),
            .Rai                        (Rai[EBRADRWIDTH-1:0]),
            .Wai                        (Wai[EBRADRWIDTH-1:0]),
            .clk                        (clk),
            .iwe                        (iwe));
   
         m_ebr_w8 #(.EBRADRWIDTH(EBRADRWIDTH),
                    .prg0(ph0), .prg1(ph1), .prg2(ph2), .prg3(ph3))
         ebrh
           (// Outputs
            .DAT_O                      (DAT_O[15:8]),
            // Inputs
            .B                          (B[15:8]),
            .bmask                      (bmask[1]),
            /*AUTOINST*/
            // Inputs
            .Rai                        (Rai[EBRADRWIDTH-1:0]),
            .Wai                        (Wai[EBRADRWIDTH-1:0]),
            .clk                        (clk),
            .iwe                        (iwe));
      end
   endgenerate
endmodule


/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * EBR program memory is split into 8-bit wide memory specified here.
 */
module m_ebr_w8
  # ( parameter EBRADRWIDTH = 9,
      parameter [4095:0] prg0 = 4096'h0,
      parameter [4095:0] prg1 = 4096'h0,
      parameter [4095:0] prg2 = 4096'h0,
      parameter [4095:0] prg3 = 4096'h0
      )
   (
    input [7:0]             B, //     Output from ALU
    input [EBRADRWIDTH-1:0] Rai, //   Read address
    input [EBRADRWIDTH-1:0] Wai, //   Write address
    input                   clk, //   System clock
    input                   bmask, // Byte mask for write, active LUW
    input                   iwe, //   Write enable
    output [7:0]            DAT_O //  Registered output
    );
   wire                     we = ~bmask & iwe;
   
   localparam NrRamsHere = (1<<(EBRADRWIDTH-9));

   generate

      if ( NrRamsHere == 1 ) begin
         /* verilator lint_off UNUSED */
         wire [7:0] dum8;
         /* verilator lint_on UNUSED */

         SB_RAM40_4K 
           #(
             .INIT_F({prg0[4095],prg0[4087],prg0[4094],prg0[4086],prg0[4093],prg0[4085],prg0[4092],prg0[4084],
                      prg0[4091],prg0[4083],prg0[4090],prg0[4082],prg0[4089],prg0[4081],prg0[4088],prg0[4080],
                      prg0[4079],prg0[4071],prg0[4078],prg0[4070],prg0[4077],prg0[4069],prg0[4076],prg0[4068],
                      prg0[4075],prg0[4067],prg0[4074],prg0[4066],prg0[4073],prg0[4065],prg0[4072],prg0[4064],
                      prg0[4063],prg0[4055],prg0[4062],prg0[4054],prg0[4061],prg0[4053],prg0[4060],prg0[4052],
                      prg0[4059],prg0[4051],prg0[4058],prg0[4050],prg0[4057],prg0[4049],prg0[4056],prg0[4048],
                      prg0[4047],prg0[4039],prg0[4046],prg0[4038],prg0[4045],prg0[4037],prg0[4044],prg0[4036],
                      prg0[4043],prg0[4035],prg0[4042],prg0[4034],prg0[4041],prg0[4033],prg0[4040],prg0[4032],
                      prg0[4031],prg0[4023],prg0[4030],prg0[4022],prg0[4029],prg0[4021],prg0[4028],prg0[4020],
                      prg0[4027],prg0[4019],prg0[4026],prg0[4018],prg0[4025],prg0[4017],prg0[4024],prg0[4016],
                      prg0[4015],prg0[4007],prg0[4014],prg0[4006],prg0[4013],prg0[4005],prg0[4012],prg0[4004],
                      prg0[4011],prg0[4003],prg0[4010],prg0[4002],prg0[4009],prg0[4001],prg0[4008],prg0[4000],
                      prg0[3999],prg0[3991],prg0[3998],prg0[3990],prg0[3997],prg0[3989],prg0[3996],prg0[3988],
                      prg0[3995],prg0[3987],prg0[3994],prg0[3986],prg0[3993],prg0[3985],prg0[3992],prg0[3984],
                      prg0[3983],prg0[3975],prg0[3982],prg0[3974],prg0[3981],prg0[3973],prg0[3980],prg0[3972],
                      prg0[3979],prg0[3971],prg0[3978],prg0[3970],prg0[3977],prg0[3969],prg0[3976],prg0[3968],
                      prg0[3967],prg0[3959],prg0[3966],prg0[3958],prg0[3965],prg0[3957],prg0[3964],prg0[3956],
                      prg0[3963],prg0[3955],prg0[3962],prg0[3954],prg0[3961],prg0[3953],prg0[3960],prg0[3952],
                      prg0[3951],prg0[3943],prg0[3950],prg0[3942],prg0[3949],prg0[3941],prg0[3948],prg0[3940],
                      prg0[3947],prg0[3939],prg0[3946],prg0[3938],prg0[3945],prg0[3937],prg0[3944],prg0[3936],
                      prg0[3935],prg0[3927],prg0[3934],prg0[3926],prg0[3933],prg0[3925],prg0[3932],prg0[3924],
                      prg0[3931],prg0[3923],prg0[3930],prg0[3922],prg0[3929],prg0[3921],prg0[3928],prg0[3920],
                      prg0[3919],prg0[3911],prg0[3918],prg0[3910],prg0[3917],prg0[3909],prg0[3916],prg0[3908],
                      prg0[3915],prg0[3907],prg0[3914],prg0[3906],prg0[3913],prg0[3905],prg0[3912],prg0[3904],
                      prg0[3903],prg0[3895],prg0[3902],prg0[3894],prg0[3901],prg0[3893],prg0[3900],prg0[3892],
                      prg0[3899],prg0[3891],prg0[3898],prg0[3890],prg0[3897],prg0[3889],prg0[3896],prg0[3888],
                      prg0[3887],prg0[3879],prg0[3886],prg0[3878],prg0[3885],prg0[3877],prg0[3884],prg0[3876],
                      prg0[3883],prg0[3875],prg0[3882],prg0[3874],prg0[3881],prg0[3873],prg0[3880],prg0[3872],
                      prg0[3871],prg0[3863],prg0[3870],prg0[3862],prg0[3869],prg0[3861],prg0[3868],prg0[3860],
                      prg0[3867],prg0[3859],prg0[3866],prg0[3858],prg0[3865],prg0[3857],prg0[3864],prg0[3856],
                      prg0[3855],prg0[3847],prg0[3854],prg0[3846],prg0[3853],prg0[3845],prg0[3852],prg0[3844],
                      prg0[3851],prg0[3843],prg0[3850],prg0[3842],prg0[3849],prg0[3841],prg0[3848],prg0[3840]}),
             .INIT_E({prg0[3839],prg0[3831],prg0[3838],prg0[3830],prg0[3837],prg0[3829],prg0[3836],prg0[3828],
                      prg0[3835],prg0[3827],prg0[3834],prg0[3826],prg0[3833],prg0[3825],prg0[3832],prg0[3824],
                      prg0[3823],prg0[3815],prg0[3822],prg0[3814],prg0[3821],prg0[3813],prg0[3820],prg0[3812],
                      prg0[3819],prg0[3811],prg0[3818],prg0[3810],prg0[3817],prg0[3809],prg0[3816],prg0[3808],
                      prg0[3807],prg0[3799],prg0[3806],prg0[3798],prg0[3805],prg0[3797],prg0[3804],prg0[3796],
                      prg0[3803],prg0[3795],prg0[3802],prg0[3794],prg0[3801],prg0[3793],prg0[3800],prg0[3792],
                      prg0[3791],prg0[3783],prg0[3790],prg0[3782],prg0[3789],prg0[3781],prg0[3788],prg0[3780],
                      prg0[3787],prg0[3779],prg0[3786],prg0[3778],prg0[3785],prg0[3777],prg0[3784],prg0[3776],
                      prg0[3775],prg0[3767],prg0[3774],prg0[3766],prg0[3773],prg0[3765],prg0[3772],prg0[3764],
                      prg0[3771],prg0[3763],prg0[3770],prg0[3762],prg0[3769],prg0[3761],prg0[3768],prg0[3760],
                      prg0[3759],prg0[3751],prg0[3758],prg0[3750],prg0[3757],prg0[3749],prg0[3756],prg0[3748],
                      prg0[3755],prg0[3747],prg0[3754],prg0[3746],prg0[3753],prg0[3745],prg0[3752],prg0[3744],
                      prg0[3743],prg0[3735],prg0[3742],prg0[3734],prg0[3741],prg0[3733],prg0[3740],prg0[3732],
                      prg0[3739],prg0[3731],prg0[3738],prg0[3730],prg0[3737],prg0[3729],prg0[3736],prg0[3728],
                      prg0[3727],prg0[3719],prg0[3726],prg0[3718],prg0[3725],prg0[3717],prg0[3724],prg0[3716],
                      prg0[3723],prg0[3715],prg0[3722],prg0[3714],prg0[3721],prg0[3713],prg0[3720],prg0[3712],
                      prg0[3711],prg0[3703],prg0[3710],prg0[3702],prg0[3709],prg0[3701],prg0[3708],prg0[3700],
                      prg0[3707],prg0[3699],prg0[3706],prg0[3698],prg0[3705],prg0[3697],prg0[3704],prg0[3696],
                      prg0[3695],prg0[3687],prg0[3694],prg0[3686],prg0[3693],prg0[3685],prg0[3692],prg0[3684],
                      prg0[3691],prg0[3683],prg0[3690],prg0[3682],prg0[3689],prg0[3681],prg0[3688],prg0[3680],
                      prg0[3679],prg0[3671],prg0[3678],prg0[3670],prg0[3677],prg0[3669],prg0[3676],prg0[3668],
                      prg0[3675],prg0[3667],prg0[3674],prg0[3666],prg0[3673],prg0[3665],prg0[3672],prg0[3664],
                      prg0[3663],prg0[3655],prg0[3662],prg0[3654],prg0[3661],prg0[3653],prg0[3660],prg0[3652],
                      prg0[3659],prg0[3651],prg0[3658],prg0[3650],prg0[3657],prg0[3649],prg0[3656],prg0[3648],
                      prg0[3647],prg0[3639],prg0[3646],prg0[3638],prg0[3645],prg0[3637],prg0[3644],prg0[3636],
                      prg0[3643],prg0[3635],prg0[3642],prg0[3634],prg0[3641],prg0[3633],prg0[3640],prg0[3632],
                      prg0[3631],prg0[3623],prg0[3630],prg0[3622],prg0[3629],prg0[3621],prg0[3628],prg0[3620],
                      prg0[3627],prg0[3619],prg0[3626],prg0[3618],prg0[3625],prg0[3617],prg0[3624],prg0[3616],
                      prg0[3615],prg0[3607],prg0[3614],prg0[3606],prg0[3613],prg0[3605],prg0[3612],prg0[3604],
                      prg0[3611],prg0[3603],prg0[3610],prg0[3602],prg0[3609],prg0[3601],prg0[3608],prg0[3600],
                      prg0[3599],prg0[3591],prg0[3598],prg0[3590],prg0[3597],prg0[3589],prg0[3596],prg0[3588],
                      prg0[3595],prg0[3587],prg0[3594],prg0[3586],prg0[3593],prg0[3585],prg0[3592],prg0[3584]}),
             .INIT_D({prg0[3583],prg0[3575],prg0[3582],prg0[3574],prg0[3581],prg0[3573],prg0[3580],prg0[3572],
                      prg0[3579],prg0[3571],prg0[3578],prg0[3570],prg0[3577],prg0[3569],prg0[3576],prg0[3568],
                      prg0[3567],prg0[3559],prg0[3566],prg0[3558],prg0[3565],prg0[3557],prg0[3564],prg0[3556],
                      prg0[3563],prg0[3555],prg0[3562],prg0[3554],prg0[3561],prg0[3553],prg0[3560],prg0[3552],
                      prg0[3551],prg0[3543],prg0[3550],prg0[3542],prg0[3549],prg0[3541],prg0[3548],prg0[3540],
                      prg0[3547],prg0[3539],prg0[3546],prg0[3538],prg0[3545],prg0[3537],prg0[3544],prg0[3536],
                      prg0[3535],prg0[3527],prg0[3534],prg0[3526],prg0[3533],prg0[3525],prg0[3532],prg0[3524],
                      prg0[3531],prg0[3523],prg0[3530],prg0[3522],prg0[3529],prg0[3521],prg0[3528],prg0[3520],
                      prg0[3519],prg0[3511],prg0[3518],prg0[3510],prg0[3517],prg0[3509],prg0[3516],prg0[3508],
                      prg0[3515],prg0[3507],prg0[3514],prg0[3506],prg0[3513],prg0[3505],prg0[3512],prg0[3504],
                      prg0[3503],prg0[3495],prg0[3502],prg0[3494],prg0[3501],prg0[3493],prg0[3500],prg0[3492],
                      prg0[3499],prg0[3491],prg0[3498],prg0[3490],prg0[3497],prg0[3489],prg0[3496],prg0[3488],
                      prg0[3487],prg0[3479],prg0[3486],prg0[3478],prg0[3485],prg0[3477],prg0[3484],prg0[3476],
                      prg0[3483],prg0[3475],prg0[3482],prg0[3474],prg0[3481],prg0[3473],prg0[3480],prg0[3472],
                      prg0[3471],prg0[3463],prg0[3470],prg0[3462],prg0[3469],prg0[3461],prg0[3468],prg0[3460],
                      prg0[3467],prg0[3459],prg0[3466],prg0[3458],prg0[3465],prg0[3457],prg0[3464],prg0[3456],
                      prg0[3455],prg0[3447],prg0[3454],prg0[3446],prg0[3453],prg0[3445],prg0[3452],prg0[3444],
                      prg0[3451],prg0[3443],prg0[3450],prg0[3442],prg0[3449],prg0[3441],prg0[3448],prg0[3440],
                      prg0[3439],prg0[3431],prg0[3438],prg0[3430],prg0[3437],prg0[3429],prg0[3436],prg0[3428],
                      prg0[3435],prg0[3427],prg0[3434],prg0[3426],prg0[3433],prg0[3425],prg0[3432],prg0[3424],
                      prg0[3423],prg0[3415],prg0[3422],prg0[3414],prg0[3421],prg0[3413],prg0[3420],prg0[3412],
                      prg0[3419],prg0[3411],prg0[3418],prg0[3410],prg0[3417],prg0[3409],prg0[3416],prg0[3408],
                      prg0[3407],prg0[3399],prg0[3406],prg0[3398],prg0[3405],prg0[3397],prg0[3404],prg0[3396],
                      prg0[3403],prg0[3395],prg0[3402],prg0[3394],prg0[3401],prg0[3393],prg0[3400],prg0[3392],
                      prg0[3391],prg0[3383],prg0[3390],prg0[3382],prg0[3389],prg0[3381],prg0[3388],prg0[3380],
                      prg0[3387],prg0[3379],prg0[3386],prg0[3378],prg0[3385],prg0[3377],prg0[3384],prg0[3376],
                      prg0[3375],prg0[3367],prg0[3374],prg0[3366],prg0[3373],prg0[3365],prg0[3372],prg0[3364],
                      prg0[3371],prg0[3363],prg0[3370],prg0[3362],prg0[3369],prg0[3361],prg0[3368],prg0[3360],
                      prg0[3359],prg0[3351],prg0[3358],prg0[3350],prg0[3357],prg0[3349],prg0[3356],prg0[3348],
                      prg0[3355],prg0[3347],prg0[3354],prg0[3346],prg0[3353],prg0[3345],prg0[3352],prg0[3344],
                      prg0[3343],prg0[3335],prg0[3342],prg0[3334],prg0[3341],prg0[3333],prg0[3340],prg0[3332],
                      prg0[3339],prg0[3331],prg0[3338],prg0[3330],prg0[3337],prg0[3329],prg0[3336],prg0[3328]}),
             .INIT_C({prg0[3327],prg0[3319],prg0[3326],prg0[3318],prg0[3325],prg0[3317],prg0[3324],prg0[3316],
                      prg0[3323],prg0[3315],prg0[3322],prg0[3314],prg0[3321],prg0[3313],prg0[3320],prg0[3312],
                      prg0[3311],prg0[3303],prg0[3310],prg0[3302],prg0[3309],prg0[3301],prg0[3308],prg0[3300],
                      prg0[3307],prg0[3299],prg0[3306],prg0[3298],prg0[3305],prg0[3297],prg0[3304],prg0[3296],
                      prg0[3295],prg0[3287],prg0[3294],prg0[3286],prg0[3293],prg0[3285],prg0[3292],prg0[3284],
                      prg0[3291],prg0[3283],prg0[3290],prg0[3282],prg0[3289],prg0[3281],prg0[3288],prg0[3280],
                      prg0[3279],prg0[3271],prg0[3278],prg0[3270],prg0[3277],prg0[3269],prg0[3276],prg0[3268],
                      prg0[3275],prg0[3267],prg0[3274],prg0[3266],prg0[3273],prg0[3265],prg0[3272],prg0[3264],
                      prg0[3263],prg0[3255],prg0[3262],prg0[3254],prg0[3261],prg0[3253],prg0[3260],prg0[3252],
                      prg0[3259],prg0[3251],prg0[3258],prg0[3250],prg0[3257],prg0[3249],prg0[3256],prg0[3248],
                      prg0[3247],prg0[3239],prg0[3246],prg0[3238],prg0[3245],prg0[3237],prg0[3244],prg0[3236],
                      prg0[3243],prg0[3235],prg0[3242],prg0[3234],prg0[3241],prg0[3233],prg0[3240],prg0[3232],
                      prg0[3231],prg0[3223],prg0[3230],prg0[3222],prg0[3229],prg0[3221],prg0[3228],prg0[3220],
                      prg0[3227],prg0[3219],prg0[3226],prg0[3218],prg0[3225],prg0[3217],prg0[3224],prg0[3216],
                      prg0[3215],prg0[3207],prg0[3214],prg0[3206],prg0[3213],prg0[3205],prg0[3212],prg0[3204],
                      prg0[3211],prg0[3203],prg0[3210],prg0[3202],prg0[3209],prg0[3201],prg0[3208],prg0[3200],
                      prg0[3199],prg0[3191],prg0[3198],prg0[3190],prg0[3197],prg0[3189],prg0[3196],prg0[3188],
                      prg0[3195],prg0[3187],prg0[3194],prg0[3186],prg0[3193],prg0[3185],prg0[3192],prg0[3184],
                      prg0[3183],prg0[3175],prg0[3182],prg0[3174],prg0[3181],prg0[3173],prg0[3180],prg0[3172],
                      prg0[3179],prg0[3171],prg0[3178],prg0[3170],prg0[3177],prg0[3169],prg0[3176],prg0[3168],
                      prg0[3167],prg0[3159],prg0[3166],prg0[3158],prg0[3165],prg0[3157],prg0[3164],prg0[3156],
                      prg0[3163],prg0[3155],prg0[3162],prg0[3154],prg0[3161],prg0[3153],prg0[3160],prg0[3152],
                      prg0[3151],prg0[3143],prg0[3150],prg0[3142],prg0[3149],prg0[3141],prg0[3148],prg0[3140],
                      prg0[3147],prg0[3139],prg0[3146],prg0[3138],prg0[3145],prg0[3137],prg0[3144],prg0[3136],
                      prg0[3135],prg0[3127],prg0[3134],prg0[3126],prg0[3133],prg0[3125],prg0[3132],prg0[3124],
                      prg0[3131],prg0[3123],prg0[3130],prg0[3122],prg0[3129],prg0[3121],prg0[3128],prg0[3120],
                      prg0[3119],prg0[3111],prg0[3118],prg0[3110],prg0[3117],prg0[3109],prg0[3116],prg0[3108],
                      prg0[3115],prg0[3107],prg0[3114],prg0[3106],prg0[3113],prg0[3105],prg0[3112],prg0[3104],
                      prg0[3103],prg0[3095],prg0[3102],prg0[3094],prg0[3101],prg0[3093],prg0[3100],prg0[3092],
                      prg0[3099],prg0[3091],prg0[3098],prg0[3090],prg0[3097],prg0[3089],prg0[3096],prg0[3088],
                      prg0[3087],prg0[3079],prg0[3086],prg0[3078],prg0[3085],prg0[3077],prg0[3084],prg0[3076],
                      prg0[3083],prg0[3075],prg0[3082],prg0[3074],prg0[3081],prg0[3073],prg0[3080],prg0[3072]}),
             .INIT_B({prg0[3071],prg0[3063],prg0[3070],prg0[3062],prg0[3069],prg0[3061],prg0[3068],prg0[3060],
                      prg0[3067],prg0[3059],prg0[3066],prg0[3058],prg0[3065],prg0[3057],prg0[3064],prg0[3056],
                      prg0[3055],prg0[3047],prg0[3054],prg0[3046],prg0[3053],prg0[3045],prg0[3052],prg0[3044],
                      prg0[3051],prg0[3043],prg0[3050],prg0[3042],prg0[3049],prg0[3041],prg0[3048],prg0[3040],
                      prg0[3039],prg0[3031],prg0[3038],prg0[3030],prg0[3037],prg0[3029],prg0[3036],prg0[3028],
                      prg0[3035],prg0[3027],prg0[3034],prg0[3026],prg0[3033],prg0[3025],prg0[3032],prg0[3024],
                      prg0[3023],prg0[3015],prg0[3022],prg0[3014],prg0[3021],prg0[3013],prg0[3020],prg0[3012],
                      prg0[3019],prg0[3011],prg0[3018],prg0[3010],prg0[3017],prg0[3009],prg0[3016],prg0[3008],
                      prg0[3007],prg0[2999],prg0[3006],prg0[2998],prg0[3005],prg0[2997],prg0[3004],prg0[2996],
                      prg0[3003],prg0[2995],prg0[3002],prg0[2994],prg0[3001],prg0[2993],prg0[3000],prg0[2992],
                      prg0[2991],prg0[2983],prg0[2990],prg0[2982],prg0[2989],prg0[2981],prg0[2988],prg0[2980],
                      prg0[2987],prg0[2979],prg0[2986],prg0[2978],prg0[2985],prg0[2977],prg0[2984],prg0[2976],
                      prg0[2975],prg0[2967],prg0[2974],prg0[2966],prg0[2973],prg0[2965],prg0[2972],prg0[2964],
                      prg0[2971],prg0[2963],prg0[2970],prg0[2962],prg0[2969],prg0[2961],prg0[2968],prg0[2960],
                      prg0[2959],prg0[2951],prg0[2958],prg0[2950],prg0[2957],prg0[2949],prg0[2956],prg0[2948],
                      prg0[2955],prg0[2947],prg0[2954],prg0[2946],prg0[2953],prg0[2945],prg0[2952],prg0[2944],
                      prg0[2943],prg0[2935],prg0[2942],prg0[2934],prg0[2941],prg0[2933],prg0[2940],prg0[2932],
                      prg0[2939],prg0[2931],prg0[2938],prg0[2930],prg0[2937],prg0[2929],prg0[2936],prg0[2928],
                      prg0[2927],prg0[2919],prg0[2926],prg0[2918],prg0[2925],prg0[2917],prg0[2924],prg0[2916],
                      prg0[2923],prg0[2915],prg0[2922],prg0[2914],prg0[2921],prg0[2913],prg0[2920],prg0[2912],
                      prg0[2911],prg0[2903],prg0[2910],prg0[2902],prg0[2909],prg0[2901],prg0[2908],prg0[2900],
                      prg0[2907],prg0[2899],prg0[2906],prg0[2898],prg0[2905],prg0[2897],prg0[2904],prg0[2896],
                      prg0[2895],prg0[2887],prg0[2894],prg0[2886],prg0[2893],prg0[2885],prg0[2892],prg0[2884],
                      prg0[2891],prg0[2883],prg0[2890],prg0[2882],prg0[2889],prg0[2881],prg0[2888],prg0[2880],
                      prg0[2879],prg0[2871],prg0[2878],prg0[2870],prg0[2877],prg0[2869],prg0[2876],prg0[2868],
                      prg0[2875],prg0[2867],prg0[2874],prg0[2866],prg0[2873],prg0[2865],prg0[2872],prg0[2864],
                      prg0[2863],prg0[2855],prg0[2862],prg0[2854],prg0[2861],prg0[2853],prg0[2860],prg0[2852],
                      prg0[2859],prg0[2851],prg0[2858],prg0[2850],prg0[2857],prg0[2849],prg0[2856],prg0[2848],
                      prg0[2847],prg0[2839],prg0[2846],prg0[2838],prg0[2845],prg0[2837],prg0[2844],prg0[2836],
                      prg0[2843],prg0[2835],prg0[2842],prg0[2834],prg0[2841],prg0[2833],prg0[2840],prg0[2832],
                      prg0[2831],prg0[2823],prg0[2830],prg0[2822],prg0[2829],prg0[2821],prg0[2828],prg0[2820],
                      prg0[2827],prg0[2819],prg0[2826],prg0[2818],prg0[2825],prg0[2817],prg0[2824],prg0[2816]}),
             .INIT_A({prg0[2815],prg0[2807],prg0[2814],prg0[2806],prg0[2813],prg0[2805],prg0[2812],prg0[2804],
                      prg0[2811],prg0[2803],prg0[2810],prg0[2802],prg0[2809],prg0[2801],prg0[2808],prg0[2800],
                      prg0[2799],prg0[2791],prg0[2798],prg0[2790],prg0[2797],prg0[2789],prg0[2796],prg0[2788],
                      prg0[2795],prg0[2787],prg0[2794],prg0[2786],prg0[2793],prg0[2785],prg0[2792],prg0[2784],
                      prg0[2783],prg0[2775],prg0[2782],prg0[2774],prg0[2781],prg0[2773],prg0[2780],prg0[2772],
                      prg0[2779],prg0[2771],prg0[2778],prg0[2770],prg0[2777],prg0[2769],prg0[2776],prg0[2768],
                      prg0[2767],prg0[2759],prg0[2766],prg0[2758],prg0[2765],prg0[2757],prg0[2764],prg0[2756],
                      prg0[2763],prg0[2755],prg0[2762],prg0[2754],prg0[2761],prg0[2753],prg0[2760],prg0[2752],
                      prg0[2751],prg0[2743],prg0[2750],prg0[2742],prg0[2749],prg0[2741],prg0[2748],prg0[2740],
                      prg0[2747],prg0[2739],prg0[2746],prg0[2738],prg0[2745],prg0[2737],prg0[2744],prg0[2736],
                      prg0[2735],prg0[2727],prg0[2734],prg0[2726],prg0[2733],prg0[2725],prg0[2732],prg0[2724],
                      prg0[2731],prg0[2723],prg0[2730],prg0[2722],prg0[2729],prg0[2721],prg0[2728],prg0[2720],
                      prg0[2719],prg0[2711],prg0[2718],prg0[2710],prg0[2717],prg0[2709],prg0[2716],prg0[2708],
                      prg0[2715],prg0[2707],prg0[2714],prg0[2706],prg0[2713],prg0[2705],prg0[2712],prg0[2704],
                      prg0[2703],prg0[2695],prg0[2702],prg0[2694],prg0[2701],prg0[2693],prg0[2700],prg0[2692],
                      prg0[2699],prg0[2691],prg0[2698],prg0[2690],prg0[2697],prg0[2689],prg0[2696],prg0[2688],
                      prg0[2687],prg0[2679],prg0[2686],prg0[2678],prg0[2685],prg0[2677],prg0[2684],prg0[2676],
                      prg0[2683],prg0[2675],prg0[2682],prg0[2674],prg0[2681],prg0[2673],prg0[2680],prg0[2672],
                      prg0[2671],prg0[2663],prg0[2670],prg0[2662],prg0[2669],prg0[2661],prg0[2668],prg0[2660],
                      prg0[2667],prg0[2659],prg0[2666],prg0[2658],prg0[2665],prg0[2657],prg0[2664],prg0[2656],
                      prg0[2655],prg0[2647],prg0[2654],prg0[2646],prg0[2653],prg0[2645],prg0[2652],prg0[2644],
                      prg0[2651],prg0[2643],prg0[2650],prg0[2642],prg0[2649],prg0[2641],prg0[2648],prg0[2640],
                      prg0[2639],prg0[2631],prg0[2638],prg0[2630],prg0[2637],prg0[2629],prg0[2636],prg0[2628],
                      prg0[2635],prg0[2627],prg0[2634],prg0[2626],prg0[2633],prg0[2625],prg0[2632],prg0[2624],
                      prg0[2623],prg0[2615],prg0[2622],prg0[2614],prg0[2621],prg0[2613],prg0[2620],prg0[2612],
                      prg0[2619],prg0[2611],prg0[2618],prg0[2610],prg0[2617],prg0[2609],prg0[2616],prg0[2608],
                      prg0[2607],prg0[2599],prg0[2606],prg0[2598],prg0[2605],prg0[2597],prg0[2604],prg0[2596],
                      prg0[2603],prg0[2595],prg0[2602],prg0[2594],prg0[2601],prg0[2593],prg0[2600],prg0[2592],
                      prg0[2591],prg0[2583],prg0[2590],prg0[2582],prg0[2589],prg0[2581],prg0[2588],prg0[2580],
                      prg0[2587],prg0[2579],prg0[2586],prg0[2578],prg0[2585],prg0[2577],prg0[2584],prg0[2576],
                      prg0[2575],prg0[2567],prg0[2574],prg0[2566],prg0[2573],prg0[2565],prg0[2572],prg0[2564],
                      prg0[2571],prg0[2563],prg0[2570],prg0[2562],prg0[2569],prg0[2561],prg0[2568],prg0[2560]}),
             .INIT_9({prg0[2559],prg0[2551],prg0[2558],prg0[2550],prg0[2557],prg0[2549],prg0[2556],prg0[2548],
                      prg0[2555],prg0[2547],prg0[2554],prg0[2546],prg0[2553],prg0[2545],prg0[2552],prg0[2544],
                      prg0[2543],prg0[2535],prg0[2542],prg0[2534],prg0[2541],prg0[2533],prg0[2540],prg0[2532],
                      prg0[2539],prg0[2531],prg0[2538],prg0[2530],prg0[2537],prg0[2529],prg0[2536],prg0[2528],
                      prg0[2527],prg0[2519],prg0[2526],prg0[2518],prg0[2525],prg0[2517],prg0[2524],prg0[2516],
                      prg0[2523],prg0[2515],prg0[2522],prg0[2514],prg0[2521],prg0[2513],prg0[2520],prg0[2512],
                      prg0[2511],prg0[2503],prg0[2510],prg0[2502],prg0[2509],prg0[2501],prg0[2508],prg0[2500],
                      prg0[2507],prg0[2499],prg0[2506],prg0[2498],prg0[2505],prg0[2497],prg0[2504],prg0[2496],
                      prg0[2495],prg0[2487],prg0[2494],prg0[2486],prg0[2493],prg0[2485],prg0[2492],prg0[2484],
                      prg0[2491],prg0[2483],prg0[2490],prg0[2482],prg0[2489],prg0[2481],prg0[2488],prg0[2480],
                      prg0[2479],prg0[2471],prg0[2478],prg0[2470],prg0[2477],prg0[2469],prg0[2476],prg0[2468],
                      prg0[2475],prg0[2467],prg0[2474],prg0[2466],prg0[2473],prg0[2465],prg0[2472],prg0[2464],
                      prg0[2463],prg0[2455],prg0[2462],prg0[2454],prg0[2461],prg0[2453],prg0[2460],prg0[2452],
                      prg0[2459],prg0[2451],prg0[2458],prg0[2450],prg0[2457],prg0[2449],prg0[2456],prg0[2448],
                      prg0[2447],prg0[2439],prg0[2446],prg0[2438],prg0[2445],prg0[2437],prg0[2444],prg0[2436],
                      prg0[2443],prg0[2435],prg0[2442],prg0[2434],prg0[2441],prg0[2433],prg0[2440],prg0[2432],
                      prg0[2431],prg0[2423],prg0[2430],prg0[2422],prg0[2429],prg0[2421],prg0[2428],prg0[2420],
                      prg0[2427],prg0[2419],prg0[2426],prg0[2418],prg0[2425],prg0[2417],prg0[2424],prg0[2416],
                      prg0[2415],prg0[2407],prg0[2414],prg0[2406],prg0[2413],prg0[2405],prg0[2412],prg0[2404],
                      prg0[2411],prg0[2403],prg0[2410],prg0[2402],prg0[2409],prg0[2401],prg0[2408],prg0[2400],
                      prg0[2399],prg0[2391],prg0[2398],prg0[2390],prg0[2397],prg0[2389],prg0[2396],prg0[2388],
                      prg0[2395],prg0[2387],prg0[2394],prg0[2386],prg0[2393],prg0[2385],prg0[2392],prg0[2384],
                      prg0[2383],prg0[2375],prg0[2382],prg0[2374],prg0[2381],prg0[2373],prg0[2380],prg0[2372],
                      prg0[2379],prg0[2371],prg0[2378],prg0[2370],prg0[2377],prg0[2369],prg0[2376],prg0[2368],
                      prg0[2367],prg0[2359],prg0[2366],prg0[2358],prg0[2365],prg0[2357],prg0[2364],prg0[2356],
                      prg0[2363],prg0[2355],prg0[2362],prg0[2354],prg0[2361],prg0[2353],prg0[2360],prg0[2352],
                      prg0[2351],prg0[2343],prg0[2350],prg0[2342],prg0[2349],prg0[2341],prg0[2348],prg0[2340],
                      prg0[2347],prg0[2339],prg0[2346],prg0[2338],prg0[2345],prg0[2337],prg0[2344],prg0[2336],
                      prg0[2335],prg0[2327],prg0[2334],prg0[2326],prg0[2333],prg0[2325],prg0[2332],prg0[2324],
                      prg0[2331],prg0[2323],prg0[2330],prg0[2322],prg0[2329],prg0[2321],prg0[2328],prg0[2320],
                      prg0[2319],prg0[2311],prg0[2318],prg0[2310],prg0[2317],prg0[2309],prg0[2316],prg0[2308],
                      prg0[2315],prg0[2307],prg0[2314],prg0[2306],prg0[2313],prg0[2305],prg0[2312],prg0[2304]}),
             .INIT_8({prg0[2303],prg0[2295],prg0[2302],prg0[2294],prg0[2301],prg0[2293],prg0[2300],prg0[2292],
                      prg0[2299],prg0[2291],prg0[2298],prg0[2290],prg0[2297],prg0[2289],prg0[2296],prg0[2288],
                      prg0[2287],prg0[2279],prg0[2286],prg0[2278],prg0[2285],prg0[2277],prg0[2284],prg0[2276],
                      prg0[2283],prg0[2275],prg0[2282],prg0[2274],prg0[2281],prg0[2273],prg0[2280],prg0[2272],
                      prg0[2271],prg0[2263],prg0[2270],prg0[2262],prg0[2269],prg0[2261],prg0[2268],prg0[2260],
                      prg0[2267],prg0[2259],prg0[2266],prg0[2258],prg0[2265],prg0[2257],prg0[2264],prg0[2256],
                      prg0[2255],prg0[2247],prg0[2254],prg0[2246],prg0[2253],prg0[2245],prg0[2252],prg0[2244],
                      prg0[2251],prg0[2243],prg0[2250],prg0[2242],prg0[2249],prg0[2241],prg0[2248],prg0[2240],
                      prg0[2239],prg0[2231],prg0[2238],prg0[2230],prg0[2237],prg0[2229],prg0[2236],prg0[2228],
                      prg0[2235],prg0[2227],prg0[2234],prg0[2226],prg0[2233],prg0[2225],prg0[2232],prg0[2224],
                      prg0[2223],prg0[2215],prg0[2222],prg0[2214],prg0[2221],prg0[2213],prg0[2220],prg0[2212],
                      prg0[2219],prg0[2211],prg0[2218],prg0[2210],prg0[2217],prg0[2209],prg0[2216],prg0[2208],
                      prg0[2207],prg0[2199],prg0[2206],prg0[2198],prg0[2205],prg0[2197],prg0[2204],prg0[2196],
                      prg0[2203],prg0[2195],prg0[2202],prg0[2194],prg0[2201],prg0[2193],prg0[2200],prg0[2192],
                      prg0[2191],prg0[2183],prg0[2190],prg0[2182],prg0[2189],prg0[2181],prg0[2188],prg0[2180],
                      prg0[2187],prg0[2179],prg0[2186],prg0[2178],prg0[2185],prg0[2177],prg0[2184],prg0[2176],
                      prg0[2175],prg0[2167],prg0[2174],prg0[2166],prg0[2173],prg0[2165],prg0[2172],prg0[2164],
                      prg0[2171],prg0[2163],prg0[2170],prg0[2162],prg0[2169],prg0[2161],prg0[2168],prg0[2160],
                      prg0[2159],prg0[2151],prg0[2158],prg0[2150],prg0[2157],prg0[2149],prg0[2156],prg0[2148],
                      prg0[2155],prg0[2147],prg0[2154],prg0[2146],prg0[2153],prg0[2145],prg0[2152],prg0[2144],
                      prg0[2143],prg0[2135],prg0[2142],prg0[2134],prg0[2141],prg0[2133],prg0[2140],prg0[2132],
                      prg0[2139],prg0[2131],prg0[2138],prg0[2130],prg0[2137],prg0[2129],prg0[2136],prg0[2128],
                      prg0[2127],prg0[2119],prg0[2126],prg0[2118],prg0[2125],prg0[2117],prg0[2124],prg0[2116],
                      prg0[2123],prg0[2115],prg0[2122],prg0[2114],prg0[2121],prg0[2113],prg0[2120],prg0[2112],
                      prg0[2111],prg0[2103],prg0[2110],prg0[2102],prg0[2109],prg0[2101],prg0[2108],prg0[2100],
                      prg0[2107],prg0[2099],prg0[2106],prg0[2098],prg0[2105],prg0[2097],prg0[2104],prg0[2096],
                      prg0[2095],prg0[2087],prg0[2094],prg0[2086],prg0[2093],prg0[2085],prg0[2092],prg0[2084],
                      prg0[2091],prg0[2083],prg0[2090],prg0[2082],prg0[2089],prg0[2081],prg0[2088],prg0[2080],
                      prg0[2079],prg0[2071],prg0[2078],prg0[2070],prg0[2077],prg0[2069],prg0[2076],prg0[2068],
                      prg0[2075],prg0[2067],prg0[2074],prg0[2066],prg0[2073],prg0[2065],prg0[2072],prg0[2064],
                      prg0[2063],prg0[2055],prg0[2062],prg0[2054],prg0[2061],prg0[2053],prg0[2060],prg0[2052],
                      prg0[2059],prg0[2051],prg0[2058],prg0[2050],prg0[2057],prg0[2049],prg0[2056],prg0[2048]}),
             .INIT_7({prg0[2047],prg0[2039],prg0[2046],prg0[2038],prg0[2045],prg0[2037],prg0[2044],prg0[2036],
                      prg0[2043],prg0[2035],prg0[2042],prg0[2034],prg0[2041],prg0[2033],prg0[2040],prg0[2032],
                      prg0[2031],prg0[2023],prg0[2030],prg0[2022],prg0[2029],prg0[2021],prg0[2028],prg0[2020],
                      prg0[2027],prg0[2019],prg0[2026],prg0[2018],prg0[2025],prg0[2017],prg0[2024],prg0[2016],
                      prg0[2015],prg0[2007],prg0[2014],prg0[2006],prg0[2013],prg0[2005],prg0[2012],prg0[2004],
                      prg0[2011],prg0[2003],prg0[2010],prg0[2002],prg0[2009],prg0[2001],prg0[2008],prg0[2000],
                      prg0[1999],prg0[1991],prg0[1998],prg0[1990],prg0[1997],prg0[1989],prg0[1996],prg0[1988],
                      prg0[1995],prg0[1987],prg0[1994],prg0[1986],prg0[1993],prg0[1985],prg0[1992],prg0[1984],
                      prg0[1983],prg0[1975],prg0[1982],prg0[1974],prg0[1981],prg0[1973],prg0[1980],prg0[1972],
                      prg0[1979],prg0[1971],prg0[1978],prg0[1970],prg0[1977],prg0[1969],prg0[1976],prg0[1968],
                      prg0[1967],prg0[1959],prg0[1966],prg0[1958],prg0[1965],prg0[1957],prg0[1964],prg0[1956],
                      prg0[1963],prg0[1955],prg0[1962],prg0[1954],prg0[1961],prg0[1953],prg0[1960],prg0[1952],
                      prg0[1951],prg0[1943],prg0[1950],prg0[1942],prg0[1949],prg0[1941],prg0[1948],prg0[1940],
                      prg0[1947],prg0[1939],prg0[1946],prg0[1938],prg0[1945],prg0[1937],prg0[1944],prg0[1936],
                      prg0[1935],prg0[1927],prg0[1934],prg0[1926],prg0[1933],prg0[1925],prg0[1932],prg0[1924],
                      prg0[1931],prg0[1923],prg0[1930],prg0[1922],prg0[1929],prg0[1921],prg0[1928],prg0[1920],
                      prg0[1919],prg0[1911],prg0[1918],prg0[1910],prg0[1917],prg0[1909],prg0[1916],prg0[1908],
                      prg0[1915],prg0[1907],prg0[1914],prg0[1906],prg0[1913],prg0[1905],prg0[1912],prg0[1904],
                      prg0[1903],prg0[1895],prg0[1902],prg0[1894],prg0[1901],prg0[1893],prg0[1900],prg0[1892],
                      prg0[1899],prg0[1891],prg0[1898],prg0[1890],prg0[1897],prg0[1889],prg0[1896],prg0[1888],
                      prg0[1887],prg0[1879],prg0[1886],prg0[1878],prg0[1885],prg0[1877],prg0[1884],prg0[1876],
                      prg0[1883],prg0[1875],prg0[1882],prg0[1874],prg0[1881],prg0[1873],prg0[1880],prg0[1872],
                      prg0[1871],prg0[1863],prg0[1870],prg0[1862],prg0[1869],prg0[1861],prg0[1868],prg0[1860],
                      prg0[1867],prg0[1859],prg0[1866],prg0[1858],prg0[1865],prg0[1857],prg0[1864],prg0[1856],
                      prg0[1855],prg0[1847],prg0[1854],prg0[1846],prg0[1853],prg0[1845],prg0[1852],prg0[1844],
                      prg0[1851],prg0[1843],prg0[1850],prg0[1842],prg0[1849],prg0[1841],prg0[1848],prg0[1840],
                      prg0[1839],prg0[1831],prg0[1838],prg0[1830],prg0[1837],prg0[1829],prg0[1836],prg0[1828],
                      prg0[1835],prg0[1827],prg0[1834],prg0[1826],prg0[1833],prg0[1825],prg0[1832],prg0[1824],
                      prg0[1823],prg0[1815],prg0[1822],prg0[1814],prg0[1821],prg0[1813],prg0[1820],prg0[1812],
                      prg0[1819],prg0[1811],prg0[1818],prg0[1810],prg0[1817],prg0[1809],prg0[1816],prg0[1808],
                      prg0[1807],prg0[1799],prg0[1806],prg0[1798],prg0[1805],prg0[1797],prg0[1804],prg0[1796],
                      prg0[1803],prg0[1795],prg0[1802],prg0[1794],prg0[1801],prg0[1793],prg0[1800],prg0[1792]}),
             .INIT_6({prg0[1791],prg0[1783],prg0[1790],prg0[1782],prg0[1789],prg0[1781],prg0[1788],prg0[1780],
                      prg0[1787],prg0[1779],prg0[1786],prg0[1778],prg0[1785],prg0[1777],prg0[1784],prg0[1776],
                      prg0[1775],prg0[1767],prg0[1774],prg0[1766],prg0[1773],prg0[1765],prg0[1772],prg0[1764],
                      prg0[1771],prg0[1763],prg0[1770],prg0[1762],prg0[1769],prg0[1761],prg0[1768],prg0[1760],
                      prg0[1759],prg0[1751],prg0[1758],prg0[1750],prg0[1757],prg0[1749],prg0[1756],prg0[1748],
                      prg0[1755],prg0[1747],prg0[1754],prg0[1746],prg0[1753],prg0[1745],prg0[1752],prg0[1744],
                      prg0[1743],prg0[1735],prg0[1742],prg0[1734],prg0[1741],prg0[1733],prg0[1740],prg0[1732],
                      prg0[1739],prg0[1731],prg0[1738],prg0[1730],prg0[1737],prg0[1729],prg0[1736],prg0[1728],
                      prg0[1727],prg0[1719],prg0[1726],prg0[1718],prg0[1725],prg0[1717],prg0[1724],prg0[1716],
                      prg0[1723],prg0[1715],prg0[1722],prg0[1714],prg0[1721],prg0[1713],prg0[1720],prg0[1712],
                      prg0[1711],prg0[1703],prg0[1710],prg0[1702],prg0[1709],prg0[1701],prg0[1708],prg0[1700],
                      prg0[1707],prg0[1699],prg0[1706],prg0[1698],prg0[1705],prg0[1697],prg0[1704],prg0[1696],
                      prg0[1695],prg0[1687],prg0[1694],prg0[1686],prg0[1693],prg0[1685],prg0[1692],prg0[1684],
                      prg0[1691],prg0[1683],prg0[1690],prg0[1682],prg0[1689],prg0[1681],prg0[1688],prg0[1680],
                      prg0[1679],prg0[1671],prg0[1678],prg0[1670],prg0[1677],prg0[1669],prg0[1676],prg0[1668],
                      prg0[1675],prg0[1667],prg0[1674],prg0[1666],prg0[1673],prg0[1665],prg0[1672],prg0[1664],
                      prg0[1663],prg0[1655],prg0[1662],prg0[1654],prg0[1661],prg0[1653],prg0[1660],prg0[1652],
                      prg0[1659],prg0[1651],prg0[1658],prg0[1650],prg0[1657],prg0[1649],prg0[1656],prg0[1648],
                      prg0[1647],prg0[1639],prg0[1646],prg0[1638],prg0[1645],prg0[1637],prg0[1644],prg0[1636],
                      prg0[1643],prg0[1635],prg0[1642],prg0[1634],prg0[1641],prg0[1633],prg0[1640],prg0[1632],
                      prg0[1631],prg0[1623],prg0[1630],prg0[1622],prg0[1629],prg0[1621],prg0[1628],prg0[1620],
                      prg0[1627],prg0[1619],prg0[1626],prg0[1618],prg0[1625],prg0[1617],prg0[1624],prg0[1616],
                      prg0[1615],prg0[1607],prg0[1614],prg0[1606],prg0[1613],prg0[1605],prg0[1612],prg0[1604],
                      prg0[1611],prg0[1603],prg0[1610],prg0[1602],prg0[1609],prg0[1601],prg0[1608],prg0[1600],
                      prg0[1599],prg0[1591],prg0[1598],prg0[1590],prg0[1597],prg0[1589],prg0[1596],prg0[1588],
                      prg0[1595],prg0[1587],prg0[1594],prg0[1586],prg0[1593],prg0[1585],prg0[1592],prg0[1584],
                      prg0[1583],prg0[1575],prg0[1582],prg0[1574],prg0[1581],prg0[1573],prg0[1580],prg0[1572],
                      prg0[1579],prg0[1571],prg0[1578],prg0[1570],prg0[1577],prg0[1569],prg0[1576],prg0[1568],
                      prg0[1567],prg0[1559],prg0[1566],prg0[1558],prg0[1565],prg0[1557],prg0[1564],prg0[1556],
                      prg0[1563],prg0[1555],prg0[1562],prg0[1554],prg0[1561],prg0[1553],prg0[1560],prg0[1552],
                      prg0[1551],prg0[1543],prg0[1550],prg0[1542],prg0[1549],prg0[1541],prg0[1548],prg0[1540],
                      prg0[1547],prg0[1539],prg0[1546],prg0[1538],prg0[1545],prg0[1537],prg0[1544],prg0[1536]}),
             .INIT_5({prg0[1535],prg0[1527],prg0[1534],prg0[1526],prg0[1533],prg0[1525],prg0[1532],prg0[1524],
                      prg0[1531],prg0[1523],prg0[1530],prg0[1522],prg0[1529],prg0[1521],prg0[1528],prg0[1520],
                      prg0[1519],prg0[1511],prg0[1518],prg0[1510],prg0[1517],prg0[1509],prg0[1516],prg0[1508],
                      prg0[1515],prg0[1507],prg0[1514],prg0[1506],prg0[1513],prg0[1505],prg0[1512],prg0[1504],
                      prg0[1503],prg0[1495],prg0[1502],prg0[1494],prg0[1501],prg0[1493],prg0[1500],prg0[1492],
                      prg0[1499],prg0[1491],prg0[1498],prg0[1490],prg0[1497],prg0[1489],prg0[1496],prg0[1488],
                      prg0[1487],prg0[1479],prg0[1486],prg0[1478],prg0[1485],prg0[1477],prg0[1484],prg0[1476],
                      prg0[1483],prg0[1475],prg0[1482],prg0[1474],prg0[1481],prg0[1473],prg0[1480],prg0[1472],
                      prg0[1471],prg0[1463],prg0[1470],prg0[1462],prg0[1469],prg0[1461],prg0[1468],prg0[1460],
                      prg0[1467],prg0[1459],prg0[1466],prg0[1458],prg0[1465],prg0[1457],prg0[1464],prg0[1456],
                      prg0[1455],prg0[1447],prg0[1454],prg0[1446],prg0[1453],prg0[1445],prg0[1452],prg0[1444],
                      prg0[1451],prg0[1443],prg0[1450],prg0[1442],prg0[1449],prg0[1441],prg0[1448],prg0[1440],
                      prg0[1439],prg0[1431],prg0[1438],prg0[1430],prg0[1437],prg0[1429],prg0[1436],prg0[1428],
                      prg0[1435],prg0[1427],prg0[1434],prg0[1426],prg0[1433],prg0[1425],prg0[1432],prg0[1424],
                      prg0[1423],prg0[1415],prg0[1422],prg0[1414],prg0[1421],prg0[1413],prg0[1420],prg0[1412],
                      prg0[1419],prg0[1411],prg0[1418],prg0[1410],prg0[1417],prg0[1409],prg0[1416],prg0[1408],
                      prg0[1407],prg0[1399],prg0[1406],prg0[1398],prg0[1405],prg0[1397],prg0[1404],prg0[1396],
                      prg0[1403],prg0[1395],prg0[1402],prg0[1394],prg0[1401],prg0[1393],prg0[1400],prg0[1392],
                      prg0[1391],prg0[1383],prg0[1390],prg0[1382],prg0[1389],prg0[1381],prg0[1388],prg0[1380],
                      prg0[1387],prg0[1379],prg0[1386],prg0[1378],prg0[1385],prg0[1377],prg0[1384],prg0[1376],
                      prg0[1375],prg0[1367],prg0[1374],prg0[1366],prg0[1373],prg0[1365],prg0[1372],prg0[1364],
                      prg0[1371],prg0[1363],prg0[1370],prg0[1362],prg0[1369],prg0[1361],prg0[1368],prg0[1360],
                      prg0[1359],prg0[1351],prg0[1358],prg0[1350],prg0[1357],prg0[1349],prg0[1356],prg0[1348],
                      prg0[1355],prg0[1347],prg0[1354],prg0[1346],prg0[1353],prg0[1345],prg0[1352],prg0[1344],
                      prg0[1343],prg0[1335],prg0[1342],prg0[1334],prg0[1341],prg0[1333],prg0[1340],prg0[1332],
                      prg0[1339],prg0[1331],prg0[1338],prg0[1330],prg0[1337],prg0[1329],prg0[1336],prg0[1328],
                      prg0[1327],prg0[1319],prg0[1326],prg0[1318],prg0[1325],prg0[1317],prg0[1324],prg0[1316],
                      prg0[1323],prg0[1315],prg0[1322],prg0[1314],prg0[1321],prg0[1313],prg0[1320],prg0[1312],
                      prg0[1311],prg0[1303],prg0[1310],prg0[1302],prg0[1309],prg0[1301],prg0[1308],prg0[1300],
                      prg0[1307],prg0[1299],prg0[1306],prg0[1298],prg0[1305],prg0[1297],prg0[1304],prg0[1296],
                      prg0[1295],prg0[1287],prg0[1294],prg0[1286],prg0[1293],prg0[1285],prg0[1292],prg0[1284],
                      prg0[1291],prg0[1283],prg0[1290],prg0[1282],prg0[1289],prg0[1281],prg0[1288],prg0[1280]}),
             .INIT_4({prg0[1279],prg0[1271],prg0[1278],prg0[1270],prg0[1277],prg0[1269],prg0[1276],prg0[1268],
                      prg0[1275],prg0[1267],prg0[1274],prg0[1266],prg0[1273],prg0[1265],prg0[1272],prg0[1264],
                      prg0[1263],prg0[1255],prg0[1262],prg0[1254],prg0[1261],prg0[1253],prg0[1260],prg0[1252],
                      prg0[1259],prg0[1251],prg0[1258],prg0[1250],prg0[1257],prg0[1249],prg0[1256],prg0[1248],
                      prg0[1247],prg0[1239],prg0[1246],prg0[1238],prg0[1245],prg0[1237],prg0[1244],prg0[1236],
                      prg0[1243],prg0[1235],prg0[1242],prg0[1234],prg0[1241],prg0[1233],prg0[1240],prg0[1232],
                      prg0[1231],prg0[1223],prg0[1230],prg0[1222],prg0[1229],prg0[1221],prg0[1228],prg0[1220],
                      prg0[1227],prg0[1219],prg0[1226],prg0[1218],prg0[1225],prg0[1217],prg0[1224],prg0[1216],
                      prg0[1215],prg0[1207],prg0[1214],prg0[1206],prg0[1213],prg0[1205],prg0[1212],prg0[1204],
                      prg0[1211],prg0[1203],prg0[1210],prg0[1202],prg0[1209],prg0[1201],prg0[1208],prg0[1200],
                      prg0[1199],prg0[1191],prg0[1198],prg0[1190],prg0[1197],prg0[1189],prg0[1196],prg0[1188],
                      prg0[1195],prg0[1187],prg0[1194],prg0[1186],prg0[1193],prg0[1185],prg0[1192],prg0[1184],
                      prg0[1183],prg0[1175],prg0[1182],prg0[1174],prg0[1181],prg0[1173],prg0[1180],prg0[1172],
                      prg0[1179],prg0[1171],prg0[1178],prg0[1170],prg0[1177],prg0[1169],prg0[1176],prg0[1168],
                      prg0[1167],prg0[1159],prg0[1166],prg0[1158],prg0[1165],prg0[1157],prg0[1164],prg0[1156],
                      prg0[1163],prg0[1155],prg0[1162],prg0[1154],prg0[1161],prg0[1153],prg0[1160],prg0[1152],
                      prg0[1151],prg0[1143],prg0[1150],prg0[1142],prg0[1149],prg0[1141],prg0[1148],prg0[1140],
                      prg0[1147],prg0[1139],prg0[1146],prg0[1138],prg0[1145],prg0[1137],prg0[1144],prg0[1136],
                      prg0[1135],prg0[1127],prg0[1134],prg0[1126],prg0[1133],prg0[1125],prg0[1132],prg0[1124],
                      prg0[1131],prg0[1123],prg0[1130],prg0[1122],prg0[1129],prg0[1121],prg0[1128],prg0[1120],
                      prg0[1119],prg0[1111],prg0[1118],prg0[1110],prg0[1117],prg0[1109],prg0[1116],prg0[1108],
                      prg0[1115],prg0[1107],prg0[1114],prg0[1106],prg0[1113],prg0[1105],prg0[1112],prg0[1104],
                      prg0[1103],prg0[1095],prg0[1102],prg0[1094],prg0[1101],prg0[1093],prg0[1100],prg0[1092],
                      prg0[1099],prg0[1091],prg0[1098],prg0[1090],prg0[1097],prg0[1089],prg0[1096],prg0[1088],
                      prg0[1087],prg0[1079],prg0[1086],prg0[1078],prg0[1085],prg0[1077],prg0[1084],prg0[1076],
                      prg0[1083],prg0[1075],prg0[1082],prg0[1074],prg0[1081],prg0[1073],prg0[1080],prg0[1072],
                      prg0[1071],prg0[1063],prg0[1070],prg0[1062],prg0[1069],prg0[1061],prg0[1068],prg0[1060],
                      prg0[1067],prg0[1059],prg0[1066],prg0[1058],prg0[1065],prg0[1057],prg0[1064],prg0[1056],
                      prg0[1055],prg0[1047],prg0[1054],prg0[1046],prg0[1053],prg0[1045],prg0[1052],prg0[1044],
                      prg0[1051],prg0[1043],prg0[1050],prg0[1042],prg0[1049],prg0[1041],prg0[1048],prg0[1040],
                      prg0[1039],prg0[1031],prg0[1038],prg0[1030],prg0[1037],prg0[1029],prg0[1036],prg0[1028],
                      prg0[1035],prg0[1027],prg0[1034],prg0[1026],prg0[1033],prg0[1025],prg0[1032],prg0[1024]}),
             .INIT_3({prg0[1023],prg0[1015],prg0[1022],prg0[1014],prg0[1021],prg0[1013],prg0[1020],prg0[1012],
                      prg0[1019],prg0[1011],prg0[1018],prg0[1010],prg0[1017],prg0[1009],prg0[1016],prg0[1008],
                      prg0[1007],prg0[ 999],prg0[1006],prg0[ 998],prg0[1005],prg0[ 997],prg0[1004],prg0[ 996],
                      prg0[1003],prg0[ 995],prg0[1002],prg0[ 994],prg0[1001],prg0[ 993],prg0[1000],prg0[ 992],
                      prg0[ 991],prg0[ 983],prg0[ 990],prg0[ 982],prg0[ 989],prg0[ 981],prg0[ 988],prg0[ 980],
                      prg0[ 987],prg0[ 979],prg0[ 986],prg0[ 978],prg0[ 985],prg0[ 977],prg0[ 984],prg0[ 976],
                      prg0[ 975],prg0[ 967],prg0[ 974],prg0[ 966],prg0[ 973],prg0[ 965],prg0[ 972],prg0[ 964],
                      prg0[ 971],prg0[ 963],prg0[ 970],prg0[ 962],prg0[ 969],prg0[ 961],prg0[ 968],prg0[ 960],
                      prg0[ 959],prg0[ 951],prg0[ 958],prg0[ 950],prg0[ 957],prg0[ 949],prg0[ 956],prg0[ 948],
                      prg0[ 955],prg0[ 947],prg0[ 954],prg0[ 946],prg0[ 953],prg0[ 945],prg0[ 952],prg0[ 944],
                      prg0[ 943],prg0[ 935],prg0[ 942],prg0[ 934],prg0[ 941],prg0[ 933],prg0[ 940],prg0[ 932],
                      prg0[ 939],prg0[ 931],prg0[ 938],prg0[ 930],prg0[ 937],prg0[ 929],prg0[ 936],prg0[ 928],
                      prg0[ 927],prg0[ 919],prg0[ 926],prg0[ 918],prg0[ 925],prg0[ 917],prg0[ 924],prg0[ 916],
                      prg0[ 923],prg0[ 915],prg0[ 922],prg0[ 914],prg0[ 921],prg0[ 913],prg0[ 920],prg0[ 912],
                      prg0[ 911],prg0[ 903],prg0[ 910],prg0[ 902],prg0[ 909],prg0[ 901],prg0[ 908],prg0[ 900],
                      prg0[ 907],prg0[ 899],prg0[ 906],prg0[ 898],prg0[ 905],prg0[ 897],prg0[ 904],prg0[ 896],
                      prg0[ 895],prg0[ 887],prg0[ 894],prg0[ 886],prg0[ 893],prg0[ 885],prg0[ 892],prg0[ 884],
                      prg0[ 891],prg0[ 883],prg0[ 890],prg0[ 882],prg0[ 889],prg0[ 881],prg0[ 888],prg0[ 880],
                      prg0[ 879],prg0[ 871],prg0[ 878],prg0[ 870],prg0[ 877],prg0[ 869],prg0[ 876],prg0[ 868],
                      prg0[ 875],prg0[ 867],prg0[ 874],prg0[ 866],prg0[ 873],prg0[ 865],prg0[ 872],prg0[ 864],
                      prg0[ 863],prg0[ 855],prg0[ 862],prg0[ 854],prg0[ 861],prg0[ 853],prg0[ 860],prg0[ 852],
                      prg0[ 859],prg0[ 851],prg0[ 858],prg0[ 850],prg0[ 857],prg0[ 849],prg0[ 856],prg0[ 848],
                      prg0[ 847],prg0[ 839],prg0[ 846],prg0[ 838],prg0[ 845],prg0[ 837],prg0[ 844],prg0[ 836],
                      prg0[ 843],prg0[ 835],prg0[ 842],prg0[ 834],prg0[ 841],prg0[ 833],prg0[ 840],prg0[ 832],
                      prg0[ 831],prg0[ 823],prg0[ 830],prg0[ 822],prg0[ 829],prg0[ 821],prg0[ 828],prg0[ 820],
                      prg0[ 827],prg0[ 819],prg0[ 826],prg0[ 818],prg0[ 825],prg0[ 817],prg0[ 824],prg0[ 816],
                      prg0[ 815],prg0[ 807],prg0[ 814],prg0[ 806],prg0[ 813],prg0[ 805],prg0[ 812],prg0[ 804],
                      prg0[ 811],prg0[ 803],prg0[ 810],prg0[ 802],prg0[ 809],prg0[ 801],prg0[ 808],prg0[ 800],
                      prg0[ 799],prg0[ 791],prg0[ 798],prg0[ 790],prg0[ 797],prg0[ 789],prg0[ 796],prg0[ 788],
                      prg0[ 795],prg0[ 787],prg0[ 794],prg0[ 786],prg0[ 793],prg0[ 785],prg0[ 792],prg0[ 784],
                      prg0[ 783],prg0[ 775],prg0[ 782],prg0[ 774],prg0[ 781],prg0[ 773],prg0[ 780],prg0[ 772],
                      prg0[ 779],prg0[ 771],prg0[ 778],prg0[ 770],prg0[ 777],prg0[ 769],prg0[ 776],prg0[ 768]}),
             .INIT_2({prg0[ 767],prg0[ 759],prg0[ 766],prg0[ 758],prg0[ 765],prg0[ 757],prg0[ 764],prg0[ 756],
                      prg0[ 763],prg0[ 755],prg0[ 762],prg0[ 754],prg0[ 761],prg0[ 753],prg0[ 760],prg0[ 752],
                      prg0[ 751],prg0[ 743],prg0[ 750],prg0[ 742],prg0[ 749],prg0[ 741],prg0[ 748],prg0[ 740],
                      prg0[ 747],prg0[ 739],prg0[ 746],prg0[ 738],prg0[ 745],prg0[ 737],prg0[ 744],prg0[ 736],
                      prg0[ 735],prg0[ 727],prg0[ 734],prg0[ 726],prg0[ 733],prg0[ 725],prg0[ 732],prg0[ 724],
                      prg0[ 731],prg0[ 723],prg0[ 730],prg0[ 722],prg0[ 729],prg0[ 721],prg0[ 728],prg0[ 720],
                      prg0[ 719],prg0[ 711],prg0[ 718],prg0[ 710],prg0[ 717],prg0[ 709],prg0[ 716],prg0[ 708],
                      prg0[ 715],prg0[ 707],prg0[ 714],prg0[ 706],prg0[ 713],prg0[ 705],prg0[ 712],prg0[ 704],
                      prg0[ 703],prg0[ 695],prg0[ 702],prg0[ 694],prg0[ 701],prg0[ 693],prg0[ 700],prg0[ 692],
                      prg0[ 699],prg0[ 691],prg0[ 698],prg0[ 690],prg0[ 697],prg0[ 689],prg0[ 696],prg0[ 688],
                      prg0[ 687],prg0[ 679],prg0[ 686],prg0[ 678],prg0[ 685],prg0[ 677],prg0[ 684],prg0[ 676],
                      prg0[ 683],prg0[ 675],prg0[ 682],prg0[ 674],prg0[ 681],prg0[ 673],prg0[ 680],prg0[ 672],
                      prg0[ 671],prg0[ 663],prg0[ 670],prg0[ 662],prg0[ 669],prg0[ 661],prg0[ 668],prg0[ 660],
                      prg0[ 667],prg0[ 659],prg0[ 666],prg0[ 658],prg0[ 665],prg0[ 657],prg0[ 664],prg0[ 656],
                      prg0[ 655],prg0[ 647],prg0[ 654],prg0[ 646],prg0[ 653],prg0[ 645],prg0[ 652],prg0[ 644],
                      prg0[ 651],prg0[ 643],prg0[ 650],prg0[ 642],prg0[ 649],prg0[ 641],prg0[ 648],prg0[ 640],
                      prg0[ 639],prg0[ 631],prg0[ 638],prg0[ 630],prg0[ 637],prg0[ 629],prg0[ 636],prg0[ 628],
                      prg0[ 635],prg0[ 627],prg0[ 634],prg0[ 626],prg0[ 633],prg0[ 625],prg0[ 632],prg0[ 624],
                      prg0[ 623],prg0[ 615],prg0[ 622],prg0[ 614],prg0[ 621],prg0[ 613],prg0[ 620],prg0[ 612],
                      prg0[ 619],prg0[ 611],prg0[ 618],prg0[ 610],prg0[ 617],prg0[ 609],prg0[ 616],prg0[ 608],
                      prg0[ 607],prg0[ 599],prg0[ 606],prg0[ 598],prg0[ 605],prg0[ 597],prg0[ 604],prg0[ 596],
                      prg0[ 603],prg0[ 595],prg0[ 602],prg0[ 594],prg0[ 601],prg0[ 593],prg0[ 600],prg0[ 592],
                      prg0[ 591],prg0[ 583],prg0[ 590],prg0[ 582],prg0[ 589],prg0[ 581],prg0[ 588],prg0[ 580],
                      prg0[ 587],prg0[ 579],prg0[ 586],prg0[ 578],prg0[ 585],prg0[ 577],prg0[ 584],prg0[ 576],
                      prg0[ 575],prg0[ 567],prg0[ 574],prg0[ 566],prg0[ 573],prg0[ 565],prg0[ 572],prg0[ 564],
                      prg0[ 571],prg0[ 563],prg0[ 570],prg0[ 562],prg0[ 569],prg0[ 561],prg0[ 568],prg0[ 560],
                      prg0[ 559],prg0[ 551],prg0[ 558],prg0[ 550],prg0[ 557],prg0[ 549],prg0[ 556],prg0[ 548],
                      prg0[ 555],prg0[ 547],prg0[ 554],prg0[ 546],prg0[ 553],prg0[ 545],prg0[ 552],prg0[ 544],
                      prg0[ 543],prg0[ 535],prg0[ 542],prg0[ 534],prg0[ 541],prg0[ 533],prg0[ 540],prg0[ 532],
                      prg0[ 539],prg0[ 531],prg0[ 538],prg0[ 530],prg0[ 537],prg0[ 529],prg0[ 536],prg0[ 528],
                      prg0[ 527],prg0[ 519],prg0[ 526],prg0[ 518],prg0[ 525],prg0[ 517],prg0[ 524],prg0[ 516],
                      prg0[ 523],prg0[ 515],prg0[ 522],prg0[ 514],prg0[ 521],prg0[ 513],prg0[ 520],prg0[ 512]}),
             .INIT_1({prg0[ 511],prg0[ 503],prg0[ 510],prg0[ 502],prg0[ 509],prg0[ 501],prg0[ 508],prg0[ 500],
                      prg0[ 507],prg0[ 499],prg0[ 506],prg0[ 498],prg0[ 505],prg0[ 497],prg0[ 504],prg0[ 496],
                      prg0[ 495],prg0[ 487],prg0[ 494],prg0[ 486],prg0[ 493],prg0[ 485],prg0[ 492],prg0[ 484],
                      prg0[ 491],prg0[ 483],prg0[ 490],prg0[ 482],prg0[ 489],prg0[ 481],prg0[ 488],prg0[ 480],
                      prg0[ 479],prg0[ 471],prg0[ 478],prg0[ 470],prg0[ 477],prg0[ 469],prg0[ 476],prg0[ 468],
                      prg0[ 475],prg0[ 467],prg0[ 474],prg0[ 466],prg0[ 473],prg0[ 465],prg0[ 472],prg0[ 464],
                      prg0[ 463],prg0[ 455],prg0[ 462],prg0[ 454],prg0[ 461],prg0[ 453],prg0[ 460],prg0[ 452],
                      prg0[ 459],prg0[ 451],prg0[ 458],prg0[ 450],prg0[ 457],prg0[ 449],prg0[ 456],prg0[ 448],
                      prg0[ 447],prg0[ 439],prg0[ 446],prg0[ 438],prg0[ 445],prg0[ 437],prg0[ 444],prg0[ 436],
                      prg0[ 443],prg0[ 435],prg0[ 442],prg0[ 434],prg0[ 441],prg0[ 433],prg0[ 440],prg0[ 432],
                      prg0[ 431],prg0[ 423],prg0[ 430],prg0[ 422],prg0[ 429],prg0[ 421],prg0[ 428],prg0[ 420],
                      prg0[ 427],prg0[ 419],prg0[ 426],prg0[ 418],prg0[ 425],prg0[ 417],prg0[ 424],prg0[ 416],
                      prg0[ 415],prg0[ 407],prg0[ 414],prg0[ 406],prg0[ 413],prg0[ 405],prg0[ 412],prg0[ 404],
                      prg0[ 411],prg0[ 403],prg0[ 410],prg0[ 402],prg0[ 409],prg0[ 401],prg0[ 408],prg0[ 400],
                      prg0[ 399],prg0[ 391],prg0[ 398],prg0[ 390],prg0[ 397],prg0[ 389],prg0[ 396],prg0[ 388],
                      prg0[ 395],prg0[ 387],prg0[ 394],prg0[ 386],prg0[ 393],prg0[ 385],prg0[ 392],prg0[ 384],
                      prg0[ 383],prg0[ 375],prg0[ 382],prg0[ 374],prg0[ 381],prg0[ 373],prg0[ 380],prg0[ 372],
                      prg0[ 379],prg0[ 371],prg0[ 378],prg0[ 370],prg0[ 377],prg0[ 369],prg0[ 376],prg0[ 368],
                      prg0[ 367],prg0[ 359],prg0[ 366],prg0[ 358],prg0[ 365],prg0[ 357],prg0[ 364],prg0[ 356],
                      prg0[ 363],prg0[ 355],prg0[ 362],prg0[ 354],prg0[ 361],prg0[ 353],prg0[ 360],prg0[ 352],
                      prg0[ 351],prg0[ 343],prg0[ 350],prg0[ 342],prg0[ 349],prg0[ 341],prg0[ 348],prg0[ 340],
                      prg0[ 347],prg0[ 339],prg0[ 346],prg0[ 338],prg0[ 345],prg0[ 337],prg0[ 344],prg0[ 336],
                      prg0[ 335],prg0[ 327],prg0[ 334],prg0[ 326],prg0[ 333],prg0[ 325],prg0[ 332],prg0[ 324],
                      prg0[ 331],prg0[ 323],prg0[ 330],prg0[ 322],prg0[ 329],prg0[ 321],prg0[ 328],prg0[ 320],
                      prg0[ 319],prg0[ 311],prg0[ 318],prg0[ 310],prg0[ 317],prg0[ 309],prg0[ 316],prg0[ 308],
                      prg0[ 315],prg0[ 307],prg0[ 314],prg0[ 306],prg0[ 313],prg0[ 305],prg0[ 312],prg0[ 304],
                      prg0[ 303],prg0[ 295],prg0[ 302],prg0[ 294],prg0[ 301],prg0[ 293],prg0[ 300],prg0[ 292],
                      prg0[ 299],prg0[ 291],prg0[ 298],prg0[ 290],prg0[ 297],prg0[ 289],prg0[ 296],prg0[ 288],
                      prg0[ 287],prg0[ 279],prg0[ 286],prg0[ 278],prg0[ 285],prg0[ 277],prg0[ 284],prg0[ 276],
                      prg0[ 283],prg0[ 275],prg0[ 282],prg0[ 274],prg0[ 281],prg0[ 273],prg0[ 280],prg0[ 272],
                      prg0[ 271],prg0[ 263],prg0[ 270],prg0[ 262],prg0[ 269],prg0[ 261],prg0[ 268],prg0[ 260],
                      prg0[ 267],prg0[ 259],prg0[ 266],prg0[ 258],prg0[ 265],prg0[ 257],prg0[ 264],prg0[ 256]}),
             .INIT_0({prg0[ 255],prg0[ 247],prg0[ 254],prg0[ 246],prg0[ 253],prg0[ 245],prg0[ 252],prg0[ 244],
                      prg0[ 251],prg0[ 243],prg0[ 250],prg0[ 242],prg0[ 249],prg0[ 241],prg0[ 248],prg0[ 240],
                      prg0[ 239],prg0[ 231],prg0[ 238],prg0[ 230],prg0[ 237],prg0[ 229],prg0[ 236],prg0[ 228],
                      prg0[ 235],prg0[ 227],prg0[ 234],prg0[ 226],prg0[ 233],prg0[ 225],prg0[ 232],prg0[ 224],
                      prg0[ 223],prg0[ 215],prg0[ 222],prg0[ 214],prg0[ 221],prg0[ 213],prg0[ 220],prg0[ 212],
                      prg0[ 219],prg0[ 211],prg0[ 218],prg0[ 210],prg0[ 217],prg0[ 209],prg0[ 216],prg0[ 208],
                      prg0[ 207],prg0[ 199],prg0[ 206],prg0[ 198],prg0[ 205],prg0[ 197],prg0[ 204],prg0[ 196],
                      prg0[ 203],prg0[ 195],prg0[ 202],prg0[ 194],prg0[ 201],prg0[ 193],prg0[ 200],prg0[ 192],
                      prg0[ 191],prg0[ 183],prg0[ 190],prg0[ 182],prg0[ 189],prg0[ 181],prg0[ 188],prg0[ 180],
                      prg0[ 187],prg0[ 179],prg0[ 186],prg0[ 178],prg0[ 185],prg0[ 177],prg0[ 184],prg0[ 176],
                      prg0[ 175],prg0[ 167],prg0[ 174],prg0[ 166],prg0[ 173],prg0[ 165],prg0[ 172],prg0[ 164],
                      prg0[ 171],prg0[ 163],prg0[ 170],prg0[ 162],prg0[ 169],prg0[ 161],prg0[ 168],prg0[ 160],
                      prg0[ 159],prg0[ 151],prg0[ 158],prg0[ 150],prg0[ 157],prg0[ 149],prg0[ 156],prg0[ 148],
                      prg0[ 155],prg0[ 147],prg0[ 154],prg0[ 146],prg0[ 153],prg0[ 145],prg0[ 152],prg0[ 144],
                      prg0[ 143],prg0[ 135],prg0[ 142],prg0[ 134],prg0[ 141],prg0[ 133],prg0[ 140],prg0[ 132],
                      prg0[ 139],prg0[ 131],prg0[ 138],prg0[ 130],prg0[ 137],prg0[ 129],prg0[ 136],prg0[ 128],
                      prg0[ 127],prg0[ 119],prg0[ 126],prg0[ 118],prg0[ 125],prg0[ 117],prg0[ 124],prg0[ 116],
                      prg0[ 123],prg0[ 115],prg0[ 122],prg0[ 114],prg0[ 121],prg0[ 113],prg0[ 120],prg0[ 112],
                      prg0[ 111],prg0[ 103],prg0[ 110],prg0[ 102],prg0[ 109],prg0[ 101],prg0[ 108],prg0[ 100],
                      prg0[ 107],prg0[  99],prg0[ 106],prg0[  98],prg0[ 105],prg0[  97],prg0[ 104],prg0[  96],
                      prg0[  95],prg0[  87],prg0[  94],prg0[  86],prg0[  93],prg0[  85],prg0[  92],prg0[  84],
                      prg0[  91],prg0[  83],prg0[  90],prg0[  82],prg0[  89],prg0[  81],prg0[  88],prg0[  80],
                      prg0[  79],prg0[  71],prg0[  78],prg0[  70],prg0[  77],prg0[  69],prg0[  76],prg0[  68],
                      prg0[  75],prg0[  67],prg0[  74],prg0[  66],prg0[  73],prg0[  65],prg0[  72],prg0[  64],
                      prg0[  63],prg0[  55],prg0[  62],prg0[  54],prg0[  61],prg0[  53],prg0[  60],prg0[  52],
                      prg0[  59],prg0[  51],prg0[  58],prg0[  50],prg0[  57],prg0[  49],prg0[  56],prg0[  48],
                      prg0[  47],prg0[  39],prg0[  46],prg0[  38],prg0[  45],prg0[  37],prg0[  44],prg0[  36],
                      prg0[  43],prg0[  35],prg0[  42],prg0[  34],prg0[  41],prg0[  33],prg0[  40],prg0[  32],
                      prg0[  31],prg0[  23],prg0[  30],prg0[  22],prg0[  29],prg0[  21],prg0[  28],prg0[  20],
                      prg0[  27],prg0[  19],prg0[  26],prg0[  18],prg0[  25],prg0[  17],prg0[  24],prg0[  16],
                      prg0[  15],prg0[   7],prg0[  14],prg0[   6],prg0[  13],prg0[   5],prg0[  12],prg0[   4],
                      prg0[  11],prg0[   3],prg0[  10],prg0[   2],prg0[   9],prg0[   1],prg0[   8],prg0[   0]}),
             .READ_MODE(1),
             .WRITE_MODE(1))
         mem
           (// Outputs
            .RDATA  ( {dum8[7],DAT_O[7],
                       dum8[6],DAT_O[6],
                       dum8[5],DAT_O[5],
                       dum8[4],DAT_O[4],
                       dum8[3],DAT_O[3],
                       dum8[2],DAT_O[2],
                       dum8[1],DAT_O[1],
                       dum8[0],DAT_O[0]}            ),
            // Input
            .MASK   ( 16'h0                         ),
            .WDATA  ( {1'b0, B[7],1'b0, B[6],
                       1'b0, B[5],1'b0, B[4],
                       1'b0, B[3],1'b0, B[2],
                       1'b0, B[1],1'b0, B[0]}       ),                       
            .WADDR  ( {2'b0,Wai[0],Wai[8:1]}        ), // Note mangling
            .RADDR  ( {2'b0,Rai[0],Rai[8:1]}        ), // Note mangling
            .RE     ( 1'b1                          ),
            .WE     ( 1'b1                          ), // May perhaps save a lut. use .WE(iwe) .WCLKE(~bmask)
            .WCLK   ( clk                           ),
            .RCLK   ( clk                           ),
            .RCLKE  ( 1'b1                          ),
            .WCLKE  ( we                            ) //  May perhaps save a lut. use .WE(iwe) .WCLKE(~bmask)
            /*AUTOINST*/);
         
      end else begin
         /* Split up to 2 KiB memory into low and high nibbles
          */
         localparam [4095:0]
           pb1 = {prg3[4091:4088],prg3[4083:4080],prg3[4075:4072],prg3[4067:4064],prg3[4059:4056],prg3[4051:4048],prg3[4043:4040],prg3[4035:4032],
                  prg3[4027:4024],prg3[4019:4016],prg3[4011:4008],prg3[4003:4000],prg3[3995:3992],prg3[3987:3984],prg3[3979:3976],prg3[3971:3968],
                  prg3[3963:3960],prg3[3955:3952],prg3[3947:3944],prg3[3939:3936],prg3[3931:3928],prg3[3923:3920],prg3[3915:3912],prg3[3907:3904],
                  prg3[3899:3896],prg3[3891:3888],prg3[3883:3880],prg3[3875:3872],prg3[3867:3864],prg3[3859:3856],prg3[3851:3848],prg3[3843:3840],
                  prg3[3835:3832],prg3[3827:3824],prg3[3819:3816],prg3[3811:3808],prg3[3803:3800],prg3[3795:3792],prg3[3787:3784],prg3[3779:3776],
                  prg3[3771:3768],prg3[3763:3760],prg3[3755:3752],prg3[3747:3744],prg3[3739:3736],prg3[3731:3728],prg3[3723:3720],prg3[3715:3712],
                  prg3[3707:3704],prg3[3699:3696],prg3[3691:3688],prg3[3683:3680],prg3[3675:3672],prg3[3667:3664],prg3[3659:3656],prg3[3651:3648],
                  prg3[3643:3640],prg3[3635:3632],prg3[3627:3624],prg3[3619:3616],prg3[3611:3608],prg3[3603:3600],prg3[3595:3592],prg3[3587:3584],
                  prg3[3579:3576],prg3[3571:3568],prg3[3563:3560],prg3[3555:3552],prg3[3547:3544],prg3[3539:3536],prg3[3531:3528],prg3[3523:3520],
                  prg3[3515:3512],prg3[3507:3504],prg3[3499:3496],prg3[3491:3488],prg3[3483:3480],prg3[3475:3472],prg3[3467:3464],prg3[3459:3456],
                  prg3[3451:3448],prg3[3443:3440],prg3[3435:3432],prg3[3427:3424],prg3[3419:3416],prg3[3411:3408],prg3[3403:3400],prg3[3395:3392],
                  prg3[3387:3384],prg3[3379:3376],prg3[3371:3368],prg3[3363:3360],prg3[3355:3352],prg3[3347:3344],prg3[3339:3336],prg3[3331:3328],
                  prg3[3323:3320],prg3[3315:3312],prg3[3307:3304],prg3[3299:3296],prg3[3291:3288],prg3[3283:3280],prg3[3275:3272],prg3[3267:3264],
                  prg3[3259:3256],prg3[3251:3248],prg3[3243:3240],prg3[3235:3232],prg3[3227:3224],prg3[3219:3216],prg3[3211:3208],prg3[3203:3200],
                  prg3[3195:3192],prg3[3187:3184],prg3[3179:3176],prg3[3171:3168],prg3[3163:3160],prg3[3155:3152],prg3[3147:3144],prg3[3139:3136],
                  prg3[3131:3128],prg3[3123:3120],prg3[3115:3112],prg3[3107:3104],prg3[3099:3096],prg3[3091:3088],prg3[3083:3080],prg3[3075:3072],
                  prg3[3067:3064],prg3[3059:3056],prg3[3051:3048],prg3[3043:3040],prg3[3035:3032],prg3[3027:3024],prg3[3019:3016],prg3[3011:3008],
                  prg3[3003:3000],prg3[2995:2992],prg3[2987:2984],prg3[2979:2976],prg3[2971:2968],prg3[2963:2960],prg3[2955:2952],prg3[2947:2944],
                  prg3[2939:2936],prg3[2931:2928],prg3[2923:2920],prg3[2915:2912],prg3[2907:2904],prg3[2899:2896],prg3[2891:2888],prg3[2883:2880],
                  prg3[2875:2872],prg3[2867:2864],prg3[2859:2856],prg3[2851:2848],prg3[2843:2840],prg3[2835:2832],prg3[2827:2824],prg3[2819:2816],
                  prg3[2811:2808],prg3[2803:2800],prg3[2795:2792],prg3[2787:2784],prg3[2779:2776],prg3[2771:2768],prg3[2763:2760],prg3[2755:2752],
                  prg3[2747:2744],prg3[2739:2736],prg3[2731:2728],prg3[2723:2720],prg3[2715:2712],prg3[2707:2704],prg3[2699:2696],prg3[2691:2688],
                  prg3[2683:2680],prg3[2675:2672],prg3[2667:2664],prg3[2659:2656],prg3[2651:2648],prg3[2643:2640],prg3[2635:2632],prg3[2627:2624],
                  prg3[2619:2616],prg3[2611:2608],prg3[2603:2600],prg3[2595:2592],prg3[2587:2584],prg3[2579:2576],prg3[2571:2568],prg3[2563:2560],
                  prg3[2555:2552],prg3[2547:2544],prg3[2539:2536],prg3[2531:2528],prg3[2523:2520],prg3[2515:2512],prg3[2507:2504],prg3[2499:2496],
                  prg3[2491:2488],prg3[2483:2480],prg3[2475:2472],prg3[2467:2464],prg3[2459:2456],prg3[2451:2448],prg3[2443:2440],prg3[2435:2432],
                  prg3[2427:2424],prg3[2419:2416],prg3[2411:2408],prg3[2403:2400],prg3[2395:2392],prg3[2387:2384],prg3[2379:2376],prg3[2371:2368],
                  prg3[2363:2360],prg3[2355:2352],prg3[2347:2344],prg3[2339:2336],prg3[2331:2328],prg3[2323:2320],prg3[2315:2312],prg3[2307:2304],
                  prg3[2299:2296],prg3[2291:2288],prg3[2283:2280],prg3[2275:2272],prg3[2267:2264],prg3[2259:2256],prg3[2251:2248],prg3[2243:2240],
                  prg3[2235:2232],prg3[2227:2224],prg3[2219:2216],prg3[2211:2208],prg3[2203:2200],prg3[2195:2192],prg3[2187:2184],prg3[2179:2176],
                  prg3[2171:2168],prg3[2163:2160],prg3[2155:2152],prg3[2147:2144],prg3[2139:2136],prg3[2131:2128],prg3[2123:2120],prg3[2115:2112],
                  prg3[2107:2104],prg3[2099:2096],prg3[2091:2088],prg3[2083:2080],prg3[2075:2072],prg3[2067:2064],prg3[2059:2056],prg3[2051:2048],
                  prg3[2043:2040],prg3[2035:2032],prg3[2027:2024],prg3[2019:2016],prg3[2011:2008],prg3[2003:2000],prg3[1995:1992],prg3[1987:1984],
                  prg3[1979:1976],prg3[1971:1968],prg3[1963:1960],prg3[1955:1952],prg3[1947:1944],prg3[1939:1936],prg3[1931:1928],prg3[1923:1920],
                  prg3[1915:1912],prg3[1907:1904],prg3[1899:1896],prg3[1891:1888],prg3[1883:1880],prg3[1875:1872],prg3[1867:1864],prg3[1859:1856],
                  prg3[1851:1848],prg3[1843:1840],prg3[1835:1832],prg3[1827:1824],prg3[1819:1816],prg3[1811:1808],prg3[1803:1800],prg3[1795:1792],
                  prg3[1787:1784],prg3[1779:1776],prg3[1771:1768],prg3[1763:1760],prg3[1755:1752],prg3[1747:1744],prg3[1739:1736],prg3[1731:1728],
                  prg3[1723:1720],prg3[1715:1712],prg3[1707:1704],prg3[1699:1696],prg3[1691:1688],prg3[1683:1680],prg3[1675:1672],prg3[1667:1664],
                  prg3[1659:1656],prg3[1651:1648],prg3[1643:1640],prg3[1635:1632],prg3[1627:1624],prg3[1619:1616],prg3[1611:1608],prg3[1603:1600],
                  prg3[1595:1592],prg3[1587:1584],prg3[1579:1576],prg3[1571:1568],prg3[1563:1560],prg3[1555:1552],prg3[1547:1544],prg3[1539:1536],
                  prg3[1531:1528],prg3[1523:1520],prg3[1515:1512],prg3[1507:1504],prg3[1499:1496],prg3[1491:1488],prg3[1483:1480],prg3[1475:1472],
                  prg3[1467:1464],prg3[1459:1456],prg3[1451:1448],prg3[1443:1440],prg3[1435:1432],prg3[1427:1424],prg3[1419:1416],prg3[1411:1408],
                  prg3[1403:1400],prg3[1395:1392],prg3[1387:1384],prg3[1379:1376],prg3[1371:1368],prg3[1363:1360],prg3[1355:1352],prg3[1347:1344],
                  prg3[1339:1336],prg3[1331:1328],prg3[1323:1320],prg3[1315:1312],prg3[1307:1304],prg3[1299:1296],prg3[1291:1288],prg3[1283:1280],
                  prg3[1275:1272],prg3[1267:1264],prg3[1259:1256],prg3[1251:1248],prg3[1243:1240],prg3[1235:1232],prg3[1227:1224],prg3[1219:1216],
                  prg3[1211:1208],prg3[1203:1200],prg3[1195:1192],prg3[1187:1184],prg3[1179:1176],prg3[1171:1168],prg3[1163:1160],prg3[1155:1152],
                  prg3[1147:1144],prg3[1139:1136],prg3[1131:1128],prg3[1123:1120],prg3[1115:1112],prg3[1107:1104],prg3[1099:1096],prg3[1091:1088],
                  prg3[1083:1080],prg3[1075:1072],prg3[1067:1064],prg3[1059:1056],prg3[1051:1048],prg3[1043:1040],prg3[1035:1032],prg3[1027:1024],
                  prg3[1019:1016],prg3[1011:1008],prg3[1003:1000],prg3[ 995: 992],prg3[ 987: 984],prg3[ 979: 976],prg3[ 971: 968],prg3[ 963: 960],
                  prg3[ 955: 952],prg3[ 947: 944],prg3[ 939: 936],prg3[ 931: 928],prg3[ 923: 920],prg3[ 915: 912],prg3[ 907: 904],prg3[ 899: 896],
                  prg3[ 891: 888],prg3[ 883: 880],prg3[ 875: 872],prg3[ 867: 864],prg3[ 859: 856],prg3[ 851: 848],prg3[ 843: 840],prg3[ 835: 832],
                  prg3[ 827: 824],prg3[ 819: 816],prg3[ 811: 808],prg3[ 803: 800],prg3[ 795: 792],prg3[ 787: 784],prg3[ 779: 776],prg3[ 771: 768],
                  prg3[ 763: 760],prg3[ 755: 752],prg3[ 747: 744],prg3[ 739: 736],prg3[ 731: 728],prg3[ 723: 720],prg3[ 715: 712],prg3[ 707: 704],
                  prg3[ 699: 696],prg3[ 691: 688],prg3[ 683: 680],prg3[ 675: 672],prg3[ 667: 664],prg3[ 659: 656],prg3[ 651: 648],prg3[ 643: 640],
                  prg3[ 635: 632],prg3[ 627: 624],prg3[ 619: 616],prg3[ 611: 608],prg3[ 603: 600],prg3[ 595: 592],prg3[ 587: 584],prg3[ 579: 576],
                  prg3[ 571: 568],prg3[ 563: 560],prg3[ 555: 552],prg3[ 547: 544],prg3[ 539: 536],prg3[ 531: 528],prg3[ 523: 520],prg3[ 515: 512],
                  prg3[ 507: 504],prg3[ 499: 496],prg3[ 491: 488],prg3[ 483: 480],prg3[ 475: 472],prg3[ 467: 464],prg3[ 459: 456],prg3[ 451: 448],
                  prg3[ 443: 440],prg3[ 435: 432],prg3[ 427: 424],prg3[ 419: 416],prg3[ 411: 408],prg3[ 403: 400],prg3[ 395: 392],prg3[ 387: 384],
                  prg3[ 379: 376],prg3[ 371: 368],prg3[ 363: 360],prg3[ 355: 352],prg3[ 347: 344],prg3[ 339: 336],prg3[ 331: 328],prg3[ 323: 320],
                  prg3[ 315: 312],prg3[ 307: 304],prg3[ 299: 296],prg3[ 291: 288],prg3[ 283: 280],prg3[ 275: 272],prg3[ 267: 264],prg3[ 259: 256],
                  prg3[ 251: 248],prg3[ 243: 240],prg3[ 235: 232],prg3[ 227: 224],prg3[ 219: 216],prg3[ 211: 208],prg3[ 203: 200],prg3[ 195: 192],
                  prg3[ 187: 184],prg3[ 179: 176],prg3[ 171: 168],prg3[ 163: 160],prg3[ 155: 152],prg3[ 147: 144],prg3[ 139: 136],prg3[ 131: 128],
                  prg3[ 123: 120],prg3[ 115: 112],prg3[ 107: 104],prg3[  99:  96],prg3[  91:  88],prg3[  83:  80],prg3[  75:  72],prg3[  67:  64],
                  prg3[  59:  56],prg3[  51:  48],prg3[  43:  40],prg3[  35:  32],prg3[  27:  24],prg3[  19:  16],prg3[  11:   8],prg3[   3:   0],
                  prg2[4091:4088],prg2[4083:4080],prg2[4075:4072],prg2[4067:4064],prg2[4059:4056],prg2[4051:4048],prg2[4043:4040],prg2[4035:4032],
                  prg2[4027:4024],prg2[4019:4016],prg2[4011:4008],prg2[4003:4000],prg2[3995:3992],prg2[3987:3984],prg2[3979:3976],prg2[3971:3968],
                  prg2[3963:3960],prg2[3955:3952],prg2[3947:3944],prg2[3939:3936],prg2[3931:3928],prg2[3923:3920],prg2[3915:3912],prg2[3907:3904],
                  prg2[3899:3896],prg2[3891:3888],prg2[3883:3880],prg2[3875:3872],prg2[3867:3864],prg2[3859:3856],prg2[3851:3848],prg2[3843:3840],
                  prg2[3835:3832],prg2[3827:3824],prg2[3819:3816],prg2[3811:3808],prg2[3803:3800],prg2[3795:3792],prg2[3787:3784],prg2[3779:3776],
                  prg2[3771:3768],prg2[3763:3760],prg2[3755:3752],prg2[3747:3744],prg2[3739:3736],prg2[3731:3728],prg2[3723:3720],prg2[3715:3712],
                  prg2[3707:3704],prg2[3699:3696],prg2[3691:3688],prg2[3683:3680],prg2[3675:3672],prg2[3667:3664],prg2[3659:3656],prg2[3651:3648],
                  prg2[3643:3640],prg2[3635:3632],prg2[3627:3624],prg2[3619:3616],prg2[3611:3608],prg2[3603:3600],prg2[3595:3592],prg2[3587:3584],
                  prg2[3579:3576],prg2[3571:3568],prg2[3563:3560],prg2[3555:3552],prg2[3547:3544],prg2[3539:3536],prg2[3531:3528],prg2[3523:3520],
                  prg2[3515:3512],prg2[3507:3504],prg2[3499:3496],prg2[3491:3488],prg2[3483:3480],prg2[3475:3472],prg2[3467:3464],prg2[3459:3456],
                  prg2[3451:3448],prg2[3443:3440],prg2[3435:3432],prg2[3427:3424],prg2[3419:3416],prg2[3411:3408],prg2[3403:3400],prg2[3395:3392],
                  prg2[3387:3384],prg2[3379:3376],prg2[3371:3368],prg2[3363:3360],prg2[3355:3352],prg2[3347:3344],prg2[3339:3336],prg2[3331:3328],
                  prg2[3323:3320],prg2[3315:3312],prg2[3307:3304],prg2[3299:3296],prg2[3291:3288],prg2[3283:3280],prg2[3275:3272],prg2[3267:3264],
                  prg2[3259:3256],prg2[3251:3248],prg2[3243:3240],prg2[3235:3232],prg2[3227:3224],prg2[3219:3216],prg2[3211:3208],prg2[3203:3200],
                  prg2[3195:3192],prg2[3187:3184],prg2[3179:3176],prg2[3171:3168],prg2[3163:3160],prg2[3155:3152],prg2[3147:3144],prg2[3139:3136],
                  prg2[3131:3128],prg2[3123:3120],prg2[3115:3112],prg2[3107:3104],prg2[3099:3096],prg2[3091:3088],prg2[3083:3080],prg2[3075:3072],
                  prg2[3067:3064],prg2[3059:3056],prg2[3051:3048],prg2[3043:3040],prg2[3035:3032],prg2[3027:3024],prg2[3019:3016],prg2[3011:3008],
                  prg2[3003:3000],prg2[2995:2992],prg2[2987:2984],prg2[2979:2976],prg2[2971:2968],prg2[2963:2960],prg2[2955:2952],prg2[2947:2944],
                  prg2[2939:2936],prg2[2931:2928],prg2[2923:2920],prg2[2915:2912],prg2[2907:2904],prg2[2899:2896],prg2[2891:2888],prg2[2883:2880],
                  prg2[2875:2872],prg2[2867:2864],prg2[2859:2856],prg2[2851:2848],prg2[2843:2840],prg2[2835:2832],prg2[2827:2824],prg2[2819:2816],
                  prg2[2811:2808],prg2[2803:2800],prg2[2795:2792],prg2[2787:2784],prg2[2779:2776],prg2[2771:2768],prg2[2763:2760],prg2[2755:2752],
                  prg2[2747:2744],prg2[2739:2736],prg2[2731:2728],prg2[2723:2720],prg2[2715:2712],prg2[2707:2704],prg2[2699:2696],prg2[2691:2688],
                  prg2[2683:2680],prg2[2675:2672],prg2[2667:2664],prg2[2659:2656],prg2[2651:2648],prg2[2643:2640],prg2[2635:2632],prg2[2627:2624],
                  prg2[2619:2616],prg2[2611:2608],prg2[2603:2600],prg2[2595:2592],prg2[2587:2584],prg2[2579:2576],prg2[2571:2568],prg2[2563:2560],
                  prg2[2555:2552],prg2[2547:2544],prg2[2539:2536],prg2[2531:2528],prg2[2523:2520],prg2[2515:2512],prg2[2507:2504],prg2[2499:2496],
                  prg2[2491:2488],prg2[2483:2480],prg2[2475:2472],prg2[2467:2464],prg2[2459:2456],prg2[2451:2448],prg2[2443:2440],prg2[2435:2432],
                  prg2[2427:2424],prg2[2419:2416],prg2[2411:2408],prg2[2403:2400],prg2[2395:2392],prg2[2387:2384],prg2[2379:2376],prg2[2371:2368],
                  prg2[2363:2360],prg2[2355:2352],prg2[2347:2344],prg2[2339:2336],prg2[2331:2328],prg2[2323:2320],prg2[2315:2312],prg2[2307:2304],
                  prg2[2299:2296],prg2[2291:2288],prg2[2283:2280],prg2[2275:2272],prg2[2267:2264],prg2[2259:2256],prg2[2251:2248],prg2[2243:2240],
                  prg2[2235:2232],prg2[2227:2224],prg2[2219:2216],prg2[2211:2208],prg2[2203:2200],prg2[2195:2192],prg2[2187:2184],prg2[2179:2176],
                  prg2[2171:2168],prg2[2163:2160],prg2[2155:2152],prg2[2147:2144],prg2[2139:2136],prg2[2131:2128],prg2[2123:2120],prg2[2115:2112],
                  prg2[2107:2104],prg2[2099:2096],prg2[2091:2088],prg2[2083:2080],prg2[2075:2072],prg2[2067:2064],prg2[2059:2056],prg2[2051:2048],
                  prg2[2043:2040],prg2[2035:2032],prg2[2027:2024],prg2[2019:2016],prg2[2011:2008],prg2[2003:2000],prg2[1995:1992],prg2[1987:1984],
                  prg2[1979:1976],prg2[1971:1968],prg2[1963:1960],prg2[1955:1952],prg2[1947:1944],prg2[1939:1936],prg2[1931:1928],prg2[1923:1920],
                  prg2[1915:1912],prg2[1907:1904],prg2[1899:1896],prg2[1891:1888],prg2[1883:1880],prg2[1875:1872],prg2[1867:1864],prg2[1859:1856],
                  prg2[1851:1848],prg2[1843:1840],prg2[1835:1832],prg2[1827:1824],prg2[1819:1816],prg2[1811:1808],prg2[1803:1800],prg2[1795:1792],
                  prg2[1787:1784],prg2[1779:1776],prg2[1771:1768],prg2[1763:1760],prg2[1755:1752],prg2[1747:1744],prg2[1739:1736],prg2[1731:1728],
                  prg2[1723:1720],prg2[1715:1712],prg2[1707:1704],prg2[1699:1696],prg2[1691:1688],prg2[1683:1680],prg2[1675:1672],prg2[1667:1664],
                  prg2[1659:1656],prg2[1651:1648],prg2[1643:1640],prg2[1635:1632],prg2[1627:1624],prg2[1619:1616],prg2[1611:1608],prg2[1603:1600],
                  prg2[1595:1592],prg2[1587:1584],prg2[1579:1576],prg2[1571:1568],prg2[1563:1560],prg2[1555:1552],prg2[1547:1544],prg2[1539:1536],
                  prg2[1531:1528],prg2[1523:1520],prg2[1515:1512],prg2[1507:1504],prg2[1499:1496],prg2[1491:1488],prg2[1483:1480],prg2[1475:1472],
                  prg2[1467:1464],prg2[1459:1456],prg2[1451:1448],prg2[1443:1440],prg2[1435:1432],prg2[1427:1424],prg2[1419:1416],prg2[1411:1408],
                  prg2[1403:1400],prg2[1395:1392],prg2[1387:1384],prg2[1379:1376],prg2[1371:1368],prg2[1363:1360],prg2[1355:1352],prg2[1347:1344],
                  prg2[1339:1336],prg2[1331:1328],prg2[1323:1320],prg2[1315:1312],prg2[1307:1304],prg2[1299:1296],prg2[1291:1288],prg2[1283:1280],
                  prg2[1275:1272],prg2[1267:1264],prg2[1259:1256],prg2[1251:1248],prg2[1243:1240],prg2[1235:1232],prg2[1227:1224],prg2[1219:1216],
                  prg2[1211:1208],prg2[1203:1200],prg2[1195:1192],prg2[1187:1184],prg2[1179:1176],prg2[1171:1168],prg2[1163:1160],prg2[1155:1152],
                  prg2[1147:1144],prg2[1139:1136],prg2[1131:1128],prg2[1123:1120],prg2[1115:1112],prg2[1107:1104],prg2[1099:1096],prg2[1091:1088],
                  prg2[1083:1080],prg2[1075:1072],prg2[1067:1064],prg2[1059:1056],prg2[1051:1048],prg2[1043:1040],prg2[1035:1032],prg2[1027:1024],
                  prg2[1019:1016],prg2[1011:1008],prg2[1003:1000],prg2[ 995: 992],prg2[ 987: 984],prg2[ 979: 976],prg2[ 971: 968],prg2[ 963: 960],
                  prg2[ 955: 952],prg2[ 947: 944],prg2[ 939: 936],prg2[ 931: 928],prg2[ 923: 920],prg2[ 915: 912],prg2[ 907: 904],prg2[ 899: 896],
                  prg2[ 891: 888],prg2[ 883: 880],prg2[ 875: 872],prg2[ 867: 864],prg2[ 859: 856],prg2[ 851: 848],prg2[ 843: 840],prg2[ 835: 832],
                  prg2[ 827: 824],prg2[ 819: 816],prg2[ 811: 808],prg2[ 803: 800],prg2[ 795: 792],prg2[ 787: 784],prg2[ 779: 776],prg2[ 771: 768],
                  prg2[ 763: 760],prg2[ 755: 752],prg2[ 747: 744],prg2[ 739: 736],prg2[ 731: 728],prg2[ 723: 720],prg2[ 715: 712],prg2[ 707: 704],
                  prg2[ 699: 696],prg2[ 691: 688],prg2[ 683: 680],prg2[ 675: 672],prg2[ 667: 664],prg2[ 659: 656],prg2[ 651: 648],prg2[ 643: 640],
                  prg2[ 635: 632],prg2[ 627: 624],prg2[ 619: 616],prg2[ 611: 608],prg2[ 603: 600],prg2[ 595: 592],prg2[ 587: 584],prg2[ 579: 576],
                  prg2[ 571: 568],prg2[ 563: 560],prg2[ 555: 552],prg2[ 547: 544],prg2[ 539: 536],prg2[ 531: 528],prg2[ 523: 520],prg2[ 515: 512],
                  prg2[ 507: 504],prg2[ 499: 496],prg2[ 491: 488],prg2[ 483: 480],prg2[ 475: 472],prg2[ 467: 464],prg2[ 459: 456],prg2[ 451: 448],
                  prg2[ 443: 440],prg2[ 435: 432],prg2[ 427: 424],prg2[ 419: 416],prg2[ 411: 408],prg2[ 403: 400],prg2[ 395: 392],prg2[ 387: 384],
                  prg2[ 379: 376],prg2[ 371: 368],prg2[ 363: 360],prg2[ 355: 352],prg2[ 347: 344],prg2[ 339: 336],prg2[ 331: 328],prg2[ 323: 320],
                  prg2[ 315: 312],prg2[ 307: 304],prg2[ 299: 296],prg2[ 291: 288],prg2[ 283: 280],prg2[ 275: 272],prg2[ 267: 264],prg2[ 259: 256],
                  prg2[ 251: 248],prg2[ 243: 240],prg2[ 235: 232],prg2[ 227: 224],prg2[ 219: 216],prg2[ 211: 208],prg2[ 203: 200],prg2[ 195: 192],
                  prg2[ 187: 184],prg2[ 179: 176],prg2[ 171: 168],prg2[ 163: 160],prg2[ 155: 152],prg2[ 147: 144],prg2[ 139: 136],prg2[ 131: 128],
                  prg2[ 123: 120],prg2[ 115: 112],prg2[ 107: 104],prg2[  99:  96],prg2[  91:  88],prg2[  83:  80],prg2[  75:  72],prg2[  67:  64],
                  prg2[  59:  56],prg2[  51:  48],prg2[  43:  40],prg2[  35:  32],prg2[  27:  24],prg2[  19:  16],prg2[  11:   8],prg2[   3:   0]};
         localparam [4095:0]
           pb0 = {prg1[4091:4088],prg1[4083:4080],prg1[4075:4072],prg1[4067:4064],prg1[4059:4056],prg1[4051:4048],prg1[4043:4040],prg1[4035:4032],
                  prg1[4027:4024],prg1[4019:4016],prg1[4011:4008],prg1[4003:4000],prg1[3995:3992],prg1[3987:3984],prg1[3979:3976],prg1[3971:3968],
                  prg1[3963:3960],prg1[3955:3952],prg1[3947:3944],prg1[3939:3936],prg1[3931:3928],prg1[3923:3920],prg1[3915:3912],prg1[3907:3904],
                  prg1[3899:3896],prg1[3891:3888],prg1[3883:3880],prg1[3875:3872],prg1[3867:3864],prg1[3859:3856],prg1[3851:3848],prg1[3843:3840],
                  prg1[3835:3832],prg1[3827:3824],prg1[3819:3816],prg1[3811:3808],prg1[3803:3800],prg1[3795:3792],prg1[3787:3784],prg1[3779:3776],
                  prg1[3771:3768],prg1[3763:3760],prg1[3755:3752],prg1[3747:3744],prg1[3739:3736],prg1[3731:3728],prg1[3723:3720],prg1[3715:3712],
                  prg1[3707:3704],prg1[3699:3696],prg1[3691:3688],prg1[3683:3680],prg1[3675:3672],prg1[3667:3664],prg1[3659:3656],prg1[3651:3648],
                  prg1[3643:3640],prg1[3635:3632],prg1[3627:3624],prg1[3619:3616],prg1[3611:3608],prg1[3603:3600],prg1[3595:3592],prg1[3587:3584],
                  prg1[3579:3576],prg1[3571:3568],prg1[3563:3560],prg1[3555:3552],prg1[3547:3544],prg1[3539:3536],prg1[3531:3528],prg1[3523:3520],
                  prg1[3515:3512],prg1[3507:3504],prg1[3499:3496],prg1[3491:3488],prg1[3483:3480],prg1[3475:3472],prg1[3467:3464],prg1[3459:3456],
                  prg1[3451:3448],prg1[3443:3440],prg1[3435:3432],prg1[3427:3424],prg1[3419:3416],prg1[3411:3408],prg1[3403:3400],prg1[3395:3392],
                  prg1[3387:3384],prg1[3379:3376],prg1[3371:3368],prg1[3363:3360],prg1[3355:3352],prg1[3347:3344],prg1[3339:3336],prg1[3331:3328],
                  prg1[3323:3320],prg1[3315:3312],prg1[3307:3304],prg1[3299:3296],prg1[3291:3288],prg1[3283:3280],prg1[3275:3272],prg1[3267:3264],
                  prg1[3259:3256],prg1[3251:3248],prg1[3243:3240],prg1[3235:3232],prg1[3227:3224],prg1[3219:3216],prg1[3211:3208],prg1[3203:3200],
                  prg1[3195:3192],prg1[3187:3184],prg1[3179:3176],prg1[3171:3168],prg1[3163:3160],prg1[3155:3152],prg1[3147:3144],prg1[3139:3136],
                  prg1[3131:3128],prg1[3123:3120],prg1[3115:3112],prg1[3107:3104],prg1[3099:3096],prg1[3091:3088],prg1[3083:3080],prg1[3075:3072],
                  prg1[3067:3064],prg1[3059:3056],prg1[3051:3048],prg1[3043:3040],prg1[3035:3032],prg1[3027:3024],prg1[3019:3016],prg1[3011:3008],
                  prg1[3003:3000],prg1[2995:2992],prg1[2987:2984],prg1[2979:2976],prg1[2971:2968],prg1[2963:2960],prg1[2955:2952],prg1[2947:2944],
                  prg1[2939:2936],prg1[2931:2928],prg1[2923:2920],prg1[2915:2912],prg1[2907:2904],prg1[2899:2896],prg1[2891:2888],prg1[2883:2880],
                  prg1[2875:2872],prg1[2867:2864],prg1[2859:2856],prg1[2851:2848],prg1[2843:2840],prg1[2835:2832],prg1[2827:2824],prg1[2819:2816],
                  prg1[2811:2808],prg1[2803:2800],prg1[2795:2792],prg1[2787:2784],prg1[2779:2776],prg1[2771:2768],prg1[2763:2760],prg1[2755:2752],
                  prg1[2747:2744],prg1[2739:2736],prg1[2731:2728],prg1[2723:2720],prg1[2715:2712],prg1[2707:2704],prg1[2699:2696],prg1[2691:2688],
                  prg1[2683:2680],prg1[2675:2672],prg1[2667:2664],prg1[2659:2656],prg1[2651:2648],prg1[2643:2640],prg1[2635:2632],prg1[2627:2624],
                  prg1[2619:2616],prg1[2611:2608],prg1[2603:2600],prg1[2595:2592],prg1[2587:2584],prg1[2579:2576],prg1[2571:2568],prg1[2563:2560],
                  prg1[2555:2552],prg1[2547:2544],prg1[2539:2536],prg1[2531:2528],prg1[2523:2520],prg1[2515:2512],prg1[2507:2504],prg1[2499:2496],
                  prg1[2491:2488],prg1[2483:2480],prg1[2475:2472],prg1[2467:2464],prg1[2459:2456],prg1[2451:2448],prg1[2443:2440],prg1[2435:2432],
                  prg1[2427:2424],prg1[2419:2416],prg1[2411:2408],prg1[2403:2400],prg1[2395:2392],prg1[2387:2384],prg1[2379:2376],prg1[2371:2368],
                  prg1[2363:2360],prg1[2355:2352],prg1[2347:2344],prg1[2339:2336],prg1[2331:2328],prg1[2323:2320],prg1[2315:2312],prg1[2307:2304],
                  prg1[2299:2296],prg1[2291:2288],prg1[2283:2280],prg1[2275:2272],prg1[2267:2264],prg1[2259:2256],prg1[2251:2248],prg1[2243:2240],
                  prg1[2235:2232],prg1[2227:2224],prg1[2219:2216],prg1[2211:2208],prg1[2203:2200],prg1[2195:2192],prg1[2187:2184],prg1[2179:2176],
                  prg1[2171:2168],prg1[2163:2160],prg1[2155:2152],prg1[2147:2144],prg1[2139:2136],prg1[2131:2128],prg1[2123:2120],prg1[2115:2112],
                  prg1[2107:2104],prg1[2099:2096],prg1[2091:2088],prg1[2083:2080],prg1[2075:2072],prg1[2067:2064],prg1[2059:2056],prg1[2051:2048],
                  prg1[2043:2040],prg1[2035:2032],prg1[2027:2024],prg1[2019:2016],prg1[2011:2008],prg1[2003:2000],prg1[1995:1992],prg1[1987:1984],
                  prg1[1979:1976],prg1[1971:1968],prg1[1963:1960],prg1[1955:1952],prg1[1947:1944],prg1[1939:1936],prg1[1931:1928],prg1[1923:1920],
                  prg1[1915:1912],prg1[1907:1904],prg1[1899:1896],prg1[1891:1888],prg1[1883:1880],prg1[1875:1872],prg1[1867:1864],prg1[1859:1856],
                  prg1[1851:1848],prg1[1843:1840],prg1[1835:1832],prg1[1827:1824],prg1[1819:1816],prg1[1811:1808],prg1[1803:1800],prg1[1795:1792],
                  prg1[1787:1784],prg1[1779:1776],prg1[1771:1768],prg1[1763:1760],prg1[1755:1752],prg1[1747:1744],prg1[1739:1736],prg1[1731:1728],
                  prg1[1723:1720],prg1[1715:1712],prg1[1707:1704],prg1[1699:1696],prg1[1691:1688],prg1[1683:1680],prg1[1675:1672],prg1[1667:1664],
                  prg1[1659:1656],prg1[1651:1648],prg1[1643:1640],prg1[1635:1632],prg1[1627:1624],prg1[1619:1616],prg1[1611:1608],prg1[1603:1600],
                  prg1[1595:1592],prg1[1587:1584],prg1[1579:1576],prg1[1571:1568],prg1[1563:1560],prg1[1555:1552],prg1[1547:1544],prg1[1539:1536],
                  prg1[1531:1528],prg1[1523:1520],prg1[1515:1512],prg1[1507:1504],prg1[1499:1496],prg1[1491:1488],prg1[1483:1480],prg1[1475:1472],
                  prg1[1467:1464],prg1[1459:1456],prg1[1451:1448],prg1[1443:1440],prg1[1435:1432],prg1[1427:1424],prg1[1419:1416],prg1[1411:1408],
                  prg1[1403:1400],prg1[1395:1392],prg1[1387:1384],prg1[1379:1376],prg1[1371:1368],prg1[1363:1360],prg1[1355:1352],prg1[1347:1344],
                  prg1[1339:1336],prg1[1331:1328],prg1[1323:1320],prg1[1315:1312],prg1[1307:1304],prg1[1299:1296],prg1[1291:1288],prg1[1283:1280],
                  prg1[1275:1272],prg1[1267:1264],prg1[1259:1256],prg1[1251:1248],prg1[1243:1240],prg1[1235:1232],prg1[1227:1224],prg1[1219:1216],
                  prg1[1211:1208],prg1[1203:1200],prg1[1195:1192],prg1[1187:1184],prg1[1179:1176],prg1[1171:1168],prg1[1163:1160],prg1[1155:1152],
                  prg1[1147:1144],prg1[1139:1136],prg1[1131:1128],prg1[1123:1120],prg1[1115:1112],prg1[1107:1104],prg1[1099:1096],prg1[1091:1088],
                  prg1[1083:1080],prg1[1075:1072],prg1[1067:1064],prg1[1059:1056],prg1[1051:1048],prg1[1043:1040],prg1[1035:1032],prg1[1027:1024],
                  prg1[1019:1016],prg1[1011:1008],prg1[1003:1000],prg1[ 995: 992],prg1[ 987: 984],prg1[ 979: 976],prg1[ 971: 968],prg1[ 963: 960],
                  prg1[ 955: 952],prg1[ 947: 944],prg1[ 939: 936],prg1[ 931: 928],prg1[ 923: 920],prg1[ 915: 912],prg1[ 907: 904],prg1[ 899: 896],
                  prg1[ 891: 888],prg1[ 883: 880],prg1[ 875: 872],prg1[ 867: 864],prg1[ 859: 856],prg1[ 851: 848],prg1[ 843: 840],prg1[ 835: 832],
                  prg1[ 827: 824],prg1[ 819: 816],prg1[ 811: 808],prg1[ 803: 800],prg1[ 795: 792],prg1[ 787: 784],prg1[ 779: 776],prg1[ 771: 768],
                  prg1[ 763: 760],prg1[ 755: 752],prg1[ 747: 744],prg1[ 739: 736],prg1[ 731: 728],prg1[ 723: 720],prg1[ 715: 712],prg1[ 707: 704],
                  prg1[ 699: 696],prg1[ 691: 688],prg1[ 683: 680],prg1[ 675: 672],prg1[ 667: 664],prg1[ 659: 656],prg1[ 651: 648],prg1[ 643: 640],
                  prg1[ 635: 632],prg1[ 627: 624],prg1[ 619: 616],prg1[ 611: 608],prg1[ 603: 600],prg1[ 595: 592],prg1[ 587: 584],prg1[ 579: 576],
                  prg1[ 571: 568],prg1[ 563: 560],prg1[ 555: 552],prg1[ 547: 544],prg1[ 539: 536],prg1[ 531: 528],prg1[ 523: 520],prg1[ 515: 512],
                  prg1[ 507: 504],prg1[ 499: 496],prg1[ 491: 488],prg1[ 483: 480],prg1[ 475: 472],prg1[ 467: 464],prg1[ 459: 456],prg1[ 451: 448],
                  prg1[ 443: 440],prg1[ 435: 432],prg1[ 427: 424],prg1[ 419: 416],prg1[ 411: 408],prg1[ 403: 400],prg1[ 395: 392],prg1[ 387: 384],
                  prg1[ 379: 376],prg1[ 371: 368],prg1[ 363: 360],prg1[ 355: 352],prg1[ 347: 344],prg1[ 339: 336],prg1[ 331: 328],prg1[ 323: 320],
                  prg1[ 315: 312],prg1[ 307: 304],prg1[ 299: 296],prg1[ 291: 288],prg1[ 283: 280],prg1[ 275: 272],prg1[ 267: 264],prg1[ 259: 256],
                  prg1[ 251: 248],prg1[ 243: 240],prg1[ 235: 232],prg1[ 227: 224],prg1[ 219: 216],prg1[ 211: 208],prg1[ 203: 200],prg1[ 195: 192],
                  prg1[ 187: 184],prg1[ 179: 176],prg1[ 171: 168],prg1[ 163: 160],prg1[ 155: 152],prg1[ 147: 144],prg1[ 139: 136],prg1[ 131: 128],
                  prg1[ 123: 120],prg1[ 115: 112],prg1[ 107: 104],prg1[  99:  96],prg1[  91:  88],prg1[  83:  80],prg1[  75:  72],prg1[  67:  64],
                  prg1[  59:  56],prg1[  51:  48],prg1[  43:  40],prg1[  35:  32],prg1[  27:  24],prg1[  19:  16],prg1[  11:   8],prg1[   3:   0],
                  prg0[4091:4088],prg0[4083:4080],prg0[4075:4072],prg0[4067:4064],prg0[4059:4056],prg0[4051:4048],prg0[4043:4040],prg0[4035:4032],
                  prg0[4027:4024],prg0[4019:4016],prg0[4011:4008],prg0[4003:4000],prg0[3995:3992],prg0[3987:3984],prg0[3979:3976],prg0[3971:3968],
                  prg0[3963:3960],prg0[3955:3952],prg0[3947:3944],prg0[3939:3936],prg0[3931:3928],prg0[3923:3920],prg0[3915:3912],prg0[3907:3904],
                  prg0[3899:3896],prg0[3891:3888],prg0[3883:3880],prg0[3875:3872],prg0[3867:3864],prg0[3859:3856],prg0[3851:3848],prg0[3843:3840],
                  prg0[3835:3832],prg0[3827:3824],prg0[3819:3816],prg0[3811:3808],prg0[3803:3800],prg0[3795:3792],prg0[3787:3784],prg0[3779:3776],
                  prg0[3771:3768],prg0[3763:3760],prg0[3755:3752],prg0[3747:3744],prg0[3739:3736],prg0[3731:3728],prg0[3723:3720],prg0[3715:3712],
                  prg0[3707:3704],prg0[3699:3696],prg0[3691:3688],prg0[3683:3680],prg0[3675:3672],prg0[3667:3664],prg0[3659:3656],prg0[3651:3648],
                  prg0[3643:3640],prg0[3635:3632],prg0[3627:3624],prg0[3619:3616],prg0[3611:3608],prg0[3603:3600],prg0[3595:3592],prg0[3587:3584],
                  prg0[3579:3576],prg0[3571:3568],prg0[3563:3560],prg0[3555:3552],prg0[3547:3544],prg0[3539:3536],prg0[3531:3528],prg0[3523:3520],
                  prg0[3515:3512],prg0[3507:3504],prg0[3499:3496],prg0[3491:3488],prg0[3483:3480],prg0[3475:3472],prg0[3467:3464],prg0[3459:3456],
                  prg0[3451:3448],prg0[3443:3440],prg0[3435:3432],prg0[3427:3424],prg0[3419:3416],prg0[3411:3408],prg0[3403:3400],prg0[3395:3392],
                  prg0[3387:3384],prg0[3379:3376],prg0[3371:3368],prg0[3363:3360],prg0[3355:3352],prg0[3347:3344],prg0[3339:3336],prg0[3331:3328],
                  prg0[3323:3320],prg0[3315:3312],prg0[3307:3304],prg0[3299:3296],prg0[3291:3288],prg0[3283:3280],prg0[3275:3272],prg0[3267:3264],
                  prg0[3259:3256],prg0[3251:3248],prg0[3243:3240],prg0[3235:3232],prg0[3227:3224],prg0[3219:3216],prg0[3211:3208],prg0[3203:3200],
                  prg0[3195:3192],prg0[3187:3184],prg0[3179:3176],prg0[3171:3168],prg0[3163:3160],prg0[3155:3152],prg0[3147:3144],prg0[3139:3136],
                  prg0[3131:3128],prg0[3123:3120],prg0[3115:3112],prg0[3107:3104],prg0[3099:3096],prg0[3091:3088],prg0[3083:3080],prg0[3075:3072],
                  prg0[3067:3064],prg0[3059:3056],prg0[3051:3048],prg0[3043:3040],prg0[3035:3032],prg0[3027:3024],prg0[3019:3016],prg0[3011:3008],
                  prg0[3003:3000],prg0[2995:2992],prg0[2987:2984],prg0[2979:2976],prg0[2971:2968],prg0[2963:2960],prg0[2955:2952],prg0[2947:2944],
                  prg0[2939:2936],prg0[2931:2928],prg0[2923:2920],prg0[2915:2912],prg0[2907:2904],prg0[2899:2896],prg0[2891:2888],prg0[2883:2880],
                  prg0[2875:2872],prg0[2867:2864],prg0[2859:2856],prg0[2851:2848],prg0[2843:2840],prg0[2835:2832],prg0[2827:2824],prg0[2819:2816],
                  prg0[2811:2808],prg0[2803:2800],prg0[2795:2792],prg0[2787:2784],prg0[2779:2776],prg0[2771:2768],prg0[2763:2760],prg0[2755:2752],
                  prg0[2747:2744],prg0[2739:2736],prg0[2731:2728],prg0[2723:2720],prg0[2715:2712],prg0[2707:2704],prg0[2699:2696],prg0[2691:2688],
                  prg0[2683:2680],prg0[2675:2672],prg0[2667:2664],prg0[2659:2656],prg0[2651:2648],prg0[2643:2640],prg0[2635:2632],prg0[2627:2624],
                  prg0[2619:2616],prg0[2611:2608],prg0[2603:2600],prg0[2595:2592],prg0[2587:2584],prg0[2579:2576],prg0[2571:2568],prg0[2563:2560],
                  prg0[2555:2552],prg0[2547:2544],prg0[2539:2536],prg0[2531:2528],prg0[2523:2520],prg0[2515:2512],prg0[2507:2504],prg0[2499:2496],
                  prg0[2491:2488],prg0[2483:2480],prg0[2475:2472],prg0[2467:2464],prg0[2459:2456],prg0[2451:2448],prg0[2443:2440],prg0[2435:2432],
                  prg0[2427:2424],prg0[2419:2416],prg0[2411:2408],prg0[2403:2400],prg0[2395:2392],prg0[2387:2384],prg0[2379:2376],prg0[2371:2368],
                  prg0[2363:2360],prg0[2355:2352],prg0[2347:2344],prg0[2339:2336],prg0[2331:2328],prg0[2323:2320],prg0[2315:2312],prg0[2307:2304],
                  prg0[2299:2296],prg0[2291:2288],prg0[2283:2280],prg0[2275:2272],prg0[2267:2264],prg0[2259:2256],prg0[2251:2248],prg0[2243:2240],
                  prg0[2235:2232],prg0[2227:2224],prg0[2219:2216],prg0[2211:2208],prg0[2203:2200],prg0[2195:2192],prg0[2187:2184],prg0[2179:2176],
                  prg0[2171:2168],prg0[2163:2160],prg0[2155:2152],prg0[2147:2144],prg0[2139:2136],prg0[2131:2128],prg0[2123:2120],prg0[2115:2112],
                  prg0[2107:2104],prg0[2099:2096],prg0[2091:2088],prg0[2083:2080],prg0[2075:2072],prg0[2067:2064],prg0[2059:2056],prg0[2051:2048],
                  prg0[2043:2040],prg0[2035:2032],prg0[2027:2024],prg0[2019:2016],prg0[2011:2008],prg0[2003:2000],prg0[1995:1992],prg0[1987:1984],
                  prg0[1979:1976],prg0[1971:1968],prg0[1963:1960],prg0[1955:1952],prg0[1947:1944],prg0[1939:1936],prg0[1931:1928],prg0[1923:1920],
                  prg0[1915:1912],prg0[1907:1904],prg0[1899:1896],prg0[1891:1888],prg0[1883:1880],prg0[1875:1872],prg0[1867:1864],prg0[1859:1856],
                  prg0[1851:1848],prg0[1843:1840],prg0[1835:1832],prg0[1827:1824],prg0[1819:1816],prg0[1811:1808],prg0[1803:1800],prg0[1795:1792],
                  prg0[1787:1784],prg0[1779:1776],prg0[1771:1768],prg0[1763:1760],prg0[1755:1752],prg0[1747:1744],prg0[1739:1736],prg0[1731:1728],
                  prg0[1723:1720],prg0[1715:1712],prg0[1707:1704],prg0[1699:1696],prg0[1691:1688],prg0[1683:1680],prg0[1675:1672],prg0[1667:1664],
                  prg0[1659:1656],prg0[1651:1648],prg0[1643:1640],prg0[1635:1632],prg0[1627:1624],prg0[1619:1616],prg0[1611:1608],prg0[1603:1600],
                  prg0[1595:1592],prg0[1587:1584],prg0[1579:1576],prg0[1571:1568],prg0[1563:1560],prg0[1555:1552],prg0[1547:1544],prg0[1539:1536],
                  prg0[1531:1528],prg0[1523:1520],prg0[1515:1512],prg0[1507:1504],prg0[1499:1496],prg0[1491:1488],prg0[1483:1480],prg0[1475:1472],
                  prg0[1467:1464],prg0[1459:1456],prg0[1451:1448],prg0[1443:1440],prg0[1435:1432],prg0[1427:1424],prg0[1419:1416],prg0[1411:1408],
                  prg0[1403:1400],prg0[1395:1392],prg0[1387:1384],prg0[1379:1376],prg0[1371:1368],prg0[1363:1360],prg0[1355:1352],prg0[1347:1344],
                  prg0[1339:1336],prg0[1331:1328],prg0[1323:1320],prg0[1315:1312],prg0[1307:1304],prg0[1299:1296],prg0[1291:1288],prg0[1283:1280],
                  prg0[1275:1272],prg0[1267:1264],prg0[1259:1256],prg0[1251:1248],prg0[1243:1240],prg0[1235:1232],prg0[1227:1224],prg0[1219:1216],
                  prg0[1211:1208],prg0[1203:1200],prg0[1195:1192],prg0[1187:1184],prg0[1179:1176],prg0[1171:1168],prg0[1163:1160],prg0[1155:1152],
                  prg0[1147:1144],prg0[1139:1136],prg0[1131:1128],prg0[1123:1120],prg0[1115:1112],prg0[1107:1104],prg0[1099:1096],prg0[1091:1088],
                  prg0[1083:1080],prg0[1075:1072],prg0[1067:1064],prg0[1059:1056],prg0[1051:1048],prg0[1043:1040],prg0[1035:1032],prg0[1027:1024],
                  prg0[1019:1016],prg0[1011:1008],prg0[1003:1000],prg0[ 995: 992],prg0[ 987: 984],prg0[ 979: 976],prg0[ 971: 968],prg0[ 963: 960],
                  prg0[ 955: 952],prg0[ 947: 944],prg0[ 939: 936],prg0[ 931: 928],prg0[ 923: 920],prg0[ 915: 912],prg0[ 907: 904],prg0[ 899: 896],
                  prg0[ 891: 888],prg0[ 883: 880],prg0[ 875: 872],prg0[ 867: 864],prg0[ 859: 856],prg0[ 851: 848],prg0[ 843: 840],prg0[ 835: 832],
                  prg0[ 827: 824],prg0[ 819: 816],prg0[ 811: 808],prg0[ 803: 800],prg0[ 795: 792],prg0[ 787: 784],prg0[ 779: 776],prg0[ 771: 768],
                  prg0[ 763: 760],prg0[ 755: 752],prg0[ 747: 744],prg0[ 739: 736],prg0[ 731: 728],prg0[ 723: 720],prg0[ 715: 712],prg0[ 707: 704],
                  prg0[ 699: 696],prg0[ 691: 688],prg0[ 683: 680],prg0[ 675: 672],prg0[ 667: 664],prg0[ 659: 656],prg0[ 651: 648],prg0[ 643: 640],
                  prg0[ 635: 632],prg0[ 627: 624],prg0[ 619: 616],prg0[ 611: 608],prg0[ 603: 600],prg0[ 595: 592],prg0[ 587: 584],prg0[ 579: 576],
                  prg0[ 571: 568],prg0[ 563: 560],prg0[ 555: 552],prg0[ 547: 544],prg0[ 539: 536],prg0[ 531: 528],prg0[ 523: 520],prg0[ 515: 512],
                  prg0[ 507: 504],prg0[ 499: 496],prg0[ 491: 488],prg0[ 483: 480],prg0[ 475: 472],prg0[ 467: 464],prg0[ 459: 456],prg0[ 451: 448],
                  prg0[ 443: 440],prg0[ 435: 432],prg0[ 427: 424],prg0[ 419: 416],prg0[ 411: 408],prg0[ 403: 400],prg0[ 395: 392],prg0[ 387: 384],
                  prg0[ 379: 376],prg0[ 371: 368],prg0[ 363: 360],prg0[ 355: 352],prg0[ 347: 344],prg0[ 339: 336],prg0[ 331: 328],prg0[ 323: 320],
                  prg0[ 315: 312],prg0[ 307: 304],prg0[ 299: 296],prg0[ 291: 288],prg0[ 283: 280],prg0[ 275: 272],prg0[ 267: 264],prg0[ 259: 256],
                  prg0[ 251: 248],prg0[ 243: 240],prg0[ 235: 232],prg0[ 227: 224],prg0[ 219: 216],prg0[ 211: 208],prg0[ 203: 200],prg0[ 195: 192],
                  prg0[ 187: 184],prg0[ 179: 176],prg0[ 171: 168],prg0[ 163: 160],prg0[ 155: 152],prg0[ 147: 144],prg0[ 139: 136],prg0[ 131: 128],
                  prg0[ 123: 120],prg0[ 115: 112],prg0[ 107: 104],prg0[  99:  96],prg0[  91:  88],prg0[  83:  80],prg0[  75:  72],prg0[  67:  64],
                  prg0[  59:  56],prg0[  51:  48],prg0[  43:  40],prg0[  35:  32],prg0[  27:  24],prg0[  19:  16],prg0[  11:   8],prg0[   3:   0]};
         localparam [4095:0]
           ph1 = {prg3[4095:4092],prg3[4087:4084],prg3[4079:4076],prg3[4071:4068],prg3[4063:4060],prg3[4055:4052],prg3[4047:4044],prg3[4039:4036],
                  prg3[4031:4028],prg3[4023:4020],prg3[4015:4012],prg3[4007:4004],prg3[3999:3996],prg3[3991:3988],prg3[3983:3980],prg3[3975:3972],
                  prg3[3967:3964],prg3[3959:3956],prg3[3951:3948],prg3[3943:3940],prg3[3935:3932],prg3[3927:3924],prg3[3919:3916],prg3[3911:3908],
                  prg3[3903:3900],prg3[3895:3892],prg3[3887:3884],prg3[3879:3876],prg3[3871:3868],prg3[3863:3860],prg3[3855:3852],prg3[3847:3844],
                  prg3[3839:3836],prg3[3831:3828],prg3[3823:3820],prg3[3815:3812],prg3[3807:3804],prg3[3799:3796],prg3[3791:3788],prg3[3783:3780],
                  prg3[3775:3772],prg3[3767:3764],prg3[3759:3756],prg3[3751:3748],prg3[3743:3740],prg3[3735:3732],prg3[3727:3724],prg3[3719:3716],
                  prg3[3711:3708],prg3[3703:3700],prg3[3695:3692],prg3[3687:3684],prg3[3679:3676],prg3[3671:3668],prg3[3663:3660],prg3[3655:3652],
                  prg3[3647:3644],prg3[3639:3636],prg3[3631:3628],prg3[3623:3620],prg3[3615:3612],prg3[3607:3604],prg3[3599:3596],prg3[3591:3588],
                  prg3[3583:3580],prg3[3575:3572],prg3[3567:3564],prg3[3559:3556],prg3[3551:3548],prg3[3543:3540],prg3[3535:3532],prg3[3527:3524],
                  prg3[3519:3516],prg3[3511:3508],prg3[3503:3500],prg3[3495:3492],prg3[3487:3484],prg3[3479:3476],prg3[3471:3468],prg3[3463:3460],
                  prg3[3455:3452],prg3[3447:3444],prg3[3439:3436],prg3[3431:3428],prg3[3423:3420],prg3[3415:3412],prg3[3407:3404],prg3[3399:3396],
                  prg3[3391:3388],prg3[3383:3380],prg3[3375:3372],prg3[3367:3364],prg3[3359:3356],prg3[3351:3348],prg3[3343:3340],prg3[3335:3332],
                  prg3[3327:3324],prg3[3319:3316],prg3[3311:3308],prg3[3303:3300],prg3[3295:3292],prg3[3287:3284],prg3[3279:3276],prg3[3271:3268],
                  prg3[3263:3260],prg3[3255:3252],prg3[3247:3244],prg3[3239:3236],prg3[3231:3228],prg3[3223:3220],prg3[3215:3212],prg3[3207:3204],
                  prg3[3199:3196],prg3[3191:3188],prg3[3183:3180],prg3[3175:3172],prg3[3167:3164],prg3[3159:3156],prg3[3151:3148],prg3[3143:3140],
                  prg3[3135:3132],prg3[3127:3124],prg3[3119:3116],prg3[3111:3108],prg3[3103:3100],prg3[3095:3092],prg3[3087:3084],prg3[3079:3076],
                  prg3[3071:3068],prg3[3063:3060],prg3[3055:3052],prg3[3047:3044],prg3[3039:3036],prg3[3031:3028],prg3[3023:3020],prg3[3015:3012],
                  prg3[3007:3004],prg3[2999:2996],prg3[2991:2988],prg3[2983:2980],prg3[2975:2972],prg3[2967:2964],prg3[2959:2956],prg3[2951:2948],
                  prg3[2943:2940],prg3[2935:2932],prg3[2927:2924],prg3[2919:2916],prg3[2911:2908],prg3[2903:2900],prg3[2895:2892],prg3[2887:2884],
                  prg3[2879:2876],prg3[2871:2868],prg3[2863:2860],prg3[2855:2852],prg3[2847:2844],prg3[2839:2836],prg3[2831:2828],prg3[2823:2820],
                  prg3[2815:2812],prg3[2807:2804],prg3[2799:2796],prg3[2791:2788],prg3[2783:2780],prg3[2775:2772],prg3[2767:2764],prg3[2759:2756],
                  prg3[2751:2748],prg3[2743:2740],prg3[2735:2732],prg3[2727:2724],prg3[2719:2716],prg3[2711:2708],prg3[2703:2700],prg3[2695:2692],
                  prg3[2687:2684],prg3[2679:2676],prg3[2671:2668],prg3[2663:2660],prg3[2655:2652],prg3[2647:2644],prg3[2639:2636],prg3[2631:2628],
                  prg3[2623:2620],prg3[2615:2612],prg3[2607:2604],prg3[2599:2596],prg3[2591:2588],prg3[2583:2580],prg3[2575:2572],prg3[2567:2564],
                  prg3[2559:2556],prg3[2551:2548],prg3[2543:2540],prg3[2535:2532],prg3[2527:2524],prg3[2519:2516],prg3[2511:2508],prg3[2503:2500],
                  prg3[2495:2492],prg3[2487:2484],prg3[2479:2476],prg3[2471:2468],prg3[2463:2460],prg3[2455:2452],prg3[2447:2444],prg3[2439:2436],
                  prg3[2431:2428],prg3[2423:2420],prg3[2415:2412],prg3[2407:2404],prg3[2399:2396],prg3[2391:2388],prg3[2383:2380],prg3[2375:2372],
                  prg3[2367:2364],prg3[2359:2356],prg3[2351:2348],prg3[2343:2340],prg3[2335:2332],prg3[2327:2324],prg3[2319:2316],prg3[2311:2308],
                  prg3[2303:2300],prg3[2295:2292],prg3[2287:2284],prg3[2279:2276],prg3[2271:2268],prg3[2263:2260],prg3[2255:2252],prg3[2247:2244],
                  prg3[2239:2236],prg3[2231:2228],prg3[2223:2220],prg3[2215:2212],prg3[2207:2204],prg3[2199:2196],prg3[2191:2188],prg3[2183:2180],
                  prg3[2175:2172],prg3[2167:2164],prg3[2159:2156],prg3[2151:2148],prg3[2143:2140],prg3[2135:2132],prg3[2127:2124],prg3[2119:2116],
                  prg3[2111:2108],prg3[2103:2100],prg3[2095:2092],prg3[2087:2084],prg3[2079:2076],prg3[2071:2068],prg3[2063:2060],prg3[2055:2052],
                  prg3[2047:2044],prg3[2039:2036],prg3[2031:2028],prg3[2023:2020],prg3[2015:2012],prg3[2007:2004],prg3[1999:1996],prg3[1991:1988],
                  prg3[1983:1980],prg3[1975:1972],prg3[1967:1964],prg3[1959:1956],prg3[1951:1948],prg3[1943:1940],prg3[1935:1932],prg3[1927:1924],
                  prg3[1919:1916],prg3[1911:1908],prg3[1903:1900],prg3[1895:1892],prg3[1887:1884],prg3[1879:1876],prg3[1871:1868],prg3[1863:1860],
                  prg3[1855:1852],prg3[1847:1844],prg3[1839:1836],prg3[1831:1828],prg3[1823:1820],prg3[1815:1812],prg3[1807:1804],prg3[1799:1796],
                  prg3[1791:1788],prg3[1783:1780],prg3[1775:1772],prg3[1767:1764],prg3[1759:1756],prg3[1751:1748],prg3[1743:1740],prg3[1735:1732],
                  prg3[1727:1724],prg3[1719:1716],prg3[1711:1708],prg3[1703:1700],prg3[1695:1692],prg3[1687:1684],prg3[1679:1676],prg3[1671:1668],
                  prg3[1663:1660],prg3[1655:1652],prg3[1647:1644],prg3[1639:1636],prg3[1631:1628],prg3[1623:1620],prg3[1615:1612],prg3[1607:1604],
                  prg3[1599:1596],prg3[1591:1588],prg3[1583:1580],prg3[1575:1572],prg3[1567:1564],prg3[1559:1556],prg3[1551:1548],prg3[1543:1540],
                  prg3[1535:1532],prg3[1527:1524],prg3[1519:1516],prg3[1511:1508],prg3[1503:1500],prg3[1495:1492],prg3[1487:1484],prg3[1479:1476],
                  prg3[1471:1468],prg3[1463:1460],prg3[1455:1452],prg3[1447:1444],prg3[1439:1436],prg3[1431:1428],prg3[1423:1420],prg3[1415:1412],
                  prg3[1407:1404],prg3[1399:1396],prg3[1391:1388],prg3[1383:1380],prg3[1375:1372],prg3[1367:1364],prg3[1359:1356],prg3[1351:1348],
                  prg3[1343:1340],prg3[1335:1332],prg3[1327:1324],prg3[1319:1316],prg3[1311:1308],prg3[1303:1300],prg3[1295:1292],prg3[1287:1284],
                  prg3[1279:1276],prg3[1271:1268],prg3[1263:1260],prg3[1255:1252],prg3[1247:1244],prg3[1239:1236],prg3[1231:1228],prg3[1223:1220],
                  prg3[1215:1212],prg3[1207:1204],prg3[1199:1196],prg3[1191:1188],prg3[1183:1180],prg3[1175:1172],prg3[1167:1164],prg3[1159:1156],
                  prg3[1151:1148],prg3[1143:1140],prg3[1135:1132],prg3[1127:1124],prg3[1119:1116],prg3[1111:1108],prg3[1103:1100],prg3[1095:1092],
                  prg3[1087:1084],prg3[1079:1076],prg3[1071:1068],prg3[1063:1060],prg3[1055:1052],prg3[1047:1044],prg3[1039:1036],prg3[1031:1028],
                  prg3[1023:1020],prg3[1015:1012],prg3[1007:1004],prg3[ 999: 996],prg3[ 991: 988],prg3[ 983: 980],prg3[ 975: 972],prg3[ 967: 964],
                  prg3[ 959: 956],prg3[ 951: 948],prg3[ 943: 940],prg3[ 935: 932],prg3[ 927: 924],prg3[ 919: 916],prg3[ 911: 908],prg3[ 903: 900],
                  prg3[ 895: 892],prg3[ 887: 884],prg3[ 879: 876],prg3[ 871: 868],prg3[ 863: 860],prg3[ 855: 852],prg3[ 847: 844],prg3[ 839: 836],
                  prg3[ 831: 828],prg3[ 823: 820],prg3[ 815: 812],prg3[ 807: 804],prg3[ 799: 796],prg3[ 791: 788],prg3[ 783: 780],prg3[ 775: 772],
                  prg3[ 767: 764],prg3[ 759: 756],prg3[ 751: 748],prg3[ 743: 740],prg3[ 735: 732],prg3[ 727: 724],prg3[ 719: 716],prg3[ 711: 708],
                  prg3[ 703: 700],prg3[ 695: 692],prg3[ 687: 684],prg3[ 679: 676],prg3[ 671: 668],prg3[ 663: 660],prg3[ 655: 652],prg3[ 647: 644],
                  prg3[ 639: 636],prg3[ 631: 628],prg3[ 623: 620],prg3[ 615: 612],prg3[ 607: 604],prg3[ 599: 596],prg3[ 591: 588],prg3[ 583: 580],
                  prg3[ 575: 572],prg3[ 567: 564],prg3[ 559: 556],prg3[ 551: 548],prg3[ 543: 540],prg3[ 535: 532],prg3[ 527: 524],prg3[ 519: 516],
                  prg3[ 511: 508],prg3[ 503: 500],prg3[ 495: 492],prg3[ 487: 484],prg3[ 479: 476],prg3[ 471: 468],prg3[ 463: 460],prg3[ 455: 452],
                  prg3[ 447: 444],prg3[ 439: 436],prg3[ 431: 428],prg3[ 423: 420],prg3[ 415: 412],prg3[ 407: 404],prg3[ 399: 396],prg3[ 391: 388],
                  prg3[ 383: 380],prg3[ 375: 372],prg3[ 367: 364],prg3[ 359: 356],prg3[ 351: 348],prg3[ 343: 340],prg3[ 335: 332],prg3[ 327: 324],
                  prg3[ 319: 316],prg3[ 311: 308],prg3[ 303: 300],prg3[ 295: 292],prg3[ 287: 284],prg3[ 279: 276],prg3[ 271: 268],prg3[ 263: 260],
                  prg3[ 255: 252],prg3[ 247: 244],prg3[ 239: 236],prg3[ 231: 228],prg3[ 223: 220],prg3[ 215: 212],prg3[ 207: 204],prg3[ 199: 196],
                  prg3[ 191: 188],prg3[ 183: 180],prg3[ 175: 172],prg3[ 167: 164],prg3[ 159: 156],prg3[ 151: 148],prg3[ 143: 140],prg3[ 135: 132],
                  prg3[ 127: 124],prg3[ 119: 116],prg3[ 111: 108],prg3[ 103: 100],prg3[  95:  92],prg3[  87:  84],prg3[  79:  76],prg3[  71:  68],
                  prg3[  63:  60],prg3[  55:  52],prg3[  47:  44],prg3[  39:  36],prg3[  31:  28],prg3[  23:  20],prg3[  15:  12],prg3[   7:   4],
                  prg2[4095:4092],prg2[4087:4084],prg2[4079:4076],prg2[4071:4068],prg2[4063:4060],prg2[4055:4052],prg2[4047:4044],prg2[4039:4036],
                  prg2[4031:4028],prg2[4023:4020],prg2[4015:4012],prg2[4007:4004],prg2[3999:3996],prg2[3991:3988],prg2[3983:3980],prg2[3975:3972],
                  prg2[3967:3964],prg2[3959:3956],prg2[3951:3948],prg2[3943:3940],prg2[3935:3932],prg2[3927:3924],prg2[3919:3916],prg2[3911:3908],
                  prg2[3903:3900],prg2[3895:3892],prg2[3887:3884],prg2[3879:3876],prg2[3871:3868],prg2[3863:3860],prg2[3855:3852],prg2[3847:3844],
                  prg2[3839:3836],prg2[3831:3828],prg2[3823:3820],prg2[3815:3812],prg2[3807:3804],prg2[3799:3796],prg2[3791:3788],prg2[3783:3780],
                  prg2[3775:3772],prg2[3767:3764],prg2[3759:3756],prg2[3751:3748],prg2[3743:3740],prg2[3735:3732],prg2[3727:3724],prg2[3719:3716],
                  prg2[3711:3708],prg2[3703:3700],prg2[3695:3692],prg2[3687:3684],prg2[3679:3676],prg2[3671:3668],prg2[3663:3660],prg2[3655:3652],
                  prg2[3647:3644],prg2[3639:3636],prg2[3631:3628],prg2[3623:3620],prg2[3615:3612],prg2[3607:3604],prg2[3599:3596],prg2[3591:3588],
                  prg2[3583:3580],prg2[3575:3572],prg2[3567:3564],prg2[3559:3556],prg2[3551:3548],prg2[3543:3540],prg2[3535:3532],prg2[3527:3524],
                  prg2[3519:3516],prg2[3511:3508],prg2[3503:3500],prg2[3495:3492],prg2[3487:3484],prg2[3479:3476],prg2[3471:3468],prg2[3463:3460],
                  prg2[3455:3452],prg2[3447:3444],prg2[3439:3436],prg2[3431:3428],prg2[3423:3420],prg2[3415:3412],prg2[3407:3404],prg2[3399:3396],
                  prg2[3391:3388],prg2[3383:3380],prg2[3375:3372],prg2[3367:3364],prg2[3359:3356],prg2[3351:3348],prg2[3343:3340],prg2[3335:3332],
                  prg2[3327:3324],prg2[3319:3316],prg2[3311:3308],prg2[3303:3300],prg2[3295:3292],prg2[3287:3284],prg2[3279:3276],prg2[3271:3268],
                  prg2[3263:3260],prg2[3255:3252],prg2[3247:3244],prg2[3239:3236],prg2[3231:3228],prg2[3223:3220],prg2[3215:3212],prg2[3207:3204],
                  prg2[3199:3196],prg2[3191:3188],prg2[3183:3180],prg2[3175:3172],prg2[3167:3164],prg2[3159:3156],prg2[3151:3148],prg2[3143:3140],
                  prg2[3135:3132],prg2[3127:3124],prg2[3119:3116],prg2[3111:3108],prg2[3103:3100],prg2[3095:3092],prg2[3087:3084],prg2[3079:3076],
                  prg2[3071:3068],prg2[3063:3060],prg2[3055:3052],prg2[3047:3044],prg2[3039:3036],prg2[3031:3028],prg2[3023:3020],prg2[3015:3012],
                  prg2[3007:3004],prg2[2999:2996],prg2[2991:2988],prg2[2983:2980],prg2[2975:2972],prg2[2967:2964],prg2[2959:2956],prg2[2951:2948],
                  prg2[2943:2940],prg2[2935:2932],prg2[2927:2924],prg2[2919:2916],prg2[2911:2908],prg2[2903:2900],prg2[2895:2892],prg2[2887:2884],
                  prg2[2879:2876],prg2[2871:2868],prg2[2863:2860],prg2[2855:2852],prg2[2847:2844],prg2[2839:2836],prg2[2831:2828],prg2[2823:2820],
                  prg2[2815:2812],prg2[2807:2804],prg2[2799:2796],prg2[2791:2788],prg2[2783:2780],prg2[2775:2772],prg2[2767:2764],prg2[2759:2756],
                  prg2[2751:2748],prg2[2743:2740],prg2[2735:2732],prg2[2727:2724],prg2[2719:2716],prg2[2711:2708],prg2[2703:2700],prg2[2695:2692],
                  prg2[2687:2684],prg2[2679:2676],prg2[2671:2668],prg2[2663:2660],prg2[2655:2652],prg2[2647:2644],prg2[2639:2636],prg2[2631:2628],
                  prg2[2623:2620],prg2[2615:2612],prg2[2607:2604],prg2[2599:2596],prg2[2591:2588],prg2[2583:2580],prg2[2575:2572],prg2[2567:2564],
                  prg2[2559:2556],prg2[2551:2548],prg2[2543:2540],prg2[2535:2532],prg2[2527:2524],prg2[2519:2516],prg2[2511:2508],prg2[2503:2500],
                  prg2[2495:2492],prg2[2487:2484],prg2[2479:2476],prg2[2471:2468],prg2[2463:2460],prg2[2455:2452],prg2[2447:2444],prg2[2439:2436],
                  prg2[2431:2428],prg2[2423:2420],prg2[2415:2412],prg2[2407:2404],prg2[2399:2396],prg2[2391:2388],prg2[2383:2380],prg2[2375:2372],
                  prg2[2367:2364],prg2[2359:2356],prg2[2351:2348],prg2[2343:2340],prg2[2335:2332],prg2[2327:2324],prg2[2319:2316],prg2[2311:2308],
                  prg2[2303:2300],prg2[2295:2292],prg2[2287:2284],prg2[2279:2276],prg2[2271:2268],prg2[2263:2260],prg2[2255:2252],prg2[2247:2244],
                  prg2[2239:2236],prg2[2231:2228],prg2[2223:2220],prg2[2215:2212],prg2[2207:2204],prg2[2199:2196],prg2[2191:2188],prg2[2183:2180],
                  prg2[2175:2172],prg2[2167:2164],prg2[2159:2156],prg2[2151:2148],prg2[2143:2140],prg2[2135:2132],prg2[2127:2124],prg2[2119:2116],
                  prg2[2111:2108],prg2[2103:2100],prg2[2095:2092],prg2[2087:2084],prg2[2079:2076],prg2[2071:2068],prg2[2063:2060],prg2[2055:2052],
                  prg2[2047:2044],prg2[2039:2036],prg2[2031:2028],prg2[2023:2020],prg2[2015:2012],prg2[2007:2004],prg2[1999:1996],prg2[1991:1988],
                  prg2[1983:1980],prg2[1975:1972],prg2[1967:1964],prg2[1959:1956],prg2[1951:1948],prg2[1943:1940],prg2[1935:1932],prg2[1927:1924],
                  prg2[1919:1916],prg2[1911:1908],prg2[1903:1900],prg2[1895:1892],prg2[1887:1884],prg2[1879:1876],prg2[1871:1868],prg2[1863:1860],
                  prg2[1855:1852],prg2[1847:1844],prg2[1839:1836],prg2[1831:1828],prg2[1823:1820],prg2[1815:1812],prg2[1807:1804],prg2[1799:1796],
                  prg2[1791:1788],prg2[1783:1780],prg2[1775:1772],prg2[1767:1764],prg2[1759:1756],prg2[1751:1748],prg2[1743:1740],prg2[1735:1732],
                  prg2[1727:1724],prg2[1719:1716],prg2[1711:1708],prg2[1703:1700],prg2[1695:1692],prg2[1687:1684],prg2[1679:1676],prg2[1671:1668],
                  prg2[1663:1660],prg2[1655:1652],prg2[1647:1644],prg2[1639:1636],prg2[1631:1628],prg2[1623:1620],prg2[1615:1612],prg2[1607:1604],
                  prg2[1599:1596],prg2[1591:1588],prg2[1583:1580],prg2[1575:1572],prg2[1567:1564],prg2[1559:1556],prg2[1551:1548],prg2[1543:1540],
                  prg2[1535:1532],prg2[1527:1524],prg2[1519:1516],prg2[1511:1508],prg2[1503:1500],prg2[1495:1492],prg2[1487:1484],prg2[1479:1476],
                  prg2[1471:1468],prg2[1463:1460],prg2[1455:1452],prg2[1447:1444],prg2[1439:1436],prg2[1431:1428],prg2[1423:1420],prg2[1415:1412],
                  prg2[1407:1404],prg2[1399:1396],prg2[1391:1388],prg2[1383:1380],prg2[1375:1372],prg2[1367:1364],prg2[1359:1356],prg2[1351:1348],
                  prg2[1343:1340],prg2[1335:1332],prg2[1327:1324],prg2[1319:1316],prg2[1311:1308],prg2[1303:1300],prg2[1295:1292],prg2[1287:1284],
                  prg2[1279:1276],prg2[1271:1268],prg2[1263:1260],prg2[1255:1252],prg2[1247:1244],prg2[1239:1236],prg2[1231:1228],prg2[1223:1220],
                  prg2[1215:1212],prg2[1207:1204],prg2[1199:1196],prg2[1191:1188],prg2[1183:1180],prg2[1175:1172],prg2[1167:1164],prg2[1159:1156],
                  prg2[1151:1148],prg2[1143:1140],prg2[1135:1132],prg2[1127:1124],prg2[1119:1116],prg2[1111:1108],prg2[1103:1100],prg2[1095:1092],
                  prg2[1087:1084],prg2[1079:1076],prg2[1071:1068],prg2[1063:1060],prg2[1055:1052],prg2[1047:1044],prg2[1039:1036],prg2[1031:1028],
                  prg2[1023:1020],prg2[1015:1012],prg2[1007:1004],prg2[ 999: 996],prg2[ 991: 988],prg2[ 983: 980],prg2[ 975: 972],prg2[ 967: 964],
                  prg2[ 959: 956],prg2[ 951: 948],prg2[ 943: 940],prg2[ 935: 932],prg2[ 927: 924],prg2[ 919: 916],prg2[ 911: 908],prg2[ 903: 900],
                  prg2[ 895: 892],prg2[ 887: 884],prg2[ 879: 876],prg2[ 871: 868],prg2[ 863: 860],prg2[ 855: 852],prg2[ 847: 844],prg2[ 839: 836],
                  prg2[ 831: 828],prg2[ 823: 820],prg2[ 815: 812],prg2[ 807: 804],prg2[ 799: 796],prg2[ 791: 788],prg2[ 783: 780],prg2[ 775: 772],
                  prg2[ 767: 764],prg2[ 759: 756],prg2[ 751: 748],prg2[ 743: 740],prg2[ 735: 732],prg2[ 727: 724],prg2[ 719: 716],prg2[ 711: 708],
                  prg2[ 703: 700],prg2[ 695: 692],prg2[ 687: 684],prg2[ 679: 676],prg2[ 671: 668],prg2[ 663: 660],prg2[ 655: 652],prg2[ 647: 644],
                  prg2[ 639: 636],prg2[ 631: 628],prg2[ 623: 620],prg2[ 615: 612],prg2[ 607: 604],prg2[ 599: 596],prg2[ 591: 588],prg2[ 583: 580],
                  prg2[ 575: 572],prg2[ 567: 564],prg2[ 559: 556],prg2[ 551: 548],prg2[ 543: 540],prg2[ 535: 532],prg2[ 527: 524],prg2[ 519: 516],
                  prg2[ 511: 508],prg2[ 503: 500],prg2[ 495: 492],prg2[ 487: 484],prg2[ 479: 476],prg2[ 471: 468],prg2[ 463: 460],prg2[ 455: 452],
                  prg2[ 447: 444],prg2[ 439: 436],prg2[ 431: 428],prg2[ 423: 420],prg2[ 415: 412],prg2[ 407: 404],prg2[ 399: 396],prg2[ 391: 388],
                  prg2[ 383: 380],prg2[ 375: 372],prg2[ 367: 364],prg2[ 359: 356],prg2[ 351: 348],prg2[ 343: 340],prg2[ 335: 332],prg2[ 327: 324],
                  prg2[ 319: 316],prg2[ 311: 308],prg2[ 303: 300],prg2[ 295: 292],prg2[ 287: 284],prg2[ 279: 276],prg2[ 271: 268],prg2[ 263: 260],
                  prg2[ 255: 252],prg2[ 247: 244],prg2[ 239: 236],prg2[ 231: 228],prg2[ 223: 220],prg2[ 215: 212],prg2[ 207: 204],prg2[ 199: 196],
                  prg2[ 191: 188],prg2[ 183: 180],prg2[ 175: 172],prg2[ 167: 164],prg2[ 159: 156],prg2[ 151: 148],prg2[ 143: 140],prg2[ 135: 132],
                  prg2[ 127: 124],prg2[ 119: 116],prg2[ 111: 108],prg2[ 103: 100],prg2[  95:  92],prg2[  87:  84],prg2[  79:  76],prg2[  71:  68],
                  prg2[  63:  60],prg2[  55:  52],prg2[  47:  44],prg2[  39:  36],prg2[  31:  28],prg2[  23:  20],prg2[  15:  12],prg2[   7:   4]};
         localparam [4095:0]
           ph0 = {prg1[4095:4092],prg1[4087:4084],prg1[4079:4076],prg1[4071:4068],prg1[4063:4060],prg1[4055:4052],prg1[4047:4044],prg1[4039:4036],
                  prg1[4031:4028],prg1[4023:4020],prg1[4015:4012],prg1[4007:4004],prg1[3999:3996],prg1[3991:3988],prg1[3983:3980],prg1[3975:3972],
                  prg1[3967:3964],prg1[3959:3956],prg1[3951:3948],prg1[3943:3940],prg1[3935:3932],prg1[3927:3924],prg1[3919:3916],prg1[3911:3908],
                  prg1[3903:3900],prg1[3895:3892],prg1[3887:3884],prg1[3879:3876],prg1[3871:3868],prg1[3863:3860],prg1[3855:3852],prg1[3847:3844],
                  prg1[3839:3836],prg1[3831:3828],prg1[3823:3820],prg1[3815:3812],prg1[3807:3804],prg1[3799:3796],prg1[3791:3788],prg1[3783:3780],
                  prg1[3775:3772],prg1[3767:3764],prg1[3759:3756],prg1[3751:3748],prg1[3743:3740],prg1[3735:3732],prg1[3727:3724],prg1[3719:3716],
                  prg1[3711:3708],prg1[3703:3700],prg1[3695:3692],prg1[3687:3684],prg1[3679:3676],prg1[3671:3668],prg1[3663:3660],prg1[3655:3652],
                  prg1[3647:3644],prg1[3639:3636],prg1[3631:3628],prg1[3623:3620],prg1[3615:3612],prg1[3607:3604],prg1[3599:3596],prg1[3591:3588],
                  prg1[3583:3580],prg1[3575:3572],prg1[3567:3564],prg1[3559:3556],prg1[3551:3548],prg1[3543:3540],prg1[3535:3532],prg1[3527:3524],
                  prg1[3519:3516],prg1[3511:3508],prg1[3503:3500],prg1[3495:3492],prg1[3487:3484],prg1[3479:3476],prg1[3471:3468],prg1[3463:3460],
                  prg1[3455:3452],prg1[3447:3444],prg1[3439:3436],prg1[3431:3428],prg1[3423:3420],prg1[3415:3412],prg1[3407:3404],prg1[3399:3396],
                  prg1[3391:3388],prg1[3383:3380],prg1[3375:3372],prg1[3367:3364],prg1[3359:3356],prg1[3351:3348],prg1[3343:3340],prg1[3335:3332],
                  prg1[3327:3324],prg1[3319:3316],prg1[3311:3308],prg1[3303:3300],prg1[3295:3292],prg1[3287:3284],prg1[3279:3276],prg1[3271:3268],
                  prg1[3263:3260],prg1[3255:3252],prg1[3247:3244],prg1[3239:3236],prg1[3231:3228],prg1[3223:3220],prg1[3215:3212],prg1[3207:3204],
                  prg1[3199:3196],prg1[3191:3188],prg1[3183:3180],prg1[3175:3172],prg1[3167:3164],prg1[3159:3156],prg1[3151:3148],prg1[3143:3140],
                  prg1[3135:3132],prg1[3127:3124],prg1[3119:3116],prg1[3111:3108],prg1[3103:3100],prg1[3095:3092],prg1[3087:3084],prg1[3079:3076],
                  prg1[3071:3068],prg1[3063:3060],prg1[3055:3052],prg1[3047:3044],prg1[3039:3036],prg1[3031:3028],prg1[3023:3020],prg1[3015:3012],
                  prg1[3007:3004],prg1[2999:2996],prg1[2991:2988],prg1[2983:2980],prg1[2975:2972],prg1[2967:2964],prg1[2959:2956],prg1[2951:2948],
                  prg1[2943:2940],prg1[2935:2932],prg1[2927:2924],prg1[2919:2916],prg1[2911:2908],prg1[2903:2900],prg1[2895:2892],prg1[2887:2884],
                  prg1[2879:2876],prg1[2871:2868],prg1[2863:2860],prg1[2855:2852],prg1[2847:2844],prg1[2839:2836],prg1[2831:2828],prg1[2823:2820],
                  prg1[2815:2812],prg1[2807:2804],prg1[2799:2796],prg1[2791:2788],prg1[2783:2780],prg1[2775:2772],prg1[2767:2764],prg1[2759:2756],
                  prg1[2751:2748],prg1[2743:2740],prg1[2735:2732],prg1[2727:2724],prg1[2719:2716],prg1[2711:2708],prg1[2703:2700],prg1[2695:2692],
                  prg1[2687:2684],prg1[2679:2676],prg1[2671:2668],prg1[2663:2660],prg1[2655:2652],prg1[2647:2644],prg1[2639:2636],prg1[2631:2628],
                  prg1[2623:2620],prg1[2615:2612],prg1[2607:2604],prg1[2599:2596],prg1[2591:2588],prg1[2583:2580],prg1[2575:2572],prg1[2567:2564],
                  prg1[2559:2556],prg1[2551:2548],prg1[2543:2540],prg1[2535:2532],prg1[2527:2524],prg1[2519:2516],prg1[2511:2508],prg1[2503:2500],
                  prg1[2495:2492],prg1[2487:2484],prg1[2479:2476],prg1[2471:2468],prg1[2463:2460],prg1[2455:2452],prg1[2447:2444],prg1[2439:2436],
                  prg1[2431:2428],prg1[2423:2420],prg1[2415:2412],prg1[2407:2404],prg1[2399:2396],prg1[2391:2388],prg1[2383:2380],prg1[2375:2372],
                  prg1[2367:2364],prg1[2359:2356],prg1[2351:2348],prg1[2343:2340],prg1[2335:2332],prg1[2327:2324],prg1[2319:2316],prg1[2311:2308],
                  prg1[2303:2300],prg1[2295:2292],prg1[2287:2284],prg1[2279:2276],prg1[2271:2268],prg1[2263:2260],prg1[2255:2252],prg1[2247:2244],
                  prg1[2239:2236],prg1[2231:2228],prg1[2223:2220],prg1[2215:2212],prg1[2207:2204],prg1[2199:2196],prg1[2191:2188],prg1[2183:2180],
                  prg1[2175:2172],prg1[2167:2164],prg1[2159:2156],prg1[2151:2148],prg1[2143:2140],prg1[2135:2132],prg1[2127:2124],prg1[2119:2116],
                  prg1[2111:2108],prg1[2103:2100],prg1[2095:2092],prg1[2087:2084],prg1[2079:2076],prg1[2071:2068],prg1[2063:2060],prg1[2055:2052],
                  prg1[2047:2044],prg1[2039:2036],prg1[2031:2028],prg1[2023:2020],prg1[2015:2012],prg1[2007:2004],prg1[1999:1996],prg1[1991:1988],
                  prg1[1983:1980],prg1[1975:1972],prg1[1967:1964],prg1[1959:1956],prg1[1951:1948],prg1[1943:1940],prg1[1935:1932],prg1[1927:1924],
                  prg1[1919:1916],prg1[1911:1908],prg1[1903:1900],prg1[1895:1892],prg1[1887:1884],prg1[1879:1876],prg1[1871:1868],prg1[1863:1860],
                  prg1[1855:1852],prg1[1847:1844],prg1[1839:1836],prg1[1831:1828],prg1[1823:1820],prg1[1815:1812],prg1[1807:1804],prg1[1799:1796],
                  prg1[1791:1788],prg1[1783:1780],prg1[1775:1772],prg1[1767:1764],prg1[1759:1756],prg1[1751:1748],prg1[1743:1740],prg1[1735:1732],
                  prg1[1727:1724],prg1[1719:1716],prg1[1711:1708],prg1[1703:1700],prg1[1695:1692],prg1[1687:1684],prg1[1679:1676],prg1[1671:1668],
                  prg1[1663:1660],prg1[1655:1652],prg1[1647:1644],prg1[1639:1636],prg1[1631:1628],prg1[1623:1620],prg1[1615:1612],prg1[1607:1604],
                  prg1[1599:1596],prg1[1591:1588],prg1[1583:1580],prg1[1575:1572],prg1[1567:1564],prg1[1559:1556],prg1[1551:1548],prg1[1543:1540],
                  prg1[1535:1532],prg1[1527:1524],prg1[1519:1516],prg1[1511:1508],prg1[1503:1500],prg1[1495:1492],prg1[1487:1484],prg1[1479:1476],
                  prg1[1471:1468],prg1[1463:1460],prg1[1455:1452],prg1[1447:1444],prg1[1439:1436],prg1[1431:1428],prg1[1423:1420],prg1[1415:1412],
                  prg1[1407:1404],prg1[1399:1396],prg1[1391:1388],prg1[1383:1380],prg1[1375:1372],prg1[1367:1364],prg1[1359:1356],prg1[1351:1348],
                  prg1[1343:1340],prg1[1335:1332],prg1[1327:1324],prg1[1319:1316],prg1[1311:1308],prg1[1303:1300],prg1[1295:1292],prg1[1287:1284],
                  prg1[1279:1276],prg1[1271:1268],prg1[1263:1260],prg1[1255:1252],prg1[1247:1244],prg1[1239:1236],prg1[1231:1228],prg1[1223:1220],
                  prg1[1215:1212],prg1[1207:1204],prg1[1199:1196],prg1[1191:1188],prg1[1183:1180],prg1[1175:1172],prg1[1167:1164],prg1[1159:1156],
                  prg1[1151:1148],prg1[1143:1140],prg1[1135:1132],prg1[1127:1124],prg1[1119:1116],prg1[1111:1108],prg1[1103:1100],prg1[1095:1092],
                  prg1[1087:1084],prg1[1079:1076],prg1[1071:1068],prg1[1063:1060],prg1[1055:1052],prg1[1047:1044],prg1[1039:1036],prg1[1031:1028],
                  prg1[1023:1020],prg1[1015:1012],prg1[1007:1004],prg1[ 999: 996],prg1[ 991: 988],prg1[ 983: 980],prg1[ 975: 972],prg1[ 967: 964],
                  prg1[ 959: 956],prg1[ 951: 948],prg1[ 943: 940],prg1[ 935: 932],prg1[ 927: 924],prg1[ 919: 916],prg1[ 911: 908],prg1[ 903: 900],
                  prg1[ 895: 892],prg1[ 887: 884],prg1[ 879: 876],prg1[ 871: 868],prg1[ 863: 860],prg1[ 855: 852],prg1[ 847: 844],prg1[ 839: 836],
                  prg1[ 831: 828],prg1[ 823: 820],prg1[ 815: 812],prg1[ 807: 804],prg1[ 799: 796],prg1[ 791: 788],prg1[ 783: 780],prg1[ 775: 772],
                  prg1[ 767: 764],prg1[ 759: 756],prg1[ 751: 748],prg1[ 743: 740],prg1[ 735: 732],prg1[ 727: 724],prg1[ 719: 716],prg1[ 711: 708],
                  prg1[ 703: 700],prg1[ 695: 692],prg1[ 687: 684],prg1[ 679: 676],prg1[ 671: 668],prg1[ 663: 660],prg1[ 655: 652],prg1[ 647: 644],
                  prg1[ 639: 636],prg1[ 631: 628],prg1[ 623: 620],prg1[ 615: 612],prg1[ 607: 604],prg1[ 599: 596],prg1[ 591: 588],prg1[ 583: 580],
                  prg1[ 575: 572],prg1[ 567: 564],prg1[ 559: 556],prg1[ 551: 548],prg1[ 543: 540],prg1[ 535: 532],prg1[ 527: 524],prg1[ 519: 516],
                  prg1[ 511: 508],prg1[ 503: 500],prg1[ 495: 492],prg1[ 487: 484],prg1[ 479: 476],prg1[ 471: 468],prg1[ 463: 460],prg1[ 455: 452],
                  prg1[ 447: 444],prg1[ 439: 436],prg1[ 431: 428],prg1[ 423: 420],prg1[ 415: 412],prg1[ 407: 404],prg1[ 399: 396],prg1[ 391: 388],
                  prg1[ 383: 380],prg1[ 375: 372],prg1[ 367: 364],prg1[ 359: 356],prg1[ 351: 348],prg1[ 343: 340],prg1[ 335: 332],prg1[ 327: 324],
                  prg1[ 319: 316],prg1[ 311: 308],prg1[ 303: 300],prg1[ 295: 292],prg1[ 287: 284],prg1[ 279: 276],prg1[ 271: 268],prg1[ 263: 260],
                  prg1[ 255: 252],prg1[ 247: 244],prg1[ 239: 236],prg1[ 231: 228],prg1[ 223: 220],prg1[ 215: 212],prg1[ 207: 204],prg1[ 199: 196],
                  prg1[ 191: 188],prg1[ 183: 180],prg1[ 175: 172],prg1[ 167: 164],prg1[ 159: 156],prg1[ 151: 148],prg1[ 143: 140],prg1[ 135: 132],
                  prg1[ 127: 124],prg1[ 119: 116],prg1[ 111: 108],prg1[ 103: 100],prg1[  95:  92],prg1[  87:  84],prg1[  79:  76],prg1[  71:  68],
                  prg1[  63:  60],prg1[  55:  52],prg1[  47:  44],prg1[  39:  36],prg1[  31:  28],prg1[  23:  20],prg1[  15:  12],prg1[   7:   4],
                  prg0[4095:4092],prg0[4087:4084],prg0[4079:4076],prg0[4071:4068],prg0[4063:4060],prg0[4055:4052],prg0[4047:4044],prg0[4039:4036],
                  prg0[4031:4028],prg0[4023:4020],prg0[4015:4012],prg0[4007:4004],prg0[3999:3996],prg0[3991:3988],prg0[3983:3980],prg0[3975:3972],
                  prg0[3967:3964],prg0[3959:3956],prg0[3951:3948],prg0[3943:3940],prg0[3935:3932],prg0[3927:3924],prg0[3919:3916],prg0[3911:3908],
                  prg0[3903:3900],prg0[3895:3892],prg0[3887:3884],prg0[3879:3876],prg0[3871:3868],prg0[3863:3860],prg0[3855:3852],prg0[3847:3844],
                  prg0[3839:3836],prg0[3831:3828],prg0[3823:3820],prg0[3815:3812],prg0[3807:3804],prg0[3799:3796],prg0[3791:3788],prg0[3783:3780],
                  prg0[3775:3772],prg0[3767:3764],prg0[3759:3756],prg0[3751:3748],prg0[3743:3740],prg0[3735:3732],prg0[3727:3724],prg0[3719:3716],
                  prg0[3711:3708],prg0[3703:3700],prg0[3695:3692],prg0[3687:3684],prg0[3679:3676],prg0[3671:3668],prg0[3663:3660],prg0[3655:3652],
                  prg0[3647:3644],prg0[3639:3636],prg0[3631:3628],prg0[3623:3620],prg0[3615:3612],prg0[3607:3604],prg0[3599:3596],prg0[3591:3588],
                  prg0[3583:3580],prg0[3575:3572],prg0[3567:3564],prg0[3559:3556],prg0[3551:3548],prg0[3543:3540],prg0[3535:3532],prg0[3527:3524],
                  prg0[3519:3516],prg0[3511:3508],prg0[3503:3500],prg0[3495:3492],prg0[3487:3484],prg0[3479:3476],prg0[3471:3468],prg0[3463:3460],
                  prg0[3455:3452],prg0[3447:3444],prg0[3439:3436],prg0[3431:3428],prg0[3423:3420],prg0[3415:3412],prg0[3407:3404],prg0[3399:3396],
                  prg0[3391:3388],prg0[3383:3380],prg0[3375:3372],prg0[3367:3364],prg0[3359:3356],prg0[3351:3348],prg0[3343:3340],prg0[3335:3332],
                  prg0[3327:3324],prg0[3319:3316],prg0[3311:3308],prg0[3303:3300],prg0[3295:3292],prg0[3287:3284],prg0[3279:3276],prg0[3271:3268],
                  prg0[3263:3260],prg0[3255:3252],prg0[3247:3244],prg0[3239:3236],prg0[3231:3228],prg0[3223:3220],prg0[3215:3212],prg0[3207:3204],
                  prg0[3199:3196],prg0[3191:3188],prg0[3183:3180],prg0[3175:3172],prg0[3167:3164],prg0[3159:3156],prg0[3151:3148],prg0[3143:3140],
                  prg0[3135:3132],prg0[3127:3124],prg0[3119:3116],prg0[3111:3108],prg0[3103:3100],prg0[3095:3092],prg0[3087:3084],prg0[3079:3076],
                  prg0[3071:3068],prg0[3063:3060],prg0[3055:3052],prg0[3047:3044],prg0[3039:3036],prg0[3031:3028],prg0[3023:3020],prg0[3015:3012],
                  prg0[3007:3004],prg0[2999:2996],prg0[2991:2988],prg0[2983:2980],prg0[2975:2972],prg0[2967:2964],prg0[2959:2956],prg0[2951:2948],
                  prg0[2943:2940],prg0[2935:2932],prg0[2927:2924],prg0[2919:2916],prg0[2911:2908],prg0[2903:2900],prg0[2895:2892],prg0[2887:2884],
                  prg0[2879:2876],prg0[2871:2868],prg0[2863:2860],prg0[2855:2852],prg0[2847:2844],prg0[2839:2836],prg0[2831:2828],prg0[2823:2820],
                  prg0[2815:2812],prg0[2807:2804],prg0[2799:2796],prg0[2791:2788],prg0[2783:2780],prg0[2775:2772],prg0[2767:2764],prg0[2759:2756],
                  prg0[2751:2748],prg0[2743:2740],prg0[2735:2732],prg0[2727:2724],prg0[2719:2716],prg0[2711:2708],prg0[2703:2700],prg0[2695:2692],
                  prg0[2687:2684],prg0[2679:2676],prg0[2671:2668],prg0[2663:2660],prg0[2655:2652],prg0[2647:2644],prg0[2639:2636],prg0[2631:2628],
                  prg0[2623:2620],prg0[2615:2612],prg0[2607:2604],prg0[2599:2596],prg0[2591:2588],prg0[2583:2580],prg0[2575:2572],prg0[2567:2564],
                  prg0[2559:2556],prg0[2551:2548],prg0[2543:2540],prg0[2535:2532],prg0[2527:2524],prg0[2519:2516],prg0[2511:2508],prg0[2503:2500],
                  prg0[2495:2492],prg0[2487:2484],prg0[2479:2476],prg0[2471:2468],prg0[2463:2460],prg0[2455:2452],prg0[2447:2444],prg0[2439:2436],
                  prg0[2431:2428],prg0[2423:2420],prg0[2415:2412],prg0[2407:2404],prg0[2399:2396],prg0[2391:2388],prg0[2383:2380],prg0[2375:2372],
                  prg0[2367:2364],prg0[2359:2356],prg0[2351:2348],prg0[2343:2340],prg0[2335:2332],prg0[2327:2324],prg0[2319:2316],prg0[2311:2308],
                  prg0[2303:2300],prg0[2295:2292],prg0[2287:2284],prg0[2279:2276],prg0[2271:2268],prg0[2263:2260],prg0[2255:2252],prg0[2247:2244],
                  prg0[2239:2236],prg0[2231:2228],prg0[2223:2220],prg0[2215:2212],prg0[2207:2204],prg0[2199:2196],prg0[2191:2188],prg0[2183:2180],
                  prg0[2175:2172],prg0[2167:2164],prg0[2159:2156],prg0[2151:2148],prg0[2143:2140],prg0[2135:2132],prg0[2127:2124],prg0[2119:2116],
                  prg0[2111:2108],prg0[2103:2100],prg0[2095:2092],prg0[2087:2084],prg0[2079:2076],prg0[2071:2068],prg0[2063:2060],prg0[2055:2052],
                  prg0[2047:2044],prg0[2039:2036],prg0[2031:2028],prg0[2023:2020],prg0[2015:2012],prg0[2007:2004],prg0[1999:1996],prg0[1991:1988],
                  prg0[1983:1980],prg0[1975:1972],prg0[1967:1964],prg0[1959:1956],prg0[1951:1948],prg0[1943:1940],prg0[1935:1932],prg0[1927:1924],
                  prg0[1919:1916],prg0[1911:1908],prg0[1903:1900],prg0[1895:1892],prg0[1887:1884],prg0[1879:1876],prg0[1871:1868],prg0[1863:1860],
                  prg0[1855:1852],prg0[1847:1844],prg0[1839:1836],prg0[1831:1828],prg0[1823:1820],prg0[1815:1812],prg0[1807:1804],prg0[1799:1796],
                  prg0[1791:1788],prg0[1783:1780],prg0[1775:1772],prg0[1767:1764],prg0[1759:1756],prg0[1751:1748],prg0[1743:1740],prg0[1735:1732],
                  prg0[1727:1724],prg0[1719:1716],prg0[1711:1708],prg0[1703:1700],prg0[1695:1692],prg0[1687:1684],prg0[1679:1676],prg0[1671:1668],
                  prg0[1663:1660],prg0[1655:1652],prg0[1647:1644],prg0[1639:1636],prg0[1631:1628],prg0[1623:1620],prg0[1615:1612],prg0[1607:1604],
                  prg0[1599:1596],prg0[1591:1588],prg0[1583:1580],prg0[1575:1572],prg0[1567:1564],prg0[1559:1556],prg0[1551:1548],prg0[1543:1540],
                  prg0[1535:1532],prg0[1527:1524],prg0[1519:1516],prg0[1511:1508],prg0[1503:1500],prg0[1495:1492],prg0[1487:1484],prg0[1479:1476],
                  prg0[1471:1468],prg0[1463:1460],prg0[1455:1452],prg0[1447:1444],prg0[1439:1436],prg0[1431:1428],prg0[1423:1420],prg0[1415:1412],
                  prg0[1407:1404],prg0[1399:1396],prg0[1391:1388],prg0[1383:1380],prg0[1375:1372],prg0[1367:1364],prg0[1359:1356],prg0[1351:1348],
                  prg0[1343:1340],prg0[1335:1332],prg0[1327:1324],prg0[1319:1316],prg0[1311:1308],prg0[1303:1300],prg0[1295:1292],prg0[1287:1284],
                  prg0[1279:1276],prg0[1271:1268],prg0[1263:1260],prg0[1255:1252],prg0[1247:1244],prg0[1239:1236],prg0[1231:1228],prg0[1223:1220],
                  prg0[1215:1212],prg0[1207:1204],prg0[1199:1196],prg0[1191:1188],prg0[1183:1180],prg0[1175:1172],prg0[1167:1164],prg0[1159:1156],
                  prg0[1151:1148],prg0[1143:1140],prg0[1135:1132],prg0[1127:1124],prg0[1119:1116],prg0[1111:1108],prg0[1103:1100],prg0[1095:1092],
                  prg0[1087:1084],prg0[1079:1076],prg0[1071:1068],prg0[1063:1060],prg0[1055:1052],prg0[1047:1044],prg0[1039:1036],prg0[1031:1028],
                  prg0[1023:1020],prg0[1015:1012],prg0[1007:1004],prg0[ 999: 996],prg0[ 991: 988],prg0[ 983: 980],prg0[ 975: 972],prg0[ 967: 964],
                  prg0[ 959: 956],prg0[ 951: 948],prg0[ 943: 940],prg0[ 935: 932],prg0[ 927: 924],prg0[ 919: 916],prg0[ 911: 908],prg0[ 903: 900],
                  prg0[ 895: 892],prg0[ 887: 884],prg0[ 879: 876],prg0[ 871: 868],prg0[ 863: 860],prg0[ 855: 852],prg0[ 847: 844],prg0[ 839: 836],
                  prg0[ 831: 828],prg0[ 823: 820],prg0[ 815: 812],prg0[ 807: 804],prg0[ 799: 796],prg0[ 791: 788],prg0[ 783: 780],prg0[ 775: 772],
                  prg0[ 767: 764],prg0[ 759: 756],prg0[ 751: 748],prg0[ 743: 740],prg0[ 735: 732],prg0[ 727: 724],prg0[ 719: 716],prg0[ 711: 708],
                  prg0[ 703: 700],prg0[ 695: 692],prg0[ 687: 684],prg0[ 679: 676],prg0[ 671: 668],prg0[ 663: 660],prg0[ 655: 652],prg0[ 647: 644],
                  prg0[ 639: 636],prg0[ 631: 628],prg0[ 623: 620],prg0[ 615: 612],prg0[ 607: 604],prg0[ 599: 596],prg0[ 591: 588],prg0[ 583: 580],
                  prg0[ 575: 572],prg0[ 567: 564],prg0[ 559: 556],prg0[ 551: 548],prg0[ 543: 540],prg0[ 535: 532],prg0[ 527: 524],prg0[ 519: 516],
                  prg0[ 511: 508],prg0[ 503: 500],prg0[ 495: 492],prg0[ 487: 484],prg0[ 479: 476],prg0[ 471: 468],prg0[ 463: 460],prg0[ 455: 452],
                  prg0[ 447: 444],prg0[ 439: 436],prg0[ 431: 428],prg0[ 423: 420],prg0[ 415: 412],prg0[ 407: 404],prg0[ 399: 396],prg0[ 391: 388],
                  prg0[ 383: 380],prg0[ 375: 372],prg0[ 367: 364],prg0[ 359: 356],prg0[ 351: 348],prg0[ 343: 340],prg0[ 335: 332],prg0[ 327: 324],
                  prg0[ 319: 316],prg0[ 311: 308],prg0[ 303: 300],prg0[ 295: 292],prg0[ 287: 284],prg0[ 279: 276],prg0[ 271: 268],prg0[ 263: 260],
                  prg0[ 255: 252],prg0[ 247: 244],prg0[ 239: 236],prg0[ 231: 228],prg0[ 223: 220],prg0[ 215: 212],prg0[ 207: 204],prg0[ 199: 196],
                  prg0[ 191: 188],prg0[ 183: 180],prg0[ 175: 172],prg0[ 167: 164],prg0[ 159: 156],prg0[ 151: 148],prg0[ 143: 140],prg0[ 135: 132],
                  prg0[ 127: 124],prg0[ 119: 116],prg0[ 111: 108],prg0[ 103: 100],prg0[  95:  92],prg0[  87:  84],prg0[  79:  76],prg0[  71:  68],
                  prg0[  63:  60],prg0[  55:  52],prg0[  47:  44],prg0[  39:  36],prg0[  31:  28],prg0[  23:  20],prg0[  15:  12],prg0[   7:   4]};

         m_ebr_w4 #(.EBRADRWIDTH(EBRADRWIDTH),
                    .prg0(pb0), .prg1(pb1))
         ebrb 
           (/*AUTOINST*/
            // Outputs
            .DAT_O                      (DAT_O[3:0]),
            // Inputs
            .B                          (B[3:0]),
            .Rai                        (Rai[EBRADRWIDTH-1:0]),
            .Wai                        (Wai[EBRADRWIDTH-1:0]),
            .clk                        (clk),
            .we                         (we));
   
         m_ebr_w4 #(.EBRADRWIDTH(EBRADRWIDTH),
                    .prg0(ph0), .prg1(ph1))
         ebrh 
           (// Outputs
            .DAT_O                      (DAT_O[7:4]),
            // Inputs
            .B                          (B[7:4]),
            /*AUTOINST*/
            // Inputs
            .Rai                        (Rai[EBRADRWIDTH-1:0]),
            .Wai                        (Wai[EBRADRWIDTH-1:0]),
            .clk                        (clk),
            .we                         (we));
   
      end
   endgenerate
endmodule


/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * EBR program memory is split into 4-bit wide memory, specified here.
 */
module m_ebr_w4
  # ( parameter EBRADRWIDTH = 10,
      parameter [4095:0] prg0 = 4096'h0,
      parameter [4095:0] prg1 = 4096'h0
      )
   (
    input [3:0]             B, //     Output from ALU
    input [EBRADRWIDTH-1:0] Rai, //   Read address
    input [EBRADRWIDTH-1:0] Wai, //   Write address
    input                   clk, //   System clock
    input                   we, //    Write enable
    output [3:0]            DAT_O //  Registered output
    );
   
   localparam NrRamsHere = (1<<(EBRADRWIDTH-10));

   generate

      if ( NrRamsHere == 1 ) begin
         /* verilator lint_off UNUSED */
         wire [11:0] dum12;
         /* verilator lint_on UNUSED */

         SB_RAM40_4K 
           #(
             .INIT_F({prg0[4095],prg0[4091],prg0[4087],prg0[4083],prg0[4094],prg0[4090],prg0[4086],prg0[4082],
                      prg0[4093],prg0[4089],prg0[4085],prg0[4081],prg0[4092],prg0[4088],prg0[4084],prg0[4080],
                      prg0[4079],prg0[4075],prg0[4071],prg0[4067],prg0[4078],prg0[4074],prg0[4070],prg0[4066],
                      prg0[4077],prg0[4073],prg0[4069],prg0[4065],prg0[4076],prg0[4072],prg0[4068],prg0[4064],
                      prg0[4063],prg0[4059],prg0[4055],prg0[4051],prg0[4062],prg0[4058],prg0[4054],prg0[4050],
                      prg0[4061],prg0[4057],prg0[4053],prg0[4049],prg0[4060],prg0[4056],prg0[4052],prg0[4048],
                      prg0[4047],prg0[4043],prg0[4039],prg0[4035],prg0[4046],prg0[4042],prg0[4038],prg0[4034],
                      prg0[4045],prg0[4041],prg0[4037],prg0[4033],prg0[4044],prg0[4040],prg0[4036],prg0[4032],
                      prg0[4031],prg0[4027],prg0[4023],prg0[4019],prg0[4030],prg0[4026],prg0[4022],prg0[4018],
                      prg0[4029],prg0[4025],prg0[4021],prg0[4017],prg0[4028],prg0[4024],prg0[4020],prg0[4016],
                      prg0[4015],prg0[4011],prg0[4007],prg0[4003],prg0[4014],prg0[4010],prg0[4006],prg0[4002],
                      prg0[4013],prg0[4009],prg0[4005],prg0[4001],prg0[4012],prg0[4008],prg0[4004],prg0[4000],
                      prg0[3999],prg0[3995],prg0[3991],prg0[3987],prg0[3998],prg0[3994],prg0[3990],prg0[3986],
                      prg0[3997],prg0[3993],prg0[3989],prg0[3985],prg0[3996],prg0[3992],prg0[3988],prg0[3984],
                      prg0[3983],prg0[3979],prg0[3975],prg0[3971],prg0[3982],prg0[3978],prg0[3974],prg0[3970],
                      prg0[3981],prg0[3977],prg0[3973],prg0[3969],prg0[3980],prg0[3976],prg0[3972],prg0[3968],
                      prg0[3967],prg0[3963],prg0[3959],prg0[3955],prg0[3966],prg0[3962],prg0[3958],prg0[3954],
                      prg0[3965],prg0[3961],prg0[3957],prg0[3953],prg0[3964],prg0[3960],prg0[3956],prg0[3952],
                      prg0[3951],prg0[3947],prg0[3943],prg0[3939],prg0[3950],prg0[3946],prg0[3942],prg0[3938],
                      prg0[3949],prg0[3945],prg0[3941],prg0[3937],prg0[3948],prg0[3944],prg0[3940],prg0[3936],
                      prg0[3935],prg0[3931],prg0[3927],prg0[3923],prg0[3934],prg0[3930],prg0[3926],prg0[3922],
                      prg0[3933],prg0[3929],prg0[3925],prg0[3921],prg0[3932],prg0[3928],prg0[3924],prg0[3920],
                      prg0[3919],prg0[3915],prg0[3911],prg0[3907],prg0[3918],prg0[3914],prg0[3910],prg0[3906],
                      prg0[3917],prg0[3913],prg0[3909],prg0[3905],prg0[3916],prg0[3912],prg0[3908],prg0[3904],
                      prg0[3903],prg0[3899],prg0[3895],prg0[3891],prg0[3902],prg0[3898],prg0[3894],prg0[3890],
                      prg0[3901],prg0[3897],prg0[3893],prg0[3889],prg0[3900],prg0[3896],prg0[3892],prg0[3888],
                      prg0[3887],prg0[3883],prg0[3879],prg0[3875],prg0[3886],prg0[3882],prg0[3878],prg0[3874],
                      prg0[3885],prg0[3881],prg0[3877],prg0[3873],prg0[3884],prg0[3880],prg0[3876],prg0[3872],
                      prg0[3871],prg0[3867],prg0[3863],prg0[3859],prg0[3870],prg0[3866],prg0[3862],prg0[3858],
                      prg0[3869],prg0[3865],prg0[3861],prg0[3857],prg0[3868],prg0[3864],prg0[3860],prg0[3856],
                      prg0[3855],prg0[3851],prg0[3847],prg0[3843],prg0[3854],prg0[3850],prg0[3846],prg0[3842],
                      prg0[3853],prg0[3849],prg0[3845],prg0[3841],prg0[3852],prg0[3848],prg0[3844],prg0[3840]}),
             .INIT_E({prg0[3839],prg0[3835],prg0[3831],prg0[3827],prg0[3838],prg0[3834],prg0[3830],prg0[3826],
                      prg0[3837],prg0[3833],prg0[3829],prg0[3825],prg0[3836],prg0[3832],prg0[3828],prg0[3824],
                      prg0[3823],prg0[3819],prg0[3815],prg0[3811],prg0[3822],prg0[3818],prg0[3814],prg0[3810],
                      prg0[3821],prg0[3817],prg0[3813],prg0[3809],prg0[3820],prg0[3816],prg0[3812],prg0[3808],
                      prg0[3807],prg0[3803],prg0[3799],prg0[3795],prg0[3806],prg0[3802],prg0[3798],prg0[3794],
                      prg0[3805],prg0[3801],prg0[3797],prg0[3793],prg0[3804],prg0[3800],prg0[3796],prg0[3792],
                      prg0[3791],prg0[3787],prg0[3783],prg0[3779],prg0[3790],prg0[3786],prg0[3782],prg0[3778],
                      prg0[3789],prg0[3785],prg0[3781],prg0[3777],prg0[3788],prg0[3784],prg0[3780],prg0[3776],
                      prg0[3775],prg0[3771],prg0[3767],prg0[3763],prg0[3774],prg0[3770],prg0[3766],prg0[3762],
                      prg0[3773],prg0[3769],prg0[3765],prg0[3761],prg0[3772],prg0[3768],prg0[3764],prg0[3760],
                      prg0[3759],prg0[3755],prg0[3751],prg0[3747],prg0[3758],prg0[3754],prg0[3750],prg0[3746],
                      prg0[3757],prg0[3753],prg0[3749],prg0[3745],prg0[3756],prg0[3752],prg0[3748],prg0[3744],
                      prg0[3743],prg0[3739],prg0[3735],prg0[3731],prg0[3742],prg0[3738],prg0[3734],prg0[3730],
                      prg0[3741],prg0[3737],prg0[3733],prg0[3729],prg0[3740],prg0[3736],prg0[3732],prg0[3728],
                      prg0[3727],prg0[3723],prg0[3719],prg0[3715],prg0[3726],prg0[3722],prg0[3718],prg0[3714],
                      prg0[3725],prg0[3721],prg0[3717],prg0[3713],prg0[3724],prg0[3720],prg0[3716],prg0[3712],
                      prg0[3711],prg0[3707],prg0[3703],prg0[3699],prg0[3710],prg0[3706],prg0[3702],prg0[3698],
                      prg0[3709],prg0[3705],prg0[3701],prg0[3697],prg0[3708],prg0[3704],prg0[3700],prg0[3696],
                      prg0[3695],prg0[3691],prg0[3687],prg0[3683],prg0[3694],prg0[3690],prg0[3686],prg0[3682],
                      prg0[3693],prg0[3689],prg0[3685],prg0[3681],prg0[3692],prg0[3688],prg0[3684],prg0[3680],
                      prg0[3679],prg0[3675],prg0[3671],prg0[3667],prg0[3678],prg0[3674],prg0[3670],prg0[3666],
                      prg0[3677],prg0[3673],prg0[3669],prg0[3665],prg0[3676],prg0[3672],prg0[3668],prg0[3664],
                      prg0[3663],prg0[3659],prg0[3655],prg0[3651],prg0[3662],prg0[3658],prg0[3654],prg0[3650],
                      prg0[3661],prg0[3657],prg0[3653],prg0[3649],prg0[3660],prg0[3656],prg0[3652],prg0[3648],
                      prg0[3647],prg0[3643],prg0[3639],prg0[3635],prg0[3646],prg0[3642],prg0[3638],prg0[3634],
                      prg0[3645],prg0[3641],prg0[3637],prg0[3633],prg0[3644],prg0[3640],prg0[3636],prg0[3632],
                      prg0[3631],prg0[3627],prg0[3623],prg0[3619],prg0[3630],prg0[3626],prg0[3622],prg0[3618],
                      prg0[3629],prg0[3625],prg0[3621],prg0[3617],prg0[3628],prg0[3624],prg0[3620],prg0[3616],
                      prg0[3615],prg0[3611],prg0[3607],prg0[3603],prg0[3614],prg0[3610],prg0[3606],prg0[3602],
                      prg0[3613],prg0[3609],prg0[3605],prg0[3601],prg0[3612],prg0[3608],prg0[3604],prg0[3600],
                      prg0[3599],prg0[3595],prg0[3591],prg0[3587],prg0[3598],prg0[3594],prg0[3590],prg0[3586],
                      prg0[3597],prg0[3593],prg0[3589],prg0[3585],prg0[3596],prg0[3592],prg0[3588],prg0[3584]}),
             .INIT_D({prg0[3583],prg0[3579],prg0[3575],prg0[3571],prg0[3582],prg0[3578],prg0[3574],prg0[3570],
                      prg0[3581],prg0[3577],prg0[3573],prg0[3569],prg0[3580],prg0[3576],prg0[3572],prg0[3568],
                      prg0[3567],prg0[3563],prg0[3559],prg0[3555],prg0[3566],prg0[3562],prg0[3558],prg0[3554],
                      prg0[3565],prg0[3561],prg0[3557],prg0[3553],prg0[3564],prg0[3560],prg0[3556],prg0[3552],
                      prg0[3551],prg0[3547],prg0[3543],prg0[3539],prg0[3550],prg0[3546],prg0[3542],prg0[3538],
                      prg0[3549],prg0[3545],prg0[3541],prg0[3537],prg0[3548],prg0[3544],prg0[3540],prg0[3536],
                      prg0[3535],prg0[3531],prg0[3527],prg0[3523],prg0[3534],prg0[3530],prg0[3526],prg0[3522],
                      prg0[3533],prg0[3529],prg0[3525],prg0[3521],prg0[3532],prg0[3528],prg0[3524],prg0[3520],
                      prg0[3519],prg0[3515],prg0[3511],prg0[3507],prg0[3518],prg0[3514],prg0[3510],prg0[3506],
                      prg0[3517],prg0[3513],prg0[3509],prg0[3505],prg0[3516],prg0[3512],prg0[3508],prg0[3504],
                      prg0[3503],prg0[3499],prg0[3495],prg0[3491],prg0[3502],prg0[3498],prg0[3494],prg0[3490],
                      prg0[3501],prg0[3497],prg0[3493],prg0[3489],prg0[3500],prg0[3496],prg0[3492],prg0[3488],
                      prg0[3487],prg0[3483],prg0[3479],prg0[3475],prg0[3486],prg0[3482],prg0[3478],prg0[3474],
                      prg0[3485],prg0[3481],prg0[3477],prg0[3473],prg0[3484],prg0[3480],prg0[3476],prg0[3472],
                      prg0[3471],prg0[3467],prg0[3463],prg0[3459],prg0[3470],prg0[3466],prg0[3462],prg0[3458],
                      prg0[3469],prg0[3465],prg0[3461],prg0[3457],prg0[3468],prg0[3464],prg0[3460],prg0[3456],
                      prg0[3455],prg0[3451],prg0[3447],prg0[3443],prg0[3454],prg0[3450],prg0[3446],prg0[3442],
                      prg0[3453],prg0[3449],prg0[3445],prg0[3441],prg0[3452],prg0[3448],prg0[3444],prg0[3440],
                      prg0[3439],prg0[3435],prg0[3431],prg0[3427],prg0[3438],prg0[3434],prg0[3430],prg0[3426],
                      prg0[3437],prg0[3433],prg0[3429],prg0[3425],prg0[3436],prg0[3432],prg0[3428],prg0[3424],
                      prg0[3423],prg0[3419],prg0[3415],prg0[3411],prg0[3422],prg0[3418],prg0[3414],prg0[3410],
                      prg0[3421],prg0[3417],prg0[3413],prg0[3409],prg0[3420],prg0[3416],prg0[3412],prg0[3408],
                      prg0[3407],prg0[3403],prg0[3399],prg0[3395],prg0[3406],prg0[3402],prg0[3398],prg0[3394],
                      prg0[3405],prg0[3401],prg0[3397],prg0[3393],prg0[3404],prg0[3400],prg0[3396],prg0[3392],
                      prg0[3391],prg0[3387],prg0[3383],prg0[3379],prg0[3390],prg0[3386],prg0[3382],prg0[3378],
                      prg0[3389],prg0[3385],prg0[3381],prg0[3377],prg0[3388],prg0[3384],prg0[3380],prg0[3376],
                      prg0[3375],prg0[3371],prg0[3367],prg0[3363],prg0[3374],prg0[3370],prg0[3366],prg0[3362],
                      prg0[3373],prg0[3369],prg0[3365],prg0[3361],prg0[3372],prg0[3368],prg0[3364],prg0[3360],
                      prg0[3359],prg0[3355],prg0[3351],prg0[3347],prg0[3358],prg0[3354],prg0[3350],prg0[3346],
                      prg0[3357],prg0[3353],prg0[3349],prg0[3345],prg0[3356],prg0[3352],prg0[3348],prg0[3344],
                      prg0[3343],prg0[3339],prg0[3335],prg0[3331],prg0[3342],prg0[3338],prg0[3334],prg0[3330],
                      prg0[3341],prg0[3337],prg0[3333],prg0[3329],prg0[3340],prg0[3336],prg0[3332],prg0[3328]}),
             .INIT_C({prg0[3327],prg0[3323],prg0[3319],prg0[3315],prg0[3326],prg0[3322],prg0[3318],prg0[3314],
                      prg0[3325],prg0[3321],prg0[3317],prg0[3313],prg0[3324],prg0[3320],prg0[3316],prg0[3312],
                      prg0[3311],prg0[3307],prg0[3303],prg0[3299],prg0[3310],prg0[3306],prg0[3302],prg0[3298],
                      prg0[3309],prg0[3305],prg0[3301],prg0[3297],prg0[3308],prg0[3304],prg0[3300],prg0[3296],
                      prg0[3295],prg0[3291],prg0[3287],prg0[3283],prg0[3294],prg0[3290],prg0[3286],prg0[3282],
                      prg0[3293],prg0[3289],prg0[3285],prg0[3281],prg0[3292],prg0[3288],prg0[3284],prg0[3280],
                      prg0[3279],prg0[3275],prg0[3271],prg0[3267],prg0[3278],prg0[3274],prg0[3270],prg0[3266],
                      prg0[3277],prg0[3273],prg0[3269],prg0[3265],prg0[3276],prg0[3272],prg0[3268],prg0[3264],
                      prg0[3263],prg0[3259],prg0[3255],prg0[3251],prg0[3262],prg0[3258],prg0[3254],prg0[3250],
                      prg0[3261],prg0[3257],prg0[3253],prg0[3249],prg0[3260],prg0[3256],prg0[3252],prg0[3248],
                      prg0[3247],prg0[3243],prg0[3239],prg0[3235],prg0[3246],prg0[3242],prg0[3238],prg0[3234],
                      prg0[3245],prg0[3241],prg0[3237],prg0[3233],prg0[3244],prg0[3240],prg0[3236],prg0[3232],
                      prg0[3231],prg0[3227],prg0[3223],prg0[3219],prg0[3230],prg0[3226],prg0[3222],prg0[3218],
                      prg0[3229],prg0[3225],prg0[3221],prg0[3217],prg0[3228],prg0[3224],prg0[3220],prg0[3216],
                      prg0[3215],prg0[3211],prg0[3207],prg0[3203],prg0[3214],prg0[3210],prg0[3206],prg0[3202],
                      prg0[3213],prg0[3209],prg0[3205],prg0[3201],prg0[3212],prg0[3208],prg0[3204],prg0[3200],
                      prg0[3199],prg0[3195],prg0[3191],prg0[3187],prg0[3198],prg0[3194],prg0[3190],prg0[3186],
                      prg0[3197],prg0[3193],prg0[3189],prg0[3185],prg0[3196],prg0[3192],prg0[3188],prg0[3184],
                      prg0[3183],prg0[3179],prg0[3175],prg0[3171],prg0[3182],prg0[3178],prg0[3174],prg0[3170],
                      prg0[3181],prg0[3177],prg0[3173],prg0[3169],prg0[3180],prg0[3176],prg0[3172],prg0[3168],
                      prg0[3167],prg0[3163],prg0[3159],prg0[3155],prg0[3166],prg0[3162],prg0[3158],prg0[3154],
                      prg0[3165],prg0[3161],prg0[3157],prg0[3153],prg0[3164],prg0[3160],prg0[3156],prg0[3152],
                      prg0[3151],prg0[3147],prg0[3143],prg0[3139],prg0[3150],prg0[3146],prg0[3142],prg0[3138],
                      prg0[3149],prg0[3145],prg0[3141],prg0[3137],prg0[3148],prg0[3144],prg0[3140],prg0[3136],
                      prg0[3135],prg0[3131],prg0[3127],prg0[3123],prg0[3134],prg0[3130],prg0[3126],prg0[3122],
                      prg0[3133],prg0[3129],prg0[3125],prg0[3121],prg0[3132],prg0[3128],prg0[3124],prg0[3120],
                      prg0[3119],prg0[3115],prg0[3111],prg0[3107],prg0[3118],prg0[3114],prg0[3110],prg0[3106],
                      prg0[3117],prg0[3113],prg0[3109],prg0[3105],prg0[3116],prg0[3112],prg0[3108],prg0[3104],
                      prg0[3103],prg0[3099],prg0[3095],prg0[3091],prg0[3102],prg0[3098],prg0[3094],prg0[3090],
                      prg0[3101],prg0[3097],prg0[3093],prg0[3089],prg0[3100],prg0[3096],prg0[3092],prg0[3088],
                      prg0[3087],prg0[3083],prg0[3079],prg0[3075],prg0[3086],prg0[3082],prg0[3078],prg0[3074],
                      prg0[3085],prg0[3081],prg0[3077],prg0[3073],prg0[3084],prg0[3080],prg0[3076],prg0[3072]}),
             .INIT_B({prg0[3071],prg0[3067],prg0[3063],prg0[3059],prg0[3070],prg0[3066],prg0[3062],prg0[3058],
                      prg0[3069],prg0[3065],prg0[3061],prg0[3057],prg0[3068],prg0[3064],prg0[3060],prg0[3056],
                      prg0[3055],prg0[3051],prg0[3047],prg0[3043],prg0[3054],prg0[3050],prg0[3046],prg0[3042],
                      prg0[3053],prg0[3049],prg0[3045],prg0[3041],prg0[3052],prg0[3048],prg0[3044],prg0[3040],
                      prg0[3039],prg0[3035],prg0[3031],prg0[3027],prg0[3038],prg0[3034],prg0[3030],prg0[3026],
                      prg0[3037],prg0[3033],prg0[3029],prg0[3025],prg0[3036],prg0[3032],prg0[3028],prg0[3024],
                      prg0[3023],prg0[3019],prg0[3015],prg0[3011],prg0[3022],prg0[3018],prg0[3014],prg0[3010],
                      prg0[3021],prg0[3017],prg0[3013],prg0[3009],prg0[3020],prg0[3016],prg0[3012],prg0[3008],
                      prg0[3007],prg0[3003],prg0[2999],prg0[2995],prg0[3006],prg0[3002],prg0[2998],prg0[2994],
                      prg0[3005],prg0[3001],prg0[2997],prg0[2993],prg0[3004],prg0[3000],prg0[2996],prg0[2992],
                      prg0[2991],prg0[2987],prg0[2983],prg0[2979],prg0[2990],prg0[2986],prg0[2982],prg0[2978],
                      prg0[2989],prg0[2985],prg0[2981],prg0[2977],prg0[2988],prg0[2984],prg0[2980],prg0[2976],
                      prg0[2975],prg0[2971],prg0[2967],prg0[2963],prg0[2974],prg0[2970],prg0[2966],prg0[2962],
                      prg0[2973],prg0[2969],prg0[2965],prg0[2961],prg0[2972],prg0[2968],prg0[2964],prg0[2960],
                      prg0[2959],prg0[2955],prg0[2951],prg0[2947],prg0[2958],prg0[2954],prg0[2950],prg0[2946],
                      prg0[2957],prg0[2953],prg0[2949],prg0[2945],prg0[2956],prg0[2952],prg0[2948],prg0[2944],
                      prg0[2943],prg0[2939],prg0[2935],prg0[2931],prg0[2942],prg0[2938],prg0[2934],prg0[2930],
                      prg0[2941],prg0[2937],prg0[2933],prg0[2929],prg0[2940],prg0[2936],prg0[2932],prg0[2928],
                      prg0[2927],prg0[2923],prg0[2919],prg0[2915],prg0[2926],prg0[2922],prg0[2918],prg0[2914],
                      prg0[2925],prg0[2921],prg0[2917],prg0[2913],prg0[2924],prg0[2920],prg0[2916],prg0[2912],
                      prg0[2911],prg0[2907],prg0[2903],prg0[2899],prg0[2910],prg0[2906],prg0[2902],prg0[2898],
                      prg0[2909],prg0[2905],prg0[2901],prg0[2897],prg0[2908],prg0[2904],prg0[2900],prg0[2896],
                      prg0[2895],prg0[2891],prg0[2887],prg0[2883],prg0[2894],prg0[2890],prg0[2886],prg0[2882],
                      prg0[2893],prg0[2889],prg0[2885],prg0[2881],prg0[2892],prg0[2888],prg0[2884],prg0[2880],
                      prg0[2879],prg0[2875],prg0[2871],prg0[2867],prg0[2878],prg0[2874],prg0[2870],prg0[2866],
                      prg0[2877],prg0[2873],prg0[2869],prg0[2865],prg0[2876],prg0[2872],prg0[2868],prg0[2864],
                      prg0[2863],prg0[2859],prg0[2855],prg0[2851],prg0[2862],prg0[2858],prg0[2854],prg0[2850],
                      prg0[2861],prg0[2857],prg0[2853],prg0[2849],prg0[2860],prg0[2856],prg0[2852],prg0[2848],
                      prg0[2847],prg0[2843],prg0[2839],prg0[2835],prg0[2846],prg0[2842],prg0[2838],prg0[2834],
                      prg0[2845],prg0[2841],prg0[2837],prg0[2833],prg0[2844],prg0[2840],prg0[2836],prg0[2832],
                      prg0[2831],prg0[2827],prg0[2823],prg0[2819],prg0[2830],prg0[2826],prg0[2822],prg0[2818],
                      prg0[2829],prg0[2825],prg0[2821],prg0[2817],prg0[2828],prg0[2824],prg0[2820],prg0[2816]}),
             .INIT_A({prg0[2815],prg0[2811],prg0[2807],prg0[2803],prg0[2814],prg0[2810],prg0[2806],prg0[2802],
                      prg0[2813],prg0[2809],prg0[2805],prg0[2801],prg0[2812],prg0[2808],prg0[2804],prg0[2800],
                      prg0[2799],prg0[2795],prg0[2791],prg0[2787],prg0[2798],prg0[2794],prg0[2790],prg0[2786],
                      prg0[2797],prg0[2793],prg0[2789],prg0[2785],prg0[2796],prg0[2792],prg0[2788],prg0[2784],
                      prg0[2783],prg0[2779],prg0[2775],prg0[2771],prg0[2782],prg0[2778],prg0[2774],prg0[2770],
                      prg0[2781],prg0[2777],prg0[2773],prg0[2769],prg0[2780],prg0[2776],prg0[2772],prg0[2768],
                      prg0[2767],prg0[2763],prg0[2759],prg0[2755],prg0[2766],prg0[2762],prg0[2758],prg0[2754],
                      prg0[2765],prg0[2761],prg0[2757],prg0[2753],prg0[2764],prg0[2760],prg0[2756],prg0[2752],
                      prg0[2751],prg0[2747],prg0[2743],prg0[2739],prg0[2750],prg0[2746],prg0[2742],prg0[2738],
                      prg0[2749],prg0[2745],prg0[2741],prg0[2737],prg0[2748],prg0[2744],prg0[2740],prg0[2736],
                      prg0[2735],prg0[2731],prg0[2727],prg0[2723],prg0[2734],prg0[2730],prg0[2726],prg0[2722],
                      prg0[2733],prg0[2729],prg0[2725],prg0[2721],prg0[2732],prg0[2728],prg0[2724],prg0[2720],
                      prg0[2719],prg0[2715],prg0[2711],prg0[2707],prg0[2718],prg0[2714],prg0[2710],prg0[2706],
                      prg0[2717],prg0[2713],prg0[2709],prg0[2705],prg0[2716],prg0[2712],prg0[2708],prg0[2704],
                      prg0[2703],prg0[2699],prg0[2695],prg0[2691],prg0[2702],prg0[2698],prg0[2694],prg0[2690],
                      prg0[2701],prg0[2697],prg0[2693],prg0[2689],prg0[2700],prg0[2696],prg0[2692],prg0[2688],
                      prg0[2687],prg0[2683],prg0[2679],prg0[2675],prg0[2686],prg0[2682],prg0[2678],prg0[2674],
                      prg0[2685],prg0[2681],prg0[2677],prg0[2673],prg0[2684],prg0[2680],prg0[2676],prg0[2672],
                      prg0[2671],prg0[2667],prg0[2663],prg0[2659],prg0[2670],prg0[2666],prg0[2662],prg0[2658],
                      prg0[2669],prg0[2665],prg0[2661],prg0[2657],prg0[2668],prg0[2664],prg0[2660],prg0[2656],
                      prg0[2655],prg0[2651],prg0[2647],prg0[2643],prg0[2654],prg0[2650],prg0[2646],prg0[2642],
                      prg0[2653],prg0[2649],prg0[2645],prg0[2641],prg0[2652],prg0[2648],prg0[2644],prg0[2640],
                      prg0[2639],prg0[2635],prg0[2631],prg0[2627],prg0[2638],prg0[2634],prg0[2630],prg0[2626],
                      prg0[2637],prg0[2633],prg0[2629],prg0[2625],prg0[2636],prg0[2632],prg0[2628],prg0[2624],
                      prg0[2623],prg0[2619],prg0[2615],prg0[2611],prg0[2622],prg0[2618],prg0[2614],prg0[2610],
                      prg0[2621],prg0[2617],prg0[2613],prg0[2609],prg0[2620],prg0[2616],prg0[2612],prg0[2608],
                      prg0[2607],prg0[2603],prg0[2599],prg0[2595],prg0[2606],prg0[2602],prg0[2598],prg0[2594],
                      prg0[2605],prg0[2601],prg0[2597],prg0[2593],prg0[2604],prg0[2600],prg0[2596],prg0[2592],
                      prg0[2591],prg0[2587],prg0[2583],prg0[2579],prg0[2590],prg0[2586],prg0[2582],prg0[2578],
                      prg0[2589],prg0[2585],prg0[2581],prg0[2577],prg0[2588],prg0[2584],prg0[2580],prg0[2576],
                      prg0[2575],prg0[2571],prg0[2567],prg0[2563],prg0[2574],prg0[2570],prg0[2566],prg0[2562],
                      prg0[2573],prg0[2569],prg0[2565],prg0[2561],prg0[2572],prg0[2568],prg0[2564],prg0[2560]}),
             .INIT_9({prg0[2559],prg0[2555],prg0[2551],prg0[2547],prg0[2558],prg0[2554],prg0[2550],prg0[2546],
                      prg0[2557],prg0[2553],prg0[2549],prg0[2545],prg0[2556],prg0[2552],prg0[2548],prg0[2544],
                      prg0[2543],prg0[2539],prg0[2535],prg0[2531],prg0[2542],prg0[2538],prg0[2534],prg0[2530],
                      prg0[2541],prg0[2537],prg0[2533],prg0[2529],prg0[2540],prg0[2536],prg0[2532],prg0[2528],
                      prg0[2527],prg0[2523],prg0[2519],prg0[2515],prg0[2526],prg0[2522],prg0[2518],prg0[2514],
                      prg0[2525],prg0[2521],prg0[2517],prg0[2513],prg0[2524],prg0[2520],prg0[2516],prg0[2512],
                      prg0[2511],prg0[2507],prg0[2503],prg0[2499],prg0[2510],prg0[2506],prg0[2502],prg0[2498],
                      prg0[2509],prg0[2505],prg0[2501],prg0[2497],prg0[2508],prg0[2504],prg0[2500],prg0[2496],
                      prg0[2495],prg0[2491],prg0[2487],prg0[2483],prg0[2494],prg0[2490],prg0[2486],prg0[2482],
                      prg0[2493],prg0[2489],prg0[2485],prg0[2481],prg0[2492],prg0[2488],prg0[2484],prg0[2480],
                      prg0[2479],prg0[2475],prg0[2471],prg0[2467],prg0[2478],prg0[2474],prg0[2470],prg0[2466],
                      prg0[2477],prg0[2473],prg0[2469],prg0[2465],prg0[2476],prg0[2472],prg0[2468],prg0[2464],
                      prg0[2463],prg0[2459],prg0[2455],prg0[2451],prg0[2462],prg0[2458],prg0[2454],prg0[2450],
                      prg0[2461],prg0[2457],prg0[2453],prg0[2449],prg0[2460],prg0[2456],prg0[2452],prg0[2448],
                      prg0[2447],prg0[2443],prg0[2439],prg0[2435],prg0[2446],prg0[2442],prg0[2438],prg0[2434],
                      prg0[2445],prg0[2441],prg0[2437],prg0[2433],prg0[2444],prg0[2440],prg0[2436],prg0[2432],
                      prg0[2431],prg0[2427],prg0[2423],prg0[2419],prg0[2430],prg0[2426],prg0[2422],prg0[2418],
                      prg0[2429],prg0[2425],prg0[2421],prg0[2417],prg0[2428],prg0[2424],prg0[2420],prg0[2416],
                      prg0[2415],prg0[2411],prg0[2407],prg0[2403],prg0[2414],prg0[2410],prg0[2406],prg0[2402],
                      prg0[2413],prg0[2409],prg0[2405],prg0[2401],prg0[2412],prg0[2408],prg0[2404],prg0[2400],
                      prg0[2399],prg0[2395],prg0[2391],prg0[2387],prg0[2398],prg0[2394],prg0[2390],prg0[2386],
                      prg0[2397],prg0[2393],prg0[2389],prg0[2385],prg0[2396],prg0[2392],prg0[2388],prg0[2384],
                      prg0[2383],prg0[2379],prg0[2375],prg0[2371],prg0[2382],prg0[2378],prg0[2374],prg0[2370],
                      prg0[2381],prg0[2377],prg0[2373],prg0[2369],prg0[2380],prg0[2376],prg0[2372],prg0[2368],
                      prg0[2367],prg0[2363],prg0[2359],prg0[2355],prg0[2366],prg0[2362],prg0[2358],prg0[2354],
                      prg0[2365],prg0[2361],prg0[2357],prg0[2353],prg0[2364],prg0[2360],prg0[2356],prg0[2352],
                      prg0[2351],prg0[2347],prg0[2343],prg0[2339],prg0[2350],prg0[2346],prg0[2342],prg0[2338],
                      prg0[2349],prg0[2345],prg0[2341],prg0[2337],prg0[2348],prg0[2344],prg0[2340],prg0[2336],
                      prg0[2335],prg0[2331],prg0[2327],prg0[2323],prg0[2334],prg0[2330],prg0[2326],prg0[2322],
                      prg0[2333],prg0[2329],prg0[2325],prg0[2321],prg0[2332],prg0[2328],prg0[2324],prg0[2320],
                      prg0[2319],prg0[2315],prg0[2311],prg0[2307],prg0[2318],prg0[2314],prg0[2310],prg0[2306],
                      prg0[2317],prg0[2313],prg0[2309],prg0[2305],prg0[2316],prg0[2312],prg0[2308],prg0[2304]}),
             .INIT_8({prg0[2303],prg0[2299],prg0[2295],prg0[2291],prg0[2302],prg0[2298],prg0[2294],prg0[2290],
                      prg0[2301],prg0[2297],prg0[2293],prg0[2289],prg0[2300],prg0[2296],prg0[2292],prg0[2288],
                      prg0[2287],prg0[2283],prg0[2279],prg0[2275],prg0[2286],prg0[2282],prg0[2278],prg0[2274],
                      prg0[2285],prg0[2281],prg0[2277],prg0[2273],prg0[2284],prg0[2280],prg0[2276],prg0[2272],
                      prg0[2271],prg0[2267],prg0[2263],prg0[2259],prg0[2270],prg0[2266],prg0[2262],prg0[2258],
                      prg0[2269],prg0[2265],prg0[2261],prg0[2257],prg0[2268],prg0[2264],prg0[2260],prg0[2256],
                      prg0[2255],prg0[2251],prg0[2247],prg0[2243],prg0[2254],prg0[2250],prg0[2246],prg0[2242],
                      prg0[2253],prg0[2249],prg0[2245],prg0[2241],prg0[2252],prg0[2248],prg0[2244],prg0[2240],
                      prg0[2239],prg0[2235],prg0[2231],prg0[2227],prg0[2238],prg0[2234],prg0[2230],prg0[2226],
                      prg0[2237],prg0[2233],prg0[2229],prg0[2225],prg0[2236],prg0[2232],prg0[2228],prg0[2224],
                      prg0[2223],prg0[2219],prg0[2215],prg0[2211],prg0[2222],prg0[2218],prg0[2214],prg0[2210],
                      prg0[2221],prg0[2217],prg0[2213],prg0[2209],prg0[2220],prg0[2216],prg0[2212],prg0[2208],
                      prg0[2207],prg0[2203],prg0[2199],prg0[2195],prg0[2206],prg0[2202],prg0[2198],prg0[2194],
                      prg0[2205],prg0[2201],prg0[2197],prg0[2193],prg0[2204],prg0[2200],prg0[2196],prg0[2192],
                      prg0[2191],prg0[2187],prg0[2183],prg0[2179],prg0[2190],prg0[2186],prg0[2182],prg0[2178],
                      prg0[2189],prg0[2185],prg0[2181],prg0[2177],prg0[2188],prg0[2184],prg0[2180],prg0[2176],
                      prg0[2175],prg0[2171],prg0[2167],prg0[2163],prg0[2174],prg0[2170],prg0[2166],prg0[2162],
                      prg0[2173],prg0[2169],prg0[2165],prg0[2161],prg0[2172],prg0[2168],prg0[2164],prg0[2160],
                      prg0[2159],prg0[2155],prg0[2151],prg0[2147],prg0[2158],prg0[2154],prg0[2150],prg0[2146],
                      prg0[2157],prg0[2153],prg0[2149],prg0[2145],prg0[2156],prg0[2152],prg0[2148],prg0[2144],
                      prg0[2143],prg0[2139],prg0[2135],prg0[2131],prg0[2142],prg0[2138],prg0[2134],prg0[2130],
                      prg0[2141],prg0[2137],prg0[2133],prg0[2129],prg0[2140],prg0[2136],prg0[2132],prg0[2128],
                      prg0[2127],prg0[2123],prg0[2119],prg0[2115],prg0[2126],prg0[2122],prg0[2118],prg0[2114],
                      prg0[2125],prg0[2121],prg0[2117],prg0[2113],prg0[2124],prg0[2120],prg0[2116],prg0[2112],
                      prg0[2111],prg0[2107],prg0[2103],prg0[2099],prg0[2110],prg0[2106],prg0[2102],prg0[2098],
                      prg0[2109],prg0[2105],prg0[2101],prg0[2097],prg0[2108],prg0[2104],prg0[2100],prg0[2096],
                      prg0[2095],prg0[2091],prg0[2087],prg0[2083],prg0[2094],prg0[2090],prg0[2086],prg0[2082],
                      prg0[2093],prg0[2089],prg0[2085],prg0[2081],prg0[2092],prg0[2088],prg0[2084],prg0[2080],
                      prg0[2079],prg0[2075],prg0[2071],prg0[2067],prg0[2078],prg0[2074],prg0[2070],prg0[2066],
                      prg0[2077],prg0[2073],prg0[2069],prg0[2065],prg0[2076],prg0[2072],prg0[2068],prg0[2064],
                      prg0[2063],prg0[2059],prg0[2055],prg0[2051],prg0[2062],prg0[2058],prg0[2054],prg0[2050],
                      prg0[2061],prg0[2057],prg0[2053],prg0[2049],prg0[2060],prg0[2056],prg0[2052],prg0[2048]}),
             .INIT_7({prg0[2047],prg0[2043],prg0[2039],prg0[2035],prg0[2046],prg0[2042],prg0[2038],prg0[2034],
                      prg0[2045],prg0[2041],prg0[2037],prg0[2033],prg0[2044],prg0[2040],prg0[2036],prg0[2032],
                      prg0[2031],prg0[2027],prg0[2023],prg0[2019],prg0[2030],prg0[2026],prg0[2022],prg0[2018],
                      prg0[2029],prg0[2025],prg0[2021],prg0[2017],prg0[2028],prg0[2024],prg0[2020],prg0[2016],
                      prg0[2015],prg0[2011],prg0[2007],prg0[2003],prg0[2014],prg0[2010],prg0[2006],prg0[2002],
                      prg0[2013],prg0[2009],prg0[2005],prg0[2001],prg0[2012],prg0[2008],prg0[2004],prg0[2000],
                      prg0[1999],prg0[1995],prg0[1991],prg0[1987],prg0[1998],prg0[1994],prg0[1990],prg0[1986],
                      prg0[1997],prg0[1993],prg0[1989],prg0[1985],prg0[1996],prg0[1992],prg0[1988],prg0[1984],
                      prg0[1983],prg0[1979],prg0[1975],prg0[1971],prg0[1982],prg0[1978],prg0[1974],prg0[1970],
                      prg0[1981],prg0[1977],prg0[1973],prg0[1969],prg0[1980],prg0[1976],prg0[1972],prg0[1968],
                      prg0[1967],prg0[1963],prg0[1959],prg0[1955],prg0[1966],prg0[1962],prg0[1958],prg0[1954],
                      prg0[1965],prg0[1961],prg0[1957],prg0[1953],prg0[1964],prg0[1960],prg0[1956],prg0[1952],
                      prg0[1951],prg0[1947],prg0[1943],prg0[1939],prg0[1950],prg0[1946],prg0[1942],prg0[1938],
                      prg0[1949],prg0[1945],prg0[1941],prg0[1937],prg0[1948],prg0[1944],prg0[1940],prg0[1936],
                      prg0[1935],prg0[1931],prg0[1927],prg0[1923],prg0[1934],prg0[1930],prg0[1926],prg0[1922],
                      prg0[1933],prg0[1929],prg0[1925],prg0[1921],prg0[1932],prg0[1928],prg0[1924],prg0[1920],
                      prg0[1919],prg0[1915],prg0[1911],prg0[1907],prg0[1918],prg0[1914],prg0[1910],prg0[1906],
                      prg0[1917],prg0[1913],prg0[1909],prg0[1905],prg0[1916],prg0[1912],prg0[1908],prg0[1904],
                      prg0[1903],prg0[1899],prg0[1895],prg0[1891],prg0[1902],prg0[1898],prg0[1894],prg0[1890],
                      prg0[1901],prg0[1897],prg0[1893],prg0[1889],prg0[1900],prg0[1896],prg0[1892],prg0[1888],
                      prg0[1887],prg0[1883],prg0[1879],prg0[1875],prg0[1886],prg0[1882],prg0[1878],prg0[1874],
                      prg0[1885],prg0[1881],prg0[1877],prg0[1873],prg0[1884],prg0[1880],prg0[1876],prg0[1872],
                      prg0[1871],prg0[1867],prg0[1863],prg0[1859],prg0[1870],prg0[1866],prg0[1862],prg0[1858],
                      prg0[1869],prg0[1865],prg0[1861],prg0[1857],prg0[1868],prg0[1864],prg0[1860],prg0[1856],
                      prg0[1855],prg0[1851],prg0[1847],prg0[1843],prg0[1854],prg0[1850],prg0[1846],prg0[1842],
                      prg0[1853],prg0[1849],prg0[1845],prg0[1841],prg0[1852],prg0[1848],prg0[1844],prg0[1840],
                      prg0[1839],prg0[1835],prg0[1831],prg0[1827],prg0[1838],prg0[1834],prg0[1830],prg0[1826],
                      prg0[1837],prg0[1833],prg0[1829],prg0[1825],prg0[1836],prg0[1832],prg0[1828],prg0[1824],
                      prg0[1823],prg0[1819],prg0[1815],prg0[1811],prg0[1822],prg0[1818],prg0[1814],prg0[1810],
                      prg0[1821],prg0[1817],prg0[1813],prg0[1809],prg0[1820],prg0[1816],prg0[1812],prg0[1808],
                      prg0[1807],prg0[1803],prg0[1799],prg0[1795],prg0[1806],prg0[1802],prg0[1798],prg0[1794],
                      prg0[1805],prg0[1801],prg0[1797],prg0[1793],prg0[1804],prg0[1800],prg0[1796],prg0[1792]}),
             .INIT_6({prg0[1791],prg0[1787],prg0[1783],prg0[1779],prg0[1790],prg0[1786],prg0[1782],prg0[1778],
                      prg0[1789],prg0[1785],prg0[1781],prg0[1777],prg0[1788],prg0[1784],prg0[1780],prg0[1776],
                      prg0[1775],prg0[1771],prg0[1767],prg0[1763],prg0[1774],prg0[1770],prg0[1766],prg0[1762],
                      prg0[1773],prg0[1769],prg0[1765],prg0[1761],prg0[1772],prg0[1768],prg0[1764],prg0[1760],
                      prg0[1759],prg0[1755],prg0[1751],prg0[1747],prg0[1758],prg0[1754],prg0[1750],prg0[1746],
                      prg0[1757],prg0[1753],prg0[1749],prg0[1745],prg0[1756],prg0[1752],prg0[1748],prg0[1744],
                      prg0[1743],prg0[1739],prg0[1735],prg0[1731],prg0[1742],prg0[1738],prg0[1734],prg0[1730],
                      prg0[1741],prg0[1737],prg0[1733],prg0[1729],prg0[1740],prg0[1736],prg0[1732],prg0[1728],
                      prg0[1727],prg0[1723],prg0[1719],prg0[1715],prg0[1726],prg0[1722],prg0[1718],prg0[1714],
                      prg0[1725],prg0[1721],prg0[1717],prg0[1713],prg0[1724],prg0[1720],prg0[1716],prg0[1712],
                      prg0[1711],prg0[1707],prg0[1703],prg0[1699],prg0[1710],prg0[1706],prg0[1702],prg0[1698],
                      prg0[1709],prg0[1705],prg0[1701],prg0[1697],prg0[1708],prg0[1704],prg0[1700],prg0[1696],
                      prg0[1695],prg0[1691],prg0[1687],prg0[1683],prg0[1694],prg0[1690],prg0[1686],prg0[1682],
                      prg0[1693],prg0[1689],prg0[1685],prg0[1681],prg0[1692],prg0[1688],prg0[1684],prg0[1680],
                      prg0[1679],prg0[1675],prg0[1671],prg0[1667],prg0[1678],prg0[1674],prg0[1670],prg0[1666],
                      prg0[1677],prg0[1673],prg0[1669],prg0[1665],prg0[1676],prg0[1672],prg0[1668],prg0[1664],
                      prg0[1663],prg0[1659],prg0[1655],prg0[1651],prg0[1662],prg0[1658],prg0[1654],prg0[1650],
                      prg0[1661],prg0[1657],prg0[1653],prg0[1649],prg0[1660],prg0[1656],prg0[1652],prg0[1648],
                      prg0[1647],prg0[1643],prg0[1639],prg0[1635],prg0[1646],prg0[1642],prg0[1638],prg0[1634],
                      prg0[1645],prg0[1641],prg0[1637],prg0[1633],prg0[1644],prg0[1640],prg0[1636],prg0[1632],
                      prg0[1631],prg0[1627],prg0[1623],prg0[1619],prg0[1630],prg0[1626],prg0[1622],prg0[1618],
                      prg0[1629],prg0[1625],prg0[1621],prg0[1617],prg0[1628],prg0[1624],prg0[1620],prg0[1616],
                      prg0[1615],prg0[1611],prg0[1607],prg0[1603],prg0[1614],prg0[1610],prg0[1606],prg0[1602],
                      prg0[1613],prg0[1609],prg0[1605],prg0[1601],prg0[1612],prg0[1608],prg0[1604],prg0[1600],
                      prg0[1599],prg0[1595],prg0[1591],prg0[1587],prg0[1598],prg0[1594],prg0[1590],prg0[1586],
                      prg0[1597],prg0[1593],prg0[1589],prg0[1585],prg0[1596],prg0[1592],prg0[1588],prg0[1584],
                      prg0[1583],prg0[1579],prg0[1575],prg0[1571],prg0[1582],prg0[1578],prg0[1574],prg0[1570],
                      prg0[1581],prg0[1577],prg0[1573],prg0[1569],prg0[1580],prg0[1576],prg0[1572],prg0[1568],
                      prg0[1567],prg0[1563],prg0[1559],prg0[1555],prg0[1566],prg0[1562],prg0[1558],prg0[1554],
                      prg0[1565],prg0[1561],prg0[1557],prg0[1553],prg0[1564],prg0[1560],prg0[1556],prg0[1552],
                      prg0[1551],prg0[1547],prg0[1543],prg0[1539],prg0[1550],prg0[1546],prg0[1542],prg0[1538],
                      prg0[1549],prg0[1545],prg0[1541],prg0[1537],prg0[1548],prg0[1544],prg0[1540],prg0[1536]}),
             .INIT_5({prg0[1535],prg0[1531],prg0[1527],prg0[1523],prg0[1534],prg0[1530],prg0[1526],prg0[1522],
                      prg0[1533],prg0[1529],prg0[1525],prg0[1521],prg0[1532],prg0[1528],prg0[1524],prg0[1520],
                      prg0[1519],prg0[1515],prg0[1511],prg0[1507],prg0[1518],prg0[1514],prg0[1510],prg0[1506],
                      prg0[1517],prg0[1513],prg0[1509],prg0[1505],prg0[1516],prg0[1512],prg0[1508],prg0[1504],
                      prg0[1503],prg0[1499],prg0[1495],prg0[1491],prg0[1502],prg0[1498],prg0[1494],prg0[1490],
                      prg0[1501],prg0[1497],prg0[1493],prg0[1489],prg0[1500],prg0[1496],prg0[1492],prg0[1488],
                      prg0[1487],prg0[1483],prg0[1479],prg0[1475],prg0[1486],prg0[1482],prg0[1478],prg0[1474],
                      prg0[1485],prg0[1481],prg0[1477],prg0[1473],prg0[1484],prg0[1480],prg0[1476],prg0[1472],
                      prg0[1471],prg0[1467],prg0[1463],prg0[1459],prg0[1470],prg0[1466],prg0[1462],prg0[1458],
                      prg0[1469],prg0[1465],prg0[1461],prg0[1457],prg0[1468],prg0[1464],prg0[1460],prg0[1456],
                      prg0[1455],prg0[1451],prg0[1447],prg0[1443],prg0[1454],prg0[1450],prg0[1446],prg0[1442],
                      prg0[1453],prg0[1449],prg0[1445],prg0[1441],prg0[1452],prg0[1448],prg0[1444],prg0[1440],
                      prg0[1439],prg0[1435],prg0[1431],prg0[1427],prg0[1438],prg0[1434],prg0[1430],prg0[1426],
                      prg0[1437],prg0[1433],prg0[1429],prg0[1425],prg0[1436],prg0[1432],prg0[1428],prg0[1424],
                      prg0[1423],prg0[1419],prg0[1415],prg0[1411],prg0[1422],prg0[1418],prg0[1414],prg0[1410],
                      prg0[1421],prg0[1417],prg0[1413],prg0[1409],prg0[1420],prg0[1416],prg0[1412],prg0[1408],
                      prg0[1407],prg0[1403],prg0[1399],prg0[1395],prg0[1406],prg0[1402],prg0[1398],prg0[1394],
                      prg0[1405],prg0[1401],prg0[1397],prg0[1393],prg0[1404],prg0[1400],prg0[1396],prg0[1392],
                      prg0[1391],prg0[1387],prg0[1383],prg0[1379],prg0[1390],prg0[1386],prg0[1382],prg0[1378],
                      prg0[1389],prg0[1385],prg0[1381],prg0[1377],prg0[1388],prg0[1384],prg0[1380],prg0[1376],
                      prg0[1375],prg0[1371],prg0[1367],prg0[1363],prg0[1374],prg0[1370],prg0[1366],prg0[1362],
                      prg0[1373],prg0[1369],prg0[1365],prg0[1361],prg0[1372],prg0[1368],prg0[1364],prg0[1360],
                      prg0[1359],prg0[1355],prg0[1351],prg0[1347],prg0[1358],prg0[1354],prg0[1350],prg0[1346],
                      prg0[1357],prg0[1353],prg0[1349],prg0[1345],prg0[1356],prg0[1352],prg0[1348],prg0[1344],
                      prg0[1343],prg0[1339],prg0[1335],prg0[1331],prg0[1342],prg0[1338],prg0[1334],prg0[1330],
                      prg0[1341],prg0[1337],prg0[1333],prg0[1329],prg0[1340],prg0[1336],prg0[1332],prg0[1328],
                      prg0[1327],prg0[1323],prg0[1319],prg0[1315],prg0[1326],prg0[1322],prg0[1318],prg0[1314],
                      prg0[1325],prg0[1321],prg0[1317],prg0[1313],prg0[1324],prg0[1320],prg0[1316],prg0[1312],
                      prg0[1311],prg0[1307],prg0[1303],prg0[1299],prg0[1310],prg0[1306],prg0[1302],prg0[1298],
                      prg0[1309],prg0[1305],prg0[1301],prg0[1297],prg0[1308],prg0[1304],prg0[1300],prg0[1296],
                      prg0[1295],prg0[1291],prg0[1287],prg0[1283],prg0[1294],prg0[1290],prg0[1286],prg0[1282],
                      prg0[1293],prg0[1289],prg0[1285],prg0[1281],prg0[1292],prg0[1288],prg0[1284],prg0[1280]}),
             .INIT_4({prg0[1279],prg0[1275],prg0[1271],prg0[1267],prg0[1278],prg0[1274],prg0[1270],prg0[1266],
                      prg0[1277],prg0[1273],prg0[1269],prg0[1265],prg0[1276],prg0[1272],prg0[1268],prg0[1264],
                      prg0[1263],prg0[1259],prg0[1255],prg0[1251],prg0[1262],prg0[1258],prg0[1254],prg0[1250],
                      prg0[1261],prg0[1257],prg0[1253],prg0[1249],prg0[1260],prg0[1256],prg0[1252],prg0[1248],
                      prg0[1247],prg0[1243],prg0[1239],prg0[1235],prg0[1246],prg0[1242],prg0[1238],prg0[1234],
                      prg0[1245],prg0[1241],prg0[1237],prg0[1233],prg0[1244],prg0[1240],prg0[1236],prg0[1232],
                      prg0[1231],prg0[1227],prg0[1223],prg0[1219],prg0[1230],prg0[1226],prg0[1222],prg0[1218],
                      prg0[1229],prg0[1225],prg0[1221],prg0[1217],prg0[1228],prg0[1224],prg0[1220],prg0[1216],
                      prg0[1215],prg0[1211],prg0[1207],prg0[1203],prg0[1214],prg0[1210],prg0[1206],prg0[1202],
                      prg0[1213],prg0[1209],prg0[1205],prg0[1201],prg0[1212],prg0[1208],prg0[1204],prg0[1200],
                      prg0[1199],prg0[1195],prg0[1191],prg0[1187],prg0[1198],prg0[1194],prg0[1190],prg0[1186],
                      prg0[1197],prg0[1193],prg0[1189],prg0[1185],prg0[1196],prg0[1192],prg0[1188],prg0[1184],
                      prg0[1183],prg0[1179],prg0[1175],prg0[1171],prg0[1182],prg0[1178],prg0[1174],prg0[1170],
                      prg0[1181],prg0[1177],prg0[1173],prg0[1169],prg0[1180],prg0[1176],prg0[1172],prg0[1168],
                      prg0[1167],prg0[1163],prg0[1159],prg0[1155],prg0[1166],prg0[1162],prg0[1158],prg0[1154],
                      prg0[1165],prg0[1161],prg0[1157],prg0[1153],prg0[1164],prg0[1160],prg0[1156],prg0[1152],
                      prg0[1151],prg0[1147],prg0[1143],prg0[1139],prg0[1150],prg0[1146],prg0[1142],prg0[1138],
                      prg0[1149],prg0[1145],prg0[1141],prg0[1137],prg0[1148],prg0[1144],prg0[1140],prg0[1136],
                      prg0[1135],prg0[1131],prg0[1127],prg0[1123],prg0[1134],prg0[1130],prg0[1126],prg0[1122],
                      prg0[1133],prg0[1129],prg0[1125],prg0[1121],prg0[1132],prg0[1128],prg0[1124],prg0[1120],
                      prg0[1119],prg0[1115],prg0[1111],prg0[1107],prg0[1118],prg0[1114],prg0[1110],prg0[1106],
                      prg0[1117],prg0[1113],prg0[1109],prg0[1105],prg0[1116],prg0[1112],prg0[1108],prg0[1104],
                      prg0[1103],prg0[1099],prg0[1095],prg0[1091],prg0[1102],prg0[1098],prg0[1094],prg0[1090],
                      prg0[1101],prg0[1097],prg0[1093],prg0[1089],prg0[1100],prg0[1096],prg0[1092],prg0[1088],
                      prg0[1087],prg0[1083],prg0[1079],prg0[1075],prg0[1086],prg0[1082],prg0[1078],prg0[1074],
                      prg0[1085],prg0[1081],prg0[1077],prg0[1073],prg0[1084],prg0[1080],prg0[1076],prg0[1072],
                      prg0[1071],prg0[1067],prg0[1063],prg0[1059],prg0[1070],prg0[1066],prg0[1062],prg0[1058],
                      prg0[1069],prg0[1065],prg0[1061],prg0[1057],prg0[1068],prg0[1064],prg0[1060],prg0[1056],
                      prg0[1055],prg0[1051],prg0[1047],prg0[1043],prg0[1054],prg0[1050],prg0[1046],prg0[1042],
                      prg0[1053],prg0[1049],prg0[1045],prg0[1041],prg0[1052],prg0[1048],prg0[1044],prg0[1040],
                      prg0[1039],prg0[1035],prg0[1031],prg0[1027],prg0[1038],prg0[1034],prg0[1030],prg0[1026],
                      prg0[1037],prg0[1033],prg0[1029],prg0[1025],prg0[1036],prg0[1032],prg0[1028],prg0[1024]}),
             .INIT_3({prg0[1023],prg0[1019],prg0[1015],prg0[1011],prg0[1022],prg0[1018],prg0[1014],prg0[1010],
                      prg0[1021],prg0[1017],prg0[1013],prg0[1009],prg0[1020],prg0[1016],prg0[1012],prg0[1008],
                      prg0[1007],prg0[1003],prg0[ 999],prg0[ 995],prg0[1006],prg0[1002],prg0[ 998],prg0[ 994],
                      prg0[1005],prg0[1001],prg0[ 997],prg0[ 993],prg0[1004],prg0[1000],prg0[ 996],prg0[ 992],
                      prg0[ 991],prg0[ 987],prg0[ 983],prg0[ 979],prg0[ 990],prg0[ 986],prg0[ 982],prg0[ 978],
                      prg0[ 989],prg0[ 985],prg0[ 981],prg0[ 977],prg0[ 988],prg0[ 984],prg0[ 980],prg0[ 976],
                      prg0[ 975],prg0[ 971],prg0[ 967],prg0[ 963],prg0[ 974],prg0[ 970],prg0[ 966],prg0[ 962],
                      prg0[ 973],prg0[ 969],prg0[ 965],prg0[ 961],prg0[ 972],prg0[ 968],prg0[ 964],prg0[ 960],
                      prg0[ 959],prg0[ 955],prg0[ 951],prg0[ 947],prg0[ 958],prg0[ 954],prg0[ 950],prg0[ 946],
                      prg0[ 957],prg0[ 953],prg0[ 949],prg0[ 945],prg0[ 956],prg0[ 952],prg0[ 948],prg0[ 944],
                      prg0[ 943],prg0[ 939],prg0[ 935],prg0[ 931],prg0[ 942],prg0[ 938],prg0[ 934],prg0[ 930],
                      prg0[ 941],prg0[ 937],prg0[ 933],prg0[ 929],prg0[ 940],prg0[ 936],prg0[ 932],prg0[ 928],
                      prg0[ 927],prg0[ 923],prg0[ 919],prg0[ 915],prg0[ 926],prg0[ 922],prg0[ 918],prg0[ 914],
                      prg0[ 925],prg0[ 921],prg0[ 917],prg0[ 913],prg0[ 924],prg0[ 920],prg0[ 916],prg0[ 912],
                      prg0[ 911],prg0[ 907],prg0[ 903],prg0[ 899],prg0[ 910],prg0[ 906],prg0[ 902],prg0[ 898],
                      prg0[ 909],prg0[ 905],prg0[ 901],prg0[ 897],prg0[ 908],prg0[ 904],prg0[ 900],prg0[ 896],
                      prg0[ 895],prg0[ 891],prg0[ 887],prg0[ 883],prg0[ 894],prg0[ 890],prg0[ 886],prg0[ 882],
                      prg0[ 893],prg0[ 889],prg0[ 885],prg0[ 881],prg0[ 892],prg0[ 888],prg0[ 884],prg0[ 880],
                      prg0[ 879],prg0[ 875],prg0[ 871],prg0[ 867],prg0[ 878],prg0[ 874],prg0[ 870],prg0[ 866],
                      prg0[ 877],prg0[ 873],prg0[ 869],prg0[ 865],prg0[ 876],prg0[ 872],prg0[ 868],prg0[ 864],
                      prg0[ 863],prg0[ 859],prg0[ 855],prg0[ 851],prg0[ 862],prg0[ 858],prg0[ 854],prg0[ 850],
                      prg0[ 861],prg0[ 857],prg0[ 853],prg0[ 849],prg0[ 860],prg0[ 856],prg0[ 852],prg0[ 848],
                      prg0[ 847],prg0[ 843],prg0[ 839],prg0[ 835],prg0[ 846],prg0[ 842],prg0[ 838],prg0[ 834],
                      prg0[ 845],prg0[ 841],prg0[ 837],prg0[ 833],prg0[ 844],prg0[ 840],prg0[ 836],prg0[ 832],
                      prg0[ 831],prg0[ 827],prg0[ 823],prg0[ 819],prg0[ 830],prg0[ 826],prg0[ 822],prg0[ 818],
                      prg0[ 829],prg0[ 825],prg0[ 821],prg0[ 817],prg0[ 828],prg0[ 824],prg0[ 820],prg0[ 816],
                      prg0[ 815],prg0[ 811],prg0[ 807],prg0[ 803],prg0[ 814],prg0[ 810],prg0[ 806],prg0[ 802],
                      prg0[ 813],prg0[ 809],prg0[ 805],prg0[ 801],prg0[ 812],prg0[ 808],prg0[ 804],prg0[ 800],
                      prg0[ 799],prg0[ 795],prg0[ 791],prg0[ 787],prg0[ 798],prg0[ 794],prg0[ 790],prg0[ 786],
                      prg0[ 797],prg0[ 793],prg0[ 789],prg0[ 785],prg0[ 796],prg0[ 792],prg0[ 788],prg0[ 784],
                      prg0[ 783],prg0[ 779],prg0[ 775],prg0[ 771],prg0[ 782],prg0[ 778],prg0[ 774],prg0[ 770],
                      prg0[ 781],prg0[ 777],prg0[ 773],prg0[ 769],prg0[ 780],prg0[ 776],prg0[ 772],prg0[ 768]}),
             .INIT_2({prg0[ 767],prg0[ 763],prg0[ 759],prg0[ 755],prg0[ 766],prg0[ 762],prg0[ 758],prg0[ 754],
                      prg0[ 765],prg0[ 761],prg0[ 757],prg0[ 753],prg0[ 764],prg0[ 760],prg0[ 756],prg0[ 752],
                      prg0[ 751],prg0[ 747],prg0[ 743],prg0[ 739],prg0[ 750],prg0[ 746],prg0[ 742],prg0[ 738],
                      prg0[ 749],prg0[ 745],prg0[ 741],prg0[ 737],prg0[ 748],prg0[ 744],prg0[ 740],prg0[ 736],
                      prg0[ 735],prg0[ 731],prg0[ 727],prg0[ 723],prg0[ 734],prg0[ 730],prg0[ 726],prg0[ 722],
                      prg0[ 733],prg0[ 729],prg0[ 725],prg0[ 721],prg0[ 732],prg0[ 728],prg0[ 724],prg0[ 720],
                      prg0[ 719],prg0[ 715],prg0[ 711],prg0[ 707],prg0[ 718],prg0[ 714],prg0[ 710],prg0[ 706],
                      prg0[ 717],prg0[ 713],prg0[ 709],prg0[ 705],prg0[ 716],prg0[ 712],prg0[ 708],prg0[ 704],
                      prg0[ 703],prg0[ 699],prg0[ 695],prg0[ 691],prg0[ 702],prg0[ 698],prg0[ 694],prg0[ 690],
                      prg0[ 701],prg0[ 697],prg0[ 693],prg0[ 689],prg0[ 700],prg0[ 696],prg0[ 692],prg0[ 688],
                      prg0[ 687],prg0[ 683],prg0[ 679],prg0[ 675],prg0[ 686],prg0[ 682],prg0[ 678],prg0[ 674],
                      prg0[ 685],prg0[ 681],prg0[ 677],prg0[ 673],prg0[ 684],prg0[ 680],prg0[ 676],prg0[ 672],
                      prg0[ 671],prg0[ 667],prg0[ 663],prg0[ 659],prg0[ 670],prg0[ 666],prg0[ 662],prg0[ 658],
                      prg0[ 669],prg0[ 665],prg0[ 661],prg0[ 657],prg0[ 668],prg0[ 664],prg0[ 660],prg0[ 656],
                      prg0[ 655],prg0[ 651],prg0[ 647],prg0[ 643],prg0[ 654],prg0[ 650],prg0[ 646],prg0[ 642],
                      prg0[ 653],prg0[ 649],prg0[ 645],prg0[ 641],prg0[ 652],prg0[ 648],prg0[ 644],prg0[ 640],
                      prg0[ 639],prg0[ 635],prg0[ 631],prg0[ 627],prg0[ 638],prg0[ 634],prg0[ 630],prg0[ 626],
                      prg0[ 637],prg0[ 633],prg0[ 629],prg0[ 625],prg0[ 636],prg0[ 632],prg0[ 628],prg0[ 624],
                      prg0[ 623],prg0[ 619],prg0[ 615],prg0[ 611],prg0[ 622],prg0[ 618],prg0[ 614],prg0[ 610],
                      prg0[ 621],prg0[ 617],prg0[ 613],prg0[ 609],prg0[ 620],prg0[ 616],prg0[ 612],prg0[ 608],
                      prg0[ 607],prg0[ 603],prg0[ 599],prg0[ 595],prg0[ 606],prg0[ 602],prg0[ 598],prg0[ 594],
                      prg0[ 605],prg0[ 601],prg0[ 597],prg0[ 593],prg0[ 604],prg0[ 600],prg0[ 596],prg0[ 592],
                      prg0[ 591],prg0[ 587],prg0[ 583],prg0[ 579],prg0[ 590],prg0[ 586],prg0[ 582],prg0[ 578],
                      prg0[ 589],prg0[ 585],prg0[ 581],prg0[ 577],prg0[ 588],prg0[ 584],prg0[ 580],prg0[ 576],
                      prg0[ 575],prg0[ 571],prg0[ 567],prg0[ 563],prg0[ 574],prg0[ 570],prg0[ 566],prg0[ 562],
                      prg0[ 573],prg0[ 569],prg0[ 565],prg0[ 561],prg0[ 572],prg0[ 568],prg0[ 564],prg0[ 560],
                      prg0[ 559],prg0[ 555],prg0[ 551],prg0[ 547],prg0[ 558],prg0[ 554],prg0[ 550],prg0[ 546],
                      prg0[ 557],prg0[ 553],prg0[ 549],prg0[ 545],prg0[ 556],prg0[ 552],prg0[ 548],prg0[ 544],
                      prg0[ 543],prg0[ 539],prg0[ 535],prg0[ 531],prg0[ 542],prg0[ 538],prg0[ 534],prg0[ 530],
                      prg0[ 541],prg0[ 537],prg0[ 533],prg0[ 529],prg0[ 540],prg0[ 536],prg0[ 532],prg0[ 528],
                      prg0[ 527],prg0[ 523],prg0[ 519],prg0[ 515],prg0[ 526],prg0[ 522],prg0[ 518],prg0[ 514],
                      prg0[ 525],prg0[ 521],prg0[ 517],prg0[ 513],prg0[ 524],prg0[ 520],prg0[ 516],prg0[ 512]}),
             .INIT_1({prg0[ 511],prg0[ 507],prg0[ 503],prg0[ 499],prg0[ 510],prg0[ 506],prg0[ 502],prg0[ 498],
                      prg0[ 509],prg0[ 505],prg0[ 501],prg0[ 497],prg0[ 508],prg0[ 504],prg0[ 500],prg0[ 496],
                      prg0[ 495],prg0[ 491],prg0[ 487],prg0[ 483],prg0[ 494],prg0[ 490],prg0[ 486],prg0[ 482],
                      prg0[ 493],prg0[ 489],prg0[ 485],prg0[ 481],prg0[ 492],prg0[ 488],prg0[ 484],prg0[ 480],
                      prg0[ 479],prg0[ 475],prg0[ 471],prg0[ 467],prg0[ 478],prg0[ 474],prg0[ 470],prg0[ 466],
                      prg0[ 477],prg0[ 473],prg0[ 469],prg0[ 465],prg0[ 476],prg0[ 472],prg0[ 468],prg0[ 464],
                      prg0[ 463],prg0[ 459],prg0[ 455],prg0[ 451],prg0[ 462],prg0[ 458],prg0[ 454],prg0[ 450],
                      prg0[ 461],prg0[ 457],prg0[ 453],prg0[ 449],prg0[ 460],prg0[ 456],prg0[ 452],prg0[ 448],
                      prg0[ 447],prg0[ 443],prg0[ 439],prg0[ 435],prg0[ 446],prg0[ 442],prg0[ 438],prg0[ 434],
                      prg0[ 445],prg0[ 441],prg0[ 437],prg0[ 433],prg0[ 444],prg0[ 440],prg0[ 436],prg0[ 432],
                      prg0[ 431],prg0[ 427],prg0[ 423],prg0[ 419],prg0[ 430],prg0[ 426],prg0[ 422],prg0[ 418],
                      prg0[ 429],prg0[ 425],prg0[ 421],prg0[ 417],prg0[ 428],prg0[ 424],prg0[ 420],prg0[ 416],
                      prg0[ 415],prg0[ 411],prg0[ 407],prg0[ 403],prg0[ 414],prg0[ 410],prg0[ 406],prg0[ 402],
                      prg0[ 413],prg0[ 409],prg0[ 405],prg0[ 401],prg0[ 412],prg0[ 408],prg0[ 404],prg0[ 400],
                      prg0[ 399],prg0[ 395],prg0[ 391],prg0[ 387],prg0[ 398],prg0[ 394],prg0[ 390],prg0[ 386],
                      prg0[ 397],prg0[ 393],prg0[ 389],prg0[ 385],prg0[ 396],prg0[ 392],prg0[ 388],prg0[ 384],
                      prg0[ 383],prg0[ 379],prg0[ 375],prg0[ 371],prg0[ 382],prg0[ 378],prg0[ 374],prg0[ 370],
                      prg0[ 381],prg0[ 377],prg0[ 373],prg0[ 369],prg0[ 380],prg0[ 376],prg0[ 372],prg0[ 368],
                      prg0[ 367],prg0[ 363],prg0[ 359],prg0[ 355],prg0[ 366],prg0[ 362],prg0[ 358],prg0[ 354],
                      prg0[ 365],prg0[ 361],prg0[ 357],prg0[ 353],prg0[ 364],prg0[ 360],prg0[ 356],prg0[ 352],
                      prg0[ 351],prg0[ 347],prg0[ 343],prg0[ 339],prg0[ 350],prg0[ 346],prg0[ 342],prg0[ 338],
                      prg0[ 349],prg0[ 345],prg0[ 341],prg0[ 337],prg0[ 348],prg0[ 344],prg0[ 340],prg0[ 336],
                      prg0[ 335],prg0[ 331],prg0[ 327],prg0[ 323],prg0[ 334],prg0[ 330],prg0[ 326],prg0[ 322],
                      prg0[ 333],prg0[ 329],prg0[ 325],prg0[ 321],prg0[ 332],prg0[ 328],prg0[ 324],prg0[ 320],
                      prg0[ 319],prg0[ 315],prg0[ 311],prg0[ 307],prg0[ 318],prg0[ 314],prg0[ 310],prg0[ 306],
                      prg0[ 317],prg0[ 313],prg0[ 309],prg0[ 305],prg0[ 316],prg0[ 312],prg0[ 308],prg0[ 304],
                      prg0[ 303],prg0[ 299],prg0[ 295],prg0[ 291],prg0[ 302],prg0[ 298],prg0[ 294],prg0[ 290],
                      prg0[ 301],prg0[ 297],prg0[ 293],prg0[ 289],prg0[ 300],prg0[ 296],prg0[ 292],prg0[ 288],
                      prg0[ 287],prg0[ 283],prg0[ 279],prg0[ 275],prg0[ 286],prg0[ 282],prg0[ 278],prg0[ 274],
                      prg0[ 285],prg0[ 281],prg0[ 277],prg0[ 273],prg0[ 284],prg0[ 280],prg0[ 276],prg0[ 272],
                      prg0[ 271],prg0[ 267],prg0[ 263],prg0[ 259],prg0[ 270],prg0[ 266],prg0[ 262],prg0[ 258],
                      prg0[ 269],prg0[ 265],prg0[ 261],prg0[ 257],prg0[ 268],prg0[ 264],prg0[ 260],prg0[ 256]}),
             .INIT_0({prg0[ 255],prg0[ 251],prg0[ 247],prg0[ 243],prg0[ 254],prg0[ 250],prg0[ 246],prg0[ 242],
                      prg0[ 253],prg0[ 249],prg0[ 245],prg0[ 241],prg0[ 252],prg0[ 248],prg0[ 244],prg0[ 240],
                      prg0[ 239],prg0[ 235],prg0[ 231],prg0[ 227],prg0[ 238],prg0[ 234],prg0[ 230],prg0[ 226],
                      prg0[ 237],prg0[ 233],prg0[ 229],prg0[ 225],prg0[ 236],prg0[ 232],prg0[ 228],prg0[ 224],
                      prg0[ 223],prg0[ 219],prg0[ 215],prg0[ 211],prg0[ 222],prg0[ 218],prg0[ 214],prg0[ 210],
                      prg0[ 221],prg0[ 217],prg0[ 213],prg0[ 209],prg0[ 220],prg0[ 216],prg0[ 212],prg0[ 208],
                      prg0[ 207],prg0[ 203],prg0[ 199],prg0[ 195],prg0[ 206],prg0[ 202],prg0[ 198],prg0[ 194],
                      prg0[ 205],prg0[ 201],prg0[ 197],prg0[ 193],prg0[ 204],prg0[ 200],prg0[ 196],prg0[ 192],
                      prg0[ 191],prg0[ 187],prg0[ 183],prg0[ 179],prg0[ 190],prg0[ 186],prg0[ 182],prg0[ 178],
                      prg0[ 189],prg0[ 185],prg0[ 181],prg0[ 177],prg0[ 188],prg0[ 184],prg0[ 180],prg0[ 176],
                      prg0[ 175],prg0[ 171],prg0[ 167],prg0[ 163],prg0[ 174],prg0[ 170],prg0[ 166],prg0[ 162],
                      prg0[ 173],prg0[ 169],prg0[ 165],prg0[ 161],prg0[ 172],prg0[ 168],prg0[ 164],prg0[ 160],
                      prg0[ 159],prg0[ 155],prg0[ 151],prg0[ 147],prg0[ 158],prg0[ 154],prg0[ 150],prg0[ 146],
                      prg0[ 157],prg0[ 153],prg0[ 149],prg0[ 145],prg0[ 156],prg0[ 152],prg0[ 148],prg0[ 144],
                      prg0[ 143],prg0[ 139],prg0[ 135],prg0[ 131],prg0[ 142],prg0[ 138],prg0[ 134],prg0[ 130],
                      prg0[ 141],prg0[ 137],prg0[ 133],prg0[ 129],prg0[ 140],prg0[ 136],prg0[ 132],prg0[ 128],
                      prg0[ 127],prg0[ 123],prg0[ 119],prg0[ 115],prg0[ 126],prg0[ 122],prg0[ 118],prg0[ 114],
                      prg0[ 125],prg0[ 121],prg0[ 117],prg0[ 113],prg0[ 124],prg0[ 120],prg0[ 116],prg0[ 112],
                      prg0[ 111],prg0[ 107],prg0[ 103],prg0[  99],prg0[ 110],prg0[ 106],prg0[ 102],prg0[  98],
                      prg0[ 109],prg0[ 105],prg0[ 101],prg0[  97],prg0[ 108],prg0[ 104],prg0[ 100],prg0[  96],
                      prg0[  95],prg0[  91],prg0[  87],prg0[  83],prg0[  94],prg0[  90],prg0[  86],prg0[  82],
                      prg0[  93],prg0[  89],prg0[  85],prg0[  81],prg0[  92],prg0[  88],prg0[  84],prg0[  80],
                      prg0[  79],prg0[  75],prg0[  71],prg0[  67],prg0[  78],prg0[  74],prg0[  70],prg0[  66],
                      prg0[  77],prg0[  73],prg0[  69],prg0[  65],prg0[  76],prg0[  72],prg0[  68],prg0[  64],
                      prg0[  63],prg0[  59],prg0[  55],prg0[  51],prg0[  62],prg0[  58],prg0[  54],prg0[  50],
                      prg0[  61],prg0[  57],prg0[  53],prg0[  49],prg0[  60],prg0[  56],prg0[  52],prg0[  48],
                      prg0[  47],prg0[  43],prg0[  39],prg0[  35],prg0[  46],prg0[  42],prg0[  38],prg0[  34],
                      prg0[  45],prg0[  41],prg0[  37],prg0[  33],prg0[  44],prg0[  40],prg0[  36],prg0[  32],
                      prg0[  31],prg0[  27],prg0[  23],prg0[  19],prg0[  30],prg0[  26],prg0[  22],prg0[  18],
                      prg0[  29],prg0[  25],prg0[  21],prg0[  17],prg0[  28],prg0[  24],prg0[  20],prg0[  16],
                      prg0[  15],prg0[  11],prg0[   7],prg0[   3],prg0[  14],prg0[  10],prg0[   6],prg0[   2],
                      prg0[  13],prg0[   9],prg0[   5],prg0[   1],prg0[  12],prg0[   8],prg0[   4],prg0[   0]}),             
             .READ_MODE(2),
             .WRITE_MODE(2))
         mem
           (// Outputs
            .RDATA  ( {dum12[11:10],
                       DAT_O[3],dum12[9:7],
                       DAT_O[2],dum12[6:4],
                       DAT_O[1],dum12[3:1],
                       DAT_O[0],dum12[0]}           ),
            // Input
            .MASK   ( 16'h0                         ),
            .WDATA  ( {2'h0,                       
                       B[3],3'h0,
                       B[2],3'h0,
                       B[1],3'h0,
                       B[0],1'b0}       ),                       
            .WADDR  ( {1'b0,Wai[1:0],Wai[9:2]}      ), // Note mangling
            .RADDR  ( {1'b0,Rai[1:0],Rai[9:2]}      ), // Note mangling
            .RE     ( 1'b1                          ),
            .WE     ( 1'b1                          ), 
            .WCLK   ( clk                           ),
            .RCLK   ( clk                           ),
            .RCLKE  ( 1'b1                          ),
            .WCLKE  ( we                            ) 
            /*AUTOINST*/);

      end else begin
         /* Split 1 KiB memory into two and two bits
          */
         localparam [4095:0]
           pb0 = {prg1[4093:4092],prg1[4089:4088],prg1[4085:4084],prg1[4081:4080],prg1[4077:4076],prg1[4073:4072],prg1[4069:4068],prg1[4065:4064],
                  prg1[4061:4060],prg1[4057:4056],prg1[4053:4052],prg1[4049:4048],prg1[4045:4044],prg1[4041:4040],prg1[4037:4036],prg1[4033:4032],
                  prg1[4029:4028],prg1[4025:4024],prg1[4021:4020],prg1[4017:4016],prg1[4013:4012],prg1[4009:4008],prg1[4005:4004],prg1[4001:4000],
                  prg1[3997:3996],prg1[3993:3992],prg1[3989:3988],prg1[3985:3984],prg1[3981:3980],prg1[3977:3976],prg1[3973:3972],prg1[3969:3968],
                  prg1[3965:3964],prg1[3961:3960],prg1[3957:3956],prg1[3953:3952],prg1[3949:3948],prg1[3945:3944],prg1[3941:3940],prg1[3937:3936],
                  prg1[3933:3932],prg1[3929:3928],prg1[3925:3924],prg1[3921:3920],prg1[3917:3916],prg1[3913:3912],prg1[3909:3908],prg1[3905:3904],
                  prg1[3901:3900],prg1[3897:3896],prg1[3893:3892],prg1[3889:3888],prg1[3885:3884],prg1[3881:3880],prg1[3877:3876],prg1[3873:3872],
                  prg1[3869:3868],prg1[3865:3864],prg1[3861:3860],prg1[3857:3856],prg1[3853:3852],prg1[3849:3848],prg1[3845:3844],prg1[3841:3840],
                  prg1[3837:3836],prg1[3833:3832],prg1[3829:3828],prg1[3825:3824],prg1[3821:3820],prg1[3817:3816],prg1[3813:3812],prg1[3809:3808],
                  prg1[3805:3804],prg1[3801:3800],prg1[3797:3796],prg1[3793:3792],prg1[3789:3788],prg1[3785:3784],prg1[3781:3780],prg1[3777:3776],
                  prg1[3773:3772],prg1[3769:3768],prg1[3765:3764],prg1[3761:3760],prg1[3757:3756],prg1[3753:3752],prg1[3749:3748],prg1[3745:3744],
                  prg1[3741:3740],prg1[3737:3736],prg1[3733:3732],prg1[3729:3728],prg1[3725:3724],prg1[3721:3720],prg1[3717:3716],prg1[3713:3712],
                  prg1[3709:3708],prg1[3705:3704],prg1[3701:3700],prg1[3697:3696],prg1[3693:3692],prg1[3689:3688],prg1[3685:3684],prg1[3681:3680],
                  prg1[3677:3676],prg1[3673:3672],prg1[3669:3668],prg1[3665:3664],prg1[3661:3660],prg1[3657:3656],prg1[3653:3652],prg1[3649:3648],
                  prg1[3645:3644],prg1[3641:3640],prg1[3637:3636],prg1[3633:3632],prg1[3629:3628],prg1[3625:3624],prg1[3621:3620],prg1[3617:3616],
                  prg1[3613:3612],prg1[3609:3608],prg1[3605:3604],prg1[3601:3600],prg1[3597:3596],prg1[3593:3592],prg1[3589:3588],prg1[3585:3584],
                  prg1[3581:3580],prg1[3577:3576],prg1[3573:3572],prg1[3569:3568],prg1[3565:3564],prg1[3561:3560],prg1[3557:3556],prg1[3553:3552],
                  prg1[3549:3548],prg1[3545:3544],prg1[3541:3540],prg1[3537:3536],prg1[3533:3532],prg1[3529:3528],prg1[3525:3524],prg1[3521:3520],
                  prg1[3517:3516],prg1[3513:3512],prg1[3509:3508],prg1[3505:3504],prg1[3501:3500],prg1[3497:3496],prg1[3493:3492],prg1[3489:3488],
                  prg1[3485:3484],prg1[3481:3480],prg1[3477:3476],prg1[3473:3472],prg1[3469:3468],prg1[3465:3464],prg1[3461:3460],prg1[3457:3456],
                  prg1[3453:3452],prg1[3449:3448],prg1[3445:3444],prg1[3441:3440],prg1[3437:3436],prg1[3433:3432],prg1[3429:3428],prg1[3425:3424],
                  prg1[3421:3420],prg1[3417:3416],prg1[3413:3412],prg1[3409:3408],prg1[3405:3404],prg1[3401:3400],prg1[3397:3396],prg1[3393:3392],
                  prg1[3389:3388],prg1[3385:3384],prg1[3381:3380],prg1[3377:3376],prg1[3373:3372],prg1[3369:3368],prg1[3365:3364],prg1[3361:3360],
                  prg1[3357:3356],prg1[3353:3352],prg1[3349:3348],prg1[3345:3344],prg1[3341:3340],prg1[3337:3336],prg1[3333:3332],prg1[3329:3328],
                  prg1[3325:3324],prg1[3321:3320],prg1[3317:3316],prg1[3313:3312],prg1[3309:3308],prg1[3305:3304],prg1[3301:3300],prg1[3297:3296],
                  prg1[3293:3292],prg1[3289:3288],prg1[3285:3284],prg1[3281:3280],prg1[3277:3276],prg1[3273:3272],prg1[3269:3268],prg1[3265:3264],
                  prg1[3261:3260],prg1[3257:3256],prg1[3253:3252],prg1[3249:3248],prg1[3245:3244],prg1[3241:3240],prg1[3237:3236],prg1[3233:3232],
                  prg1[3229:3228],prg1[3225:3224],prg1[3221:3220],prg1[3217:3216],prg1[3213:3212],prg1[3209:3208],prg1[3205:3204],prg1[3201:3200],
                  prg1[3197:3196],prg1[3193:3192],prg1[3189:3188],prg1[3185:3184],prg1[3181:3180],prg1[3177:3176],prg1[3173:3172],prg1[3169:3168],
                  prg1[3165:3164],prg1[3161:3160],prg1[3157:3156],prg1[3153:3152],prg1[3149:3148],prg1[3145:3144],prg1[3141:3140],prg1[3137:3136],
                  prg1[3133:3132],prg1[3129:3128],prg1[3125:3124],prg1[3121:3120],prg1[3117:3116],prg1[3113:3112],prg1[3109:3108],prg1[3105:3104],
                  prg1[3101:3100],prg1[3097:3096],prg1[3093:3092],prg1[3089:3088],prg1[3085:3084],prg1[3081:3080],prg1[3077:3076],prg1[3073:3072],
                  prg1[3069:3068],prg1[3065:3064],prg1[3061:3060],prg1[3057:3056],prg1[3053:3052],prg1[3049:3048],prg1[3045:3044],prg1[3041:3040],
                  prg1[3037:3036],prg1[3033:3032],prg1[3029:3028],prg1[3025:3024],prg1[3021:3020],prg1[3017:3016],prg1[3013:3012],prg1[3009:3008],
                  prg1[3005:3004],prg1[3001:3000],prg1[2997:2996],prg1[2993:2992],prg1[2989:2988],prg1[2985:2984],prg1[2981:2980],prg1[2977:2976],
                  prg1[2973:2972],prg1[2969:2968],prg1[2965:2964],prg1[2961:2960],prg1[2957:2956],prg1[2953:2952],prg1[2949:2948],prg1[2945:2944],
                  prg1[2941:2940],prg1[2937:2936],prg1[2933:2932],prg1[2929:2928],prg1[2925:2924],prg1[2921:2920],prg1[2917:2916],prg1[2913:2912],
                  prg1[2909:2908],prg1[2905:2904],prg1[2901:2900],prg1[2897:2896],prg1[2893:2892],prg1[2889:2888],prg1[2885:2884],prg1[2881:2880],
                  prg1[2877:2876],prg1[2873:2872],prg1[2869:2868],prg1[2865:2864],prg1[2861:2860],prg1[2857:2856],prg1[2853:2852],prg1[2849:2848],
                  prg1[2845:2844],prg1[2841:2840],prg1[2837:2836],prg1[2833:2832],prg1[2829:2828],prg1[2825:2824],prg1[2821:2820],prg1[2817:2816],
                  prg1[2813:2812],prg1[2809:2808],prg1[2805:2804],prg1[2801:2800],prg1[2797:2796],prg1[2793:2792],prg1[2789:2788],prg1[2785:2784],
                  prg1[2781:2780],prg1[2777:2776],prg1[2773:2772],prg1[2769:2768],prg1[2765:2764],prg1[2761:2760],prg1[2757:2756],prg1[2753:2752],
                  prg1[2749:2748],prg1[2745:2744],prg1[2741:2740],prg1[2737:2736],prg1[2733:2732],prg1[2729:2728],prg1[2725:2724],prg1[2721:2720],
                  prg1[2717:2716],prg1[2713:2712],prg1[2709:2708],prg1[2705:2704],prg1[2701:2700],prg1[2697:2696],prg1[2693:2692],prg1[2689:2688],
                  prg1[2685:2684],prg1[2681:2680],prg1[2677:2676],prg1[2673:2672],prg1[2669:2668],prg1[2665:2664],prg1[2661:2660],prg1[2657:2656],
                  prg1[2653:2652],prg1[2649:2648],prg1[2645:2644],prg1[2641:2640],prg1[2637:2636],prg1[2633:2632],prg1[2629:2628],prg1[2625:2624],
                  prg1[2621:2620],prg1[2617:2616],prg1[2613:2612],prg1[2609:2608],prg1[2605:2604],prg1[2601:2600],prg1[2597:2596],prg1[2593:2592],
                  prg1[2589:2588],prg1[2585:2584],prg1[2581:2580],prg1[2577:2576],prg1[2573:2572],prg1[2569:2568],prg1[2565:2564],prg1[2561:2560],
                  prg1[2557:2556],prg1[2553:2552],prg1[2549:2548],prg1[2545:2544],prg1[2541:2540],prg1[2537:2536],prg1[2533:2532],prg1[2529:2528],
                  prg1[2525:2524],prg1[2521:2520],prg1[2517:2516],prg1[2513:2512],prg1[2509:2508],prg1[2505:2504],prg1[2501:2500],prg1[2497:2496],
                  prg1[2493:2492],prg1[2489:2488],prg1[2485:2484],prg1[2481:2480],prg1[2477:2476],prg1[2473:2472],prg1[2469:2468],prg1[2465:2464],
                  prg1[2461:2460],prg1[2457:2456],prg1[2453:2452],prg1[2449:2448],prg1[2445:2444],prg1[2441:2440],prg1[2437:2436],prg1[2433:2432],
                  prg1[2429:2428],prg1[2425:2424],prg1[2421:2420],prg1[2417:2416],prg1[2413:2412],prg1[2409:2408],prg1[2405:2404],prg1[2401:2400],
                  prg1[2397:2396],prg1[2393:2392],prg1[2389:2388],prg1[2385:2384],prg1[2381:2380],prg1[2377:2376],prg1[2373:2372],prg1[2369:2368],
                  prg1[2365:2364],prg1[2361:2360],prg1[2357:2356],prg1[2353:2352],prg1[2349:2348],prg1[2345:2344],prg1[2341:2340],prg1[2337:2336],
                  prg1[2333:2332],prg1[2329:2328],prg1[2325:2324],prg1[2321:2320],prg1[2317:2316],prg1[2313:2312],prg1[2309:2308],prg1[2305:2304],
                  prg1[2301:2300],prg1[2297:2296],prg1[2293:2292],prg1[2289:2288],prg1[2285:2284],prg1[2281:2280],prg1[2277:2276],prg1[2273:2272],
                  prg1[2269:2268],prg1[2265:2264],prg1[2261:2260],prg1[2257:2256],prg1[2253:2252],prg1[2249:2248],prg1[2245:2244],prg1[2241:2240],
                  prg1[2237:2236],prg1[2233:2232],prg1[2229:2228],prg1[2225:2224],prg1[2221:2220],prg1[2217:2216],prg1[2213:2212],prg1[2209:2208],
                  prg1[2205:2204],prg1[2201:2200],prg1[2197:2196],prg1[2193:2192],prg1[2189:2188],prg1[2185:2184],prg1[2181:2180],prg1[2177:2176],
                  prg1[2173:2172],prg1[2169:2168],prg1[2165:2164],prg1[2161:2160],prg1[2157:2156],prg1[2153:2152],prg1[2149:2148],prg1[2145:2144],
                  prg1[2141:2140],prg1[2137:2136],prg1[2133:2132],prg1[2129:2128],prg1[2125:2124],prg1[2121:2120],prg1[2117:2116],prg1[2113:2112],
                  prg1[2109:2108],prg1[2105:2104],prg1[2101:2100],prg1[2097:2096],prg1[2093:2092],prg1[2089:2088],prg1[2085:2084],prg1[2081:2080],
                  prg1[2077:2076],prg1[2073:2072],prg1[2069:2068],prg1[2065:2064],prg1[2061:2060],prg1[2057:2056],prg1[2053:2052],prg1[2049:2048],
                  prg1[2045:2044],prg1[2041:2040],prg1[2037:2036],prg1[2033:2032],prg1[2029:2028],prg1[2025:2024],prg1[2021:2020],prg1[2017:2016],
                  prg1[2013:2012],prg1[2009:2008],prg1[2005:2004],prg1[2001:2000],prg1[1997:1996],prg1[1993:1992],prg1[1989:1988],prg1[1985:1984],
                  prg1[1981:1980],prg1[1977:1976],prg1[1973:1972],prg1[1969:1968],prg1[1965:1964],prg1[1961:1960],prg1[1957:1956],prg1[1953:1952],
                  prg1[1949:1948],prg1[1945:1944],prg1[1941:1940],prg1[1937:1936],prg1[1933:1932],prg1[1929:1928],prg1[1925:1924],prg1[1921:1920],
                  prg1[1917:1916],prg1[1913:1912],prg1[1909:1908],prg1[1905:1904],prg1[1901:1900],prg1[1897:1896],prg1[1893:1892],prg1[1889:1888],
                  prg1[1885:1884],prg1[1881:1880],prg1[1877:1876],prg1[1873:1872],prg1[1869:1868],prg1[1865:1864],prg1[1861:1860],prg1[1857:1856],
                  prg1[1853:1852],prg1[1849:1848],prg1[1845:1844],prg1[1841:1840],prg1[1837:1836],prg1[1833:1832],prg1[1829:1828],prg1[1825:1824],
                  prg1[1821:1820],prg1[1817:1816],prg1[1813:1812],prg1[1809:1808],prg1[1805:1804],prg1[1801:1800],prg1[1797:1796],prg1[1793:1792],
                  prg1[1789:1788],prg1[1785:1784],prg1[1781:1780],prg1[1777:1776],prg1[1773:1772],prg1[1769:1768],prg1[1765:1764],prg1[1761:1760],
                  prg1[1757:1756],prg1[1753:1752],prg1[1749:1748],prg1[1745:1744],prg1[1741:1740],prg1[1737:1736],prg1[1733:1732],prg1[1729:1728],
                  prg1[1725:1724],prg1[1721:1720],prg1[1717:1716],prg1[1713:1712],prg1[1709:1708],prg1[1705:1704],prg1[1701:1700],prg1[1697:1696],
                  prg1[1693:1692],prg1[1689:1688],prg1[1685:1684],prg1[1681:1680],prg1[1677:1676],prg1[1673:1672],prg1[1669:1668],prg1[1665:1664],
                  prg1[1661:1660],prg1[1657:1656],prg1[1653:1652],prg1[1649:1648],prg1[1645:1644],prg1[1641:1640],prg1[1637:1636],prg1[1633:1632],
                  prg1[1629:1628],prg1[1625:1624],prg1[1621:1620],prg1[1617:1616],prg1[1613:1612],prg1[1609:1608],prg1[1605:1604],prg1[1601:1600],
                  prg1[1597:1596],prg1[1593:1592],prg1[1589:1588],prg1[1585:1584],prg1[1581:1580],prg1[1577:1576],prg1[1573:1572],prg1[1569:1568],
                  prg1[1565:1564],prg1[1561:1560],prg1[1557:1556],prg1[1553:1552],prg1[1549:1548],prg1[1545:1544],prg1[1541:1540],prg1[1537:1536],
                  prg1[1533:1532],prg1[1529:1528],prg1[1525:1524],prg1[1521:1520],prg1[1517:1516],prg1[1513:1512],prg1[1509:1508],prg1[1505:1504],
                  prg1[1501:1500],prg1[1497:1496],prg1[1493:1492],prg1[1489:1488],prg1[1485:1484],prg1[1481:1480],prg1[1477:1476],prg1[1473:1472],
                  prg1[1469:1468],prg1[1465:1464],prg1[1461:1460],prg1[1457:1456],prg1[1453:1452],prg1[1449:1448],prg1[1445:1444],prg1[1441:1440],
                  prg1[1437:1436],prg1[1433:1432],prg1[1429:1428],prg1[1425:1424],prg1[1421:1420],prg1[1417:1416],prg1[1413:1412],prg1[1409:1408],
                  prg1[1405:1404],prg1[1401:1400],prg1[1397:1396],prg1[1393:1392],prg1[1389:1388],prg1[1385:1384],prg1[1381:1380],prg1[1377:1376],
                  prg1[1373:1372],prg1[1369:1368],prg1[1365:1364],prg1[1361:1360],prg1[1357:1356],prg1[1353:1352],prg1[1349:1348],prg1[1345:1344],
                  prg1[1341:1340],prg1[1337:1336],prg1[1333:1332],prg1[1329:1328],prg1[1325:1324],prg1[1321:1320],prg1[1317:1316],prg1[1313:1312],
                  prg1[1309:1308],prg1[1305:1304],prg1[1301:1300],prg1[1297:1296],prg1[1293:1292],prg1[1289:1288],prg1[1285:1284],prg1[1281:1280],
                  prg1[1277:1276],prg1[1273:1272],prg1[1269:1268],prg1[1265:1264],prg1[1261:1260],prg1[1257:1256],prg1[1253:1252],prg1[1249:1248],
                  prg1[1245:1244],prg1[1241:1240],prg1[1237:1236],prg1[1233:1232],prg1[1229:1228],prg1[1225:1224],prg1[1221:1220],prg1[1217:1216],
                  prg1[1213:1212],prg1[1209:1208],prg1[1205:1204],prg1[1201:1200],prg1[1197:1196],prg1[1193:1192],prg1[1189:1188],prg1[1185:1184],
                  prg1[1181:1180],prg1[1177:1176],prg1[1173:1172],prg1[1169:1168],prg1[1165:1164],prg1[1161:1160],prg1[1157:1156],prg1[1153:1152],
                  prg1[1149:1148],prg1[1145:1144],prg1[1141:1140],prg1[1137:1136],prg1[1133:1132],prg1[1129:1128],prg1[1125:1124],prg1[1121:1120],
                  prg1[1117:1116],prg1[1113:1112],prg1[1109:1108],prg1[1105:1104],prg1[1101:1100],prg1[1097:1096],prg1[1093:1092],prg1[1089:1088],
                  prg1[1085:1084],prg1[1081:1080],prg1[1077:1076],prg1[1073:1072],prg1[1069:1068],prg1[1065:1064],prg1[1061:1060],prg1[1057:1056],
                  prg1[1053:1052],prg1[1049:1048],prg1[1045:1044],prg1[1041:1040],prg1[1037:1036],prg1[1033:1032],prg1[1029:1028],prg1[1025:1024],
                  prg1[1021:1020],prg1[1017:1016],prg1[1013:1012],prg1[1009:1008],prg1[1005:1004],prg1[1001:1000],prg1[ 997: 996],prg1[ 993: 992],
                  prg1[ 989: 988],prg1[ 985: 984],prg1[ 981: 980],prg1[ 977: 976],prg1[ 973: 972],prg1[ 969: 968],prg1[ 965: 964],prg1[ 961: 960],
                  prg1[ 957: 956],prg1[ 953: 952],prg1[ 949: 948],prg1[ 945: 944],prg1[ 941: 940],prg1[ 937: 936],prg1[ 933: 932],prg1[ 929: 928],
                  prg1[ 925: 924],prg1[ 921: 920],prg1[ 917: 916],prg1[ 913: 912],prg1[ 909: 908],prg1[ 905: 904],prg1[ 901: 900],prg1[ 897: 896],
                  prg1[ 893: 892],prg1[ 889: 888],prg1[ 885: 884],prg1[ 881: 880],prg1[ 877: 876],prg1[ 873: 872],prg1[ 869: 868],prg1[ 865: 864],
                  prg1[ 861: 860],prg1[ 857: 856],prg1[ 853: 852],prg1[ 849: 848],prg1[ 845: 844],prg1[ 841: 840],prg1[ 837: 836],prg1[ 833: 832],
                  prg1[ 829: 828],prg1[ 825: 824],prg1[ 821: 820],prg1[ 817: 816],prg1[ 813: 812],prg1[ 809: 808],prg1[ 805: 804],prg1[ 801: 800],
                  prg1[ 797: 796],prg1[ 793: 792],prg1[ 789: 788],prg1[ 785: 784],prg1[ 781: 780],prg1[ 777: 776],prg1[ 773: 772],prg1[ 769: 768],
                  prg1[ 765: 764],prg1[ 761: 760],prg1[ 757: 756],prg1[ 753: 752],prg1[ 749: 748],prg1[ 745: 744],prg1[ 741: 740],prg1[ 737: 736],
                  prg1[ 733: 732],prg1[ 729: 728],prg1[ 725: 724],prg1[ 721: 720],prg1[ 717: 716],prg1[ 713: 712],prg1[ 709: 708],prg1[ 705: 704],
                  prg1[ 701: 700],prg1[ 697: 696],prg1[ 693: 692],prg1[ 689: 688],prg1[ 685: 684],prg1[ 681: 680],prg1[ 677: 676],prg1[ 673: 672],
                  prg1[ 669: 668],prg1[ 665: 664],prg1[ 661: 660],prg1[ 657: 656],prg1[ 653: 652],prg1[ 649: 648],prg1[ 645: 644],prg1[ 641: 640],
                  prg1[ 637: 636],prg1[ 633: 632],prg1[ 629: 628],prg1[ 625: 624],prg1[ 621: 620],prg1[ 617: 616],prg1[ 613: 612],prg1[ 609: 608],
                  prg1[ 605: 604],prg1[ 601: 600],prg1[ 597: 596],prg1[ 593: 592],prg1[ 589: 588],prg1[ 585: 584],prg1[ 581: 580],prg1[ 577: 576],
                  prg1[ 573: 572],prg1[ 569: 568],prg1[ 565: 564],prg1[ 561: 560],prg1[ 557: 556],prg1[ 553: 552],prg1[ 549: 548],prg1[ 545: 544],
                  prg1[ 541: 540],prg1[ 537: 536],prg1[ 533: 532],prg1[ 529: 528],prg1[ 525: 524],prg1[ 521: 520],prg1[ 517: 516],prg1[ 513: 512],
                  prg1[ 509: 508],prg1[ 505: 504],prg1[ 501: 500],prg1[ 497: 496],prg1[ 493: 492],prg1[ 489: 488],prg1[ 485: 484],prg1[ 481: 480],
                  prg1[ 477: 476],prg1[ 473: 472],prg1[ 469: 468],prg1[ 465: 464],prg1[ 461: 460],prg1[ 457: 456],prg1[ 453: 452],prg1[ 449: 448],
                  prg1[ 445: 444],prg1[ 441: 440],prg1[ 437: 436],prg1[ 433: 432],prg1[ 429: 428],prg1[ 425: 424],prg1[ 421: 420],prg1[ 417: 416],
                  prg1[ 413: 412],prg1[ 409: 408],prg1[ 405: 404],prg1[ 401: 400],prg1[ 397: 396],prg1[ 393: 392],prg1[ 389: 388],prg1[ 385: 384],
                  prg1[ 381: 380],prg1[ 377: 376],prg1[ 373: 372],prg1[ 369: 368],prg1[ 365: 364],prg1[ 361: 360],prg1[ 357: 356],prg1[ 353: 352],
                  prg1[ 349: 348],prg1[ 345: 344],prg1[ 341: 340],prg1[ 337: 336],prg1[ 333: 332],prg1[ 329: 328],prg1[ 325: 324],prg1[ 321: 320],
                  prg1[ 317: 316],prg1[ 313: 312],prg1[ 309: 308],prg1[ 305: 304],prg1[ 301: 300],prg1[ 297: 296],prg1[ 293: 292],prg1[ 289: 288],
                  prg1[ 285: 284],prg1[ 281: 280],prg1[ 277: 276],prg1[ 273: 272],prg1[ 269: 268],prg1[ 265: 264],prg1[ 261: 260],prg1[ 257: 256],
                  prg1[ 253: 252],prg1[ 249: 248],prg1[ 245: 244],prg1[ 241: 240],prg1[ 237: 236],prg1[ 233: 232],prg1[ 229: 228],prg1[ 225: 224],
                  prg1[ 221: 220],prg1[ 217: 216],prg1[ 213: 212],prg1[ 209: 208],prg1[ 205: 204],prg1[ 201: 200],prg1[ 197: 196],prg1[ 193: 192],
                  prg1[ 189: 188],prg1[ 185: 184],prg1[ 181: 180],prg1[ 177: 176],prg1[ 173: 172],prg1[ 169: 168],prg1[ 165: 164],prg1[ 161: 160],
                  prg1[ 157: 156],prg1[ 153: 152],prg1[ 149: 148],prg1[ 145: 144],prg1[ 141: 140],prg1[ 137: 136],prg1[ 133: 132],prg1[ 129: 128],
                  prg1[ 125: 124],prg1[ 121: 120],prg1[ 117: 116],prg1[ 113: 112],prg1[ 109: 108],prg1[ 105: 104],prg1[ 101: 100],prg1[  97:  96],
                  prg1[  93:  92],prg1[  89:  88],prg1[  85:  84],prg1[  81:  80],prg1[  77:  76],prg1[  73:  72],prg1[  69:  68],prg1[  65:  64],
                  prg1[  61:  60],prg1[  57:  56],prg1[  53:  52],prg1[  49:  48],prg1[  45:  44],prg1[  41:  40],prg1[  37:  36],prg1[  33:  32],
                  prg1[  29:  28],prg1[  25:  24],prg1[  21:  20],prg1[  17:  16],prg1[  13:  12],prg1[   9:   8],prg1[   5:   4],prg1[   1:   0],
                  prg0[4093:4092],prg0[4089:4088],prg0[4085:4084],prg0[4081:4080],prg0[4077:4076],prg0[4073:4072],prg0[4069:4068],prg0[4065:4064],
                  prg0[4061:4060],prg0[4057:4056],prg0[4053:4052],prg0[4049:4048],prg0[4045:4044],prg0[4041:4040],prg0[4037:4036],prg0[4033:4032],
                  prg0[4029:4028],prg0[4025:4024],prg0[4021:4020],prg0[4017:4016],prg0[4013:4012],prg0[4009:4008],prg0[4005:4004],prg0[4001:4000],
                  prg0[3997:3996],prg0[3993:3992],prg0[3989:3988],prg0[3985:3984],prg0[3981:3980],prg0[3977:3976],prg0[3973:3972],prg0[3969:3968],
                  prg0[3965:3964],prg0[3961:3960],prg0[3957:3956],prg0[3953:3952],prg0[3949:3948],prg0[3945:3944],prg0[3941:3940],prg0[3937:3936],
                  prg0[3933:3932],prg0[3929:3928],prg0[3925:3924],prg0[3921:3920],prg0[3917:3916],prg0[3913:3912],prg0[3909:3908],prg0[3905:3904],
                  prg0[3901:3900],prg0[3897:3896],prg0[3893:3892],prg0[3889:3888],prg0[3885:3884],prg0[3881:3880],prg0[3877:3876],prg0[3873:3872],
                  prg0[3869:3868],prg0[3865:3864],prg0[3861:3860],prg0[3857:3856],prg0[3853:3852],prg0[3849:3848],prg0[3845:3844],prg0[3841:3840],
                  prg0[3837:3836],prg0[3833:3832],prg0[3829:3828],prg0[3825:3824],prg0[3821:3820],prg0[3817:3816],prg0[3813:3812],prg0[3809:3808],
                  prg0[3805:3804],prg0[3801:3800],prg0[3797:3796],prg0[3793:3792],prg0[3789:3788],prg0[3785:3784],prg0[3781:3780],prg0[3777:3776],
                  prg0[3773:3772],prg0[3769:3768],prg0[3765:3764],prg0[3761:3760],prg0[3757:3756],prg0[3753:3752],prg0[3749:3748],prg0[3745:3744],
                  prg0[3741:3740],prg0[3737:3736],prg0[3733:3732],prg0[3729:3728],prg0[3725:3724],prg0[3721:3720],prg0[3717:3716],prg0[3713:3712],
                  prg0[3709:3708],prg0[3705:3704],prg0[3701:3700],prg0[3697:3696],prg0[3693:3692],prg0[3689:3688],prg0[3685:3684],prg0[3681:3680],
                  prg0[3677:3676],prg0[3673:3672],prg0[3669:3668],prg0[3665:3664],prg0[3661:3660],prg0[3657:3656],prg0[3653:3652],prg0[3649:3648],
                  prg0[3645:3644],prg0[3641:3640],prg0[3637:3636],prg0[3633:3632],prg0[3629:3628],prg0[3625:3624],prg0[3621:3620],prg0[3617:3616],
                  prg0[3613:3612],prg0[3609:3608],prg0[3605:3604],prg0[3601:3600],prg0[3597:3596],prg0[3593:3592],prg0[3589:3588],prg0[3585:3584],
                  prg0[3581:3580],prg0[3577:3576],prg0[3573:3572],prg0[3569:3568],prg0[3565:3564],prg0[3561:3560],prg0[3557:3556],prg0[3553:3552],
                  prg0[3549:3548],prg0[3545:3544],prg0[3541:3540],prg0[3537:3536],prg0[3533:3532],prg0[3529:3528],prg0[3525:3524],prg0[3521:3520],
                  prg0[3517:3516],prg0[3513:3512],prg0[3509:3508],prg0[3505:3504],prg0[3501:3500],prg0[3497:3496],prg0[3493:3492],prg0[3489:3488],
                  prg0[3485:3484],prg0[3481:3480],prg0[3477:3476],prg0[3473:3472],prg0[3469:3468],prg0[3465:3464],prg0[3461:3460],prg0[3457:3456],
                  prg0[3453:3452],prg0[3449:3448],prg0[3445:3444],prg0[3441:3440],prg0[3437:3436],prg0[3433:3432],prg0[3429:3428],prg0[3425:3424],
                  prg0[3421:3420],prg0[3417:3416],prg0[3413:3412],prg0[3409:3408],prg0[3405:3404],prg0[3401:3400],prg0[3397:3396],prg0[3393:3392],
                  prg0[3389:3388],prg0[3385:3384],prg0[3381:3380],prg0[3377:3376],prg0[3373:3372],prg0[3369:3368],prg0[3365:3364],prg0[3361:3360],
                  prg0[3357:3356],prg0[3353:3352],prg0[3349:3348],prg0[3345:3344],prg0[3341:3340],prg0[3337:3336],prg0[3333:3332],prg0[3329:3328],
                  prg0[3325:3324],prg0[3321:3320],prg0[3317:3316],prg0[3313:3312],prg0[3309:3308],prg0[3305:3304],prg0[3301:3300],prg0[3297:3296],
                  prg0[3293:3292],prg0[3289:3288],prg0[3285:3284],prg0[3281:3280],prg0[3277:3276],prg0[3273:3272],prg0[3269:3268],prg0[3265:3264],
                  prg0[3261:3260],prg0[3257:3256],prg0[3253:3252],prg0[3249:3248],prg0[3245:3244],prg0[3241:3240],prg0[3237:3236],prg0[3233:3232],
                  prg0[3229:3228],prg0[3225:3224],prg0[3221:3220],prg0[3217:3216],prg0[3213:3212],prg0[3209:3208],prg0[3205:3204],prg0[3201:3200],
                  prg0[3197:3196],prg0[3193:3192],prg0[3189:3188],prg0[3185:3184],prg0[3181:3180],prg0[3177:3176],prg0[3173:3172],prg0[3169:3168],
                  prg0[3165:3164],prg0[3161:3160],prg0[3157:3156],prg0[3153:3152],prg0[3149:3148],prg0[3145:3144],prg0[3141:3140],prg0[3137:3136],
                  prg0[3133:3132],prg0[3129:3128],prg0[3125:3124],prg0[3121:3120],prg0[3117:3116],prg0[3113:3112],prg0[3109:3108],prg0[3105:3104],
                  prg0[3101:3100],prg0[3097:3096],prg0[3093:3092],prg0[3089:3088],prg0[3085:3084],prg0[3081:3080],prg0[3077:3076],prg0[3073:3072],
                  prg0[3069:3068],prg0[3065:3064],prg0[3061:3060],prg0[3057:3056],prg0[3053:3052],prg0[3049:3048],prg0[3045:3044],prg0[3041:3040],
                  prg0[3037:3036],prg0[3033:3032],prg0[3029:3028],prg0[3025:3024],prg0[3021:3020],prg0[3017:3016],prg0[3013:3012],prg0[3009:3008],
                  prg0[3005:3004],prg0[3001:3000],prg0[2997:2996],prg0[2993:2992],prg0[2989:2988],prg0[2985:2984],prg0[2981:2980],prg0[2977:2976],
                  prg0[2973:2972],prg0[2969:2968],prg0[2965:2964],prg0[2961:2960],prg0[2957:2956],prg0[2953:2952],prg0[2949:2948],prg0[2945:2944],
                  prg0[2941:2940],prg0[2937:2936],prg0[2933:2932],prg0[2929:2928],prg0[2925:2924],prg0[2921:2920],prg0[2917:2916],prg0[2913:2912],
                  prg0[2909:2908],prg0[2905:2904],prg0[2901:2900],prg0[2897:2896],prg0[2893:2892],prg0[2889:2888],prg0[2885:2884],prg0[2881:2880],
                  prg0[2877:2876],prg0[2873:2872],prg0[2869:2868],prg0[2865:2864],prg0[2861:2860],prg0[2857:2856],prg0[2853:2852],prg0[2849:2848],
                  prg0[2845:2844],prg0[2841:2840],prg0[2837:2836],prg0[2833:2832],prg0[2829:2828],prg0[2825:2824],prg0[2821:2820],prg0[2817:2816],
                  prg0[2813:2812],prg0[2809:2808],prg0[2805:2804],prg0[2801:2800],prg0[2797:2796],prg0[2793:2792],prg0[2789:2788],prg0[2785:2784],
                  prg0[2781:2780],prg0[2777:2776],prg0[2773:2772],prg0[2769:2768],prg0[2765:2764],prg0[2761:2760],prg0[2757:2756],prg0[2753:2752],
                  prg0[2749:2748],prg0[2745:2744],prg0[2741:2740],prg0[2737:2736],prg0[2733:2732],prg0[2729:2728],prg0[2725:2724],prg0[2721:2720],
                  prg0[2717:2716],prg0[2713:2712],prg0[2709:2708],prg0[2705:2704],prg0[2701:2700],prg0[2697:2696],prg0[2693:2692],prg0[2689:2688],
                  prg0[2685:2684],prg0[2681:2680],prg0[2677:2676],prg0[2673:2672],prg0[2669:2668],prg0[2665:2664],prg0[2661:2660],prg0[2657:2656],
                  prg0[2653:2652],prg0[2649:2648],prg0[2645:2644],prg0[2641:2640],prg0[2637:2636],prg0[2633:2632],prg0[2629:2628],prg0[2625:2624],
                  prg0[2621:2620],prg0[2617:2616],prg0[2613:2612],prg0[2609:2608],prg0[2605:2604],prg0[2601:2600],prg0[2597:2596],prg0[2593:2592],
                  prg0[2589:2588],prg0[2585:2584],prg0[2581:2580],prg0[2577:2576],prg0[2573:2572],prg0[2569:2568],prg0[2565:2564],prg0[2561:2560],
                  prg0[2557:2556],prg0[2553:2552],prg0[2549:2548],prg0[2545:2544],prg0[2541:2540],prg0[2537:2536],prg0[2533:2532],prg0[2529:2528],
                  prg0[2525:2524],prg0[2521:2520],prg0[2517:2516],prg0[2513:2512],prg0[2509:2508],prg0[2505:2504],prg0[2501:2500],prg0[2497:2496],
                  prg0[2493:2492],prg0[2489:2488],prg0[2485:2484],prg0[2481:2480],prg0[2477:2476],prg0[2473:2472],prg0[2469:2468],prg0[2465:2464],
                  prg0[2461:2460],prg0[2457:2456],prg0[2453:2452],prg0[2449:2448],prg0[2445:2444],prg0[2441:2440],prg0[2437:2436],prg0[2433:2432],
                  prg0[2429:2428],prg0[2425:2424],prg0[2421:2420],prg0[2417:2416],prg0[2413:2412],prg0[2409:2408],prg0[2405:2404],prg0[2401:2400],
                  prg0[2397:2396],prg0[2393:2392],prg0[2389:2388],prg0[2385:2384],prg0[2381:2380],prg0[2377:2376],prg0[2373:2372],prg0[2369:2368],
                  prg0[2365:2364],prg0[2361:2360],prg0[2357:2356],prg0[2353:2352],prg0[2349:2348],prg0[2345:2344],prg0[2341:2340],prg0[2337:2336],
                  prg0[2333:2332],prg0[2329:2328],prg0[2325:2324],prg0[2321:2320],prg0[2317:2316],prg0[2313:2312],prg0[2309:2308],prg0[2305:2304],
                  prg0[2301:2300],prg0[2297:2296],prg0[2293:2292],prg0[2289:2288],prg0[2285:2284],prg0[2281:2280],prg0[2277:2276],prg0[2273:2272],
                  prg0[2269:2268],prg0[2265:2264],prg0[2261:2260],prg0[2257:2256],prg0[2253:2252],prg0[2249:2248],prg0[2245:2244],prg0[2241:2240],
                  prg0[2237:2236],prg0[2233:2232],prg0[2229:2228],prg0[2225:2224],prg0[2221:2220],prg0[2217:2216],prg0[2213:2212],prg0[2209:2208],
                  prg0[2205:2204],prg0[2201:2200],prg0[2197:2196],prg0[2193:2192],prg0[2189:2188],prg0[2185:2184],prg0[2181:2180],prg0[2177:2176],
                  prg0[2173:2172],prg0[2169:2168],prg0[2165:2164],prg0[2161:2160],prg0[2157:2156],prg0[2153:2152],prg0[2149:2148],prg0[2145:2144],
                  prg0[2141:2140],prg0[2137:2136],prg0[2133:2132],prg0[2129:2128],prg0[2125:2124],prg0[2121:2120],prg0[2117:2116],prg0[2113:2112],
                  prg0[2109:2108],prg0[2105:2104],prg0[2101:2100],prg0[2097:2096],prg0[2093:2092],prg0[2089:2088],prg0[2085:2084],prg0[2081:2080],
                  prg0[2077:2076],prg0[2073:2072],prg0[2069:2068],prg0[2065:2064],prg0[2061:2060],prg0[2057:2056],prg0[2053:2052],prg0[2049:2048],
                  prg0[2045:2044],prg0[2041:2040],prg0[2037:2036],prg0[2033:2032],prg0[2029:2028],prg0[2025:2024],prg0[2021:2020],prg0[2017:2016],
                  prg0[2013:2012],prg0[2009:2008],prg0[2005:2004],prg0[2001:2000],prg0[1997:1996],prg0[1993:1992],prg0[1989:1988],prg0[1985:1984],
                  prg0[1981:1980],prg0[1977:1976],prg0[1973:1972],prg0[1969:1968],prg0[1965:1964],prg0[1961:1960],prg0[1957:1956],prg0[1953:1952],
                  prg0[1949:1948],prg0[1945:1944],prg0[1941:1940],prg0[1937:1936],prg0[1933:1932],prg0[1929:1928],prg0[1925:1924],prg0[1921:1920],
                  prg0[1917:1916],prg0[1913:1912],prg0[1909:1908],prg0[1905:1904],prg0[1901:1900],prg0[1897:1896],prg0[1893:1892],prg0[1889:1888],
                  prg0[1885:1884],prg0[1881:1880],prg0[1877:1876],prg0[1873:1872],prg0[1869:1868],prg0[1865:1864],prg0[1861:1860],prg0[1857:1856],
                  prg0[1853:1852],prg0[1849:1848],prg0[1845:1844],prg0[1841:1840],prg0[1837:1836],prg0[1833:1832],prg0[1829:1828],prg0[1825:1824],
                  prg0[1821:1820],prg0[1817:1816],prg0[1813:1812],prg0[1809:1808],prg0[1805:1804],prg0[1801:1800],prg0[1797:1796],prg0[1793:1792],
                  prg0[1789:1788],prg0[1785:1784],prg0[1781:1780],prg0[1777:1776],prg0[1773:1772],prg0[1769:1768],prg0[1765:1764],prg0[1761:1760],
                  prg0[1757:1756],prg0[1753:1752],prg0[1749:1748],prg0[1745:1744],prg0[1741:1740],prg0[1737:1736],prg0[1733:1732],prg0[1729:1728],
                  prg0[1725:1724],prg0[1721:1720],prg0[1717:1716],prg0[1713:1712],prg0[1709:1708],prg0[1705:1704],prg0[1701:1700],prg0[1697:1696],
                  prg0[1693:1692],prg0[1689:1688],prg0[1685:1684],prg0[1681:1680],prg0[1677:1676],prg0[1673:1672],prg0[1669:1668],prg0[1665:1664],
                  prg0[1661:1660],prg0[1657:1656],prg0[1653:1652],prg0[1649:1648],prg0[1645:1644],prg0[1641:1640],prg0[1637:1636],prg0[1633:1632],
                  prg0[1629:1628],prg0[1625:1624],prg0[1621:1620],prg0[1617:1616],prg0[1613:1612],prg0[1609:1608],prg0[1605:1604],prg0[1601:1600],
                  prg0[1597:1596],prg0[1593:1592],prg0[1589:1588],prg0[1585:1584],prg0[1581:1580],prg0[1577:1576],prg0[1573:1572],prg0[1569:1568],
                  prg0[1565:1564],prg0[1561:1560],prg0[1557:1556],prg0[1553:1552],prg0[1549:1548],prg0[1545:1544],prg0[1541:1540],prg0[1537:1536],
                  prg0[1533:1532],prg0[1529:1528],prg0[1525:1524],prg0[1521:1520],prg0[1517:1516],prg0[1513:1512],prg0[1509:1508],prg0[1505:1504],
                  prg0[1501:1500],prg0[1497:1496],prg0[1493:1492],prg0[1489:1488],prg0[1485:1484],prg0[1481:1480],prg0[1477:1476],prg0[1473:1472],
                  prg0[1469:1468],prg0[1465:1464],prg0[1461:1460],prg0[1457:1456],prg0[1453:1452],prg0[1449:1448],prg0[1445:1444],prg0[1441:1440],
                  prg0[1437:1436],prg0[1433:1432],prg0[1429:1428],prg0[1425:1424],prg0[1421:1420],prg0[1417:1416],prg0[1413:1412],prg0[1409:1408],
                  prg0[1405:1404],prg0[1401:1400],prg0[1397:1396],prg0[1393:1392],prg0[1389:1388],prg0[1385:1384],prg0[1381:1380],prg0[1377:1376],
                  prg0[1373:1372],prg0[1369:1368],prg0[1365:1364],prg0[1361:1360],prg0[1357:1356],prg0[1353:1352],prg0[1349:1348],prg0[1345:1344],
                  prg0[1341:1340],prg0[1337:1336],prg0[1333:1332],prg0[1329:1328],prg0[1325:1324],prg0[1321:1320],prg0[1317:1316],prg0[1313:1312],
                  prg0[1309:1308],prg0[1305:1304],prg0[1301:1300],prg0[1297:1296],prg0[1293:1292],prg0[1289:1288],prg0[1285:1284],prg0[1281:1280],
                  prg0[1277:1276],prg0[1273:1272],prg0[1269:1268],prg0[1265:1264],prg0[1261:1260],prg0[1257:1256],prg0[1253:1252],prg0[1249:1248],
                  prg0[1245:1244],prg0[1241:1240],prg0[1237:1236],prg0[1233:1232],prg0[1229:1228],prg0[1225:1224],prg0[1221:1220],prg0[1217:1216],
                  prg0[1213:1212],prg0[1209:1208],prg0[1205:1204],prg0[1201:1200],prg0[1197:1196],prg0[1193:1192],prg0[1189:1188],prg0[1185:1184],
                  prg0[1181:1180],prg0[1177:1176],prg0[1173:1172],prg0[1169:1168],prg0[1165:1164],prg0[1161:1160],prg0[1157:1156],prg0[1153:1152],
                  prg0[1149:1148],prg0[1145:1144],prg0[1141:1140],prg0[1137:1136],prg0[1133:1132],prg0[1129:1128],prg0[1125:1124],prg0[1121:1120],
                  prg0[1117:1116],prg0[1113:1112],prg0[1109:1108],prg0[1105:1104],prg0[1101:1100],prg0[1097:1096],prg0[1093:1092],prg0[1089:1088],
                  prg0[1085:1084],prg0[1081:1080],prg0[1077:1076],prg0[1073:1072],prg0[1069:1068],prg0[1065:1064],prg0[1061:1060],prg0[1057:1056],
                  prg0[1053:1052],prg0[1049:1048],prg0[1045:1044],prg0[1041:1040],prg0[1037:1036],prg0[1033:1032],prg0[1029:1028],prg0[1025:1024],
                  prg0[1021:1020],prg0[1017:1016],prg0[1013:1012],prg0[1009:1008],prg0[1005:1004],prg0[1001:1000],prg0[ 997: 996],prg0[ 993: 992],
                  prg0[ 989: 988],prg0[ 985: 984],prg0[ 981: 980],prg0[ 977: 976],prg0[ 973: 972],prg0[ 969: 968],prg0[ 965: 964],prg0[ 961: 960],
                  prg0[ 957: 956],prg0[ 953: 952],prg0[ 949: 948],prg0[ 945: 944],prg0[ 941: 940],prg0[ 937: 936],prg0[ 933: 932],prg0[ 929: 928],
                  prg0[ 925: 924],prg0[ 921: 920],prg0[ 917: 916],prg0[ 913: 912],prg0[ 909: 908],prg0[ 905: 904],prg0[ 901: 900],prg0[ 897: 896],
                  prg0[ 893: 892],prg0[ 889: 888],prg0[ 885: 884],prg0[ 881: 880],prg0[ 877: 876],prg0[ 873: 872],prg0[ 869: 868],prg0[ 865: 864],
                  prg0[ 861: 860],prg0[ 857: 856],prg0[ 853: 852],prg0[ 849: 848],prg0[ 845: 844],prg0[ 841: 840],prg0[ 837: 836],prg0[ 833: 832],
                  prg0[ 829: 828],prg0[ 825: 824],prg0[ 821: 820],prg0[ 817: 816],prg0[ 813: 812],prg0[ 809: 808],prg0[ 805: 804],prg0[ 801: 800],
                  prg0[ 797: 796],prg0[ 793: 792],prg0[ 789: 788],prg0[ 785: 784],prg0[ 781: 780],prg0[ 777: 776],prg0[ 773: 772],prg0[ 769: 768],
                  prg0[ 765: 764],prg0[ 761: 760],prg0[ 757: 756],prg0[ 753: 752],prg0[ 749: 748],prg0[ 745: 744],prg0[ 741: 740],prg0[ 737: 736],
                  prg0[ 733: 732],prg0[ 729: 728],prg0[ 725: 724],prg0[ 721: 720],prg0[ 717: 716],prg0[ 713: 712],prg0[ 709: 708],prg0[ 705: 704],
                  prg0[ 701: 700],prg0[ 697: 696],prg0[ 693: 692],prg0[ 689: 688],prg0[ 685: 684],prg0[ 681: 680],prg0[ 677: 676],prg0[ 673: 672],
                  prg0[ 669: 668],prg0[ 665: 664],prg0[ 661: 660],prg0[ 657: 656],prg0[ 653: 652],prg0[ 649: 648],prg0[ 645: 644],prg0[ 641: 640],
                  prg0[ 637: 636],prg0[ 633: 632],prg0[ 629: 628],prg0[ 625: 624],prg0[ 621: 620],prg0[ 617: 616],prg0[ 613: 612],prg0[ 609: 608],
                  prg0[ 605: 604],prg0[ 601: 600],prg0[ 597: 596],prg0[ 593: 592],prg0[ 589: 588],prg0[ 585: 584],prg0[ 581: 580],prg0[ 577: 576],
                  prg0[ 573: 572],prg0[ 569: 568],prg0[ 565: 564],prg0[ 561: 560],prg0[ 557: 556],prg0[ 553: 552],prg0[ 549: 548],prg0[ 545: 544],
                  prg0[ 541: 540],prg0[ 537: 536],prg0[ 533: 532],prg0[ 529: 528],prg0[ 525: 524],prg0[ 521: 520],prg0[ 517: 516],prg0[ 513: 512],
                  prg0[ 509: 508],prg0[ 505: 504],prg0[ 501: 500],prg0[ 497: 496],prg0[ 493: 492],prg0[ 489: 488],prg0[ 485: 484],prg0[ 481: 480],
                  prg0[ 477: 476],prg0[ 473: 472],prg0[ 469: 468],prg0[ 465: 464],prg0[ 461: 460],prg0[ 457: 456],prg0[ 453: 452],prg0[ 449: 448],
                  prg0[ 445: 444],prg0[ 441: 440],prg0[ 437: 436],prg0[ 433: 432],prg0[ 429: 428],prg0[ 425: 424],prg0[ 421: 420],prg0[ 417: 416],
                  prg0[ 413: 412],prg0[ 409: 408],prg0[ 405: 404],prg0[ 401: 400],prg0[ 397: 396],prg0[ 393: 392],prg0[ 389: 388],prg0[ 385: 384],
                  prg0[ 381: 380],prg0[ 377: 376],prg0[ 373: 372],prg0[ 369: 368],prg0[ 365: 364],prg0[ 361: 360],prg0[ 357: 356],prg0[ 353: 352],
                  prg0[ 349: 348],prg0[ 345: 344],prg0[ 341: 340],prg0[ 337: 336],prg0[ 333: 332],prg0[ 329: 328],prg0[ 325: 324],prg0[ 321: 320],
                  prg0[ 317: 316],prg0[ 313: 312],prg0[ 309: 308],prg0[ 305: 304],prg0[ 301: 300],prg0[ 297: 296],prg0[ 293: 292],prg0[ 289: 288],
                  prg0[ 285: 284],prg0[ 281: 280],prg0[ 277: 276],prg0[ 273: 272],prg0[ 269: 268],prg0[ 265: 264],prg0[ 261: 260],prg0[ 257: 256],
                  prg0[ 253: 252],prg0[ 249: 248],prg0[ 245: 244],prg0[ 241: 240],prg0[ 237: 236],prg0[ 233: 232],prg0[ 229: 228],prg0[ 225: 224],
                  prg0[ 221: 220],prg0[ 217: 216],prg0[ 213: 212],prg0[ 209: 208],prg0[ 205: 204],prg0[ 201: 200],prg0[ 197: 196],prg0[ 193: 192],
                  prg0[ 189: 188],prg0[ 185: 184],prg0[ 181: 180],prg0[ 177: 176],prg0[ 173: 172],prg0[ 169: 168],prg0[ 165: 164],prg0[ 161: 160],
                  prg0[ 157: 156],prg0[ 153: 152],prg0[ 149: 148],prg0[ 145: 144],prg0[ 141: 140],prg0[ 137: 136],prg0[ 133: 132],prg0[ 129: 128],
                  prg0[ 125: 124],prg0[ 121: 120],prg0[ 117: 116],prg0[ 113: 112],prg0[ 109: 108],prg0[ 105: 104],prg0[ 101: 100],prg0[  97:  96],
                  prg0[  93:  92],prg0[  89:  88],prg0[  85:  84],prg0[  81:  80],prg0[  77:  76],prg0[  73:  72],prg0[  69:  68],prg0[  65:  64],
                  prg0[  61:  60],prg0[  57:  56],prg0[  53:  52],prg0[  49:  48],prg0[  45:  44],prg0[  41:  40],prg0[  37:  36],prg0[  33:  32],
                  prg0[  29:  28],prg0[  25:  24],prg0[  21:  20],prg0[  17:  16],prg0[  13:  12],prg0[   9:   8],prg0[   5:   4],prg0[   1:   0]};
         localparam [4095:0]
           ph0 = {prg1[4095:4094],prg1[4091:4090],prg1[4087:4086],prg1[4083:4082],prg1[4079:4078],prg1[4075:4074],prg1[4071:4070],prg1[4067:4066],
                  prg1[4063:4062],prg1[4059:4058],prg1[4055:4054],prg1[4051:4050],prg1[4047:4046],prg1[4043:4042],prg1[4039:4038],prg1[4035:4034],
                  prg1[4031:4030],prg1[4027:4026],prg1[4023:4022],prg1[4019:4018],prg1[4015:4014],prg1[4011:4010],prg1[4007:4006],prg1[4003:4002],
                  prg1[3999:3998],prg1[3995:3994],prg1[3991:3990],prg1[3987:3986],prg1[3983:3982],prg1[3979:3978],prg1[3975:3974],prg1[3971:3970],
                  prg1[3967:3966],prg1[3963:3962],prg1[3959:3958],prg1[3955:3954],prg1[3951:3950],prg1[3947:3946],prg1[3943:3942],prg1[3939:3938],
                  prg1[3935:3934],prg1[3931:3930],prg1[3927:3926],prg1[3923:3922],prg1[3919:3918],prg1[3915:3914],prg1[3911:3910],prg1[3907:3906],
                  prg1[3903:3902],prg1[3899:3898],prg1[3895:3894],prg1[3891:3890],prg1[3887:3886],prg1[3883:3882],prg1[3879:3878],prg1[3875:3874],
                  prg1[3871:3870],prg1[3867:3866],prg1[3863:3862],prg1[3859:3858],prg1[3855:3854],prg1[3851:3850],prg1[3847:3846],prg1[3843:3842],
                  prg1[3839:3838],prg1[3835:3834],prg1[3831:3830],prg1[3827:3826],prg1[3823:3822],prg1[3819:3818],prg1[3815:3814],prg1[3811:3810],
                  prg1[3807:3806],prg1[3803:3802],prg1[3799:3798],prg1[3795:3794],prg1[3791:3790],prg1[3787:3786],prg1[3783:3782],prg1[3779:3778],
                  prg1[3775:3774],prg1[3771:3770],prg1[3767:3766],prg1[3763:3762],prg1[3759:3758],prg1[3755:3754],prg1[3751:3750],prg1[3747:3746],
                  prg1[3743:3742],prg1[3739:3738],prg1[3735:3734],prg1[3731:3730],prg1[3727:3726],prg1[3723:3722],prg1[3719:3718],prg1[3715:3714],
                  prg1[3711:3710],prg1[3707:3706],prg1[3703:3702],prg1[3699:3698],prg1[3695:3694],prg1[3691:3690],prg1[3687:3686],prg1[3683:3682],
                  prg1[3679:3678],prg1[3675:3674],prg1[3671:3670],prg1[3667:3666],prg1[3663:3662],prg1[3659:3658],prg1[3655:3654],prg1[3651:3650],
                  prg1[3647:3646],prg1[3643:3642],prg1[3639:3638],prg1[3635:3634],prg1[3631:3630],prg1[3627:3626],prg1[3623:3622],prg1[3619:3618],
                  prg1[3615:3614],prg1[3611:3610],prg1[3607:3606],prg1[3603:3602],prg1[3599:3598],prg1[3595:3594],prg1[3591:3590],prg1[3587:3586],
                  prg1[3583:3582],prg1[3579:3578],prg1[3575:3574],prg1[3571:3570],prg1[3567:3566],prg1[3563:3562],prg1[3559:3558],prg1[3555:3554],
                  prg1[3551:3550],prg1[3547:3546],prg1[3543:3542],prg1[3539:3538],prg1[3535:3534],prg1[3531:3530],prg1[3527:3526],prg1[3523:3522],
                  prg1[3519:3518],prg1[3515:3514],prg1[3511:3510],prg1[3507:3506],prg1[3503:3502],prg1[3499:3498],prg1[3495:3494],prg1[3491:3490],
                  prg1[3487:3486],prg1[3483:3482],prg1[3479:3478],prg1[3475:3474],prg1[3471:3470],prg1[3467:3466],prg1[3463:3462],prg1[3459:3458],
                  prg1[3455:3454],prg1[3451:3450],prg1[3447:3446],prg1[3443:3442],prg1[3439:3438],prg1[3435:3434],prg1[3431:3430],prg1[3427:3426],
                  prg1[3423:3422],prg1[3419:3418],prg1[3415:3414],prg1[3411:3410],prg1[3407:3406],prg1[3403:3402],prg1[3399:3398],prg1[3395:3394],
                  prg1[3391:3390],prg1[3387:3386],prg1[3383:3382],prg1[3379:3378],prg1[3375:3374],prg1[3371:3370],prg1[3367:3366],prg1[3363:3362],
                  prg1[3359:3358],prg1[3355:3354],prg1[3351:3350],prg1[3347:3346],prg1[3343:3342],prg1[3339:3338],prg1[3335:3334],prg1[3331:3330],
                  prg1[3327:3326],prg1[3323:3322],prg1[3319:3318],prg1[3315:3314],prg1[3311:3310],prg1[3307:3306],prg1[3303:3302],prg1[3299:3298],
                  prg1[3295:3294],prg1[3291:3290],prg1[3287:3286],prg1[3283:3282],prg1[3279:3278],prg1[3275:3274],prg1[3271:3270],prg1[3267:3266],
                  prg1[3263:3262],prg1[3259:3258],prg1[3255:3254],prg1[3251:3250],prg1[3247:3246],prg1[3243:3242],prg1[3239:3238],prg1[3235:3234],
                  prg1[3231:3230],prg1[3227:3226],prg1[3223:3222],prg1[3219:3218],prg1[3215:3214],prg1[3211:3210],prg1[3207:3206],prg1[3203:3202],
                  prg1[3199:3198],prg1[3195:3194],prg1[3191:3190],prg1[3187:3186],prg1[3183:3182],prg1[3179:3178],prg1[3175:3174],prg1[3171:3170],
                  prg1[3167:3166],prg1[3163:3162],prg1[3159:3158],prg1[3155:3154],prg1[3151:3150],prg1[3147:3146],prg1[3143:3142],prg1[3139:3138],
                  prg1[3135:3134],prg1[3131:3130],prg1[3127:3126],prg1[3123:3122],prg1[3119:3118],prg1[3115:3114],prg1[3111:3110],prg1[3107:3106],
                  prg1[3103:3102],prg1[3099:3098],prg1[3095:3094],prg1[3091:3090],prg1[3087:3086],prg1[3083:3082],prg1[3079:3078],prg1[3075:3074],
                  prg1[3071:3070],prg1[3067:3066],prg1[3063:3062],prg1[3059:3058],prg1[3055:3054],prg1[3051:3050],prg1[3047:3046],prg1[3043:3042],
                  prg1[3039:3038],prg1[3035:3034],prg1[3031:3030],prg1[3027:3026],prg1[3023:3022],prg1[3019:3018],prg1[3015:3014],prg1[3011:3010],
                  prg1[3007:3006],prg1[3003:3002],prg1[2999:2998],prg1[2995:2994],prg1[2991:2990],prg1[2987:2986],prg1[2983:2982],prg1[2979:2978],
                  prg1[2975:2974],prg1[2971:2970],prg1[2967:2966],prg1[2963:2962],prg1[2959:2958],prg1[2955:2954],prg1[2951:2950],prg1[2947:2946],
                  prg1[2943:2942],prg1[2939:2938],prg1[2935:2934],prg1[2931:2930],prg1[2927:2926],prg1[2923:2922],prg1[2919:2918],prg1[2915:2914],
                  prg1[2911:2910],prg1[2907:2906],prg1[2903:2902],prg1[2899:2898],prg1[2895:2894],prg1[2891:2890],prg1[2887:2886],prg1[2883:2882],
                  prg1[2879:2878],prg1[2875:2874],prg1[2871:2870],prg1[2867:2866],prg1[2863:2862],prg1[2859:2858],prg1[2855:2854],prg1[2851:2850],
                  prg1[2847:2846],prg1[2843:2842],prg1[2839:2838],prg1[2835:2834],prg1[2831:2830],prg1[2827:2826],prg1[2823:2822],prg1[2819:2818],
                  prg1[2815:2814],prg1[2811:2810],prg1[2807:2806],prg1[2803:2802],prg1[2799:2798],prg1[2795:2794],prg1[2791:2790],prg1[2787:2786],
                  prg1[2783:2782],prg1[2779:2778],prg1[2775:2774],prg1[2771:2770],prg1[2767:2766],prg1[2763:2762],prg1[2759:2758],prg1[2755:2754],
                  prg1[2751:2750],prg1[2747:2746],prg1[2743:2742],prg1[2739:2738],prg1[2735:2734],prg1[2731:2730],prg1[2727:2726],prg1[2723:2722],
                  prg1[2719:2718],prg1[2715:2714],prg1[2711:2710],prg1[2707:2706],prg1[2703:2702],prg1[2699:2698],prg1[2695:2694],prg1[2691:2690],
                  prg1[2687:2686],prg1[2683:2682],prg1[2679:2678],prg1[2675:2674],prg1[2671:2670],prg1[2667:2666],prg1[2663:2662],prg1[2659:2658],
                  prg1[2655:2654],prg1[2651:2650],prg1[2647:2646],prg1[2643:2642],prg1[2639:2638],prg1[2635:2634],prg1[2631:2630],prg1[2627:2626],
                  prg1[2623:2622],prg1[2619:2618],prg1[2615:2614],prg1[2611:2610],prg1[2607:2606],prg1[2603:2602],prg1[2599:2598],prg1[2595:2594],
                  prg1[2591:2590],prg1[2587:2586],prg1[2583:2582],prg1[2579:2578],prg1[2575:2574],prg1[2571:2570],prg1[2567:2566],prg1[2563:2562],
                  prg1[2559:2558],prg1[2555:2554],prg1[2551:2550],prg1[2547:2546],prg1[2543:2542],prg1[2539:2538],prg1[2535:2534],prg1[2531:2530],
                  prg1[2527:2526],prg1[2523:2522],prg1[2519:2518],prg1[2515:2514],prg1[2511:2510],prg1[2507:2506],prg1[2503:2502],prg1[2499:2498],
                  prg1[2495:2494],prg1[2491:2490],prg1[2487:2486],prg1[2483:2482],prg1[2479:2478],prg1[2475:2474],prg1[2471:2470],prg1[2467:2466],
                  prg1[2463:2462],prg1[2459:2458],prg1[2455:2454],prg1[2451:2450],prg1[2447:2446],prg1[2443:2442],prg1[2439:2438],prg1[2435:2434],
                  prg1[2431:2430],prg1[2427:2426],prg1[2423:2422],prg1[2419:2418],prg1[2415:2414],prg1[2411:2410],prg1[2407:2406],prg1[2403:2402],
                  prg1[2399:2398],prg1[2395:2394],prg1[2391:2390],prg1[2387:2386],prg1[2383:2382],prg1[2379:2378],prg1[2375:2374],prg1[2371:2370],
                  prg1[2367:2366],prg1[2363:2362],prg1[2359:2358],prg1[2355:2354],prg1[2351:2350],prg1[2347:2346],prg1[2343:2342],prg1[2339:2338],
                  prg1[2335:2334],prg1[2331:2330],prg1[2327:2326],prg1[2323:2322],prg1[2319:2318],prg1[2315:2314],prg1[2311:2310],prg1[2307:2306],
                  prg1[2303:2302],prg1[2299:2298],prg1[2295:2294],prg1[2291:2290],prg1[2287:2286],prg1[2283:2282],prg1[2279:2278],prg1[2275:2274],
                  prg1[2271:2270],prg1[2267:2266],prg1[2263:2262],prg1[2259:2258],prg1[2255:2254],prg1[2251:2250],prg1[2247:2246],prg1[2243:2242],
                  prg1[2239:2238],prg1[2235:2234],prg1[2231:2230],prg1[2227:2226],prg1[2223:2222],prg1[2219:2218],prg1[2215:2214],prg1[2211:2210],
                  prg1[2207:2206],prg1[2203:2202],prg1[2199:2198],prg1[2195:2194],prg1[2191:2190],prg1[2187:2186],prg1[2183:2182],prg1[2179:2178],
                  prg1[2175:2174],prg1[2171:2170],prg1[2167:2166],prg1[2163:2162],prg1[2159:2158],prg1[2155:2154],prg1[2151:2150],prg1[2147:2146],
                  prg1[2143:2142],prg1[2139:2138],prg1[2135:2134],prg1[2131:2130],prg1[2127:2126],prg1[2123:2122],prg1[2119:2118],prg1[2115:2114],
                  prg1[2111:2110],prg1[2107:2106],prg1[2103:2102],prg1[2099:2098],prg1[2095:2094],prg1[2091:2090],prg1[2087:2086],prg1[2083:2082],
                  prg1[2079:2078],prg1[2075:2074],prg1[2071:2070],prg1[2067:2066],prg1[2063:2062],prg1[2059:2058],prg1[2055:2054],prg1[2051:2050],
                  prg1[2047:2046],prg1[2043:2042],prg1[2039:2038],prg1[2035:2034],prg1[2031:2030],prg1[2027:2026],prg1[2023:2022],prg1[2019:2018],
                  prg1[2015:2014],prg1[2011:2010],prg1[2007:2006],prg1[2003:2002],prg1[1999:1998],prg1[1995:1994],prg1[1991:1990],prg1[1987:1986],
                  prg1[1983:1982],prg1[1979:1978],prg1[1975:1974],prg1[1971:1970],prg1[1967:1966],prg1[1963:1962],prg1[1959:1958],prg1[1955:1954],
                  prg1[1951:1950],prg1[1947:1946],prg1[1943:1942],prg1[1939:1938],prg1[1935:1934],prg1[1931:1930],prg1[1927:1926],prg1[1923:1922],
                  prg1[1919:1918],prg1[1915:1914],prg1[1911:1910],prg1[1907:1906],prg1[1903:1902],prg1[1899:1898],prg1[1895:1894],prg1[1891:1890],
                  prg1[1887:1886],prg1[1883:1882],prg1[1879:1878],prg1[1875:1874],prg1[1871:1870],prg1[1867:1866],prg1[1863:1862],prg1[1859:1858],
                  prg1[1855:1854],prg1[1851:1850],prg1[1847:1846],prg1[1843:1842],prg1[1839:1838],prg1[1835:1834],prg1[1831:1830],prg1[1827:1826],
                  prg1[1823:1822],prg1[1819:1818],prg1[1815:1814],prg1[1811:1810],prg1[1807:1806],prg1[1803:1802],prg1[1799:1798],prg1[1795:1794],
                  prg1[1791:1790],prg1[1787:1786],prg1[1783:1782],prg1[1779:1778],prg1[1775:1774],prg1[1771:1770],prg1[1767:1766],prg1[1763:1762],
                  prg1[1759:1758],prg1[1755:1754],prg1[1751:1750],prg1[1747:1746],prg1[1743:1742],prg1[1739:1738],prg1[1735:1734],prg1[1731:1730],
                  prg1[1727:1726],prg1[1723:1722],prg1[1719:1718],prg1[1715:1714],prg1[1711:1710],prg1[1707:1706],prg1[1703:1702],prg1[1699:1698],
                  prg1[1695:1694],prg1[1691:1690],prg1[1687:1686],prg1[1683:1682],prg1[1679:1678],prg1[1675:1674],prg1[1671:1670],prg1[1667:1666],
                  prg1[1663:1662],prg1[1659:1658],prg1[1655:1654],prg1[1651:1650],prg1[1647:1646],prg1[1643:1642],prg1[1639:1638],prg1[1635:1634],
                  prg1[1631:1630],prg1[1627:1626],prg1[1623:1622],prg1[1619:1618],prg1[1615:1614],prg1[1611:1610],prg1[1607:1606],prg1[1603:1602],
                  prg1[1599:1598],prg1[1595:1594],prg1[1591:1590],prg1[1587:1586],prg1[1583:1582],prg1[1579:1578],prg1[1575:1574],prg1[1571:1570],
                  prg1[1567:1566],prg1[1563:1562],prg1[1559:1558],prg1[1555:1554],prg1[1551:1550],prg1[1547:1546],prg1[1543:1542],prg1[1539:1538],
                  prg1[1535:1534],prg1[1531:1530],prg1[1527:1526],prg1[1523:1522],prg1[1519:1518],prg1[1515:1514],prg1[1511:1510],prg1[1507:1506],
                  prg1[1503:1502],prg1[1499:1498],prg1[1495:1494],prg1[1491:1490],prg1[1487:1486],prg1[1483:1482],prg1[1479:1478],prg1[1475:1474],
                  prg1[1471:1470],prg1[1467:1466],prg1[1463:1462],prg1[1459:1458],prg1[1455:1454],prg1[1451:1450],prg1[1447:1446],prg1[1443:1442],
                  prg1[1439:1438],prg1[1435:1434],prg1[1431:1430],prg1[1427:1426],prg1[1423:1422],prg1[1419:1418],prg1[1415:1414],prg1[1411:1410],
                  prg1[1407:1406],prg1[1403:1402],prg1[1399:1398],prg1[1395:1394],prg1[1391:1390],prg1[1387:1386],prg1[1383:1382],prg1[1379:1378],
                  prg1[1375:1374],prg1[1371:1370],prg1[1367:1366],prg1[1363:1362],prg1[1359:1358],prg1[1355:1354],prg1[1351:1350],prg1[1347:1346],
                  prg1[1343:1342],prg1[1339:1338],prg1[1335:1334],prg1[1331:1330],prg1[1327:1326],prg1[1323:1322],prg1[1319:1318],prg1[1315:1314],
                  prg1[1311:1310],prg1[1307:1306],prg1[1303:1302],prg1[1299:1298],prg1[1295:1294],prg1[1291:1290],prg1[1287:1286],prg1[1283:1282],
                  prg1[1279:1278],prg1[1275:1274],prg1[1271:1270],prg1[1267:1266],prg1[1263:1262],prg1[1259:1258],prg1[1255:1254],prg1[1251:1250],
                  prg1[1247:1246],prg1[1243:1242],prg1[1239:1238],prg1[1235:1234],prg1[1231:1230],prg1[1227:1226],prg1[1223:1222],prg1[1219:1218],
                  prg1[1215:1214],prg1[1211:1210],prg1[1207:1206],prg1[1203:1202],prg1[1199:1198],prg1[1195:1194],prg1[1191:1190],prg1[1187:1186],
                  prg1[1183:1182],prg1[1179:1178],prg1[1175:1174],prg1[1171:1170],prg1[1167:1166],prg1[1163:1162],prg1[1159:1158],prg1[1155:1154],
                  prg1[1151:1150],prg1[1147:1146],prg1[1143:1142],prg1[1139:1138],prg1[1135:1134],prg1[1131:1130],prg1[1127:1126],prg1[1123:1122],
                  prg1[1119:1118],prg1[1115:1114],prg1[1111:1110],prg1[1107:1106],prg1[1103:1102],prg1[1099:1098],prg1[1095:1094],prg1[1091:1090],
                  prg1[1087:1086],prg1[1083:1082],prg1[1079:1078],prg1[1075:1074],prg1[1071:1070],prg1[1067:1066],prg1[1063:1062],prg1[1059:1058],
                  prg1[1055:1054],prg1[1051:1050],prg1[1047:1046],prg1[1043:1042],prg1[1039:1038],prg1[1035:1034],prg1[1031:1030],prg1[1027:1026],
                  prg1[1023:1022],prg1[1019:1018],prg1[1015:1014],prg1[1011:1010],prg1[1007:1006],prg1[1003:1002],prg1[ 999: 998],prg1[ 995: 994],
                  prg1[ 991: 990],prg1[ 987: 986],prg1[ 983: 982],prg1[ 979: 978],prg1[ 975: 974],prg1[ 971: 970],prg1[ 967: 966],prg1[ 963: 962],
                  prg1[ 959: 958],prg1[ 955: 954],prg1[ 951: 950],prg1[ 947: 946],prg1[ 943: 942],prg1[ 939: 938],prg1[ 935: 934],prg1[ 931: 930],
                  prg1[ 927: 926],prg1[ 923: 922],prg1[ 919: 918],prg1[ 915: 914],prg1[ 911: 910],prg1[ 907: 906],prg1[ 903: 902],prg1[ 899: 898],
                  prg1[ 895: 894],prg1[ 891: 890],prg1[ 887: 886],prg1[ 883: 882],prg1[ 879: 878],prg1[ 875: 874],prg1[ 871: 870],prg1[ 867: 866],
                  prg1[ 863: 862],prg1[ 859: 858],prg1[ 855: 854],prg1[ 851: 850],prg1[ 847: 846],prg1[ 843: 842],prg1[ 839: 838],prg1[ 835: 834],
                  prg1[ 831: 830],prg1[ 827: 826],prg1[ 823: 822],prg1[ 819: 818],prg1[ 815: 814],prg1[ 811: 810],prg1[ 807: 806],prg1[ 803: 802],
                  prg1[ 799: 798],prg1[ 795: 794],prg1[ 791: 790],prg1[ 787: 786],prg1[ 783: 782],prg1[ 779: 778],prg1[ 775: 774],prg1[ 771: 770],
                  prg1[ 767: 766],prg1[ 763: 762],prg1[ 759: 758],prg1[ 755: 754],prg1[ 751: 750],prg1[ 747: 746],prg1[ 743: 742],prg1[ 739: 738],
                  prg1[ 735: 734],prg1[ 731: 730],prg1[ 727: 726],prg1[ 723: 722],prg1[ 719: 718],prg1[ 715: 714],prg1[ 711: 710],prg1[ 707: 706],
                  prg1[ 703: 702],prg1[ 699: 698],prg1[ 695: 694],prg1[ 691: 690],prg1[ 687: 686],prg1[ 683: 682],prg1[ 679: 678],prg1[ 675: 674],
                  prg1[ 671: 670],prg1[ 667: 666],prg1[ 663: 662],prg1[ 659: 658],prg1[ 655: 654],prg1[ 651: 650],prg1[ 647: 646],prg1[ 643: 642],
                  prg1[ 639: 638],prg1[ 635: 634],prg1[ 631: 630],prg1[ 627: 626],prg1[ 623: 622],prg1[ 619: 618],prg1[ 615: 614],prg1[ 611: 610],
                  prg1[ 607: 606],prg1[ 603: 602],prg1[ 599: 598],prg1[ 595: 594],prg1[ 591: 590],prg1[ 587: 586],prg1[ 583: 582],prg1[ 579: 578],
                  prg1[ 575: 574],prg1[ 571: 570],prg1[ 567: 566],prg1[ 563: 562],prg1[ 559: 558],prg1[ 555: 554],prg1[ 551: 550],prg1[ 547: 546],
                  prg1[ 543: 542],prg1[ 539: 538],prg1[ 535: 534],prg1[ 531: 530],prg1[ 527: 526],prg1[ 523: 522],prg1[ 519: 518],prg1[ 515: 514],
                  prg1[ 511: 510],prg1[ 507: 506],prg1[ 503: 502],prg1[ 499: 498],prg1[ 495: 494],prg1[ 491: 490],prg1[ 487: 486],prg1[ 483: 482],
                  prg1[ 479: 478],prg1[ 475: 474],prg1[ 471: 470],prg1[ 467: 466],prg1[ 463: 462],prg1[ 459: 458],prg1[ 455: 454],prg1[ 451: 450],
                  prg1[ 447: 446],prg1[ 443: 442],prg1[ 439: 438],prg1[ 435: 434],prg1[ 431: 430],prg1[ 427: 426],prg1[ 423: 422],prg1[ 419: 418],
                  prg1[ 415: 414],prg1[ 411: 410],prg1[ 407: 406],prg1[ 403: 402],prg1[ 399: 398],prg1[ 395: 394],prg1[ 391: 390],prg1[ 387: 386],
                  prg1[ 383: 382],prg1[ 379: 378],prg1[ 375: 374],prg1[ 371: 370],prg1[ 367: 366],prg1[ 363: 362],prg1[ 359: 358],prg1[ 355: 354],
                  prg1[ 351: 350],prg1[ 347: 346],prg1[ 343: 342],prg1[ 339: 338],prg1[ 335: 334],prg1[ 331: 330],prg1[ 327: 326],prg1[ 323: 322],
                  prg1[ 319: 318],prg1[ 315: 314],prg1[ 311: 310],prg1[ 307: 306],prg1[ 303: 302],prg1[ 299: 298],prg1[ 295: 294],prg1[ 291: 290],
                  prg1[ 287: 286],prg1[ 283: 282],prg1[ 279: 278],prg1[ 275: 274],prg1[ 271: 270],prg1[ 267: 266],prg1[ 263: 262],prg1[ 259: 258],
                  prg1[ 255: 254],prg1[ 251: 250],prg1[ 247: 246],prg1[ 243: 242],prg1[ 239: 238],prg1[ 235: 234],prg1[ 231: 230],prg1[ 227: 226],
                  prg1[ 223: 222],prg1[ 219: 218],prg1[ 215: 214],prg1[ 211: 210],prg1[ 207: 206],prg1[ 203: 202],prg1[ 199: 198],prg1[ 195: 194],
                  prg1[ 191: 190],prg1[ 187: 186],prg1[ 183: 182],prg1[ 179: 178],prg1[ 175: 174],prg1[ 171: 170],prg1[ 167: 166],prg1[ 163: 162],
                  prg1[ 159: 158],prg1[ 155: 154],prg1[ 151: 150],prg1[ 147: 146],prg1[ 143: 142],prg1[ 139: 138],prg1[ 135: 134],prg1[ 131: 130],
                  prg1[ 127: 126],prg1[ 123: 122],prg1[ 119: 118],prg1[ 115: 114],prg1[ 111: 110],prg1[ 107: 106],prg1[ 103: 102],prg1[  99:  98],
                  prg1[  95:  94],prg1[  91:  90],prg1[  87:  86],prg1[  83:  82],prg1[  79:  78],prg1[  75:  74],prg1[  71:  70],prg1[  67:  66],
                  prg1[  63:  62],prg1[  59:  58],prg1[  55:  54],prg1[  51:  50],prg1[  47:  46],prg1[  43:  42],prg1[  39:  38],prg1[  35:  34],
                  prg1[  31:  30],prg1[  27:  26],prg1[  23:  22],prg1[  19:  18],prg1[  15:  14],prg1[  11:  10],prg1[   7:   6],prg1[   3:   2],
                  prg0[4095:4094],prg0[4091:4090],prg0[4087:4086],prg0[4083:4082],prg0[4079:4078],prg0[4075:4074],prg0[4071:4070],prg0[4067:4066],
                  prg0[4063:4062],prg0[4059:4058],prg0[4055:4054],prg0[4051:4050],prg0[4047:4046],prg0[4043:4042],prg0[4039:4038],prg0[4035:4034],
                  prg0[4031:4030],prg0[4027:4026],prg0[4023:4022],prg0[4019:4018],prg0[4015:4014],prg0[4011:4010],prg0[4007:4006],prg0[4003:4002],
                  prg0[3999:3998],prg0[3995:3994],prg0[3991:3990],prg0[3987:3986],prg0[3983:3982],prg0[3979:3978],prg0[3975:3974],prg0[3971:3970],
                  prg0[3967:3966],prg0[3963:3962],prg0[3959:3958],prg0[3955:3954],prg0[3951:3950],prg0[3947:3946],prg0[3943:3942],prg0[3939:3938],
                  prg0[3935:3934],prg0[3931:3930],prg0[3927:3926],prg0[3923:3922],prg0[3919:3918],prg0[3915:3914],prg0[3911:3910],prg0[3907:3906],
                  prg0[3903:3902],prg0[3899:3898],prg0[3895:3894],prg0[3891:3890],prg0[3887:3886],prg0[3883:3882],prg0[3879:3878],prg0[3875:3874],
                  prg0[3871:3870],prg0[3867:3866],prg0[3863:3862],prg0[3859:3858],prg0[3855:3854],prg0[3851:3850],prg0[3847:3846],prg0[3843:3842],
                  prg0[3839:3838],prg0[3835:3834],prg0[3831:3830],prg0[3827:3826],prg0[3823:3822],prg0[3819:3818],prg0[3815:3814],prg0[3811:3810],
                  prg0[3807:3806],prg0[3803:3802],prg0[3799:3798],prg0[3795:3794],prg0[3791:3790],prg0[3787:3786],prg0[3783:3782],prg0[3779:3778],
                  prg0[3775:3774],prg0[3771:3770],prg0[3767:3766],prg0[3763:3762],prg0[3759:3758],prg0[3755:3754],prg0[3751:3750],prg0[3747:3746],
                  prg0[3743:3742],prg0[3739:3738],prg0[3735:3734],prg0[3731:3730],prg0[3727:3726],prg0[3723:3722],prg0[3719:3718],prg0[3715:3714],
                  prg0[3711:3710],prg0[3707:3706],prg0[3703:3702],prg0[3699:3698],prg0[3695:3694],prg0[3691:3690],prg0[3687:3686],prg0[3683:3682],
                  prg0[3679:3678],prg0[3675:3674],prg0[3671:3670],prg0[3667:3666],prg0[3663:3662],prg0[3659:3658],prg0[3655:3654],prg0[3651:3650],
                  prg0[3647:3646],prg0[3643:3642],prg0[3639:3638],prg0[3635:3634],prg0[3631:3630],prg0[3627:3626],prg0[3623:3622],prg0[3619:3618],
                  prg0[3615:3614],prg0[3611:3610],prg0[3607:3606],prg0[3603:3602],prg0[3599:3598],prg0[3595:3594],prg0[3591:3590],prg0[3587:3586],
                  prg0[3583:3582],prg0[3579:3578],prg0[3575:3574],prg0[3571:3570],prg0[3567:3566],prg0[3563:3562],prg0[3559:3558],prg0[3555:3554],
                  prg0[3551:3550],prg0[3547:3546],prg0[3543:3542],prg0[3539:3538],prg0[3535:3534],prg0[3531:3530],prg0[3527:3526],prg0[3523:3522],
                  prg0[3519:3518],prg0[3515:3514],prg0[3511:3510],prg0[3507:3506],prg0[3503:3502],prg0[3499:3498],prg0[3495:3494],prg0[3491:3490],
                  prg0[3487:3486],prg0[3483:3482],prg0[3479:3478],prg0[3475:3474],prg0[3471:3470],prg0[3467:3466],prg0[3463:3462],prg0[3459:3458],
                  prg0[3455:3454],prg0[3451:3450],prg0[3447:3446],prg0[3443:3442],prg0[3439:3438],prg0[3435:3434],prg0[3431:3430],prg0[3427:3426],
                  prg0[3423:3422],prg0[3419:3418],prg0[3415:3414],prg0[3411:3410],prg0[3407:3406],prg0[3403:3402],prg0[3399:3398],prg0[3395:3394],
                  prg0[3391:3390],prg0[3387:3386],prg0[3383:3382],prg0[3379:3378],prg0[3375:3374],prg0[3371:3370],prg0[3367:3366],prg0[3363:3362],
                  prg0[3359:3358],prg0[3355:3354],prg0[3351:3350],prg0[3347:3346],prg0[3343:3342],prg0[3339:3338],prg0[3335:3334],prg0[3331:3330],
                  prg0[3327:3326],prg0[3323:3322],prg0[3319:3318],prg0[3315:3314],prg0[3311:3310],prg0[3307:3306],prg0[3303:3302],prg0[3299:3298],
                  prg0[3295:3294],prg0[3291:3290],prg0[3287:3286],prg0[3283:3282],prg0[3279:3278],prg0[3275:3274],prg0[3271:3270],prg0[3267:3266],
                  prg0[3263:3262],prg0[3259:3258],prg0[3255:3254],prg0[3251:3250],prg0[3247:3246],prg0[3243:3242],prg0[3239:3238],prg0[3235:3234],
                  prg0[3231:3230],prg0[3227:3226],prg0[3223:3222],prg0[3219:3218],prg0[3215:3214],prg0[3211:3210],prg0[3207:3206],prg0[3203:3202],
                  prg0[3199:3198],prg0[3195:3194],prg0[3191:3190],prg0[3187:3186],prg0[3183:3182],prg0[3179:3178],prg0[3175:3174],prg0[3171:3170],
                  prg0[3167:3166],prg0[3163:3162],prg0[3159:3158],prg0[3155:3154],prg0[3151:3150],prg0[3147:3146],prg0[3143:3142],prg0[3139:3138],
                  prg0[3135:3134],prg0[3131:3130],prg0[3127:3126],prg0[3123:3122],prg0[3119:3118],prg0[3115:3114],prg0[3111:3110],prg0[3107:3106],
                  prg0[3103:3102],prg0[3099:3098],prg0[3095:3094],prg0[3091:3090],prg0[3087:3086],prg0[3083:3082],prg0[3079:3078],prg0[3075:3074],
                  prg0[3071:3070],prg0[3067:3066],prg0[3063:3062],prg0[3059:3058],prg0[3055:3054],prg0[3051:3050],prg0[3047:3046],prg0[3043:3042],
                  prg0[3039:3038],prg0[3035:3034],prg0[3031:3030],prg0[3027:3026],prg0[3023:3022],prg0[3019:3018],prg0[3015:3014],prg0[3011:3010],
                  prg0[3007:3006],prg0[3003:3002],prg0[2999:2998],prg0[2995:2994],prg0[2991:2990],prg0[2987:2986],prg0[2983:2982],prg0[2979:2978],
                  prg0[2975:2974],prg0[2971:2970],prg0[2967:2966],prg0[2963:2962],prg0[2959:2958],prg0[2955:2954],prg0[2951:2950],prg0[2947:2946],
                  prg0[2943:2942],prg0[2939:2938],prg0[2935:2934],prg0[2931:2930],prg0[2927:2926],prg0[2923:2922],prg0[2919:2918],prg0[2915:2914],
                  prg0[2911:2910],prg0[2907:2906],prg0[2903:2902],prg0[2899:2898],prg0[2895:2894],prg0[2891:2890],prg0[2887:2886],prg0[2883:2882],
                  prg0[2879:2878],prg0[2875:2874],prg0[2871:2870],prg0[2867:2866],prg0[2863:2862],prg0[2859:2858],prg0[2855:2854],prg0[2851:2850],
                  prg0[2847:2846],prg0[2843:2842],prg0[2839:2838],prg0[2835:2834],prg0[2831:2830],prg0[2827:2826],prg0[2823:2822],prg0[2819:2818],
                  prg0[2815:2814],prg0[2811:2810],prg0[2807:2806],prg0[2803:2802],prg0[2799:2798],prg0[2795:2794],prg0[2791:2790],prg0[2787:2786],
                  prg0[2783:2782],prg0[2779:2778],prg0[2775:2774],prg0[2771:2770],prg0[2767:2766],prg0[2763:2762],prg0[2759:2758],prg0[2755:2754],
                  prg0[2751:2750],prg0[2747:2746],prg0[2743:2742],prg0[2739:2738],prg0[2735:2734],prg0[2731:2730],prg0[2727:2726],prg0[2723:2722],
                  prg0[2719:2718],prg0[2715:2714],prg0[2711:2710],prg0[2707:2706],prg0[2703:2702],prg0[2699:2698],prg0[2695:2694],prg0[2691:2690],
                  prg0[2687:2686],prg0[2683:2682],prg0[2679:2678],prg0[2675:2674],prg0[2671:2670],prg0[2667:2666],prg0[2663:2662],prg0[2659:2658],
                  prg0[2655:2654],prg0[2651:2650],prg0[2647:2646],prg0[2643:2642],prg0[2639:2638],prg0[2635:2634],prg0[2631:2630],prg0[2627:2626],
                  prg0[2623:2622],prg0[2619:2618],prg0[2615:2614],prg0[2611:2610],prg0[2607:2606],prg0[2603:2602],prg0[2599:2598],prg0[2595:2594],
                  prg0[2591:2590],prg0[2587:2586],prg0[2583:2582],prg0[2579:2578],prg0[2575:2574],prg0[2571:2570],prg0[2567:2566],prg0[2563:2562],
                  prg0[2559:2558],prg0[2555:2554],prg0[2551:2550],prg0[2547:2546],prg0[2543:2542],prg0[2539:2538],prg0[2535:2534],prg0[2531:2530],
                  prg0[2527:2526],prg0[2523:2522],prg0[2519:2518],prg0[2515:2514],prg0[2511:2510],prg0[2507:2506],prg0[2503:2502],prg0[2499:2498],
                  prg0[2495:2494],prg0[2491:2490],prg0[2487:2486],prg0[2483:2482],prg0[2479:2478],prg0[2475:2474],prg0[2471:2470],prg0[2467:2466],
                  prg0[2463:2462],prg0[2459:2458],prg0[2455:2454],prg0[2451:2450],prg0[2447:2446],prg0[2443:2442],prg0[2439:2438],prg0[2435:2434],
                  prg0[2431:2430],prg0[2427:2426],prg0[2423:2422],prg0[2419:2418],prg0[2415:2414],prg0[2411:2410],prg0[2407:2406],prg0[2403:2402],
                  prg0[2399:2398],prg0[2395:2394],prg0[2391:2390],prg0[2387:2386],prg0[2383:2382],prg0[2379:2378],prg0[2375:2374],prg0[2371:2370],
                  prg0[2367:2366],prg0[2363:2362],prg0[2359:2358],prg0[2355:2354],prg0[2351:2350],prg0[2347:2346],prg0[2343:2342],prg0[2339:2338],
                  prg0[2335:2334],prg0[2331:2330],prg0[2327:2326],prg0[2323:2322],prg0[2319:2318],prg0[2315:2314],prg0[2311:2310],prg0[2307:2306],
                  prg0[2303:2302],prg0[2299:2298],prg0[2295:2294],prg0[2291:2290],prg0[2287:2286],prg0[2283:2282],prg0[2279:2278],prg0[2275:2274],
                  prg0[2271:2270],prg0[2267:2266],prg0[2263:2262],prg0[2259:2258],prg0[2255:2254],prg0[2251:2250],prg0[2247:2246],prg0[2243:2242],
                  prg0[2239:2238],prg0[2235:2234],prg0[2231:2230],prg0[2227:2226],prg0[2223:2222],prg0[2219:2218],prg0[2215:2214],prg0[2211:2210],
                  prg0[2207:2206],prg0[2203:2202],prg0[2199:2198],prg0[2195:2194],prg0[2191:2190],prg0[2187:2186],prg0[2183:2182],prg0[2179:2178],
                  prg0[2175:2174],prg0[2171:2170],prg0[2167:2166],prg0[2163:2162],prg0[2159:2158],prg0[2155:2154],prg0[2151:2150],prg0[2147:2146],
                  prg0[2143:2142],prg0[2139:2138],prg0[2135:2134],prg0[2131:2130],prg0[2127:2126],prg0[2123:2122],prg0[2119:2118],prg0[2115:2114],
                  prg0[2111:2110],prg0[2107:2106],prg0[2103:2102],prg0[2099:2098],prg0[2095:2094],prg0[2091:2090],prg0[2087:2086],prg0[2083:2082],
                  prg0[2079:2078],prg0[2075:2074],prg0[2071:2070],prg0[2067:2066],prg0[2063:2062],prg0[2059:2058],prg0[2055:2054],prg0[2051:2050],
                  prg0[2047:2046],prg0[2043:2042],prg0[2039:2038],prg0[2035:2034],prg0[2031:2030],prg0[2027:2026],prg0[2023:2022],prg0[2019:2018],
                  prg0[2015:2014],prg0[2011:2010],prg0[2007:2006],prg0[2003:2002],prg0[1999:1998],prg0[1995:1994],prg0[1991:1990],prg0[1987:1986],
                  prg0[1983:1982],prg0[1979:1978],prg0[1975:1974],prg0[1971:1970],prg0[1967:1966],prg0[1963:1962],prg0[1959:1958],prg0[1955:1954],
                  prg0[1951:1950],prg0[1947:1946],prg0[1943:1942],prg0[1939:1938],prg0[1935:1934],prg0[1931:1930],prg0[1927:1926],prg0[1923:1922],
                  prg0[1919:1918],prg0[1915:1914],prg0[1911:1910],prg0[1907:1906],prg0[1903:1902],prg0[1899:1898],prg0[1895:1894],prg0[1891:1890],
                  prg0[1887:1886],prg0[1883:1882],prg0[1879:1878],prg0[1875:1874],prg0[1871:1870],prg0[1867:1866],prg0[1863:1862],prg0[1859:1858],
                  prg0[1855:1854],prg0[1851:1850],prg0[1847:1846],prg0[1843:1842],prg0[1839:1838],prg0[1835:1834],prg0[1831:1830],prg0[1827:1826],
                  prg0[1823:1822],prg0[1819:1818],prg0[1815:1814],prg0[1811:1810],prg0[1807:1806],prg0[1803:1802],prg0[1799:1798],prg0[1795:1794],
                  prg0[1791:1790],prg0[1787:1786],prg0[1783:1782],prg0[1779:1778],prg0[1775:1774],prg0[1771:1770],prg0[1767:1766],prg0[1763:1762],
                  prg0[1759:1758],prg0[1755:1754],prg0[1751:1750],prg0[1747:1746],prg0[1743:1742],prg0[1739:1738],prg0[1735:1734],prg0[1731:1730],
                  prg0[1727:1726],prg0[1723:1722],prg0[1719:1718],prg0[1715:1714],prg0[1711:1710],prg0[1707:1706],prg0[1703:1702],prg0[1699:1698],
                  prg0[1695:1694],prg0[1691:1690],prg0[1687:1686],prg0[1683:1682],prg0[1679:1678],prg0[1675:1674],prg0[1671:1670],prg0[1667:1666],
                  prg0[1663:1662],prg0[1659:1658],prg0[1655:1654],prg0[1651:1650],prg0[1647:1646],prg0[1643:1642],prg0[1639:1638],prg0[1635:1634],
                  prg0[1631:1630],prg0[1627:1626],prg0[1623:1622],prg0[1619:1618],prg0[1615:1614],prg0[1611:1610],prg0[1607:1606],prg0[1603:1602],
                  prg0[1599:1598],prg0[1595:1594],prg0[1591:1590],prg0[1587:1586],prg0[1583:1582],prg0[1579:1578],prg0[1575:1574],prg0[1571:1570],
                  prg0[1567:1566],prg0[1563:1562],prg0[1559:1558],prg0[1555:1554],prg0[1551:1550],prg0[1547:1546],prg0[1543:1542],prg0[1539:1538],
                  prg0[1535:1534],prg0[1531:1530],prg0[1527:1526],prg0[1523:1522],prg0[1519:1518],prg0[1515:1514],prg0[1511:1510],prg0[1507:1506],
                  prg0[1503:1502],prg0[1499:1498],prg0[1495:1494],prg0[1491:1490],prg0[1487:1486],prg0[1483:1482],prg0[1479:1478],prg0[1475:1474],
                  prg0[1471:1470],prg0[1467:1466],prg0[1463:1462],prg0[1459:1458],prg0[1455:1454],prg0[1451:1450],prg0[1447:1446],prg0[1443:1442],
                  prg0[1439:1438],prg0[1435:1434],prg0[1431:1430],prg0[1427:1426],prg0[1423:1422],prg0[1419:1418],prg0[1415:1414],prg0[1411:1410],
                  prg0[1407:1406],prg0[1403:1402],prg0[1399:1398],prg0[1395:1394],prg0[1391:1390],prg0[1387:1386],prg0[1383:1382],prg0[1379:1378],
                  prg0[1375:1374],prg0[1371:1370],prg0[1367:1366],prg0[1363:1362],prg0[1359:1358],prg0[1355:1354],prg0[1351:1350],prg0[1347:1346],
                  prg0[1343:1342],prg0[1339:1338],prg0[1335:1334],prg0[1331:1330],prg0[1327:1326],prg0[1323:1322],prg0[1319:1318],prg0[1315:1314],
                  prg0[1311:1310],prg0[1307:1306],prg0[1303:1302],prg0[1299:1298],prg0[1295:1294],prg0[1291:1290],prg0[1287:1286],prg0[1283:1282],
                  prg0[1279:1278],prg0[1275:1274],prg0[1271:1270],prg0[1267:1266],prg0[1263:1262],prg0[1259:1258],prg0[1255:1254],prg0[1251:1250],
                  prg0[1247:1246],prg0[1243:1242],prg0[1239:1238],prg0[1235:1234],prg0[1231:1230],prg0[1227:1226],prg0[1223:1222],prg0[1219:1218],
                  prg0[1215:1214],prg0[1211:1210],prg0[1207:1206],prg0[1203:1202],prg0[1199:1198],prg0[1195:1194],prg0[1191:1190],prg0[1187:1186],
                  prg0[1183:1182],prg0[1179:1178],prg0[1175:1174],prg0[1171:1170],prg0[1167:1166],prg0[1163:1162],prg0[1159:1158],prg0[1155:1154],
                  prg0[1151:1150],prg0[1147:1146],prg0[1143:1142],prg0[1139:1138],prg0[1135:1134],prg0[1131:1130],prg0[1127:1126],prg0[1123:1122],
                  prg0[1119:1118],prg0[1115:1114],prg0[1111:1110],prg0[1107:1106],prg0[1103:1102],prg0[1099:1098],prg0[1095:1094],prg0[1091:1090],
                  prg0[1087:1086],prg0[1083:1082],prg0[1079:1078],prg0[1075:1074],prg0[1071:1070],prg0[1067:1066],prg0[1063:1062],prg0[1059:1058],
                  prg0[1055:1054],prg0[1051:1050],prg0[1047:1046],prg0[1043:1042],prg0[1039:1038],prg0[1035:1034],prg0[1031:1030],prg0[1027:1026],
                  prg0[1023:1022],prg0[1019:1018],prg0[1015:1014],prg0[1011:1010],prg0[1007:1006],prg0[1003:1002],prg0[ 999: 998],prg0[ 995: 994],
                  prg0[ 991: 990],prg0[ 987: 986],prg0[ 983: 982],prg0[ 979: 978],prg0[ 975: 974],prg0[ 971: 970],prg0[ 967: 966],prg0[ 963: 962],
                  prg0[ 959: 958],prg0[ 955: 954],prg0[ 951: 950],prg0[ 947: 946],prg0[ 943: 942],prg0[ 939: 938],prg0[ 935: 934],prg0[ 931: 930],
                  prg0[ 927: 926],prg0[ 923: 922],prg0[ 919: 918],prg0[ 915: 914],prg0[ 911: 910],prg0[ 907: 906],prg0[ 903: 902],prg0[ 899: 898],
                  prg0[ 895: 894],prg0[ 891: 890],prg0[ 887: 886],prg0[ 883: 882],prg0[ 879: 878],prg0[ 875: 874],prg0[ 871: 870],prg0[ 867: 866],
                  prg0[ 863: 862],prg0[ 859: 858],prg0[ 855: 854],prg0[ 851: 850],prg0[ 847: 846],prg0[ 843: 842],prg0[ 839: 838],prg0[ 835: 834],
                  prg0[ 831: 830],prg0[ 827: 826],prg0[ 823: 822],prg0[ 819: 818],prg0[ 815: 814],prg0[ 811: 810],prg0[ 807: 806],prg0[ 803: 802],
                  prg0[ 799: 798],prg0[ 795: 794],prg0[ 791: 790],prg0[ 787: 786],prg0[ 783: 782],prg0[ 779: 778],prg0[ 775: 774],prg0[ 771: 770],
                  prg0[ 767: 766],prg0[ 763: 762],prg0[ 759: 758],prg0[ 755: 754],prg0[ 751: 750],prg0[ 747: 746],prg0[ 743: 742],prg0[ 739: 738],
                  prg0[ 735: 734],prg0[ 731: 730],prg0[ 727: 726],prg0[ 723: 722],prg0[ 719: 718],prg0[ 715: 714],prg0[ 711: 710],prg0[ 707: 706],
                  prg0[ 703: 702],prg0[ 699: 698],prg0[ 695: 694],prg0[ 691: 690],prg0[ 687: 686],prg0[ 683: 682],prg0[ 679: 678],prg0[ 675: 674],
                  prg0[ 671: 670],prg0[ 667: 666],prg0[ 663: 662],prg0[ 659: 658],prg0[ 655: 654],prg0[ 651: 650],prg0[ 647: 646],prg0[ 643: 642],
                  prg0[ 639: 638],prg0[ 635: 634],prg0[ 631: 630],prg0[ 627: 626],prg0[ 623: 622],prg0[ 619: 618],prg0[ 615: 614],prg0[ 611: 610],
                  prg0[ 607: 606],prg0[ 603: 602],prg0[ 599: 598],prg0[ 595: 594],prg0[ 591: 590],prg0[ 587: 586],prg0[ 583: 582],prg0[ 579: 578],
                  prg0[ 575: 574],prg0[ 571: 570],prg0[ 567: 566],prg0[ 563: 562],prg0[ 559: 558],prg0[ 555: 554],prg0[ 551: 550],prg0[ 547: 546],
                  prg0[ 543: 542],prg0[ 539: 538],prg0[ 535: 534],prg0[ 531: 530],prg0[ 527: 526],prg0[ 523: 522],prg0[ 519: 518],prg0[ 515: 514],
                  prg0[ 511: 510],prg0[ 507: 506],prg0[ 503: 502],prg0[ 499: 498],prg0[ 495: 494],prg0[ 491: 490],prg0[ 487: 486],prg0[ 483: 482],
                  prg0[ 479: 478],prg0[ 475: 474],prg0[ 471: 470],prg0[ 467: 466],prg0[ 463: 462],prg0[ 459: 458],prg0[ 455: 454],prg0[ 451: 450],
                  prg0[ 447: 446],prg0[ 443: 442],prg0[ 439: 438],prg0[ 435: 434],prg0[ 431: 430],prg0[ 427: 426],prg0[ 423: 422],prg0[ 419: 418],
                  prg0[ 415: 414],prg0[ 411: 410],prg0[ 407: 406],prg0[ 403: 402],prg0[ 399: 398],prg0[ 395: 394],prg0[ 391: 390],prg0[ 387: 386],
                  prg0[ 383: 382],prg0[ 379: 378],prg0[ 375: 374],prg0[ 371: 370],prg0[ 367: 366],prg0[ 363: 362],prg0[ 359: 358],prg0[ 355: 354],
                  prg0[ 351: 350],prg0[ 347: 346],prg0[ 343: 342],prg0[ 339: 338],prg0[ 335: 334],prg0[ 331: 330],prg0[ 327: 326],prg0[ 323: 322],
                  prg0[ 319: 318],prg0[ 315: 314],prg0[ 311: 310],prg0[ 307: 306],prg0[ 303: 302],prg0[ 299: 298],prg0[ 295: 294],prg0[ 291: 290],
                  prg0[ 287: 286],prg0[ 283: 282],prg0[ 279: 278],prg0[ 275: 274],prg0[ 271: 270],prg0[ 267: 266],prg0[ 263: 262],prg0[ 259: 258],
                  prg0[ 255: 254],prg0[ 251: 250],prg0[ 247: 246],prg0[ 243: 242],prg0[ 239: 238],prg0[ 235: 234],prg0[ 231: 230],prg0[ 227: 226],
                  prg0[ 223: 222],prg0[ 219: 218],prg0[ 215: 214],prg0[ 211: 210],prg0[ 207: 206],prg0[ 203: 202],prg0[ 199: 198],prg0[ 195: 194],
                  prg0[ 191: 190],prg0[ 187: 186],prg0[ 183: 182],prg0[ 179: 178],prg0[ 175: 174],prg0[ 171: 170],prg0[ 167: 166],prg0[ 163: 162],
                  prg0[ 159: 158],prg0[ 155: 154],prg0[ 151: 150],prg0[ 147: 146],prg0[ 143: 142],prg0[ 139: 138],prg0[ 135: 134],prg0[ 131: 130],
                  prg0[ 127: 126],prg0[ 123: 122],prg0[ 119: 118],prg0[ 115: 114],prg0[ 111: 110],prg0[ 107: 106],prg0[ 103: 102],prg0[  99:  98],
                  prg0[  95:  94],prg0[  91:  90],prg0[  87:  86],prg0[  83:  82],prg0[  79:  78],prg0[  75:  74],prg0[  71:  70],prg0[  67:  66],
                  prg0[  63:  62],prg0[  59:  58],prg0[  55:  54],prg0[  51:  50],prg0[  47:  46],prg0[  43:  42],prg0[  39:  38],prg0[  35:  34],
                  prg0[  31:  30],prg0[  27:  26],prg0[  23:  22],prg0[  19:  18],prg0[  15:  14],prg0[  11:  10],prg0[   7:   6],prg0[   3:   2]};

         m_ebr_w2 #(.prg0(pb0))
         ebrb 
           (/*AUTOINST*/
            // Outputs
            .DAT_O                      (DAT_O[1:0]),
            // Inputs
            .B                          (B[1:0]),
            .Rai                        (Rai[10:0]),
            .Wai                        (Wai[10:0]),
            .clk                        (clk),
            .we                         (we));
   
         m_ebr_w2 #(.prg0(ph0))
         ebrh
           (// Outputs
            .DAT_O                      (DAT_O[3:2]),
            // Inputs
            .B                          (B[3:2]),
            /*AUTOINST*/
            // Inputs
            .Rai                        (Rai[10:0]),
            .Wai                        (Wai[10:0]),
            .clk                        (clk),
            .we                         (we));
   
         
      end
   endgenerate   
endmodule

/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * EBR program memory is split into 2-bit wide memory, specified here.
 */
module m_ebr_w2
  # ( parameter [4095:0] prg0 = 4096'h0
      )
   (
    input [1:0]  B, //     Output from ALU
    input [10:0] Rai, //   Read address
    input [10:0] Wai, //   Write address
    input        clk, //   System clock
    input        we, //    Write enable
    output [1:0] DAT_O //  Registered output
    );

   /* verilator lint_off UNUSED */
   wire [13:0]   dum14;
   /* verilator lint_on UNUSED */

   SB_RAM40_4K 
     #(
       .INIT_F({prg0[4095],prg0[4093],prg0[4091],prg0[4089],prg0[4087],prg0[4085],prg0[4083],prg0[4081],
                prg0[4094],prg0[4092],prg0[4090],prg0[4088],prg0[4086],prg0[4084],prg0[4082],prg0[4080],
                prg0[4079],prg0[4077],prg0[4075],prg0[4073],prg0[4071],prg0[4069],prg0[4067],prg0[4065],
                prg0[4078],prg0[4076],prg0[4074],prg0[4072],prg0[4070],prg0[4068],prg0[4066],prg0[4064],
                prg0[4063],prg0[4061],prg0[4059],prg0[4057],prg0[4055],prg0[4053],prg0[4051],prg0[4049],
                prg0[4062],prg0[4060],prg0[4058],prg0[4056],prg0[4054],prg0[4052],prg0[4050],prg0[4048],
                prg0[4047],prg0[4045],prg0[4043],prg0[4041],prg0[4039],prg0[4037],prg0[4035],prg0[4033],
                prg0[4046],prg0[4044],prg0[4042],prg0[4040],prg0[4038],prg0[4036],prg0[4034],prg0[4032],
                prg0[4031],prg0[4029],prg0[4027],prg0[4025],prg0[4023],prg0[4021],prg0[4019],prg0[4017],
                prg0[4030],prg0[4028],prg0[4026],prg0[4024],prg0[4022],prg0[4020],prg0[4018],prg0[4016],
                prg0[4015],prg0[4013],prg0[4011],prg0[4009],prg0[4007],prg0[4005],prg0[4003],prg0[4001],
                prg0[4014],prg0[4012],prg0[4010],prg0[4008],prg0[4006],prg0[4004],prg0[4002],prg0[4000],
                prg0[3999],prg0[3997],prg0[3995],prg0[3993],prg0[3991],prg0[3989],prg0[3987],prg0[3985],
                prg0[3998],prg0[3996],prg0[3994],prg0[3992],prg0[3990],prg0[3988],prg0[3986],prg0[3984],
                prg0[3983],prg0[3981],prg0[3979],prg0[3977],prg0[3975],prg0[3973],prg0[3971],prg0[3969],
                prg0[3982],prg0[3980],prg0[3978],prg0[3976],prg0[3974],prg0[3972],prg0[3970],prg0[3968],
                prg0[3967],prg0[3965],prg0[3963],prg0[3961],prg0[3959],prg0[3957],prg0[3955],prg0[3953],
                prg0[3966],prg0[3964],prg0[3962],prg0[3960],prg0[3958],prg0[3956],prg0[3954],prg0[3952],
                prg0[3951],prg0[3949],prg0[3947],prg0[3945],prg0[3943],prg0[3941],prg0[3939],prg0[3937],
                prg0[3950],prg0[3948],prg0[3946],prg0[3944],prg0[3942],prg0[3940],prg0[3938],prg0[3936],
                prg0[3935],prg0[3933],prg0[3931],prg0[3929],prg0[3927],prg0[3925],prg0[3923],prg0[3921],
                prg0[3934],prg0[3932],prg0[3930],prg0[3928],prg0[3926],prg0[3924],prg0[3922],prg0[3920],
                prg0[3919],prg0[3917],prg0[3915],prg0[3913],prg0[3911],prg0[3909],prg0[3907],prg0[3905],
                prg0[3918],prg0[3916],prg0[3914],prg0[3912],prg0[3910],prg0[3908],prg0[3906],prg0[3904],
                prg0[3903],prg0[3901],prg0[3899],prg0[3897],prg0[3895],prg0[3893],prg0[3891],prg0[3889],
                prg0[3902],prg0[3900],prg0[3898],prg0[3896],prg0[3894],prg0[3892],prg0[3890],prg0[3888],
                prg0[3887],prg0[3885],prg0[3883],prg0[3881],prg0[3879],prg0[3877],prg0[3875],prg0[3873],
                prg0[3886],prg0[3884],prg0[3882],prg0[3880],prg0[3878],prg0[3876],prg0[3874],prg0[3872],
                prg0[3871],prg0[3869],prg0[3867],prg0[3865],prg0[3863],prg0[3861],prg0[3859],prg0[3857],
                prg0[3870],prg0[3868],prg0[3866],prg0[3864],prg0[3862],prg0[3860],prg0[3858],prg0[3856],
                prg0[3855],prg0[3853],prg0[3851],prg0[3849],prg0[3847],prg0[3845],prg0[3843],prg0[3841],
                prg0[3854],prg0[3852],prg0[3850],prg0[3848],prg0[3846],prg0[3844],prg0[3842],prg0[3840]}),
       .INIT_E({prg0[3839],prg0[3837],prg0[3835],prg0[3833],prg0[3831],prg0[3829],prg0[3827],prg0[3825],
                prg0[3838],prg0[3836],prg0[3834],prg0[3832],prg0[3830],prg0[3828],prg0[3826],prg0[3824],
                prg0[3823],prg0[3821],prg0[3819],prg0[3817],prg0[3815],prg0[3813],prg0[3811],prg0[3809],
                prg0[3822],prg0[3820],prg0[3818],prg0[3816],prg0[3814],prg0[3812],prg0[3810],prg0[3808],
                prg0[3807],prg0[3805],prg0[3803],prg0[3801],prg0[3799],prg0[3797],prg0[3795],prg0[3793],
                prg0[3806],prg0[3804],prg0[3802],prg0[3800],prg0[3798],prg0[3796],prg0[3794],prg0[3792],
                prg0[3791],prg0[3789],prg0[3787],prg0[3785],prg0[3783],prg0[3781],prg0[3779],prg0[3777],
                prg0[3790],prg0[3788],prg0[3786],prg0[3784],prg0[3782],prg0[3780],prg0[3778],prg0[3776],
                prg0[3775],prg0[3773],prg0[3771],prg0[3769],prg0[3767],prg0[3765],prg0[3763],prg0[3761],
                prg0[3774],prg0[3772],prg0[3770],prg0[3768],prg0[3766],prg0[3764],prg0[3762],prg0[3760],
                prg0[3759],prg0[3757],prg0[3755],prg0[3753],prg0[3751],prg0[3749],prg0[3747],prg0[3745],
                prg0[3758],prg0[3756],prg0[3754],prg0[3752],prg0[3750],prg0[3748],prg0[3746],prg0[3744],
                prg0[3743],prg0[3741],prg0[3739],prg0[3737],prg0[3735],prg0[3733],prg0[3731],prg0[3729],
                prg0[3742],prg0[3740],prg0[3738],prg0[3736],prg0[3734],prg0[3732],prg0[3730],prg0[3728],
                prg0[3727],prg0[3725],prg0[3723],prg0[3721],prg0[3719],prg0[3717],prg0[3715],prg0[3713],
                prg0[3726],prg0[3724],prg0[3722],prg0[3720],prg0[3718],prg0[3716],prg0[3714],prg0[3712],
                prg0[3711],prg0[3709],prg0[3707],prg0[3705],prg0[3703],prg0[3701],prg0[3699],prg0[3697],
                prg0[3710],prg0[3708],prg0[3706],prg0[3704],prg0[3702],prg0[3700],prg0[3698],prg0[3696],
                prg0[3695],prg0[3693],prg0[3691],prg0[3689],prg0[3687],prg0[3685],prg0[3683],prg0[3681],
                prg0[3694],prg0[3692],prg0[3690],prg0[3688],prg0[3686],prg0[3684],prg0[3682],prg0[3680],
                prg0[3679],prg0[3677],prg0[3675],prg0[3673],prg0[3671],prg0[3669],prg0[3667],prg0[3665],
                prg0[3678],prg0[3676],prg0[3674],prg0[3672],prg0[3670],prg0[3668],prg0[3666],prg0[3664],
                prg0[3663],prg0[3661],prg0[3659],prg0[3657],prg0[3655],prg0[3653],prg0[3651],prg0[3649],
                prg0[3662],prg0[3660],prg0[3658],prg0[3656],prg0[3654],prg0[3652],prg0[3650],prg0[3648],
                prg0[3647],prg0[3645],prg0[3643],prg0[3641],prg0[3639],prg0[3637],prg0[3635],prg0[3633],
                prg0[3646],prg0[3644],prg0[3642],prg0[3640],prg0[3638],prg0[3636],prg0[3634],prg0[3632],
                prg0[3631],prg0[3629],prg0[3627],prg0[3625],prg0[3623],prg0[3621],prg0[3619],prg0[3617],
                prg0[3630],prg0[3628],prg0[3626],prg0[3624],prg0[3622],prg0[3620],prg0[3618],prg0[3616],
                prg0[3615],prg0[3613],prg0[3611],prg0[3609],prg0[3607],prg0[3605],prg0[3603],prg0[3601],
                prg0[3614],prg0[3612],prg0[3610],prg0[3608],prg0[3606],prg0[3604],prg0[3602],prg0[3600],
                prg0[3599],prg0[3597],prg0[3595],prg0[3593],prg0[3591],prg0[3589],prg0[3587],prg0[3585],
                prg0[3598],prg0[3596],prg0[3594],prg0[3592],prg0[3590],prg0[3588],prg0[3586],prg0[3584]}),
       .INIT_D({prg0[3583],prg0[3581],prg0[3579],prg0[3577],prg0[3575],prg0[3573],prg0[3571],prg0[3569],
                prg0[3582],prg0[3580],prg0[3578],prg0[3576],prg0[3574],prg0[3572],prg0[3570],prg0[3568],
                prg0[3567],prg0[3565],prg0[3563],prg0[3561],prg0[3559],prg0[3557],prg0[3555],prg0[3553],
                prg0[3566],prg0[3564],prg0[3562],prg0[3560],prg0[3558],prg0[3556],prg0[3554],prg0[3552],
                prg0[3551],prg0[3549],prg0[3547],prg0[3545],prg0[3543],prg0[3541],prg0[3539],prg0[3537],
                prg0[3550],prg0[3548],prg0[3546],prg0[3544],prg0[3542],prg0[3540],prg0[3538],prg0[3536],
                prg0[3535],prg0[3533],prg0[3531],prg0[3529],prg0[3527],prg0[3525],prg0[3523],prg0[3521],
                prg0[3534],prg0[3532],prg0[3530],prg0[3528],prg0[3526],prg0[3524],prg0[3522],prg0[3520],
                prg0[3519],prg0[3517],prg0[3515],prg0[3513],prg0[3511],prg0[3509],prg0[3507],prg0[3505],
                prg0[3518],prg0[3516],prg0[3514],prg0[3512],prg0[3510],prg0[3508],prg0[3506],prg0[3504],
                prg0[3503],prg0[3501],prg0[3499],prg0[3497],prg0[3495],prg0[3493],prg0[3491],prg0[3489],
                prg0[3502],prg0[3500],prg0[3498],prg0[3496],prg0[3494],prg0[3492],prg0[3490],prg0[3488],
                prg0[3487],prg0[3485],prg0[3483],prg0[3481],prg0[3479],prg0[3477],prg0[3475],prg0[3473],
                prg0[3486],prg0[3484],prg0[3482],prg0[3480],prg0[3478],prg0[3476],prg0[3474],prg0[3472],
                prg0[3471],prg0[3469],prg0[3467],prg0[3465],prg0[3463],prg0[3461],prg0[3459],prg0[3457],
                prg0[3470],prg0[3468],prg0[3466],prg0[3464],prg0[3462],prg0[3460],prg0[3458],prg0[3456],
                prg0[3455],prg0[3453],prg0[3451],prg0[3449],prg0[3447],prg0[3445],prg0[3443],prg0[3441],
                prg0[3454],prg0[3452],prg0[3450],prg0[3448],prg0[3446],prg0[3444],prg0[3442],prg0[3440],
                prg0[3439],prg0[3437],prg0[3435],prg0[3433],prg0[3431],prg0[3429],prg0[3427],prg0[3425],
                prg0[3438],prg0[3436],prg0[3434],prg0[3432],prg0[3430],prg0[3428],prg0[3426],prg0[3424],
                prg0[3423],prg0[3421],prg0[3419],prg0[3417],prg0[3415],prg0[3413],prg0[3411],prg0[3409],
                prg0[3422],prg0[3420],prg0[3418],prg0[3416],prg0[3414],prg0[3412],prg0[3410],prg0[3408],
                prg0[3407],prg0[3405],prg0[3403],prg0[3401],prg0[3399],prg0[3397],prg0[3395],prg0[3393],
                prg0[3406],prg0[3404],prg0[3402],prg0[3400],prg0[3398],prg0[3396],prg0[3394],prg0[3392],
                prg0[3391],prg0[3389],prg0[3387],prg0[3385],prg0[3383],prg0[3381],prg0[3379],prg0[3377],
                prg0[3390],prg0[3388],prg0[3386],prg0[3384],prg0[3382],prg0[3380],prg0[3378],prg0[3376],
                prg0[3375],prg0[3373],prg0[3371],prg0[3369],prg0[3367],prg0[3365],prg0[3363],prg0[3361],
                prg0[3374],prg0[3372],prg0[3370],prg0[3368],prg0[3366],prg0[3364],prg0[3362],prg0[3360],
                prg0[3359],prg0[3357],prg0[3355],prg0[3353],prg0[3351],prg0[3349],prg0[3347],prg0[3345],
                prg0[3358],prg0[3356],prg0[3354],prg0[3352],prg0[3350],prg0[3348],prg0[3346],prg0[3344],
                prg0[3343],prg0[3341],prg0[3339],prg0[3337],prg0[3335],prg0[3333],prg0[3331],prg0[3329],
                prg0[3342],prg0[3340],prg0[3338],prg0[3336],prg0[3334],prg0[3332],prg0[3330],prg0[3328]}),
       .INIT_C({prg0[3327],prg0[3325],prg0[3323],prg0[3321],prg0[3319],prg0[3317],prg0[3315],prg0[3313],
                prg0[3326],prg0[3324],prg0[3322],prg0[3320],prg0[3318],prg0[3316],prg0[3314],prg0[3312],
                prg0[3311],prg0[3309],prg0[3307],prg0[3305],prg0[3303],prg0[3301],prg0[3299],prg0[3297],
                prg0[3310],prg0[3308],prg0[3306],prg0[3304],prg0[3302],prg0[3300],prg0[3298],prg0[3296],
                prg0[3295],prg0[3293],prg0[3291],prg0[3289],prg0[3287],prg0[3285],prg0[3283],prg0[3281],
                prg0[3294],prg0[3292],prg0[3290],prg0[3288],prg0[3286],prg0[3284],prg0[3282],prg0[3280],
                prg0[3279],prg0[3277],prg0[3275],prg0[3273],prg0[3271],prg0[3269],prg0[3267],prg0[3265],
                prg0[3278],prg0[3276],prg0[3274],prg0[3272],prg0[3270],prg0[3268],prg0[3266],prg0[3264],
                prg0[3263],prg0[3261],prg0[3259],prg0[3257],prg0[3255],prg0[3253],prg0[3251],prg0[3249],
                prg0[3262],prg0[3260],prg0[3258],prg0[3256],prg0[3254],prg0[3252],prg0[3250],prg0[3248],
                prg0[3247],prg0[3245],prg0[3243],prg0[3241],prg0[3239],prg0[3237],prg0[3235],prg0[3233],
                prg0[3246],prg0[3244],prg0[3242],prg0[3240],prg0[3238],prg0[3236],prg0[3234],prg0[3232],
                prg0[3231],prg0[3229],prg0[3227],prg0[3225],prg0[3223],prg0[3221],prg0[3219],prg0[3217],
                prg0[3230],prg0[3228],prg0[3226],prg0[3224],prg0[3222],prg0[3220],prg0[3218],prg0[3216],
                prg0[3215],prg0[3213],prg0[3211],prg0[3209],prg0[3207],prg0[3205],prg0[3203],prg0[3201],
                prg0[3214],prg0[3212],prg0[3210],prg0[3208],prg0[3206],prg0[3204],prg0[3202],prg0[3200],
                prg0[3199],prg0[3197],prg0[3195],prg0[3193],prg0[3191],prg0[3189],prg0[3187],prg0[3185],
                prg0[3198],prg0[3196],prg0[3194],prg0[3192],prg0[3190],prg0[3188],prg0[3186],prg0[3184],
                prg0[3183],prg0[3181],prg0[3179],prg0[3177],prg0[3175],prg0[3173],prg0[3171],prg0[3169],
                prg0[3182],prg0[3180],prg0[3178],prg0[3176],prg0[3174],prg0[3172],prg0[3170],prg0[3168],
                prg0[3167],prg0[3165],prg0[3163],prg0[3161],prg0[3159],prg0[3157],prg0[3155],prg0[3153],
                prg0[3166],prg0[3164],prg0[3162],prg0[3160],prg0[3158],prg0[3156],prg0[3154],prg0[3152],
                prg0[3151],prg0[3149],prg0[3147],prg0[3145],prg0[3143],prg0[3141],prg0[3139],prg0[3137],
                prg0[3150],prg0[3148],prg0[3146],prg0[3144],prg0[3142],prg0[3140],prg0[3138],prg0[3136],
                prg0[3135],prg0[3133],prg0[3131],prg0[3129],prg0[3127],prg0[3125],prg0[3123],prg0[3121],
                prg0[3134],prg0[3132],prg0[3130],prg0[3128],prg0[3126],prg0[3124],prg0[3122],prg0[3120],
                prg0[3119],prg0[3117],prg0[3115],prg0[3113],prg0[3111],prg0[3109],prg0[3107],prg0[3105],
                prg0[3118],prg0[3116],prg0[3114],prg0[3112],prg0[3110],prg0[3108],prg0[3106],prg0[3104],
                prg0[3103],prg0[3101],prg0[3099],prg0[3097],prg0[3095],prg0[3093],prg0[3091],prg0[3089],
                prg0[3102],prg0[3100],prg0[3098],prg0[3096],prg0[3094],prg0[3092],prg0[3090],prg0[3088],
                prg0[3087],prg0[3085],prg0[3083],prg0[3081],prg0[3079],prg0[3077],prg0[3075],prg0[3073],
                prg0[3086],prg0[3084],prg0[3082],prg0[3080],prg0[3078],prg0[3076],prg0[3074],prg0[3072]}),
       .INIT_B({prg0[3071],prg0[3069],prg0[3067],prg0[3065],prg0[3063],prg0[3061],prg0[3059],prg0[3057],
                prg0[3070],prg0[3068],prg0[3066],prg0[3064],prg0[3062],prg0[3060],prg0[3058],prg0[3056],
                prg0[3055],prg0[3053],prg0[3051],prg0[3049],prg0[3047],prg0[3045],prg0[3043],prg0[3041],
                prg0[3054],prg0[3052],prg0[3050],prg0[3048],prg0[3046],prg0[3044],prg0[3042],prg0[3040],
                prg0[3039],prg0[3037],prg0[3035],prg0[3033],prg0[3031],prg0[3029],prg0[3027],prg0[3025],
                prg0[3038],prg0[3036],prg0[3034],prg0[3032],prg0[3030],prg0[3028],prg0[3026],prg0[3024],
                prg0[3023],prg0[3021],prg0[3019],prg0[3017],prg0[3015],prg0[3013],prg0[3011],prg0[3009],
                prg0[3022],prg0[3020],prg0[3018],prg0[3016],prg0[3014],prg0[3012],prg0[3010],prg0[3008],
                prg0[3007],prg0[3005],prg0[3003],prg0[3001],prg0[2999],prg0[2997],prg0[2995],prg0[2993],
                prg0[3006],prg0[3004],prg0[3002],prg0[3000],prg0[2998],prg0[2996],prg0[2994],prg0[2992],
                prg0[2991],prg0[2989],prg0[2987],prg0[2985],prg0[2983],prg0[2981],prg0[2979],prg0[2977],
                prg0[2990],prg0[2988],prg0[2986],prg0[2984],prg0[2982],prg0[2980],prg0[2978],prg0[2976],
                prg0[2975],prg0[2973],prg0[2971],prg0[2969],prg0[2967],prg0[2965],prg0[2963],prg0[2961],
                prg0[2974],prg0[2972],prg0[2970],prg0[2968],prg0[2966],prg0[2964],prg0[2962],prg0[2960],
                prg0[2959],prg0[2957],prg0[2955],prg0[2953],prg0[2951],prg0[2949],prg0[2947],prg0[2945],
                prg0[2958],prg0[2956],prg0[2954],prg0[2952],prg0[2950],prg0[2948],prg0[2946],prg0[2944],
                prg0[2943],prg0[2941],prg0[2939],prg0[2937],prg0[2935],prg0[2933],prg0[2931],prg0[2929],
                prg0[2942],prg0[2940],prg0[2938],prg0[2936],prg0[2934],prg0[2932],prg0[2930],prg0[2928],
                prg0[2927],prg0[2925],prg0[2923],prg0[2921],prg0[2919],prg0[2917],prg0[2915],prg0[2913],
                prg0[2926],prg0[2924],prg0[2922],prg0[2920],prg0[2918],prg0[2916],prg0[2914],prg0[2912],
                prg0[2911],prg0[2909],prg0[2907],prg0[2905],prg0[2903],prg0[2901],prg0[2899],prg0[2897],
                prg0[2910],prg0[2908],prg0[2906],prg0[2904],prg0[2902],prg0[2900],prg0[2898],prg0[2896],
                prg0[2895],prg0[2893],prg0[2891],prg0[2889],prg0[2887],prg0[2885],prg0[2883],prg0[2881],
                prg0[2894],prg0[2892],prg0[2890],prg0[2888],prg0[2886],prg0[2884],prg0[2882],prg0[2880],
                prg0[2879],prg0[2877],prg0[2875],prg0[2873],prg0[2871],prg0[2869],prg0[2867],prg0[2865],
                prg0[2878],prg0[2876],prg0[2874],prg0[2872],prg0[2870],prg0[2868],prg0[2866],prg0[2864],
                prg0[2863],prg0[2861],prg0[2859],prg0[2857],prg0[2855],prg0[2853],prg0[2851],prg0[2849],
                prg0[2862],prg0[2860],prg0[2858],prg0[2856],prg0[2854],prg0[2852],prg0[2850],prg0[2848],
                prg0[2847],prg0[2845],prg0[2843],prg0[2841],prg0[2839],prg0[2837],prg0[2835],prg0[2833],
                prg0[2846],prg0[2844],prg0[2842],prg0[2840],prg0[2838],prg0[2836],prg0[2834],prg0[2832],
                prg0[2831],prg0[2829],prg0[2827],prg0[2825],prg0[2823],prg0[2821],prg0[2819],prg0[2817],
                prg0[2830],prg0[2828],prg0[2826],prg0[2824],prg0[2822],prg0[2820],prg0[2818],prg0[2816]}),
       .INIT_A({prg0[2815],prg0[2813],prg0[2811],prg0[2809],prg0[2807],prg0[2805],prg0[2803],prg0[2801],
                prg0[2814],prg0[2812],prg0[2810],prg0[2808],prg0[2806],prg0[2804],prg0[2802],prg0[2800],
                prg0[2799],prg0[2797],prg0[2795],prg0[2793],prg0[2791],prg0[2789],prg0[2787],prg0[2785],
                prg0[2798],prg0[2796],prg0[2794],prg0[2792],prg0[2790],prg0[2788],prg0[2786],prg0[2784],
                prg0[2783],prg0[2781],prg0[2779],prg0[2777],prg0[2775],prg0[2773],prg0[2771],prg0[2769],
                prg0[2782],prg0[2780],prg0[2778],prg0[2776],prg0[2774],prg0[2772],prg0[2770],prg0[2768],
                prg0[2767],prg0[2765],prg0[2763],prg0[2761],prg0[2759],prg0[2757],prg0[2755],prg0[2753],
                prg0[2766],prg0[2764],prg0[2762],prg0[2760],prg0[2758],prg0[2756],prg0[2754],prg0[2752],
                prg0[2751],prg0[2749],prg0[2747],prg0[2745],prg0[2743],prg0[2741],prg0[2739],prg0[2737],
                prg0[2750],prg0[2748],prg0[2746],prg0[2744],prg0[2742],prg0[2740],prg0[2738],prg0[2736],
                prg0[2735],prg0[2733],prg0[2731],prg0[2729],prg0[2727],prg0[2725],prg0[2723],prg0[2721],
                prg0[2734],prg0[2732],prg0[2730],prg0[2728],prg0[2726],prg0[2724],prg0[2722],prg0[2720],
                prg0[2719],prg0[2717],prg0[2715],prg0[2713],prg0[2711],prg0[2709],prg0[2707],prg0[2705],
                prg0[2718],prg0[2716],prg0[2714],prg0[2712],prg0[2710],prg0[2708],prg0[2706],prg0[2704],
                prg0[2703],prg0[2701],prg0[2699],prg0[2697],prg0[2695],prg0[2693],prg0[2691],prg0[2689],
                prg0[2702],prg0[2700],prg0[2698],prg0[2696],prg0[2694],prg0[2692],prg0[2690],prg0[2688],
                prg0[2687],prg0[2685],prg0[2683],prg0[2681],prg0[2679],prg0[2677],prg0[2675],prg0[2673],
                prg0[2686],prg0[2684],prg0[2682],prg0[2680],prg0[2678],prg0[2676],prg0[2674],prg0[2672],
                prg0[2671],prg0[2669],prg0[2667],prg0[2665],prg0[2663],prg0[2661],prg0[2659],prg0[2657],
                prg0[2670],prg0[2668],prg0[2666],prg0[2664],prg0[2662],prg0[2660],prg0[2658],prg0[2656],
                prg0[2655],prg0[2653],prg0[2651],prg0[2649],prg0[2647],prg0[2645],prg0[2643],prg0[2641],
                prg0[2654],prg0[2652],prg0[2650],prg0[2648],prg0[2646],prg0[2644],prg0[2642],prg0[2640],
                prg0[2639],prg0[2637],prg0[2635],prg0[2633],prg0[2631],prg0[2629],prg0[2627],prg0[2625],
                prg0[2638],prg0[2636],prg0[2634],prg0[2632],prg0[2630],prg0[2628],prg0[2626],prg0[2624],
                prg0[2623],prg0[2621],prg0[2619],prg0[2617],prg0[2615],prg0[2613],prg0[2611],prg0[2609],
                prg0[2622],prg0[2620],prg0[2618],prg0[2616],prg0[2614],prg0[2612],prg0[2610],prg0[2608],
                prg0[2607],prg0[2605],prg0[2603],prg0[2601],prg0[2599],prg0[2597],prg0[2595],prg0[2593],
                prg0[2606],prg0[2604],prg0[2602],prg0[2600],prg0[2598],prg0[2596],prg0[2594],prg0[2592],
                prg0[2591],prg0[2589],prg0[2587],prg0[2585],prg0[2583],prg0[2581],prg0[2579],prg0[2577],
                prg0[2590],prg0[2588],prg0[2586],prg0[2584],prg0[2582],prg0[2580],prg0[2578],prg0[2576],
                prg0[2575],prg0[2573],prg0[2571],prg0[2569],prg0[2567],prg0[2565],prg0[2563],prg0[2561],
                prg0[2574],prg0[2572],prg0[2570],prg0[2568],prg0[2566],prg0[2564],prg0[2562],prg0[2560]}),
       .INIT_9({prg0[2559],prg0[2557],prg0[2555],prg0[2553],prg0[2551],prg0[2549],prg0[2547],prg0[2545],
                prg0[2558],prg0[2556],prg0[2554],prg0[2552],prg0[2550],prg0[2548],prg0[2546],prg0[2544],
                prg0[2543],prg0[2541],prg0[2539],prg0[2537],prg0[2535],prg0[2533],prg0[2531],prg0[2529],
                prg0[2542],prg0[2540],prg0[2538],prg0[2536],prg0[2534],prg0[2532],prg0[2530],prg0[2528],
                prg0[2527],prg0[2525],prg0[2523],prg0[2521],prg0[2519],prg0[2517],prg0[2515],prg0[2513],
                prg0[2526],prg0[2524],prg0[2522],prg0[2520],prg0[2518],prg0[2516],prg0[2514],prg0[2512],
                prg0[2511],prg0[2509],prg0[2507],prg0[2505],prg0[2503],prg0[2501],prg0[2499],prg0[2497],
                prg0[2510],prg0[2508],prg0[2506],prg0[2504],prg0[2502],prg0[2500],prg0[2498],prg0[2496],
                prg0[2495],prg0[2493],prg0[2491],prg0[2489],prg0[2487],prg0[2485],prg0[2483],prg0[2481],
                prg0[2494],prg0[2492],prg0[2490],prg0[2488],prg0[2486],prg0[2484],prg0[2482],prg0[2480],
                prg0[2479],prg0[2477],prg0[2475],prg0[2473],prg0[2471],prg0[2469],prg0[2467],prg0[2465],
                prg0[2478],prg0[2476],prg0[2474],prg0[2472],prg0[2470],prg0[2468],prg0[2466],prg0[2464],
                prg0[2463],prg0[2461],prg0[2459],prg0[2457],prg0[2455],prg0[2453],prg0[2451],prg0[2449],
                prg0[2462],prg0[2460],prg0[2458],prg0[2456],prg0[2454],prg0[2452],prg0[2450],prg0[2448],
                prg0[2447],prg0[2445],prg0[2443],prg0[2441],prg0[2439],prg0[2437],prg0[2435],prg0[2433],
                prg0[2446],prg0[2444],prg0[2442],prg0[2440],prg0[2438],prg0[2436],prg0[2434],prg0[2432],
                prg0[2431],prg0[2429],prg0[2427],prg0[2425],prg0[2423],prg0[2421],prg0[2419],prg0[2417],
                prg0[2430],prg0[2428],prg0[2426],prg0[2424],prg0[2422],prg0[2420],prg0[2418],prg0[2416],
                prg0[2415],prg0[2413],prg0[2411],prg0[2409],prg0[2407],prg0[2405],prg0[2403],prg0[2401],
                prg0[2414],prg0[2412],prg0[2410],prg0[2408],prg0[2406],prg0[2404],prg0[2402],prg0[2400],
                prg0[2399],prg0[2397],prg0[2395],prg0[2393],prg0[2391],prg0[2389],prg0[2387],prg0[2385],
                prg0[2398],prg0[2396],prg0[2394],prg0[2392],prg0[2390],prg0[2388],prg0[2386],prg0[2384],
                prg0[2383],prg0[2381],prg0[2379],prg0[2377],prg0[2375],prg0[2373],prg0[2371],prg0[2369],
                prg0[2382],prg0[2380],prg0[2378],prg0[2376],prg0[2374],prg0[2372],prg0[2370],prg0[2368],
                prg0[2367],prg0[2365],prg0[2363],prg0[2361],prg0[2359],prg0[2357],prg0[2355],prg0[2353],
                prg0[2366],prg0[2364],prg0[2362],prg0[2360],prg0[2358],prg0[2356],prg0[2354],prg0[2352],
                prg0[2351],prg0[2349],prg0[2347],prg0[2345],prg0[2343],prg0[2341],prg0[2339],prg0[2337],
                prg0[2350],prg0[2348],prg0[2346],prg0[2344],prg0[2342],prg0[2340],prg0[2338],prg0[2336],
                prg0[2335],prg0[2333],prg0[2331],prg0[2329],prg0[2327],prg0[2325],prg0[2323],prg0[2321],
                prg0[2334],prg0[2332],prg0[2330],prg0[2328],prg0[2326],prg0[2324],prg0[2322],prg0[2320],
                prg0[2319],prg0[2317],prg0[2315],prg0[2313],prg0[2311],prg0[2309],prg0[2307],prg0[2305],
                prg0[2318],prg0[2316],prg0[2314],prg0[2312],prg0[2310],prg0[2308],prg0[2306],prg0[2304]}),
       .INIT_8({prg0[2303],prg0[2301],prg0[2299],prg0[2297],prg0[2295],prg0[2293],prg0[2291],prg0[2289],
                prg0[2302],prg0[2300],prg0[2298],prg0[2296],prg0[2294],prg0[2292],prg0[2290],prg0[2288],
                prg0[2287],prg0[2285],prg0[2283],prg0[2281],prg0[2279],prg0[2277],prg0[2275],prg0[2273],
                prg0[2286],prg0[2284],prg0[2282],prg0[2280],prg0[2278],prg0[2276],prg0[2274],prg0[2272],
                prg0[2271],prg0[2269],prg0[2267],prg0[2265],prg0[2263],prg0[2261],prg0[2259],prg0[2257],
                prg0[2270],prg0[2268],prg0[2266],prg0[2264],prg0[2262],prg0[2260],prg0[2258],prg0[2256],
                prg0[2255],prg0[2253],prg0[2251],prg0[2249],prg0[2247],prg0[2245],prg0[2243],prg0[2241],
                prg0[2254],prg0[2252],prg0[2250],prg0[2248],prg0[2246],prg0[2244],prg0[2242],prg0[2240],
                prg0[2239],prg0[2237],prg0[2235],prg0[2233],prg0[2231],prg0[2229],prg0[2227],prg0[2225],
                prg0[2238],prg0[2236],prg0[2234],prg0[2232],prg0[2230],prg0[2228],prg0[2226],prg0[2224],
                prg0[2223],prg0[2221],prg0[2219],prg0[2217],prg0[2215],prg0[2213],prg0[2211],prg0[2209],
                prg0[2222],prg0[2220],prg0[2218],prg0[2216],prg0[2214],prg0[2212],prg0[2210],prg0[2208],
                prg0[2207],prg0[2205],prg0[2203],prg0[2201],prg0[2199],prg0[2197],prg0[2195],prg0[2193],
                prg0[2206],prg0[2204],prg0[2202],prg0[2200],prg0[2198],prg0[2196],prg0[2194],prg0[2192],
                prg0[2191],prg0[2189],prg0[2187],prg0[2185],prg0[2183],prg0[2181],prg0[2179],prg0[2177],
                prg0[2190],prg0[2188],prg0[2186],prg0[2184],prg0[2182],prg0[2180],prg0[2178],prg0[2176],
                prg0[2175],prg0[2173],prg0[2171],prg0[2169],prg0[2167],prg0[2165],prg0[2163],prg0[2161],
                prg0[2174],prg0[2172],prg0[2170],prg0[2168],prg0[2166],prg0[2164],prg0[2162],prg0[2160],
                prg0[2159],prg0[2157],prg0[2155],prg0[2153],prg0[2151],prg0[2149],prg0[2147],prg0[2145],
                prg0[2158],prg0[2156],prg0[2154],prg0[2152],prg0[2150],prg0[2148],prg0[2146],prg0[2144],
                prg0[2143],prg0[2141],prg0[2139],prg0[2137],prg0[2135],prg0[2133],prg0[2131],prg0[2129],
                prg0[2142],prg0[2140],prg0[2138],prg0[2136],prg0[2134],prg0[2132],prg0[2130],prg0[2128],
                prg0[2127],prg0[2125],prg0[2123],prg0[2121],prg0[2119],prg0[2117],prg0[2115],prg0[2113],
                prg0[2126],prg0[2124],prg0[2122],prg0[2120],prg0[2118],prg0[2116],prg0[2114],prg0[2112],
                prg0[2111],prg0[2109],prg0[2107],prg0[2105],prg0[2103],prg0[2101],prg0[2099],prg0[2097],
                prg0[2110],prg0[2108],prg0[2106],prg0[2104],prg0[2102],prg0[2100],prg0[2098],prg0[2096],
                prg0[2095],prg0[2093],prg0[2091],prg0[2089],prg0[2087],prg0[2085],prg0[2083],prg0[2081],
                prg0[2094],prg0[2092],prg0[2090],prg0[2088],prg0[2086],prg0[2084],prg0[2082],prg0[2080],
                prg0[2079],prg0[2077],prg0[2075],prg0[2073],prg0[2071],prg0[2069],prg0[2067],prg0[2065],
                prg0[2078],prg0[2076],prg0[2074],prg0[2072],prg0[2070],prg0[2068],prg0[2066],prg0[2064],
                prg0[2063],prg0[2061],prg0[2059],prg0[2057],prg0[2055],prg0[2053],prg0[2051],prg0[2049],
                prg0[2062],prg0[2060],prg0[2058],prg0[2056],prg0[2054],prg0[2052],prg0[2050],prg0[2048]}),
       .INIT_7({prg0[2047],prg0[2045],prg0[2043],prg0[2041],prg0[2039],prg0[2037],prg0[2035],prg0[2033],
                prg0[2046],prg0[2044],prg0[2042],prg0[2040],prg0[2038],prg0[2036],prg0[2034],prg0[2032],
                prg0[2031],prg0[2029],prg0[2027],prg0[2025],prg0[2023],prg0[2021],prg0[2019],prg0[2017],
                prg0[2030],prg0[2028],prg0[2026],prg0[2024],prg0[2022],prg0[2020],prg0[2018],prg0[2016],
                prg0[2015],prg0[2013],prg0[2011],prg0[2009],prg0[2007],prg0[2005],prg0[2003],prg0[2001],
                prg0[2014],prg0[2012],prg0[2010],prg0[2008],prg0[2006],prg0[2004],prg0[2002],prg0[2000],
                prg0[1999],prg0[1997],prg0[1995],prg0[1993],prg0[1991],prg0[1989],prg0[1987],prg0[1985],
                prg0[1998],prg0[1996],prg0[1994],prg0[1992],prg0[1990],prg0[1988],prg0[1986],prg0[1984],
                prg0[1983],prg0[1981],prg0[1979],prg0[1977],prg0[1975],prg0[1973],prg0[1971],prg0[1969],
                prg0[1982],prg0[1980],prg0[1978],prg0[1976],prg0[1974],prg0[1972],prg0[1970],prg0[1968],
                prg0[1967],prg0[1965],prg0[1963],prg0[1961],prg0[1959],prg0[1957],prg0[1955],prg0[1953],
                prg0[1966],prg0[1964],prg0[1962],prg0[1960],prg0[1958],prg0[1956],prg0[1954],prg0[1952],
                prg0[1951],prg0[1949],prg0[1947],prg0[1945],prg0[1943],prg0[1941],prg0[1939],prg0[1937],
                prg0[1950],prg0[1948],prg0[1946],prg0[1944],prg0[1942],prg0[1940],prg0[1938],prg0[1936],
                prg0[1935],prg0[1933],prg0[1931],prg0[1929],prg0[1927],prg0[1925],prg0[1923],prg0[1921],
                prg0[1934],prg0[1932],prg0[1930],prg0[1928],prg0[1926],prg0[1924],prg0[1922],prg0[1920],
                prg0[1919],prg0[1917],prg0[1915],prg0[1913],prg0[1911],prg0[1909],prg0[1907],prg0[1905],
                prg0[1918],prg0[1916],prg0[1914],prg0[1912],prg0[1910],prg0[1908],prg0[1906],prg0[1904],
                prg0[1903],prg0[1901],prg0[1899],prg0[1897],prg0[1895],prg0[1893],prg0[1891],prg0[1889],
                prg0[1902],prg0[1900],prg0[1898],prg0[1896],prg0[1894],prg0[1892],prg0[1890],prg0[1888],
                prg0[1887],prg0[1885],prg0[1883],prg0[1881],prg0[1879],prg0[1877],prg0[1875],prg0[1873],
                prg0[1886],prg0[1884],prg0[1882],prg0[1880],prg0[1878],prg0[1876],prg0[1874],prg0[1872],
                prg0[1871],prg0[1869],prg0[1867],prg0[1865],prg0[1863],prg0[1861],prg0[1859],prg0[1857],
                prg0[1870],prg0[1868],prg0[1866],prg0[1864],prg0[1862],prg0[1860],prg0[1858],prg0[1856],
                prg0[1855],prg0[1853],prg0[1851],prg0[1849],prg0[1847],prg0[1845],prg0[1843],prg0[1841],
                prg0[1854],prg0[1852],prg0[1850],prg0[1848],prg0[1846],prg0[1844],prg0[1842],prg0[1840],
                prg0[1839],prg0[1837],prg0[1835],prg0[1833],prg0[1831],prg0[1829],prg0[1827],prg0[1825],
                prg0[1838],prg0[1836],prg0[1834],prg0[1832],prg0[1830],prg0[1828],prg0[1826],prg0[1824],
                prg0[1823],prg0[1821],prg0[1819],prg0[1817],prg0[1815],prg0[1813],prg0[1811],prg0[1809],
                prg0[1822],prg0[1820],prg0[1818],prg0[1816],prg0[1814],prg0[1812],prg0[1810],prg0[1808],
                prg0[1807],prg0[1805],prg0[1803],prg0[1801],prg0[1799],prg0[1797],prg0[1795],prg0[1793],
                prg0[1806],prg0[1804],prg0[1802],prg0[1800],prg0[1798],prg0[1796],prg0[1794],prg0[1792]}),
       .INIT_6({prg0[1791],prg0[1789],prg0[1787],prg0[1785],prg0[1783],prg0[1781],prg0[1779],prg0[1777],
                prg0[1790],prg0[1788],prg0[1786],prg0[1784],prg0[1782],prg0[1780],prg0[1778],prg0[1776],
                prg0[1775],prg0[1773],prg0[1771],prg0[1769],prg0[1767],prg0[1765],prg0[1763],prg0[1761],
                prg0[1774],prg0[1772],prg0[1770],prg0[1768],prg0[1766],prg0[1764],prg0[1762],prg0[1760],
                prg0[1759],prg0[1757],prg0[1755],prg0[1753],prg0[1751],prg0[1749],prg0[1747],prg0[1745],
                prg0[1758],prg0[1756],prg0[1754],prg0[1752],prg0[1750],prg0[1748],prg0[1746],prg0[1744],
                prg0[1743],prg0[1741],prg0[1739],prg0[1737],prg0[1735],prg0[1733],prg0[1731],prg0[1729],
                prg0[1742],prg0[1740],prg0[1738],prg0[1736],prg0[1734],prg0[1732],prg0[1730],prg0[1728],
                prg0[1727],prg0[1725],prg0[1723],prg0[1721],prg0[1719],prg0[1717],prg0[1715],prg0[1713],
                prg0[1726],prg0[1724],prg0[1722],prg0[1720],prg0[1718],prg0[1716],prg0[1714],prg0[1712],
                prg0[1711],prg0[1709],prg0[1707],prg0[1705],prg0[1703],prg0[1701],prg0[1699],prg0[1697],
                prg0[1710],prg0[1708],prg0[1706],prg0[1704],prg0[1702],prg0[1700],prg0[1698],prg0[1696],
                prg0[1695],prg0[1693],prg0[1691],prg0[1689],prg0[1687],prg0[1685],prg0[1683],prg0[1681],
                prg0[1694],prg0[1692],prg0[1690],prg0[1688],prg0[1686],prg0[1684],prg0[1682],prg0[1680],
                prg0[1679],prg0[1677],prg0[1675],prg0[1673],prg0[1671],prg0[1669],prg0[1667],prg0[1665],
                prg0[1678],prg0[1676],prg0[1674],prg0[1672],prg0[1670],prg0[1668],prg0[1666],prg0[1664],
                prg0[1663],prg0[1661],prg0[1659],prg0[1657],prg0[1655],prg0[1653],prg0[1651],prg0[1649],
                prg0[1662],prg0[1660],prg0[1658],prg0[1656],prg0[1654],prg0[1652],prg0[1650],prg0[1648],
                prg0[1647],prg0[1645],prg0[1643],prg0[1641],prg0[1639],prg0[1637],prg0[1635],prg0[1633],
                prg0[1646],prg0[1644],prg0[1642],prg0[1640],prg0[1638],prg0[1636],prg0[1634],prg0[1632],
                prg0[1631],prg0[1629],prg0[1627],prg0[1625],prg0[1623],prg0[1621],prg0[1619],prg0[1617],
                prg0[1630],prg0[1628],prg0[1626],prg0[1624],prg0[1622],prg0[1620],prg0[1618],prg0[1616],
                prg0[1615],prg0[1613],prg0[1611],prg0[1609],prg0[1607],prg0[1605],prg0[1603],prg0[1601],
                prg0[1614],prg0[1612],prg0[1610],prg0[1608],prg0[1606],prg0[1604],prg0[1602],prg0[1600],
                prg0[1599],prg0[1597],prg0[1595],prg0[1593],prg0[1591],prg0[1589],prg0[1587],prg0[1585],
                prg0[1598],prg0[1596],prg0[1594],prg0[1592],prg0[1590],prg0[1588],prg0[1586],prg0[1584],
                prg0[1583],prg0[1581],prg0[1579],prg0[1577],prg0[1575],prg0[1573],prg0[1571],prg0[1569],
                prg0[1582],prg0[1580],prg0[1578],prg0[1576],prg0[1574],prg0[1572],prg0[1570],prg0[1568],
                prg0[1567],prg0[1565],prg0[1563],prg0[1561],prg0[1559],prg0[1557],prg0[1555],prg0[1553],
                prg0[1566],prg0[1564],prg0[1562],prg0[1560],prg0[1558],prg0[1556],prg0[1554],prg0[1552],
                prg0[1551],prg0[1549],prg0[1547],prg0[1545],prg0[1543],prg0[1541],prg0[1539],prg0[1537],
                prg0[1550],prg0[1548],prg0[1546],prg0[1544],prg0[1542],prg0[1540],prg0[1538],prg0[1536]}),
       .INIT_5({prg0[1535],prg0[1533],prg0[1531],prg0[1529],prg0[1527],prg0[1525],prg0[1523],prg0[1521],
                prg0[1534],prg0[1532],prg0[1530],prg0[1528],prg0[1526],prg0[1524],prg0[1522],prg0[1520],
                prg0[1519],prg0[1517],prg0[1515],prg0[1513],prg0[1511],prg0[1509],prg0[1507],prg0[1505],
                prg0[1518],prg0[1516],prg0[1514],prg0[1512],prg0[1510],prg0[1508],prg0[1506],prg0[1504],
                prg0[1503],prg0[1501],prg0[1499],prg0[1497],prg0[1495],prg0[1493],prg0[1491],prg0[1489],
                prg0[1502],prg0[1500],prg0[1498],prg0[1496],prg0[1494],prg0[1492],prg0[1490],prg0[1488],
                prg0[1487],prg0[1485],prg0[1483],prg0[1481],prg0[1479],prg0[1477],prg0[1475],prg0[1473],
                prg0[1486],prg0[1484],prg0[1482],prg0[1480],prg0[1478],prg0[1476],prg0[1474],prg0[1472],
                prg0[1471],prg0[1469],prg0[1467],prg0[1465],prg0[1463],prg0[1461],prg0[1459],prg0[1457],
                prg0[1470],prg0[1468],prg0[1466],prg0[1464],prg0[1462],prg0[1460],prg0[1458],prg0[1456],
                prg0[1455],prg0[1453],prg0[1451],prg0[1449],prg0[1447],prg0[1445],prg0[1443],prg0[1441],
                prg0[1454],prg0[1452],prg0[1450],prg0[1448],prg0[1446],prg0[1444],prg0[1442],prg0[1440],
                prg0[1439],prg0[1437],prg0[1435],prg0[1433],prg0[1431],prg0[1429],prg0[1427],prg0[1425],
                prg0[1438],prg0[1436],prg0[1434],prg0[1432],prg0[1430],prg0[1428],prg0[1426],prg0[1424],
                prg0[1423],prg0[1421],prg0[1419],prg0[1417],prg0[1415],prg0[1413],prg0[1411],prg0[1409],
                prg0[1422],prg0[1420],prg0[1418],prg0[1416],prg0[1414],prg0[1412],prg0[1410],prg0[1408],
                prg0[1407],prg0[1405],prg0[1403],prg0[1401],prg0[1399],prg0[1397],prg0[1395],prg0[1393],
                prg0[1406],prg0[1404],prg0[1402],prg0[1400],prg0[1398],prg0[1396],prg0[1394],prg0[1392],
                prg0[1391],prg0[1389],prg0[1387],prg0[1385],prg0[1383],prg0[1381],prg0[1379],prg0[1377],
                prg0[1390],prg0[1388],prg0[1386],prg0[1384],prg0[1382],prg0[1380],prg0[1378],prg0[1376],
                prg0[1375],prg0[1373],prg0[1371],prg0[1369],prg0[1367],prg0[1365],prg0[1363],prg0[1361],
                prg0[1374],prg0[1372],prg0[1370],prg0[1368],prg0[1366],prg0[1364],prg0[1362],prg0[1360],
                prg0[1359],prg0[1357],prg0[1355],prg0[1353],prg0[1351],prg0[1349],prg0[1347],prg0[1345],
                prg0[1358],prg0[1356],prg0[1354],prg0[1352],prg0[1350],prg0[1348],prg0[1346],prg0[1344],
                prg0[1343],prg0[1341],prg0[1339],prg0[1337],prg0[1335],prg0[1333],prg0[1331],prg0[1329],
                prg0[1342],prg0[1340],prg0[1338],prg0[1336],prg0[1334],prg0[1332],prg0[1330],prg0[1328],
                prg0[1327],prg0[1325],prg0[1323],prg0[1321],prg0[1319],prg0[1317],prg0[1315],prg0[1313],
                prg0[1326],prg0[1324],prg0[1322],prg0[1320],prg0[1318],prg0[1316],prg0[1314],prg0[1312],
                prg0[1311],prg0[1309],prg0[1307],prg0[1305],prg0[1303],prg0[1301],prg0[1299],prg0[1297],
                prg0[1310],prg0[1308],prg0[1306],prg0[1304],prg0[1302],prg0[1300],prg0[1298],prg0[1296],
                prg0[1295],prg0[1293],prg0[1291],prg0[1289],prg0[1287],prg0[1285],prg0[1283],prg0[1281],
                prg0[1294],prg0[1292],prg0[1290],prg0[1288],prg0[1286],prg0[1284],prg0[1282],prg0[1280]}),
       .INIT_4({prg0[1279],prg0[1277],prg0[1275],prg0[1273],prg0[1271],prg0[1269],prg0[1267],prg0[1265],
                prg0[1278],prg0[1276],prg0[1274],prg0[1272],prg0[1270],prg0[1268],prg0[1266],prg0[1264],
                prg0[1263],prg0[1261],prg0[1259],prg0[1257],prg0[1255],prg0[1253],prg0[1251],prg0[1249],
                prg0[1262],prg0[1260],prg0[1258],prg0[1256],prg0[1254],prg0[1252],prg0[1250],prg0[1248],
                prg0[1247],prg0[1245],prg0[1243],prg0[1241],prg0[1239],prg0[1237],prg0[1235],prg0[1233],
                prg0[1246],prg0[1244],prg0[1242],prg0[1240],prg0[1238],prg0[1236],prg0[1234],prg0[1232],
                prg0[1231],prg0[1229],prg0[1227],prg0[1225],prg0[1223],prg0[1221],prg0[1219],prg0[1217],
                prg0[1230],prg0[1228],prg0[1226],prg0[1224],prg0[1222],prg0[1220],prg0[1218],prg0[1216],
                prg0[1215],prg0[1213],prg0[1211],prg0[1209],prg0[1207],prg0[1205],prg0[1203],prg0[1201],
                prg0[1214],prg0[1212],prg0[1210],prg0[1208],prg0[1206],prg0[1204],prg0[1202],prg0[1200],
                prg0[1199],prg0[1197],prg0[1195],prg0[1193],prg0[1191],prg0[1189],prg0[1187],prg0[1185],
                prg0[1198],prg0[1196],prg0[1194],prg0[1192],prg0[1190],prg0[1188],prg0[1186],prg0[1184],
                prg0[1183],prg0[1181],prg0[1179],prg0[1177],prg0[1175],prg0[1173],prg0[1171],prg0[1169],
                prg0[1182],prg0[1180],prg0[1178],prg0[1176],prg0[1174],prg0[1172],prg0[1170],prg0[1168],
                prg0[1167],prg0[1165],prg0[1163],prg0[1161],prg0[1159],prg0[1157],prg0[1155],prg0[1153],
                prg0[1166],prg0[1164],prg0[1162],prg0[1160],prg0[1158],prg0[1156],prg0[1154],prg0[1152],
                prg0[1151],prg0[1149],prg0[1147],prg0[1145],prg0[1143],prg0[1141],prg0[1139],prg0[1137],
                prg0[1150],prg0[1148],prg0[1146],prg0[1144],prg0[1142],prg0[1140],prg0[1138],prg0[1136],
                prg0[1135],prg0[1133],prg0[1131],prg0[1129],prg0[1127],prg0[1125],prg0[1123],prg0[1121],
                prg0[1134],prg0[1132],prg0[1130],prg0[1128],prg0[1126],prg0[1124],prg0[1122],prg0[1120],
                prg0[1119],prg0[1117],prg0[1115],prg0[1113],prg0[1111],prg0[1109],prg0[1107],prg0[1105],
                prg0[1118],prg0[1116],prg0[1114],prg0[1112],prg0[1110],prg0[1108],prg0[1106],prg0[1104],
                prg0[1103],prg0[1101],prg0[1099],prg0[1097],prg0[1095],prg0[1093],prg0[1091],prg0[1089],
                prg0[1102],prg0[1100],prg0[1098],prg0[1096],prg0[1094],prg0[1092],prg0[1090],prg0[1088],
                prg0[1087],prg0[1085],prg0[1083],prg0[1081],prg0[1079],prg0[1077],prg0[1075],prg0[1073],
                prg0[1086],prg0[1084],prg0[1082],prg0[1080],prg0[1078],prg0[1076],prg0[1074],prg0[1072],
                prg0[1071],prg0[1069],prg0[1067],prg0[1065],prg0[1063],prg0[1061],prg0[1059],prg0[1057],
                prg0[1070],prg0[1068],prg0[1066],prg0[1064],prg0[1062],prg0[1060],prg0[1058],prg0[1056],
                prg0[1055],prg0[1053],prg0[1051],prg0[1049],prg0[1047],prg0[1045],prg0[1043],prg0[1041],
                prg0[1054],prg0[1052],prg0[1050],prg0[1048],prg0[1046],prg0[1044],prg0[1042],prg0[1040],
                prg0[1039],prg0[1037],prg0[1035],prg0[1033],prg0[1031],prg0[1029],prg0[1027],prg0[1025],
                prg0[1038],prg0[1036],prg0[1034],prg0[1032],prg0[1030],prg0[1028],prg0[1026],prg0[1024]}),
       .INIT_3({prg0[1023],prg0[1021],prg0[1019],prg0[1017],prg0[1015],prg0[1013],prg0[1011],prg0[1009],
                prg0[1022],prg0[1020],prg0[1018],prg0[1016],prg0[1014],prg0[1012],prg0[1010],prg0[1008],
                prg0[1007],prg0[1005],prg0[1003],prg0[1001],prg0[ 999],prg0[ 997],prg0[ 995],prg0[ 993],
                prg0[1006],prg0[1004],prg0[1002],prg0[1000],prg0[ 998],prg0[ 996],prg0[ 994],prg0[ 992],
                prg0[ 991],prg0[ 989],prg0[ 987],prg0[ 985],prg0[ 983],prg0[ 981],prg0[ 979],prg0[ 977],
                prg0[ 990],prg0[ 988],prg0[ 986],prg0[ 984],prg0[ 982],prg0[ 980],prg0[ 978],prg0[ 976],
                prg0[ 975],prg0[ 973],prg0[ 971],prg0[ 969],prg0[ 967],prg0[ 965],prg0[ 963],prg0[ 961],
                prg0[ 974],prg0[ 972],prg0[ 970],prg0[ 968],prg0[ 966],prg0[ 964],prg0[ 962],prg0[ 960],
                prg0[ 959],prg0[ 957],prg0[ 955],prg0[ 953],prg0[ 951],prg0[ 949],prg0[ 947],prg0[ 945],
                prg0[ 958],prg0[ 956],prg0[ 954],prg0[ 952],prg0[ 950],prg0[ 948],prg0[ 946],prg0[ 944],
                prg0[ 943],prg0[ 941],prg0[ 939],prg0[ 937],prg0[ 935],prg0[ 933],prg0[ 931],prg0[ 929],
                prg0[ 942],prg0[ 940],prg0[ 938],prg0[ 936],prg0[ 934],prg0[ 932],prg0[ 930],prg0[ 928],
                prg0[ 927],prg0[ 925],prg0[ 923],prg0[ 921],prg0[ 919],prg0[ 917],prg0[ 915],prg0[ 913],
                prg0[ 926],prg0[ 924],prg0[ 922],prg0[ 920],prg0[ 918],prg0[ 916],prg0[ 914],prg0[ 912],
                prg0[ 911],prg0[ 909],prg0[ 907],prg0[ 905],prg0[ 903],prg0[ 901],prg0[ 899],prg0[ 897],
                prg0[ 910],prg0[ 908],prg0[ 906],prg0[ 904],prg0[ 902],prg0[ 900],prg0[ 898],prg0[ 896],
                prg0[ 895],prg0[ 893],prg0[ 891],prg0[ 889],prg0[ 887],prg0[ 885],prg0[ 883],prg0[ 881],
                prg0[ 894],prg0[ 892],prg0[ 890],prg0[ 888],prg0[ 886],prg0[ 884],prg0[ 882],prg0[ 880],
                prg0[ 879],prg0[ 877],prg0[ 875],prg0[ 873],prg0[ 871],prg0[ 869],prg0[ 867],prg0[ 865],
                prg0[ 878],prg0[ 876],prg0[ 874],prg0[ 872],prg0[ 870],prg0[ 868],prg0[ 866],prg0[ 864],
                prg0[ 863],prg0[ 861],prg0[ 859],prg0[ 857],prg0[ 855],prg0[ 853],prg0[ 851],prg0[ 849],
                prg0[ 862],prg0[ 860],prg0[ 858],prg0[ 856],prg0[ 854],prg0[ 852],prg0[ 850],prg0[ 848],
                prg0[ 847],prg0[ 845],prg0[ 843],prg0[ 841],prg0[ 839],prg0[ 837],prg0[ 835],prg0[ 833],
                prg0[ 846],prg0[ 844],prg0[ 842],prg0[ 840],prg0[ 838],prg0[ 836],prg0[ 834],prg0[ 832],
                prg0[ 831],prg0[ 829],prg0[ 827],prg0[ 825],prg0[ 823],prg0[ 821],prg0[ 819],prg0[ 817],
                prg0[ 830],prg0[ 828],prg0[ 826],prg0[ 824],prg0[ 822],prg0[ 820],prg0[ 818],prg0[ 816],
                prg0[ 815],prg0[ 813],prg0[ 811],prg0[ 809],prg0[ 807],prg0[ 805],prg0[ 803],prg0[ 801],
                prg0[ 814],prg0[ 812],prg0[ 810],prg0[ 808],prg0[ 806],prg0[ 804],prg0[ 802],prg0[ 800],
                prg0[ 799],prg0[ 797],prg0[ 795],prg0[ 793],prg0[ 791],prg0[ 789],prg0[ 787],prg0[ 785],
                prg0[ 798],prg0[ 796],prg0[ 794],prg0[ 792],prg0[ 790],prg0[ 788],prg0[ 786],prg0[ 784],
                prg0[ 783],prg0[ 781],prg0[ 779],prg0[ 777],prg0[ 775],prg0[ 773],prg0[ 771],prg0[ 769],
                prg0[ 782],prg0[ 780],prg0[ 778],prg0[ 776],prg0[ 774],prg0[ 772],prg0[ 770],prg0[ 768]}),
       .INIT_2({prg0[ 767],prg0[ 765],prg0[ 763],prg0[ 761],prg0[ 759],prg0[ 757],prg0[ 755],prg0[ 753],
                prg0[ 766],prg0[ 764],prg0[ 762],prg0[ 760],prg0[ 758],prg0[ 756],prg0[ 754],prg0[ 752],
                prg0[ 751],prg0[ 749],prg0[ 747],prg0[ 745],prg0[ 743],prg0[ 741],prg0[ 739],prg0[ 737],
                prg0[ 750],prg0[ 748],prg0[ 746],prg0[ 744],prg0[ 742],prg0[ 740],prg0[ 738],prg0[ 736],
                prg0[ 735],prg0[ 733],prg0[ 731],prg0[ 729],prg0[ 727],prg0[ 725],prg0[ 723],prg0[ 721],
                prg0[ 734],prg0[ 732],prg0[ 730],prg0[ 728],prg0[ 726],prg0[ 724],prg0[ 722],prg0[ 720],
                prg0[ 719],prg0[ 717],prg0[ 715],prg0[ 713],prg0[ 711],prg0[ 709],prg0[ 707],prg0[ 705],
                prg0[ 718],prg0[ 716],prg0[ 714],prg0[ 712],prg0[ 710],prg0[ 708],prg0[ 706],prg0[ 704],
                prg0[ 703],prg0[ 701],prg0[ 699],prg0[ 697],prg0[ 695],prg0[ 693],prg0[ 691],prg0[ 689],
                prg0[ 702],prg0[ 700],prg0[ 698],prg0[ 696],prg0[ 694],prg0[ 692],prg0[ 690],prg0[ 688],
                prg0[ 687],prg0[ 685],prg0[ 683],prg0[ 681],prg0[ 679],prg0[ 677],prg0[ 675],prg0[ 673],
                prg0[ 686],prg0[ 684],prg0[ 682],prg0[ 680],prg0[ 678],prg0[ 676],prg0[ 674],prg0[ 672],
                prg0[ 671],prg0[ 669],prg0[ 667],prg0[ 665],prg0[ 663],prg0[ 661],prg0[ 659],prg0[ 657],
                prg0[ 670],prg0[ 668],prg0[ 666],prg0[ 664],prg0[ 662],prg0[ 660],prg0[ 658],prg0[ 656],
                prg0[ 655],prg0[ 653],prg0[ 651],prg0[ 649],prg0[ 647],prg0[ 645],prg0[ 643],prg0[ 641],
                prg0[ 654],prg0[ 652],prg0[ 650],prg0[ 648],prg0[ 646],prg0[ 644],prg0[ 642],prg0[ 640],
                prg0[ 639],prg0[ 637],prg0[ 635],prg0[ 633],prg0[ 631],prg0[ 629],prg0[ 627],prg0[ 625],
                prg0[ 638],prg0[ 636],prg0[ 634],prg0[ 632],prg0[ 630],prg0[ 628],prg0[ 626],prg0[ 624],
                prg0[ 623],prg0[ 621],prg0[ 619],prg0[ 617],prg0[ 615],prg0[ 613],prg0[ 611],prg0[ 609],
                prg0[ 622],prg0[ 620],prg0[ 618],prg0[ 616],prg0[ 614],prg0[ 612],prg0[ 610],prg0[ 608],
                prg0[ 607],prg0[ 605],prg0[ 603],prg0[ 601],prg0[ 599],prg0[ 597],prg0[ 595],prg0[ 593],
                prg0[ 606],prg0[ 604],prg0[ 602],prg0[ 600],prg0[ 598],prg0[ 596],prg0[ 594],prg0[ 592],
                prg0[ 591],prg0[ 589],prg0[ 587],prg0[ 585],prg0[ 583],prg0[ 581],prg0[ 579],prg0[ 577],
                prg0[ 590],prg0[ 588],prg0[ 586],prg0[ 584],prg0[ 582],prg0[ 580],prg0[ 578],prg0[ 576],
                prg0[ 575],prg0[ 573],prg0[ 571],prg0[ 569],prg0[ 567],prg0[ 565],prg0[ 563],prg0[ 561],
                prg0[ 574],prg0[ 572],prg0[ 570],prg0[ 568],prg0[ 566],prg0[ 564],prg0[ 562],prg0[ 560],
                prg0[ 559],prg0[ 557],prg0[ 555],prg0[ 553],prg0[ 551],prg0[ 549],prg0[ 547],prg0[ 545],
                prg0[ 558],prg0[ 556],prg0[ 554],prg0[ 552],prg0[ 550],prg0[ 548],prg0[ 546],prg0[ 544],
                prg0[ 543],prg0[ 541],prg0[ 539],prg0[ 537],prg0[ 535],prg0[ 533],prg0[ 531],prg0[ 529],
                prg0[ 542],prg0[ 540],prg0[ 538],prg0[ 536],prg0[ 534],prg0[ 532],prg0[ 530],prg0[ 528],
                prg0[ 527],prg0[ 525],prg0[ 523],prg0[ 521],prg0[ 519],prg0[ 517],prg0[ 515],prg0[ 513],
                prg0[ 526],prg0[ 524],prg0[ 522],prg0[ 520],prg0[ 518],prg0[ 516],prg0[ 514],prg0[ 512]}),
       .INIT_1({prg0[ 511],prg0[ 509],prg0[ 507],prg0[ 505],prg0[ 503],prg0[ 501],prg0[ 499],prg0[ 497],
                prg0[ 510],prg0[ 508],prg0[ 506],prg0[ 504],prg0[ 502],prg0[ 500],prg0[ 498],prg0[ 496],
                prg0[ 495],prg0[ 493],prg0[ 491],prg0[ 489],prg0[ 487],prg0[ 485],prg0[ 483],prg0[ 481],
                prg0[ 494],prg0[ 492],prg0[ 490],prg0[ 488],prg0[ 486],prg0[ 484],prg0[ 482],prg0[ 480],
                prg0[ 479],prg0[ 477],prg0[ 475],prg0[ 473],prg0[ 471],prg0[ 469],prg0[ 467],prg0[ 465],
                prg0[ 478],prg0[ 476],prg0[ 474],prg0[ 472],prg0[ 470],prg0[ 468],prg0[ 466],prg0[ 464],
                prg0[ 463],prg0[ 461],prg0[ 459],prg0[ 457],prg0[ 455],prg0[ 453],prg0[ 451],prg0[ 449],
                prg0[ 462],prg0[ 460],prg0[ 458],prg0[ 456],prg0[ 454],prg0[ 452],prg0[ 450],prg0[ 448],
                prg0[ 447],prg0[ 445],prg0[ 443],prg0[ 441],prg0[ 439],prg0[ 437],prg0[ 435],prg0[ 433],
                prg0[ 446],prg0[ 444],prg0[ 442],prg0[ 440],prg0[ 438],prg0[ 436],prg0[ 434],prg0[ 432],
                prg0[ 431],prg0[ 429],prg0[ 427],prg0[ 425],prg0[ 423],prg0[ 421],prg0[ 419],prg0[ 417],
                prg0[ 430],prg0[ 428],prg0[ 426],prg0[ 424],prg0[ 422],prg0[ 420],prg0[ 418],prg0[ 416],
                prg0[ 415],prg0[ 413],prg0[ 411],prg0[ 409],prg0[ 407],prg0[ 405],prg0[ 403],prg0[ 401],
                prg0[ 414],prg0[ 412],prg0[ 410],prg0[ 408],prg0[ 406],prg0[ 404],prg0[ 402],prg0[ 400],
                prg0[ 399],prg0[ 397],prg0[ 395],prg0[ 393],prg0[ 391],prg0[ 389],prg0[ 387],prg0[ 385],
                prg0[ 398],prg0[ 396],prg0[ 394],prg0[ 392],prg0[ 390],prg0[ 388],prg0[ 386],prg0[ 384],
                prg0[ 383],prg0[ 381],prg0[ 379],prg0[ 377],prg0[ 375],prg0[ 373],prg0[ 371],prg0[ 369],
                prg0[ 382],prg0[ 380],prg0[ 378],prg0[ 376],prg0[ 374],prg0[ 372],prg0[ 370],prg0[ 368],
                prg0[ 367],prg0[ 365],prg0[ 363],prg0[ 361],prg0[ 359],prg0[ 357],prg0[ 355],prg0[ 353],
                prg0[ 366],prg0[ 364],prg0[ 362],prg0[ 360],prg0[ 358],prg0[ 356],prg0[ 354],prg0[ 352],
                prg0[ 351],prg0[ 349],prg0[ 347],prg0[ 345],prg0[ 343],prg0[ 341],prg0[ 339],prg0[ 337],
                prg0[ 350],prg0[ 348],prg0[ 346],prg0[ 344],prg0[ 342],prg0[ 340],prg0[ 338],prg0[ 336],
                prg0[ 335],prg0[ 333],prg0[ 331],prg0[ 329],prg0[ 327],prg0[ 325],prg0[ 323],prg0[ 321],
                prg0[ 334],prg0[ 332],prg0[ 330],prg0[ 328],prg0[ 326],prg0[ 324],prg0[ 322],prg0[ 320],
                prg0[ 319],prg0[ 317],prg0[ 315],prg0[ 313],prg0[ 311],prg0[ 309],prg0[ 307],prg0[ 305],
                prg0[ 318],prg0[ 316],prg0[ 314],prg0[ 312],prg0[ 310],prg0[ 308],prg0[ 306],prg0[ 304],
                prg0[ 303],prg0[ 301],prg0[ 299],prg0[ 297],prg0[ 295],prg0[ 293],prg0[ 291],prg0[ 289],
                prg0[ 302],prg0[ 300],prg0[ 298],prg0[ 296],prg0[ 294],prg0[ 292],prg0[ 290],prg0[ 288],
                prg0[ 287],prg0[ 285],prg0[ 283],prg0[ 281],prg0[ 279],prg0[ 277],prg0[ 275],prg0[ 273],
                prg0[ 286],prg0[ 284],prg0[ 282],prg0[ 280],prg0[ 278],prg0[ 276],prg0[ 274],prg0[ 272],
                prg0[ 271],prg0[ 269],prg0[ 267],prg0[ 265],prg0[ 263],prg0[ 261],prg0[ 259],prg0[ 257],
                prg0[ 270],prg0[ 268],prg0[ 266],prg0[ 264],prg0[ 262],prg0[ 260],prg0[ 258],prg0[ 256]}),
       .INIT_0({prg0[ 255],prg0[ 253],prg0[ 251],prg0[ 249],prg0[ 247],prg0[ 245],prg0[ 243],prg0[ 241],
                prg0[ 254],prg0[ 252],prg0[ 250],prg0[ 248],prg0[ 246],prg0[ 244],prg0[ 242],prg0[ 240],
                prg0[ 239],prg0[ 237],prg0[ 235],prg0[ 233],prg0[ 231],prg0[ 229],prg0[ 227],prg0[ 225],
                prg0[ 238],prg0[ 236],prg0[ 234],prg0[ 232],prg0[ 230],prg0[ 228],prg0[ 226],prg0[ 224],
                prg0[ 223],prg0[ 221],prg0[ 219],prg0[ 217],prg0[ 215],prg0[ 213],prg0[ 211],prg0[ 209],
                prg0[ 222],prg0[ 220],prg0[ 218],prg0[ 216],prg0[ 214],prg0[ 212],prg0[ 210],prg0[ 208],
                prg0[ 207],prg0[ 205],prg0[ 203],prg0[ 201],prg0[ 199],prg0[ 197],prg0[ 195],prg0[ 193],
                prg0[ 206],prg0[ 204],prg0[ 202],prg0[ 200],prg0[ 198],prg0[ 196],prg0[ 194],prg0[ 192],
                prg0[ 191],prg0[ 189],prg0[ 187],prg0[ 185],prg0[ 183],prg0[ 181],prg0[ 179],prg0[ 177],
                prg0[ 190],prg0[ 188],prg0[ 186],prg0[ 184],prg0[ 182],prg0[ 180],prg0[ 178],prg0[ 176],
                prg0[ 175],prg0[ 173],prg0[ 171],prg0[ 169],prg0[ 167],prg0[ 165],prg0[ 163],prg0[ 161],
                prg0[ 174],prg0[ 172],prg0[ 170],prg0[ 168],prg0[ 166],prg0[ 164],prg0[ 162],prg0[ 160],
                prg0[ 159],prg0[ 157],prg0[ 155],prg0[ 153],prg0[ 151],prg0[ 149],prg0[ 147],prg0[ 145],
                prg0[ 158],prg0[ 156],prg0[ 154],prg0[ 152],prg0[ 150],prg0[ 148],prg0[ 146],prg0[ 144],
                prg0[ 143],prg0[ 141],prg0[ 139],prg0[ 137],prg0[ 135],prg0[ 133],prg0[ 131],prg0[ 129],
                prg0[ 142],prg0[ 140],prg0[ 138],prg0[ 136],prg0[ 134],prg0[ 132],prg0[ 130],prg0[ 128],
                prg0[ 127],prg0[ 125],prg0[ 123],prg0[ 121],prg0[ 119],prg0[ 117],prg0[ 115],prg0[ 113],
                prg0[ 126],prg0[ 124],prg0[ 122],prg0[ 120],prg0[ 118],prg0[ 116],prg0[ 114],prg0[ 112],
                prg0[ 111],prg0[ 109],prg0[ 107],prg0[ 105],prg0[ 103],prg0[ 101],prg0[  99],prg0[  97],
                prg0[ 110],prg0[ 108],prg0[ 106],prg0[ 104],prg0[ 102],prg0[ 100],prg0[  98],prg0[  96],
                prg0[  95],prg0[  93],prg0[  91],prg0[  89],prg0[  87],prg0[  85],prg0[  83],prg0[  81],
                prg0[  94],prg0[  92],prg0[  90],prg0[  88],prg0[  86],prg0[  84],prg0[  82],prg0[  80],
                prg0[  79],prg0[  77],prg0[  75],prg0[  73],prg0[  71],prg0[  69],prg0[  67],prg0[  65],
                prg0[  78],prg0[  76],prg0[  74],prg0[  72],prg0[  70],prg0[  68],prg0[  66],prg0[  64],
                prg0[  63],prg0[  61],prg0[  59],prg0[  57],prg0[  55],prg0[  53],prg0[  51],prg0[  49],
                prg0[  62],prg0[  60],prg0[  58],prg0[  56],prg0[  54],prg0[  52],prg0[  50],prg0[  48],
                prg0[  47],prg0[  45],prg0[  43],prg0[  41],prg0[  39],prg0[  37],prg0[  35],prg0[  33],
                prg0[  46],prg0[  44],prg0[  42],prg0[  40],prg0[  38],prg0[  36],prg0[  34],prg0[  32],
                prg0[  31],prg0[  29],prg0[  27],prg0[  25],prg0[  23],prg0[  21],prg0[  19],prg0[  17],
                prg0[  30],prg0[  28],prg0[  26],prg0[  24],prg0[  22],prg0[  20],prg0[  18],prg0[  16],
                prg0[  15],prg0[  13],prg0[  11],prg0[   9],prg0[   7],prg0[   5],prg0[   3],prg0[   1],
                prg0[  14],prg0[  12],prg0[  10],prg0[   8],prg0[   6],prg0[   4],prg0[   2],prg0[   0]}),
       .READ_MODE(3),
       .WRITE_MODE(3))
   mem
     (// Outputs
      .RDATA  ( {dum14[13:10],
                 DAT_O[1],dum14[9:3],
                 DAT_O[0],dum14[2:0]}         ),
      // Input
      .MASK   ( 16'h0                         ),
      .WDATA  ( {4'h0,                       
                 B[1],7'h0,
                 B[0],3'b0}       ),                       
      .WADDR  ( {Wai[2:0],Wai[10:3]}          ), // Note mangling
      .RADDR  ( {Rai[2:0],Rai[10:3]}          ), // Note mangling
      .RE     ( 1'b1                          ),
      .WE     ( 1'b1                          ), 
      .WCLK   ( clk                           ),
      .RCLK   ( clk                           ),
      .RCLKE  ( 1'b1                          ),
      .WCLKE  ( we                            ) 
      /*AUTOINST*/);
   
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * We must be able to read the registers, and internal working
 * variables and magical constants. We must also be able to execute 
 * in this Blockram, this is the home of my Bootloader.
 *
 *
 *                                sa[23:20]       
 *       READ                     read Read       WRITE      sa[27:24]        
 *       ADR                      sel  Select     ADR                            
 *       9876543210               ||||                       write 
 *       ---------------------------------------+            sel    Comment
 *       __B[9:2]     Alu         1101 11 B[9:2]+----------------------------
 *       000_SRC200   rs2         1110 10 SRC2    __Q[9:2]   00xx  
 *       000_SRC100   rs1         1111 01 SRC1    00u__TRG   0100   u = 1 if TRG == 0
 *                                                           0101   free
 *                                                           011x   free
 * 80 20 0010000000   jj          0000 00         00100000   1000  
 * 84 21 0010000100   rinst       0001 00         00100001   1001   aka minstret
 * 88 22 0010001000   pc          0010 00         00100010   1010  
 * 8c 23 0010001100   ttime       0011 00         00100011   1011   aka mcycle          
 * 90 24 0010010000   rInternISR  0100 00                           
 * 94 25 0010010100   rFFFFFF7F   0101 00         x
 * 98 26 0010011000   r000000FF   0110 00         
 * 9c 27 0010011100   r0000FFFF   0111 00         
 * a0 28 0010100000   rFFFF7FFF   1000 00         
 * a4 29 0010100100   mtvec       1001 00         
 * a8 2a 0010101000   r00000000   1010 00         x
 * ac 2b 0010101100   rFFFFFFFF   1011 00         
 * b0 2c 0010110000   yy          1100            00101100   1100  
 * b4 2d 0010110100   mepc                        00101101   1101  
 * b8 2e 0010111000   mcause                      00101110   1110  
 * bc 2f 0010111100   mtval                       00101111   1111                
 * 
 * There are a few irregularities on the read address. 
 *     sa23 may be modified. This is used to either read rFFFFFFFF or tinytime 
 *     during instruction fetch. 
 *     With sa[23:20] = 1011, rFFFFFFFF is always read, sa23mod == 1.
 *     With sa[23:20] = 0011, rFFFFFFFF is read when rack == 0, then sa23mod == 1
 *                            tinytime is read when rack == 1, then sa23mod == 0
 *
 *     sa20 may be modified, with sa34 == 1, sa20 is dependent on rack
 *     This is used to select r00000000 or rFFFFFFFF in the last cycle
 *     of memory read for instructions lb, lb, lbu, and lhu, needed
 *     to get shifting correct.
 * 
 */

module m_rai
  # ( parameter HIGHLEVEL = 0, EBRADRWIDTH = 8 )
   (
    input [EBRADRWIDTH+1:0]  B, //        Read address may come directly out from ALU
    input [4:0]              SRC1, //     or from source register 1
    input [4:0]              SRC2, //     or source register 2
    input                    sa20, //     | These are the basic select signals
    input                    sa21, //     |
    input                    sa22, //     |
    input                    sa23, //     |
    input                    sram_ack, // || These may modify sa20
    input                    qACK, //     ||    Qualified acknowledge, usually (ACK_I | sysregack)
    input                    sa34, //     ||
    input                    sa40,
    input                    STB_O,
    input                    sram_stb,
    output [EBRADRWIDTH-1:0] Rai,
    output                   m_rai_killwarning
    );
   /*
    sa40
    |sa34
    ||
    00                     {sa23,sa22,sa21,sa20 }  Normal select
    01 & ~anyack           {sa23,sa22,sa21,1'b0 }  Force L         1010 // | Only ever selects between
    01 & anyack            {sa23,sa22,sa21,sa20 }  Force H         1011 // | these. rHorL
    10 & ~anystrobe        {1'b0,sa22,sa21,1'b0 }  Force PC        0010 // || Only ever selects between
    10 & anystrobe         {sa23,sa22,sa21,sa20 }  Force H         1011 // || these. rHorPC
    11 & ~anystrobe        {1'b0,sa22,sa21,sa20 }  Force Ttime     0011 // | Only ever selects between
    11 & anystrobe         {sa23,sa22,sa21,sa20 }  Force H         1011 // | these. rHorTtime
                                        
                               
    */
   generate
      if ( HIGHLEVEL != 0 ) begin
         wire [11:0]               zeros = 12'h0;
         wire                      anyack;
         wire                      anystrobe;
         wire [3:0]                sel;
         reg [11:0]                extRai;

         assign anyack    = sram_ack | qACK;
         assign anystrobe = STB_O | sram_stb;
         assign sel[0]    = sa20 & ( (~sa40 & ~sa34 )             |
                                     (~sa40 &  sa34 & anyack )    |
                                     ( sa40 & ~sa34 & anystrobe ) |
                                     ( sa40 &  sa34) );
         assign sel[1]    = sa21;
         assign sel[2]    = sa22;
         assign sel[3]    = sa23 & ( ~sa40 | anystrobe );

         always @(/*AS*/B or SRC1 or SRC2 or sel or zeros)
           case ( sel )
             4'b0000 : extRai = 12'h20; // jj
             4'b0001 : extRai = 12'h21; // rinst
             4'b0010 : extRai = 12'h22; // pc
             4'b0011 : extRai = 12'h23; // ttime         
             4'b0100 : extRai = 12'h24; // rInternISR    
             4'b0101 : extRai = 12'h25; // rFFFFFF7F     
             4'b0110 : extRai = 12'h26; // r000000FF     
             4'b0111 : extRai = 12'h27; // r0000FFFF     
             4'b1000 : extRai = 12'h28; // rFFFF7FFF     
             4'b1001 : extRai = 12'h29; // mtvec         
             4'b1010 : extRai = 12'h2a; // r00000000     
             4'b1011 : extRai = 12'h2b; // rFFFFFFFF     
             4'b1100 : extRai = 12'h2c; // yy            
             4'b1101 : extRai = {zeros[11:EBRADRWIDTH],B[EBRADRWIDTH+1:2]};  // ALU
             4'b1110 : extRai = {7'b0,SRC2}; // SRC2
             4'b1111 : extRai = {7'b0,SRC1}; // SRC1                                        
            endcase

         assign Rai = extRai[EBRADRWIDTH-1:0];
         assign m_rai_killwarning = &B[1:0] & &extRai;
         
      end else begin
         wire [3:0] sel;
         assign m_rai_killwarning = &B[1:0];

         wire       ss0,ss1,b0a,b1a,b2a,b3a,b4a;
         
//         assign sel[0]    = sa20 & ( (~sa40 &  sa34 & (sram_ack | qACK)  ) |
//                                     ( sa40 & ~sa34 & (sram_stb | STB_O) ) |
//                                     (~sa40 & ~sa34 )                      |
//                                     ( sa40 &  sa34) );
         wire       sel0hack,sel0h;
         SB_LUT4 #(.LUT_INIT(16'h00e0)) L_sel0hack( .O(sel0hack), .I3(sa40), .I2(sa34), .I1(sram_ack), .I0(qACK ));
         SB_LUT4 #(.LUT_INIT(16'hfe0f)) L_sel0h(    .O(sel0h),    .I3(sa40), .I2(sa34), .I1(sram_stb), .I0(STB_O));
         SB_LUT4 #(.LUT_INIT(16'he0e0)) L_sel_0( .O(sel[0]), .I3(1'b0), .I2(sa20), .I1(sel0h), .I0(sel0hack));         
         assign sel[1] = sa21;
         assign sel[2] = sa22;
         SB_LUT4 #(.LUT_INIT(16'hfd00)) L_sel_3( .O(sel[3]), .I3(sa23),      .I2(STB_O),        .I1(sram_stb), .I0(sa40));
         
         
         SB_LUT4 #(.LUT_INIT(16'h8080)) L_ss0( .O(ss0), .I3(1'b0), .I2(sel[0]), .I1(sel[3]), .I0(sel[2]));
         SB_LUT4 #(.LUT_INIT(16'h8080)) L_ss1( .O(ss1), .I3(1'b0), .I2(sel[3]), .I1(sel[2]), .I0(sel[1]));
         
         /* ss1 -----I3--------+---------------I3----------+
          * ss0 -----I2--+----|0\                          |
          * SRC1[0] -I1-|1\   |  |-------------I2---+-----|1\
          *             |  |--|1/     B[2] --- I1 -|1\    |  |--- Rai[0]   
          * SRC2[0] -I0-|0/                        |  |---|0/
          *                         sel[0] --- I0 -|0/
          */

         SB_LUT4 #(.LUT_INIT(16'hcaf0)) L_b0a(  .O(b0a),    .I3(ss1), .I2(ss0), .I1(SRC1[0]), .I0(SRC2[0]));
         SB_LUT4 #(.LUT_INIT(16'hf0ca)) L_Rai0( .O(Rai[0]), .I3(ss1), .I2(b0a), .I1(B[2]),    .I0(sel[0]));
         
         /* ss1 -----I3--------+---------------I3----------+
          * ss0 -----I2--+----|0\                          |
          * SRC1[x] -I1-|1\   |  |-------------I2---+-----|1\
          *             |  |--|1/   B[x+2] --- I1 -|1\    |  |--- Rai[x]   x = 1,2,3
          * SRC2[x] -I0-|0/                        |  |---|0/
          *                         sel[0] --- I0 -|0/
          */

         SB_LUT4 #(.LUT_INIT(16'hcaf0)) L_b1a(  .O(b1a),    .I3(ss1), .I2(ss0), .I1(SRC1[1]), .I0(SRC2[1]));
         SB_LUT4 #(.LUT_INIT(16'hf0ca)) L_Rai1( .O(Rai[1]), .I3(ss1), .I2(b1a), .I1(B[3]),    .I0(sel[1]));
         SB_LUT4 #(.LUT_INIT(16'hcaf0)) L_b2a(  .O(b2a),    .I3(ss1), .I2(ss0), .I1(SRC1[2]), .I0(SRC2[2]));
         SB_LUT4 #(.LUT_INIT(16'hf0ca)) L_Rai2( .O(Rai[2]), .I3(ss1), .I2(b2a), .I1(B[4]),    .I0(sel[2]));
         SB_LUT4 #(.LUT_INIT(16'hcaf0)) L_b3a(  .O(b3a),    .I3(ss1), .I2(ss0), .I1(SRC1[3]), .I0(SRC2[3]));
         SB_LUT4 #(.LUT_INIT(16'hf0ca)) L_Rai3( .O(Rai[3]), .I3(ss1), .I2(b3a), .I1(B[5]),    .I0(sel[3]));

         /* ss1 -----I3--------+---------------I3----------+
          * ss0 -----I2--+----|0\                          |
          * SRC1[4] -I1-|1\   |  |-------------I2---+-----|1\
          *             |  |--|1/   B[4+2] --- I1 -|1\    |  |--- Rai[4]
          * SRC2[4] -I0-|0/                        |  |---|0/
          *                              0 --- I0 -|0/
          */
         SB_LUT4 #(.LUT_INIT(16'hcaf0)) L_b4a(  .O(b4a),    .I3(ss1), .I2(ss0), .I1(SRC1[4]), .I0(SRC2[4]));
         SB_LUT4 #(.LUT_INIT(16'hf0ca)) L_Rai4( .O(Rai[4]), .I3(ss1), .I2(b4a), .I1(B[6]),    .I0(1'b0));

         /* ss1 -----I3--------+---------------I3----------+
          * ss0 -----I2--+----|0\                          |
          *       0 -I1-|1\   |  |-------------I2---+-----|1\
          *             |  |--|1/   B[5+2] --- I1 -|1\    |  |--- Rai[5]
          *       0 -I0-|0/                        |  |---|0/
          *                              1 --- I0 -|0/
          * But this can be simplified.
          * 
          */
         SB_LUT4 #(.LUT_INIT(16'h00cf)) L_Rai5( .O(Rai[5]), .I3(ss1), .I2(ss0), .I1(B[7]), .I0(1'b0));
         /*
          * Rai[6] = ~s1 & s0 & B[8] 
          * Rai[7] = ~s1 & s0 & B[9] etc
          */
         SB_LUT4 #(.LUT_INIT(16'h0808)) L_Rai6( .O(Rai[6]), .I3(1'b0), .I2(ss1), .I1(ss0), .I0(B[8]));
         SB_LUT4 #(.LUT_INIT(16'h0808)) L_Rai7( .O(Rai[7]), .I3(1'b0), .I2(ss1), .I1(ss0), .I0(B[9]));
         if ( EBRADRWIDTH > 8 ) begin
            SB_LUT4 #(.LUT_INIT(16'h0808)) L_Rai8( .O(Rai[8]), .I3(1'b0), .I2(ss1), .I1(ss0), .I0(B[10]));
            if ( EBRADRWIDTH > 9 ) begin
               SB_LUT4 #(.LUT_INIT(16'h0808)) L_Rai9( .O(Rai[9]), .I3(1'b0), .I2(ss1), .I1(ss0), .I0(B[11]));
               if ( EBRADRWIDTH > 10 ) begin
                  SB_LUT4 #(.LUT_INIT(16'h0808)) L_Rai10( .O(Rai[10]), .I3(1'b0), .I2(ss1), .I1(ss0), .I0(B[12]));
               end
            end
         end            
      end
   endgenerate
endmodule
    
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * Lsb write adr is a mux from Q (for WAE/WAQ/WAQH/WAQB), the values
 * in TRG[4:0], and fixed addresses. 
 *
 *                             sa[23:20]       
 *    READ                     read Read       WRITE      sa[27:24]        
 *    ADR                      sel  Select     ADR                            
 *    9876543210               ||||                       write 
 *    ---------------------------------------+            sel    Comment
 *    __B[9:2]     Alu         1101 11 B[9:2]+----------------------------
 *    000_SRC200   rs2         1110 10 SRC2    __Q[9:2]   00xx  
 *    000_SRC100   rs1         1111 01 SRC1    00u__TRG   0100   u = 1 if TRG == 0
 *                                                        0101   free
 *                                                        011x   free
 * 20 0010000000   jj          0000 00         00100000   1000  
 * 21 0010000100   rinst       0001 00         00100001   1001   aka minstret
 * 22 0010001000   pc          0010 00         00100010   1010  
 * 23 0010001100   ttime       0011 00         00100011   1011   aka mcycle          
 * 24 0010010000   rInternISR  0100 00                           
 * 25 0010010100   rFFFFFF7F   0101 00         
 * 26 0010011000   r000000FF   0110 00         
 * 27 0010011100   r0000FFFF   0111 00         
 * 28 0010100000   rFFFF7FFF   1000 00         
 * 29 0010100100   mtvec       1001 00         
 * 2a 0010101000   r00000000   1010 00         
 * 2b 0010101100   rFFFFFFFF   1011 00         
 * 2c 0010110000   yy          1100            00101100   1100  
 * 2d 0010110100   mepc                        00101101   1101  
 * 2e 0010111000   mcause                      00101110   1110  
 * 2f 0010111100   mtval                       00101111   1111                
 * 
 * With EBRADRWIDTH == 8, highlevel use 12 LUTs
 * With EBRADRWIDTH == 8, lowlevel  use 10 LUTs
 */
module m_wai
  # ( parameter HIGHLEVEL = 0, EBRADRWIDTH = 8 )
   (
    input [EBRADRWIDTH+1:0]  ADR_O,
    input [4:0]              TRG,
    input                    sa24,sa25,sa26,sa27,
    output [EBRADRWIDTH-1:0] Wai,
    output                   m_wai_killwarning
    );
   
   generate
      if ( HIGHLEVEL != 0 ) begin
         /* verilator lint_off UNUSED */
         reg [11:0]  extWai;
         wire [11:0] zeros = 12'h0;
         /* verilator lint_on UNUSED */
         wire        u = TRG == 5'h0 ? 1'b1 : 1'b0;
         always @(/*AS*/ADR_O or TRG or sa24 or sa25 or sa26 or sa27
                  or u or zeros) begin
            case ({sa27,sa26,sa25,sa24})
              4'b0000 : extWai = {zeros[11:EBRADRWIDTH],ADR_O[EBRADRWIDTH+1:2]};  // 
              4'b0001 : extWai = {zeros[11:EBRADRWIDTH],ADR_O[EBRADRWIDTH+1:2]};  // 
              4'b0010 : extWai = {zeros[11:EBRADRWIDTH],ADR_O[EBRADRWIDTH+1:2]};  // 
              4'b0011 : extWai = {zeros[11:EBRADRWIDTH],ADR_O[EBRADRWIDTH+1:2]};  //          
              4'b0100 : extWai = {6'b0,u,TRG}; // 
              4'b0101 : extWai = {6'b0,u,TRG}; // 
              4'b0110 : extWai = {6'b0,u,TRG}; // 
              4'b0111 : extWai = {6'b0,u,TRG}; // 
              4'b1000 : extWai = 12'h20; // jj
              4'b1001 : extWai = 12'h21; // rinst
              4'b1010 : extWai = 12'h22; // pc
              4'b1011 : extWai = 12'h23; // ttime
              4'b1100 : extWai = 12'h2c; // yy            
              4'b1101 : extWai = 12'h2d; // mepc
              4'b1110 : extWai = 12'h2e; // mcause
              4'b1111 : extWai = 12'h2f; // mtval
            endcase
         end
         assign Wai = extWai[EBRADRWIDTH-1:0];
      end else begin
         wire preWai0,preWai1,waicy0,waicy1,waicy2,waicy3,waicy4;

         SB_LUT4 #(.LUT_INIT(16'hcaca)) L_2318(.O(preWai0),.I3(1'b0),.I2(sa27),.I1(sa24),.I0(ADR_O[2]));     
         SB_LUT4 #(.LUT_INIT(16'haae2)) L_2319(.O(Wai[0]),.I3(sa27),.I2(TRG[0]),.I1(sa26),.I0(preWai0));    SB_CARRY CY_2319(.CO(waicy0),.CI(1'b0),.I1(TRG[0]),.I0(sa26));
         SB_LUT4 #(.LUT_INIT(16'hcaca)) L_2320(.O(preWai1),.I3(1'b0),.I2(sa27),.I1(sa25),.I0(ADR_O[3]));     
         SB_LUT4 #(.LUT_INIT(16'haae2)) L_2321(.O(Wai[1]),.I3(sa27),.I2(TRG[1]),.I1(sa26),.I0(preWai1));    SB_CARRY CY_2321(.CO(waicy1),.CI(waicy0),.I1(TRG[1]),.I0(sa26));
         SB_LUT4 #(.LUT_INIT(16'hcce2)) L_2322(.O(Wai[2]),.I3(sa27),.I2(TRG[2]),.I1(sa26),.I0(ADR_O[4]));   SB_CARRY CY_2322(.CO(waicy2),.CI(waicy1),.I1(TRG[2]),.I0(sa26));
         SB_LUT4 #(.LUT_INIT(16'hcce2)) L_2323(.O(Wai[3]),.I3(sa27),.I2(TRG[3]),.I1(sa26),.I0(ADR_O[5]));   SB_CARRY CY_2323(.CO(waicy3),.CI(waicy2),.I1(TRG[3]),.I0(sa26));
         SB_LUT4 #(.LUT_INIT(16'h00e2)) L_2324(.O(Wai[4]),.I3(sa27),.I2(TRG[4]),.I1(sa26),.I0(ADR_O[6]));   SB_CARRY CY_2324(.CO(waicy4),.CI(waicy3),.I1(TRG[4]),.I0(sa26));
         SB_LUT4 #(.LUT_INIT(16'hf2fe)) L_2325(.O(Wai[5]),.I3(waicy4),.I2(sa27),.I1(sa26),.I0(ADR_O[7]));    
         SB_LUT4 #(.LUT_INIT(16'h0202)) L_2326(.O(Wai[6]),.I3(1'b0),.I2(sa27),.I1(sa26),.I0(ADR_O[8]));      
         SB_LUT4 #(.LUT_INIT(16'h0202)) L_2327(.O(Wai[7]),.I3(1'b0),.I2(sa27),.I1(sa26),.I0(ADR_O[9]));      
         
         if ( EBRADRWIDTH > 8 ) begin
            SB_LUT4 #(.LUT_INIT(16'h0202)) L_93(.O(Wai[8]),.I3(1'b0),.I2(sa27),.I1(sa26),.I0(ADR_O[10]));      
            if ( EBRADRWIDTH > 9 ) begin
               SB_LUT4 #(.LUT_INIT(16'h0202)) L_95(.O(Wai[9]),.I3(1'b0),.I2(sa27),.I1(sa26),.I0(ADR_O[11]));      
               if ( EBRADRWIDTH > 10 ) begin
                  SB_LUT4 #(.LUT_INIT(16'h0202)) L_97(.O(Wai[10]),.I3(1'b0),.I2(sa27),.I1(sa26),.I0(ADR_O[12]));      
               end
            end
         end
      end
   endgenerate
   assign m_wai_killwarning = &ADR_O[1:0];
endmodule
    
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * The operation register is simply 32 flip-flops with clock enable.
 * If we play our cards right, these registers are co-located with
 * the input mux LUTs. A requirement is then that chained LUTs are
 * used for the A-part of the ALU. This is surprisingly difficult
 * to arrange.
 * 
 * When corerunning == 0, OpC == 0, but it is not so easy to see why.
 * During the very first cycle, sa12 is unknown, it comes from EBR.
 * If sa12 is low, no problem, OpC will stay low.
 * If sa12 is high, we get INSTR <= Di.
 * 
 * Di comes from the input mux,          
 *   assign Di = sa00mod ? DAT_O : (DAT_O & rDee | ~DAT_O & shADR_O);
 * the select signal sa00mod is 0 the first cycle, and when 
 * corerunning == 0, so we have:
 *   Di = DAT_O & rDee | ~DAT_O & shADR_O) 
 * 
 * The very first cycle DAT_O is unknowm, it comes from EBR. However,
 * rDee == 0 and shADR_0 == 0, so Di is indeed 0.
 * 
 * The above is slightly different now that RVC is implemented.
 * Insead of sa12, we have is_valid_instrlow and is_valid_instrhigh.
 * If RVC is not included, these are infact sa12. If RVC is included,
 * these are a result of (sa12 & something), so at startup sa12 will
 * never "as low as ever", and the above argumentation holds.
 */
module m_opreg
  # ( parameter HIGHLEVEL = 0, RVC = 1)
  ( 
    input         clk,
//    input         sa12,
    /* verilator lint_off UNUSED */
    input         is_valid_instrlow,
    input         is_valid_instrhigh,
    /* verilator lint_on UNUSED */
    input [31:0]  Dii,
    output [31:0] INSTR,
    output [4:0]  TRG,SRC1,SRC2,
    output [2:0]  FUNC3,
    output [6:0]  FUNC7
    );
   
   generate
      if ( HIGHLEVEL ) begin

         reg [31:0]     rINSTRUCTION;
         always @(posedge clk) begin
            if ( is_valid_instrlow )
              rINSTRUCTION[15:0] <= Dii[15:0];
            if ( is_valid_instrhigh )
              rINSTRUCTION[31:16] <= Dii[31:16];               
         end
         assign INSTR = rINSTRUCTION;
         
      end else begin

         SB_DFFE OpC15_0  [15:0]  (.Q(INSTR[15:0]), .E(is_valid_instrlow), .C(clk),.D(Dii[15:0]));
         SB_DFFE OpC31_16 [31:16] (.Q(INSTR[31:16]),.E(is_valid_instrhigh),.C(clk),.D(Dii[31:16]));
         
      end
   endgenerate
   
   assign TRG     = INSTR[11:7];
   assign FUNC3   = INSTR[14:12];
   assign SRC1    = INSTR[19:15];
   assign SRC2    = INSTR[24:20];
   assign FUNC7   = INSTR[31:25];
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 *
 * This module:
 * ------------
 * o Construction to modify an alu input so that +2, +3 and +4 can be 
 *   realized easily
 * o Construction to hold execution of midgetv for (at least) the 
 *   first cycle 
 * o Optionally support for the cycle counter, and by extension mtime
 * o Optionally support for detection of bus-error
 * 
 * We must be able to let the ALU increment by 2, 3 or 4.
 * This is among other used when PC is incremented.
 *
 * A cycle counter with a 64-bit resolution is mandatory in most
 * implementations of RISC-V. I solve this by timing each instruction
 * in a 7-bit counter rcnt. Duing OpCode fetch this counter is added
 * to ttime, the counter is reset to 1. Register ttime contains the
 * low 32 bits of the cycle counter. rcnt is multiplexed with ADR_O
 * used by input QQ of the ALU during a cycle in OpCode fetch.  The
 * slowest "native" instruction is "shl rd,rs,31", shift operations by
 * 31. These instructions require 41 clock cycles. A consequence is
 * that the cycle counter must be 6 bits so no cycle count is
 * lost. However, when a load or store accesses slow i/o I got into a
 * problem. The fastest store byte instruction "sb x19,3(x22)" for
 * example, require 37 instructions with a zero-latency output
 * register. Let me specify that any "sb" should work with a register
 * with a 16 cycle latency, and set the limit on the cycle count
 * "bus-error cutoff" accordingly. In itself this is not a problem, I
 * require around 54 cycles in total < 64. But a problem arises when I
 * consider the "lh" instruction. With bus-error cutoff as above, a
 * "lh" instruction may need 73 cycles > 64. Hence I increase the
 * width of the cycle counter to 7.  Finally: Midgetv may be used with
 * slow program memory. I do not distinguish between latency additions
 * from memory or from i/o. With the present solution, I at most allow
 * 31 cycles latency for both the operand fetch, and the data fetch.
 *
 * This module also determines if midgetv is up and running. 
 * -  If we have no cyclecounter, corerunning goes high one cycle 
 *    after input signal 'start' is asserted.  
 * -  If we have a cyclecounter, 'start' is used as an enable for the 
 *    counter, and must be high 128 consequtive cycles to let midgetv 
 *    free. This should be handy if the clock of midgetv comes from a 
 *    PLL or an unstable clock (as is the case of iceblink40-hx1k 
 *    boards).
 *
 * If the 7-bit counter rcnt reaches 64 when the core is running, and
 * STB_O is set, we exit to a trap with bus-error. This will happen if
 * an IO device does not answer in a reasonable number of cycles. So
 * how many cycles of IO before a bus-error happens? These are results
 * from simulation program t190.s, run in SRAM. The numbers assume a
 * program executing from SRAM with a 1-cycle read latency for OpCode
 * fetch.
 *                        Max latency for
 *   Instruction          successfull instruction
 * - LW/LH(U)/LB(U)     : 58
 * - SW                 : 58
 * - SH to lsb adr 0b00 : 54
 * - SH to lsb adr 0b10 : 39
 * - SB to lsb adr 0b00 : 54
 * - SB to lsb adr 0b01 : 47
 * - SB to lsb adr 0b10 : 39
 * - SB to lsb adr 0b11 : 31
 * 
 * Size of this module in SB_LUTs:
 * HIGHLEVEL
 * | NO_CYCLECNT
 * 1 0 Lattice LSE/Synplify Pro  : 24/27
 * 1 1 Lattice LSE/Synplify Pro  : 3
 * 0 0                           : 16
 * 0 1                           : 3
 * 
 * Parameters:
 * -----------
 * HIGHLEVEL
 * ---------
 * 1 : RTL description
 * 0 : Low-level primitives
 * 
 * NO_CYCLECOUNT 
 * -------------
 * 1 : To save 13 LUTs, rcnt is optional
 *     s_cyclecnt
 *     ||    QQ[1:0]
 *     0x    {~pcinc_by_2,1'b1}   To implement +2, +3 (and +4 with the help of carry in)
 *     x1    {ADR_O[1],start}     rcnt degenerates to instruction counter.
 *     1x    ADR_O[1:0]           Let through ADR_O
 * 0 : rcnt is implemented
 *     s_cyclecnt
 *     ||    QQ[6:0]             
 *     ----- -------             
 *     00    {ADR_O[6:2],{~pcinc_by_2,1'b1}}  To implement +2, +3, (and +4 with the help of carry in)
 *     x1    rccnt                            Muxing in rcnt, reset counter.
 *     10    ADR_O[6:0]                       Let through ADR_O
 */
module m_cyclecnt
  # ( parameter HIGHLEVEL = 0, NO_CYCLECNT = 0, RVC = 0 )
  ( 
    input         clk,
    input         start,
    input [1:0]   s_cyclecnt,
/* verilator lint_off UNUSED */
    input         pcinc_by_2, // pc is to be incremented by 2 rather than 4, if ctrl_pcinc_by_2 also true
    input         ctrl_pcinc_by_2,
    input         STB_O,
/* verilator lint_on UNUSED */
    input [31:0]  ADR_O,
    output [31:0] QQ, 
    output        corerunning,
    output        buserror, 
    output [6:0]  dbg_rccnt
    );
   
   generate
      
      if ( HIGHLEVEL ) begin
         /* At a certain stage I had to put synthesis attributes on cmbrcriun and rcrun, I do not recall why.
          * Anyway, Sept 2020, Synplify pro used to many SB_GB resources, Removing the attributes helped. Why?
          * Probably because the SB_GB resources were eaten as I had used a very high fanout limit.
          * Changing the limit to 100 solved the issue
          */
         wire cmbrcrun /* synthesis syn_keep=1 */;
         reg  rcrun /* synt  hesis syn_keep=1 */;
         wire final_pcinc_by_2 = pcinc_by_2 & ctrl_pcinc_by_2;
         
         if ( NO_CYCLECNT == 1 ) begin
            
            // =======================================================
            // HIGLEVEL, NO CYCLECNT
            // Note the flipflop "rcrun". Even if "start" is hardcoded
            // to 1, midgetv will wait one cycle at startup, so that
            // control output from EBR is valid.
            // No possibility to find a bus error.
            // =======================================================

            assign QQ[1:0] = s_cyclecnt[0] ? {ADR_O[1],start} : (s_cyclecnt[1] ? ADR_O[1:0] : {~final_pcinc_by_2,1'b1} );
            assign QQ[6:2] = ADR_O[6:2];
            assign buserror = 1'b0;
            assign cmbrcrun = rcrun | start;
            always @(posedge clk)
              rcrun <= cmbrcrun;
            assign corerunning = rcrun;
            assign dbg_rccnt = {6'b0,STB_O};
            
         end else begin
            
            // =======================================================
            // HIGLEVEL, CYCLECNT
            // When start has been asserted 128 consequtive cycles, 
            // rcrun is set, the core is running. Even if start is
            // deasserted later on, the core continues to run. However,
            // the cycle counter will only count if start is high.
            //
            // If the cyclecounter increments from 0b111111 we have
            // a bus-error, some IO has not given ACK, buserror is 
            // set one cycle.
            // =======================================================

            reg [6:0]   rccnt;
            reg         rbuserror;
            wire [7:0]  ccnt = start ? (s_cyclecnt[0] ? 1 : rccnt + 1) : 0;
            wire        cmbbuserror = (rccnt[5:0] == 6'b111111) & STB_O;
            assign cmbrcrun    = ccnt[7] | rcrun;
            
            always @(posedge clk) begin
               rccnt[6:0] <= ccnt[6:0];
               rcrun      <= cmbrcrun;
               rbuserror  <= cmbbuserror;
            end
            
//            assign QQ[6:0] = s_cyclecnt[0] ? rccnt : (s_cyclecnt[1] ? ADR_O[6:0] : {ADR_O[6:2],2'h3} );
            assign QQ[6:0] = s_cyclecnt[0] ? rccnt : (s_cyclecnt[1] ? ADR_O[6:0] : {ADR_O[6:2],~final_pcinc_by_2,1'h1} );
            assign buserror = rbuserror;
            assign corerunning = rcrun;
            assign dbg_rccnt = rccnt;
         end

      end else begin

         if ( NO_CYCLECNT == 1 ) begin

            // =======================================================
            // LOWLEVEL, NO CYCLECNT
            // =======================================================
            
            wire cmb_rcrun,hQQ1;
            assign QQ[6:2] = ADR_O[6:2];

            if ( RVC == 0 ) begin               
               bn_l4 #(.I(16'hcacf)) c_qq_10 [1:0] (.o(QQ[1:0]), .i3(s_cyclecnt[1]), .i2(s_cyclecnt[0]), .i1(2'b11), .i0(ADR_O[1:0]) );
               SB_LUT4 #(.LUT_INIT(16'heeee)) cmb_rcrun_l(.O(cmb_rcrun), .I3(1'b0), .I2(1'b0), .I1(corerunning), .I0(start));
               SB_DFF rcrun(.Q(corerunning), .C(clk), .D(cmb_rcrun));
            end else begin
               // Is possible to save 1 lut by using carrychain.
               //          SB_LUT4 #(.LUT_INIT(16'habab)) qqmux1(.O(QQ[1]),.I3(1'b0),.I2(s_cyclecnt[0]), .I1(s_cyclecnt[1]), .I0(ADR_O[1]));
               bn_l4 #(.I(16'haa3f)) l_hQQ1( .o(hQQ1),  .i3(s_cyclecnt[1]), .i2(ctrl_pcinc_by_2),.i1(pcinc_by_2), .i0(ADR_O[1]) );
               bn_l4 #(.I(16'hcaca)) c_qq_1( .o(QQ[1]), .i3(1'b0),          .i2(s_cyclecnt[0]),  .i1(ADR_O[1]),   .i0(hQQ1    ) );
               
               SB_LUT4 #(.LUT_INIT(16'haacf)) qqmux0(.O(QQ[0]),.I3(s_cyclecnt[0]),.I2(s_cyclecnt[1]), .I1(ADR_O[0]), .I0(start)); 
               SB_LUT4 #(.LUT_INIT(16'heeee)) cmb_rcrun_l(.O(cmb_rcrun), .I3(1'b0), .I2(1'b0), .I1(corerunning), .I0(start));
               SB_DFF rcrun(.Q(corerunning), .C(clk), .D(cmb_rcrun));
            end
               
            assign buserror = 1'b0;            
            assign dbg_rccnt = 0;
            
         end else begin

            // =======================================================
            // LOWLEVEL, CYCLECNT
            // =======================================================
            
            /*                         ___                  
             *                   -----|I0 |               __  
             *                   -----|I1 |-cmb_rcrun----|  |-- corerunning
             *           corerunning -|I2 |              >__|      
             *                     +--|I3_|                      
             *                     |ccntcy[7]
             *                    /y\
             *                    |||  ___                                            ___         
             *           start   -(((-|I0 |               __             ADR_O[6] ---|I0 |           
             *           rcnt[6] -((+-|I1 |-ccnt[6]------|  |-- rcnt[6] -------------|I1 |- QQ[6] 
             *     s_cyclecnt[0] -+(--|I2 |              >__|         s_cyclecnt[0] -|I2 |        
             *                     +--|I3_|                                         -|I3_|        
             *                     |ccntcy[6]
             *                    /y\                                 
             *                    |||  ___                              
             *           STB_O   -(((-|I0 |               __             
             *               1   -((+-|I1 |-cmb_buserror-|  |-- buserror
             *               0   -+(--|I2 |              >__|           
             *                     +--|I3_|                            
             *                     |ccntcy[5]
             *                    /y\
             *                    |||  ___                                            ___         
             *           start   -(((-|I0 |               __             ADR_O[5] ---|I0 |           
             *           rcnt[5] -((+-|I1 |-ccnt[5]------|  |-- rcnt[5] -------------|I1 |- QQ[5] 
             *     s_cyclecnt[0] -+(--|I2 |              >__|         s_cyclecnt[0] -|I2 |        
             *                     +--|I3_|                                         -|I3_|        
             *                     |ccntcy[4]                         
             *                    /y\                                 
             *                    |||  ___                                            ___         
             *           start   -(((-|I0 |               __             ADR_O[4] ---|I0 |        
             *           rcnt[4] -((+-|I1 |-ccnt[4]------|  |-- rcnt[4] -------------|I1 |- QQ[4] 
             *     s_cyclecnt[0] -+(--|I2 |              >__|         s_cyclecnt[0] -|I2 |        
             *                     +--|I3_|                                         -|I3_|        
             *                     |ccntcy[3]                         
             *                    /y\                                            
             *                    |||  ___                                            ___         
             *           start   -(((-|I0 |               __           ADR_O[3] -----|I0 |        
             *           rcnt[3] -((+-|I1 |-ccnt[3]------|  |-- rcnt[3] -------------|I1 |- QQ[3] 
             *     s_cyclecnt[0] -+(--|I2 |              >__|     s_cyclecnt[0] -----|I2 |        
             *                     +--|I3_|                                         -|I3_|        
             *                     |ccntcy[2]                                    
             *                    /y\                                            
             *                    |||  ___                                            ___         
             *           start   -(((-|I0 |               __           ADR_O[2] -----|I0 |        
             *           rcnt[2] -((+-|I1 |-ccnt[2]------|  |-- rcnt[2] -------------|I1 |- QQ[2] 
             *     s_cyclecnt[0] -+(--|I2 |              >__|     s_cyclecnt[0] -----|I2 |        
             *                     +--|I3_|                                         -|I3_|        
             *                     |ccntcy[1]                                         ___         
             *                     |                                   ADR_O[1] -----|I0 |        
             *                     |                                 pcinc_by_2 -----|I1 |-+ hQQ1
             *                     |                            ctrl_pcinc_by_2 -----|I2 | |       
             *                    /y\                             s_cyclecnt[1] -----|I3_| |         
             *                    |||  ___                                                 |  ___         
             *           start   -(((-|I0 |               __                               +-|I0 |        
             *           rcnt[1] -((+-|I1 |-ccnt[1]------|  |-- rcnt[1] ---------------------|I1 |- QQ[1] 
             *     s_cyclecnt[0] -+(--|I2 |              >__|     s_cyclecnt[0] -------------|I2 |        
             *                     +--|I3_|                       s_cyclecnt[1] -------------|I3_|        
             *                     |ccntcy[0]                                    
             *                    /y\                                            
             *                    |||  ___                                            ___  
             *           start   -(((-|I0 |               __           ADR_O[0] -----|I0 | 
             *           rcnt[0] -((+-|I1 |-ccnt[0]------|  |-- rcnt[0] -------------|I1 |- QQ[0]
             *                 0 -+(--|I2 |              >__|     s_cyclecnt[0] -----|I2 | 
             *     s_cyclecnt[0] --(--|I3_|                       s_cyclecnt[1] -----|I3_|        
             *                     |                                             
             *                     1                                             
             *
             * Note subtility in LUT/CARRY of ccnt[0]. The very first cycle s_cyclecnt[0] is unknown. We want to 
             * kill the carry chain or else rcrun will go high prematurely.
             *
             */
            
            wire [6:0] ccnt,rccnt;
            /* verilator lint_off UNOPTFLAT */
            wire [7:0] ccntcy;
            /* verilator lint_on UNOPTFLAT */
            wire       cmb_rcrun,cmbbuserror;
            
            bn_lcy4_b #(.I(16'haa22)) l_ccntlsb(     .o(ccnt[0]),    .co(ccntcy[0]),   .ci(1'b1),        .i3(s_cyclecnt[0]), .i2(1'b0),              .i1(rccnt[0]),   .i0(start));
            bn_lcy4_b #(.I(16'h0208)) l_ccnt [4:0] ( .o(ccnt[5:1]),  .co(ccntcy[5:1]), .ci(ccntcy[4:0]), .i3(ccntcy[4:0]),      .i2(s_cyclecnt[0]),  .i1(rccnt[5:1]), .i0(start));
            bn_lcy4_b #(.I(16'haa00)) l_buserror(    .o(cmbbuserror),.co(ccntcy[6]),   .ci(ccntcy[5]),   .i3(ccntcy[5]),        .i2(1'b0),               .i1(1'b1),       .i0(STB_O));
            bn_lcy4_b #(.I(16'h0208)) l_ccnt6(       .o(ccnt[6]),    .co(ccntcy[7]),   .ci(ccntcy[6]),   .i3(ccntcy[6]),        .i2(s_cyclecnt[0]),  .i1(rccnt[6]),   .i0(start));
            bn_l4     #(.I(16'hfff0)) l_rcrun      ( .o(cmb_rcrun),  .i3(ccntcy[7]), .i2(corerunning), .i1(1'b0), .i0(1'b0));
            SB_DFF r_rcntlsb [6:0] ( .Q(rccnt),       .C(clk), .D(ccnt));
            SB_DFF r_buserror(       .Q(buserror),    .C(clk), .D(cmbbuserror));
            SB_DFF r_rcrun         ( .Q(corerunning), .C(clk), .D(cmb_rcrun));

            if ( RVC == 0 ) begin
               bn_l4 #(.I(16'hcacf)) c_qq_10 [1:0] (.o(QQ[1:0]), .i3(s_cyclecnt[1]), .i2(s_cyclecnt[0]), .i1(rccnt[1:0]), .i0(ADR_O[1:0]) );
            end else begin
               wire       hQQ1;
               bn_l4 #(.I(16'haa3f)) l_hQQ1( .o(hQQ1),  .i3(s_cyclecnt[1]), .i2(ctrl_pcinc_by_2),.i1(pcinc_by_2), .i0(ADR_O[1]) );
               bn_l4 #(.I(16'hcaca)) c_qq_1( .o(QQ[1]), .i3(1'b0),          .i2(s_cyclecnt[0]),  .i1(rccnt[1]),   .i0(hQQ1    ) );
               bn_l4 #(.I(16'hcacf)) c_qq_0( .o(QQ[0]), .i3(s_cyclecnt[1]), .i2(s_cyclecnt[0]),  .i1(rccnt[0]),   .i0(ADR_O[0]) );
            end
            bn_l4 #(.I(16'hcaca)) c_qq_62 [4:0] (.o(QQ[6:2]), .i3(1'b0), .i2(s_cyclecnt[0]), .i1(rccnt[6:2]), .i0(ADR_O[6:2]) );
            assign dbg_rccnt = rccnt;
            
         end
      end
   endgenerate
   
   assign QQ[31:7] = ADR_O[31:7];
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 */

module m_condcode # ( parameter HIGHLEVEL = 0, MULDIV = 0 )
   (
    input        clk, //          System clock
    input        alu_carryout, // Out of the ALU carry chain
    input [31:0] INSTR, //        from INSTRUCTION register
    input        A31,
    input        QQ31, //
    /* Verilator lint_off UNUSED */
    input        use_dinx,
    input        cond_holdq, // fitte, is this needed
    input        ceM, //          Enable bidirectional shiftreg used to distinguish mult/div add/shift cycles
    input [2:0]  s_alu, // fitte,
//    input        Di31, // fitte
    input        sa14, // When rM is loaded, rF is cleared
    /* Verilator lint_on UNUSED */
    input        rzcy32, //       Registered zero-detect from m_immexp_zfind_q
    output       raluF, //        Registered aluF for use by SLT(I)/SLTU(I)
    output       is_brcond, //    Combinatorical for BEQ/BNE/BLT(U)/BGE(U)
    /* Verilator lint_off UNDRIVEN */
    output       cmb_rF2,
    /* Verilator lint_on UNDRIVEN */
    output       m_condcode_killwarnings
    );
   
   generate
      if ( MULDIV == 0 ) begin
         reg       cmb_aluF,tmp_raluF,tmp_is_brcond;
         
         always @(*)
           case (INSTR[14:12])
             3'b010 : cmb_aluF = ((A31^QQ31)&(~alu_carryout)) | (A31&QQ31);
             3'b011 : cmb_aluF = ~alu_carryout; 
             3'b100 : cmb_aluF = ((A31^QQ31)&(~alu_carryout)) | (A31&QQ31);
             3'b101 : cmb_aluF = ((A31^QQ31)&(~alu_carryout)) | (A31&QQ31);
             3'b110 : cmb_aluF = ~alu_carryout;
             3'b111 : cmb_aluF = ~alu_carryout;
             default: cmb_aluF = 1'b0;  
           endcase
         
         always @(posedge clk) 
           tmp_raluF <= cmb_aluF;
         assign raluF = tmp_raluF;
         
         always @(*)
           case (INSTR[14:12])
             3'b000 : tmp_is_brcond = ~rzcy32;
             3'b001 : tmp_is_brcond = rzcy32;
             3'b100 : tmp_is_brcond = raluF ;
             3'b101 : tmp_is_brcond = ~raluF;
             3'b110 : tmp_is_brcond = raluF ;
             3'b111 : tmp_is_brcond = ~raluF;
             default :tmp_is_brcond = 1'b0;
           endcase   
         assign is_brcond = tmp_is_brcond;
         assign m_condcode_killwarnings = &INSTR[31:15] | &INSTR[11:0];

         assign cmb_rF2 = 0;
         
      end else begin
         
/*
 *   When MULDIV == 0
 *                     0 : use (~alu_carryout&(A31^QQ[31])) | (A31&QQ[31])
 *              ___    1 : use ~alu_carryout                               
 *   FUNC3[0] -|I0 |-+ pre_cmb_aluF
 *   FUNC3[1] -|I1 | |
 *   FUNC3[2] -|I2 | |   ___                    +----------------------- raluF
 *            -|I3_| +--|I0 |                _  |           ___
 *   QQ31   ------------|I1 |--  cmb_aluF --| |-+----------|I0 |-------- is_brcond
 *   A31    ------------|I2 |               >_|  rzcy32 ---|I1 |
 *                 +----|I3_|                    FUNC3[0] -|I2 |
 *                 |                             FUNC3[2] -|I3_|
 *                 | alu_carryout
 *                 :
 *             (alu carry)
 *             (chain here)
 *                 :
 * 
 * 
 *   When MULDIV == 1
 *    
 *                       ___                    +----------------------- raluF
 *    feed[0] ----------|I0 |                _  |           ___
 *    feed[1] ----------|I1 |--  cmb_aluF --| |-+----------|I0 |-------- is_brcond
 *    feed[2] ----------|I2 |               >_|  rzcy32 ---|I1 |
 *                 +----|I3_|                             -|I2 |
 *                 |                                      -|I3_|
 *                /y\    ___
 *    addtype[1] -(((---|I0 |
 *             1 -+||   |I1 |--  cond_holdq = ~alu_carryout & addtype[1];
 *             0 --(+   |I2 |
 *                 +----|I3_|
 *                 | alu_carryout
 *                 :
 *             (alu carry)
 *             (chain here)
 *                 :
 * 
 * 
 * Recall:
 * ========
 * INSTR[25]
 * |INSTR[6:0]
 * x1100011    branches
 * x0010011    slti/sltui
 * 00110011    slt/sltu
 * 10110011    mul/div
 * 
 * 
 * To cover branches and slt[u][i] and MUL/MULH/MULHSU/MULHU, DIV/DIVU/REM/REMU
 * ============================================================================
 * 
 * use_dinx
 * | enm (in this column 'o' mean it will be low, but should be treated as dont' care)
 * | | INSTR[25]           
 * | | |INSTR[6:5]         
 * | | ||| FUNC3 Opcodes       cmb_aluF                                           
 * 0 x 101 000   MUL           x
 * 0 0 101 001   MULH          alu_carryout^rF^Di[31]                               During ADD. If the Add chg to PASSQ, alu_carryout == 0, Di[31] == 0: rF correct
 * 0 1 101 001   MULH          rF                                                   During SRA.
 * 0 o 001 010   SLT  SLTI     (Di[31]&QQ[31]) | ((Di[31]^QQ[31])&~alu_carryout)  
 * 0 o x00 011   SLTU SLTUI    ~alu_carryout                                      
 * 0 0 101 010   MULHSU        alu_carryout^rF^Di[31]                               During ADD. If the Add chg to PASSQ, alu_carryout == 0, Di[31] == 0: rF correct
 * 0 1 101 010   MULHSU        rF                                                   During SRA.
 * 0 0 101 011   MULHU         alu_carryout                                         During ADD. If the ADD chg to PASSQ, alu_carryout == 0: 0 correct
 * 0 1 101 011   MULHU         0                                                    During SLR
 * 0 0 101 1xx   DIV[U]/REM[U] alu_carryout^rF^1                                    During ADD
 * 0 1 101 1xx   DIV[U]/REM[U] QQ[31]                                               During SLL
 * 0 o x11 000   BEQ           x                                                  
 * 0 o x11 001   BNE           x                                                  
 * 0 o x11 100   BLT           (Di[31]&QQ[31]) | ((Di[31]^QQ[31])&~alu_carryout)  
 * 0 o x11 101   BGE           (Di[31]&QQ[31]) | ((Di[31]^QQ[31])&~alu_carryout)  
 * 0 o x11 110   BLTU          ~alu_carryout                                      
 * 0 o x11 111   BGEU          ~alu_carryout                                      
 * 1 x xxx xxx                 Cleared at start of each instruction
 * - - --- ---   All others are dontcare.
 * 
 * I want to make
 * feed[2:0]  cmb_aluF
 * 00a        a
 * 01a        alu_carryout^a
 * 1ba        b | (a&~alu_carryout)
 * 
 * use_dinx
 * | enm
 * | | INSTR[25]           
 * | | |INSTR[6:5]         
 * | | ||| FUNC3 Opcodes       cmb_aluF                                   cmb_aluF        
 * | 1 101 001   MULH          rF                                         a         
 * | 1 101 010   MULHSU        rF                                         a         
 * | 1 101 011   MULHU         0                                          a         
 * | 1 101 1xx   DIV[U]/REM[U] QQ31                                       a         
 * 1 x xxx xxx                 0                                          a
 * 
 * 0 x x00 011   SLTU SLTUI    ~alu_carryout                              alu_carryout^a
 * 0 x x11 110   BLTU          ~alu_carryout                              alu_carryout^a
 * 0 x x11 111   BGEU          ~alu_carryout                              alu_carryout^a
 * 0 0 101 011   MULHU         alu_carryout                               alu_carryout^a
 * 0 0 101 001   MULH          alu_carryout^rF^A31                        alu_carryout^a
 * 0 0 101 010   MULHSU        alu_carryout^rF^A31                        alu_carryout^a
 * 0 0 101 1xx   DIV[U]/REM[U] alu_carryout^rF^1                          alu_carryout^a
 * 
 * 0 x 001 010   SLT  SLTI     (A31&QQ31) | ((A31^QQ31)&~alu_carryout)  b | (a&~alu_carryout)
 * 0 x x11 100   BLT           (A31&QQ31) | ((A31^QQ31)&~alu_carryout)  b | (a&~alu_carryout)
 * 0 x x11 101   BGE           (A31&QQ31) | ((A31^QQ31)&~alu_carryout)  b | (a&~alu_carryout)
 * 
 */

         reg [2:0] feed;
         reg       tmp_rF;
         wire      rF;
         reg       cmb_aluF;
         reg       tmp_is_brcond;
         
         always @(*)                                  
           casez ({use_dinx,ceM,INSTR[25],INSTR[6:5],INSTR[14:12]})
             //  use_dinx
             //  | ceM
             //  | | INSTR[25]          feed[2]
             //  | | |INSTR[6:5]        |      feed[1]
             //  | | ||| FUNC3          |      |          feed[0]
             //  | | ||| |||            |      |          |               Opcpdes
             8'b 0_1_101_011 : feed = { 1'b0,  1'b0     , 1'b0     }; //  MULHU              Shift right logical
             8'b 0_1_101_001 : feed = { 1'b0,  1'b0     , rF       }; //  MULH               Shift right arithmetic  
             8'b 0_1_101_010 : feed = { 1'b0,  1'b0     , rF       }; //  MULHSU             Shift right arithmetic
             8'b 0_1_101_1?? : feed = { 1'b0,  1'b0     , QQ31     }; //  DIV[U]/REM[U]      Shift left
             8'b 1_?_???_??? : feed = { 1'b0,  1'b0     , 1'b0     }; //  clear at dinx
                                                 
             8'b 0_?_?00_011 : feed = { 1'b0,  1'b1     , 1'b1     }; //  SLTIU            
             8'b 0_?_001_011 : feed = { 1'b0,  1'b1     , 1'b1     }; //  SLTU             
             8'b 0_?_?11_11? : feed = { 1'b0,  1'b1     , 1'b1     }; //  BLTU/BGEU        

             8'b 0_0_101_011 : feed = { 1'b0,  1'b1     , 1'b0     }; //  MULHU              unsigned addition
             8'b 0_0_101_001 : feed = { 1'b0,  1'b1     , rF^A31   }; //  MULH               signed addition
             8'b 0_0_101_010 : feed = { 1'b0,  1'b1     , rF^A31   }; //  MULHSU             signed addition
             8'b 0_0_101_1?? : feed = { 1'b0,  1'b1     , rF^1'b1  }; //  DIV[U]/REM[U]      unsigned subtraction
                                             
             8'b 0_?_?00_010 : feed = { 1'b1,  A31&QQ31 , A31^QQ31}; //  SLTI           
             8'b 0_?_001_010 : feed = { 1'b1,  A31&QQ31 , A31^QQ31}; //  SLT  
             8'b 0_?_?11_100 : feed = { 1'b1,  A31&QQ31 , A31^QQ31}; //  BLT                 
             8'b 0_?_?11_101 : feed = { 1'b1,  A31&QQ31 , A31^QQ31}; //  BGE
             default :       feed = 3'b000; // Think I see a bug in Verilator. This fails if I say feed = 3'b???
           endcase
         reg       basic;
         always @(*)
           casez (feed)
             3'b000 : basic = 1'b0;
             3'b001 : basic = 1'b1;
             3'b010 : basic = alu_carryout;
             3'b011 : basic = ~alu_carryout;
             3'b100 : basic = 1'b0;
             3'b101 : basic = ~alu_carryout;
             3'b11? : basic = 1'b1;
           endcase                             
         
         always @(*)
           casez ({sa14,s_alu})
             4'b1000 : cmb_aluF = rF;    // A_nearXOR
             4'b00?? : cmb_aluF = 0;     // Q clear.
             4'b0100 : cmb_aluF = basic; // Q clear, used by SLTxx
             4'b0101 : cmb_aluF = 0;     // Q clear.
             4'b011? : cmb_aluF = 0;
             default : cmb_aluF = basic;
           endcase
         
         always @(posedge clk)
           if ( ~cond_holdq )
             tmp_rF <= cmb_aluF;
         assign rF = tmp_rF;
         assign cmb_rF2 = cmb_aluF;

         always @(*)
           casez ({INSTR[6],INSTR[14],INSTR[12]})
             3'b0?? : tmp_is_brcond = ~rzcy32;
             3'b100 : tmp_is_brcond = ~rzcy32;
             3'b101 : tmp_is_brcond = rzcy32;
             3'b110 : tmp_is_brcond = rF ;
             3'b111 : tmp_is_brcond = ~rF;
           endcase   
         assign is_brcond = tmp_is_brcond;
         assign raluF = rF;
         assign m_condcode_killwarnings = &INSTR[31:26] | &INSTR[24:7] | &INSTR[4:0];
      end
   endgenerate
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * midgetv has no barrel shifter, shifting is done in microcode.
 * Here is the logic for the shift counter - a 5-bit down counter. 
 * 
 * This module also give a 1'b1 on a carry chain, to save one LUT in the ALU
 * (probably due to routing constraints).
 *
 * s_shift[1:0]
 * ||B[1:0]
 * ||||         Action      Loadval
 * 00xx         Load        B[4:0]   
 * 0100         Load        00000    
 * 0101         Load        01000
 * 0110         Load        10000
 * 0111         Load        11000
 * 10xx         Count down
 * 11xx         Hold
 * 
 * HIGHLEVEL   Size in SB_LUT4s:
 * 0           11            
 * 1           13 (Lattice LSE)
 *             15 (Synplify Pro)
 */
module m_shiftcounter
  # ( parameter HIGHLEVEL = 0 )   
   (
    input        clk, //          System clock
    input [1:0]  s_shift, //     Operation
    input [4:0]  B, //            For initial value
    output       lastshift, //    Counter decrements to zero
    output [4:0] dbg_rshcnt  //   
    );
   
   generate
      if ( HIGHLEVEL ) begin
         
         reg [4:0] rshcnt;
         reg       rr_lastshift;
         reg [5:0] shcnt;
         
         always @(/*AS*/B or rshcnt or s_shift) begin
            case ( s_shift )
              2'b00 : shcnt = {1'b0,B[4:0]};
              2'b01 : shcnt = {1'b0,B[1:0],3'b000};
              2'b10 : shcnt = {1'b0,rshcnt}+6'b011111 + {5'b00000,s_shift[0]};
              2'b11 : shcnt = {1'b0,rshcnt}+6'b011111 + {5'b00000,s_shift[0]};
            endcase      
         end

         assign lastshift = ~shcnt[5] & s_shift[1];
         always @(posedge clk) 
           rshcnt <= shcnt[4:0];
         assign dbg_rshcnt = rshcnt[4:0];
      end else begin


         /*
          *                       
          *                      
          *                                
          *                          ___    
          *         s_shift[1] -----|I0 |   
          *                vcc ---- |I1 |---------- lastshift = ~shcy[4] & s_shift[1]. The cycle we are loading the counter is not the last shift.
          *                vcc ---- |I2 |    
          *                      +--|I3_|    
          *                      |shcy[4]
          *                     /y\  ___
          *          d[3] ------(((-|I0 |     __
          *    s_shift[1] ------+((-|I1 |----|  |-- rshcnt[4]
          *          rshcnt[4] --(+-|I2 |    |  |
          *                      +--|I3_|    >__|               
          *                      |shcy[3]
          *                     /y\  ___
          *          d[2] ------(((-|I0 |     __
          *    s_shift[1] ------+((-|I1 |----|  |-- rshcnt[3]
          *          rshcnt[3] --(+-|I2 |    |  |
          *                      +--|I3_|    >__|
          *                      |shcy[2]
          *                     /y\  ___
          *          d[1] ------(((-|I0 |     __
          *    s_shift[1] ------+((-|I1 |----|  |-- rshcnt[2]
          *          rshcnt[2] --(+-|I2 |    |  |
          *                      +--|I3_|    >__|
          *                      |shcy[1]
          *                     /y\  ___
          *          d[0] ------(((-|I0 |     __
          *    s_shift[1] ------+((-|I1 |----|  |-- rshcnt[1]
          *          rshcnt[1] --(+-|I2 |    |  |
          *                      +--|I3_|    >__|
          *                      |shcy[0]
          *                     /y\  ___
          *    s_shift[1] ------(((-|I0 |     __
          *    s_shift[0] ------+((-|I1 |----|  |-- rshcnt[0]
          *          rshcnt[0] --(+-|I2 |    |  |
          *          B[0] -------(--|I3_|    >__|
          *                      |
          *                      vcc
          *         
          *                          ___ 
          *                B[1] ----|I0 |-- d1 = ~s_shift[0] & B[1]
          *          s_shift[0] ----|I1 |
          *                     ----|I2 |
          *                     ----|I3_|
          *               
          *                          ___ 
          *                B[2] ----|I0 |-- d2 = ~s_shift[0] & B[2]
          *          s_shift[0] ----|I1 |
          *                     ----|I2 |
          *                     ----|I3_|
          *               
          *                          ___ 
          *                B[3] ----|I0 |-- d3 = (~s_shift[0] & B[3]) | s_shift[0] & B[0]
          *                B[0] ----|I1 |
          *          s_shift[0] ----|I2 |
          *                     ----|I3_|
          *               
          *                          ___ 
          *                B[4] ----|I0 |-- d4 = (~s_shift[0] & B[4]) | s_shift[0] & B[1]
          *                B[1] ----|I1 |
          *          s_shift[0] ----|I2 |
          *                     ----|I3_|
          *       
          */
         wire [4:0] rshcnt,shcnt;
         wire [3:0] d;
         /* verilator lint_off UNOPTFLAT */
         wire [4:0] shcy;
         /* verilator lint_on UNOPTFLAT */
         
         bn_l4 #(.I(16'h2222)) cmb_d21 [1:0] ( .o(d[1:0]), .i3(1'b0), .i2(1'b0), .i1(s_shift[0]),   .i0(B[2:1]));
         bn_l4 #(.I(16'hcaca)) cmb_d43 [1:0] ( .o(d[3:2]), .i3(1'b0), .i2(s_shift[0]), .i1(B[1:0]), .i0(B[4:3]));

         bn_lcy4_b #(.I(16'h9382)) cmb_shcnt0        (.o(shcnt[0]),   .co(shcy[0]),  .ci(1'b1), .i3(B[0]),      .i2(rshcnt[0]),   .i1(s_shift[0]), .i0(s_shift[1]));
         bn_lcy4   #(.I(16'he22e)) cmb_shcnt41 [3:0] (.o(shcnt[4:1]), .co(shcy[4:1]),           .i3(shcy[3:0]), .i2(rshcnt[4:1]), .i1(s_shift[1]), .i0(d[3:0]));
         bn_l4   #(.I(16'h00aa)) cmb_lastshift     (.o(lastshift),  .i3(shcy[4]),   .i2(1'b1),        .i1(1'b1),          .i0(s_shift[1]));

         SB_DFF reg_shcnt40 [4:0] ( .Q(rshcnt[4:0]), .C(clk), .D(shcnt[4:0]));
         assign dbg_rshcnt = rshcnt[4:0];
      end
   endgenerate
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * 
 * If we have MTIMETAP >= MTIMETAP_LOWLIM, interrupts and mtime is implemented 
 * in midgetv. From user code, the following holds:
 *
 * Stated as memory-mapped in riscv-privileged:
 * Machine-level MSIP bit: 
 *     Exposed for writing by remote harts. Not implemented here (we only
 *     support one hart). MSIP is simply a bit in the MIP register.
 * mtimecmph/mtimecmp: 
 *     Real value is in EBR 0xf8/0xfc. 
 * mtimeh/mtime is exposed as a memory-mapped machine-mode read/write register
 *     Real value is in EBR 0xe0/0xe4.
 * 
 *   Write adr
 *   3322222222221111111111            Write to           EBR Address
 *   10987654321098765432109876543210  register or bit    |    Reg. name    Side effect on write
 * 0b001xxxxxxxxxxxxxxx1xxxxx111000xx  register mtime     0xe0 mtime        Clears mtimeincip
 * 0b001xxxxxxxxxxxxxx1xxxxxx111011xx  register minstreth 0xec minstreth    Clears minstreth
 * 0b001xxxxxxxxxxxxx1xxxxxxx100000xx  bit mtip           0x80 __jj
 * 0b001xxxxxxxxxxxx1xxxxxxxx100000xx  register mstatus   0x80 __jj
 * 0b001xxxxxxxxxxx1xxxxxxxxx100000xx  register mie       0x80 __jj
 * 0b001xxxxxxxxxx1xxxxxxxxxx100000xx  register mip       0x80 __jj         Updates msip
 * 0b001xxxxxxxxx1xxxxxxxxxxx111110xx  register mtimecmp  0xf8 mtimecmp     Clears mtip
 * 0b001xxxxxxxxx1xxxxxxxxxxx111111xx  register mtimecmph 0xfc mtimecmph    Clears mtip
 * 
 * Read adr                            
 *   3322222222221111111111            
 *   10987654321098765432109876543210  Read register      
 * 0b010xxxxxxxxxxxxxxxxxxxxxxxxxxxxx  reserved for future extension
 * 0b01100xxxxxxxxxxxxxxxxxxxxxxxxxxx  All normal input frome external port
 * 0b01101xxxxxxxxxxxxxxxxxxxxxxxxxxx  mip
 * 0b01110xxxxxxxxxxxxxxxxxxxxxxxxxxx  mie
 * 0b01111xxxxxxxxxxxxxxxxxxxxxxxxxxx  mstatus
 * 
 * The reason for the change is that I will disallow read/write to EBR when executing in
 * SRAM. This protects the registers and constants. We may still access anything when
 * executing in EBR. The only way to get from SRAM to EBR will be via an exception or 
 * a CSR instruction.
 * 
 * Changes to get this to happen:
 * 1. FF that say "executes in SRAM":
 * 2. If executing in SRAM, and a write-attempt to __pc is made which is outside
 *    of SRAM, give exception instead. 
 * 3. If executing in SRAM, and a read or write attemt is done to EBR, give exception.
 * 
 * This is only an outline of the idea:
 * 
 * always @(posedge clk) begin
 *    if ( Wpc ) begin
 *       if ( EXECinSRAM == 0 ) begin
 *          EXECinSRAM <= B[31] | B[30];
 *       end else begin
 *          if ( isr_intoCSR || isr_intoTrap ) begin
 *             EXECinSRAM <= 0;
 *          end else if ( B[31] | B[30] ) begin
 *             exception_illegal_adr;
 *          end
 *       end
 *    end
 * end
 *
 * The FF is easy to implement. The decision to give illegal exception is more
 * tricky, and involves considerable work in microcode. 
 *
 * ===============================================================
 *
 * Layout of register:
 * -------------------
 * 31        18 17           16          15 12 11   10 8 7    6 4 3    2 0
 * 000000000000 mrinstretip  mtimeincip  0000  meip 000  mtip 000 msip 000  MIP
 * 000000000000 mrinstrettie mtimeincie  0000  meie 000  mtie 000 msie 000  MIE
 * 000000000000 0            0           0001  1    000  mpie 000 mie  000  MSTATUS
 * 
 * register MIP 
 * ------------
 * 31 19 17       16         15 12 11   10   9    8    7    6    5    4    3    2    1    0
 * WPRI  MRINSTIP MTIMEINCIP WPRI  MEIP WPRI SEIP UEIP MTIP WPRI STIP UTIP MSIP WPRI SSIP USIP
 * 
 * Field        Access     Contents/comment 
 * WPRI         Read-only  0
 * MRINSTRETIP  Read-only  x Retired instruction counter overflow of low 32 bits interrupt pending.
 *                           Set when mreinstl overflows. Cleared by a write to mrinsth. 
 * MTIMEINCIP   Read-only  x Request to increment mtime interrupt pending. Set when cyclecnt
 *                           increments to (1<<MTIMETAP). Cleared by any write to mtime.
 * MEIP         Read-only  x External interrupt pending. Set by external interrupt source.
 *                           Clearable by writing to external interrupt source
 * SEIP         Read-only  0
 * UEIP         Read-only  0
 * MTIP         Read/spes  x Time compare interrupt pending. Set by code in internal interrupt
 *                           when mtime >= mtimecmp. Should not be set by other user code.
 *                           Cleared when mtimecmp or mtimecmph is written.
 * STIP         Read-only  0
 * UTIP         Read-only  0
 * MSIP         Read/write x Software interrupt pending. Set.cleared by write to MSIPreg address.
 * SSIP         Read-only  0
 * USIP         Read-only  0
 * 
 * register MIE
 * ------------
 * 31 19 17          16         15 12 11   10   9    8    7    6    5    4    3    2    1    0
 * WPRI  MRINSTRETIE MTIMEINCIE WPRI  MEIE WPRI SEIE UEIE MTIE WPRI STIE UTIE MSIE WPRI SSIE USIE
 * 
 * Field        Access     Contents/Comment
 * WPRI         Read-only  0
 * MRINSTRETTIE Read/write x  Software controlled.           
 * MTIMEINCIE   Read/write x  Software controlled.           
 * MEIE         Read/write x  Software controlled
 * SEIE         Read-only  0
 * UEIE         Read-only  0
 * MTIE         Read/write x  Software controlled
 * STIE         Read-only  0
 * UTIE         Read-only  0
 * MSIE         Read/write x  With only M-mode implemented, and only one hart, there is no real
 *                            sense to implement this bit in hardware. However, to be compatible
 *                            I implement it after all.
 * SSIE         Read-only  0
 * USIE         Read-only  0
 *
 * register MSTATUS
 * ----------------
 * 31 30 23 22  21 20  19  18  17   16 15   14 13   12:11    10 9 8   7    6    5    4    3   2    1   0
 * SD WPRI  TSR TW TVM MXR SUM MPRV XS[1:0] FS[1:0] MPP[1:0] WPRI SPP MPIE WPRI SPIE UPIE MIE WPRI SIE UIE
 * 
 * Field      Access     Contents/Comment
 * WPRI  
 * SD         Read-only  0 XS and FS hardwired to zero
 * TSR        Read-only  0 S-mode not supported
 * TW         Read-only  0 No modes less privileged than M-mode
 * TVM        Read-only  0 S-mode not supported
 * MXR        Read-only  0 S-mode not supported
 * SUM        Read-only  0 S-mode not supported
 * MPRV       Read-only  0 U-mode not supported
 * XS[1:0]    Read-only  0 No floating point
 * FS[1:0]    Read-only  0 No floating point
 * MPP[1:0]   Read-only  3 The only mode that is implemented is Machine-mode
 * SPP        Read-only  0
 * MPIE       Read/Write x
 * SPIE       Read-only  0
 * UPIE       Read-only  0
 * MIE        Read/write x  Global interrupt enable
 * SIE        Read-only  0
 * UIE        Read-only  0
 * 
 */
module m_status_and_interrupts
  # ( parameter 
      HIGHLEVEL = 1,
      HAS_MINSTRET = 0,
      HAS_EBR_MINSTRET = 0      
      )
   (
    /* verilator lint_off UNUSED */
    input        clk,
    input        alu_tapout, //      True when ttime[MTIMETA] increments from 0 to 1, and isWttime is true
    input        alu_minstretofl, // True when minstret overflows in 32 bits.
    input [31:0] B, //               ALU result, used in "ij" 
    input [31:0] DAT_O, //           From EBR
    input [31:0] ADR_O, //           Address
    input        sa38, //              | Shows if we enters traps, executes "ij", or enters CSR emulation
    input        sa39, //              |
    input        meip, //            External interrupt pending
    input        ctrlreg_we, //      User code writes to EBR with address in ADR_O. To find out if we write to mtime, minstreth, mip,mie,mstatus or bit mtip
    output       mrinstretip, //       |
    output       mtimeincip, //        | These are all registers.
    output       mtip, //              |
    output       msip, //              |
    output       mrinstretie, //       |
    output       mtimeincie, //        |
    output       meie, //              |
    output       mtie, //              |
    output       msie, //              |
    output       mpie, //              |
    output       mie, //               | 
    output       qualint, //         qualified interrupt pending
    output       m_status_and_interrupts_killwarnings
    /* verilator lint_on UNUSED */
    );

   reg           r_incsr;

   assign m_status_and_interrupts_killwarnings = &B | &DAT_O | &ADR_O;
   
   generate
      if ( HIGHLEVEL ) begin
         // =============================================================================
         // HIGHLEVEL
         // =============================================================================

         /* mtimeincip is set when the cycle counter increments to (1<<MTIMETAP).
          * When user code writes mtime, mtimeincip is cleared
          */
         wire       write_to_mtime = ctrlreg_we & ADR_O[13]; 
         reg        r_mtimeincip;
         always @(posedge clk)
           r_mtimeincip <= ( alu_tapout | r_mtimeincip)  & ~write_to_mtime;
         
         /* minstrethip is set when the retired instruction counter overflows in 32 bits.
          * When user code write minstreth, minstretip is cleared
          */
         wire       the_r_minstrethip;
         if ( HAS_EBR_MINSTRET || HAS_EBR_MINSTRET ) begin
            reg        r_minstrethip;
            wire       write_to_minstreth = ctrlreg_we & ADR_O[14];
            wire       cmb_minstrethip = (alu_minstretofl | r_minstrethip ) & ~write_to_minstreth;
            always @(posedge clk)         
              r_minstrethip <= cmb_minstrethip;
            assign the_r_minstrethip = r_minstrethip;
         end else begin
            assign the_r_minstrethip = 1'b0;
         end
         
         /* MTIP is set under software control, this should only be used
          * by the internal interrupt routine that increments {mtimeh,mtime}. 
          * It is cleared when mtimecmp or mtimecmph is written. 
          */
         reg        r_mtip;
         wire       write_to_mtip      = ctrlreg_we & ADR_O[15];
         wire       write_to_mtimecmpx = ctrlreg_we & ADR_O[19];
         wire       cmb_mtip = (write_to_mtip | r_mtip) & ~write_to_mtimecmpx;
         always @(posedge clk) 
            r_mtip <= cmb_mtip;
         
         /* MSIP is only under software control. This is possible because we have only one hart.
          */
         wire       write_to_msip =  ctrlreg_we & ADR_O[18];
         reg        r_msip;
         always @(posedge clk)
           r_msip <= (~write_to_msip & r_msip) | (write_to_msip & DAT_O[3]);
         
         /* Selective interrupt enable bits in mie are implemented in a straight forward fashion
          */
         wire       write_to_mie = ctrlreg_we & ADR_O[17];
         reg        r_mrinstretie,r_mtimeincie,r_meie,r_mtie,r_msie;
         always @(posedge clk) begin
            r_mrinstretie <= (~write_to_mie & r_mrinstretie) | ( write_to_mie & DAT_O[17] );
            r_mtimeincie  <= (~write_to_mie & r_mtimeincie ) | ( write_to_mie & DAT_O[16] );
            r_meie        <= (~write_to_mie & r_meie       ) | ( write_to_mie & DAT_O[11] );
            r_mtie        <= (~write_to_mie & r_mtie       ) | ( write_to_mie & DAT_O[7] );
            r_msie        <= (~write_to_mie & r_msie       ) | ( write_to_mie & DAT_O[3] );      
         end
         
         /* Register mpie is involved. 
          *   o The user code can write it.
          *     Here we must see if we have (writeIO & ADR_O[2])
          *   o When an interrupt is taken, mpie <= mie
          *     Microcode sets sa[39:38] to isr_intoTrap
          *   o When a trap occurs, mpie <= mie
          *     Microcode sets sa[39:38] to isr_intoTrap
          *   o When MRET is executed, mpie <= 1
          *     Instruction "ij" will have B[1] == 1 in this case, and sa[39:38] is isr_use_ij
          *   o When accessing an illegal CSR and transferring control to a trap, mpie <= mie
          *     Instruction "ij" will have B[0] == 1 in this case, and sa[39:38] is isr_use_ij
          */
         wire write_to_mstatus = ctrlreg_we & ADR_O[16];
         reg  r_mpie,r_mie;
         wire isr_use_ij = ~sa39 & sa38;
         wire isr_intoCSR = sa39 & ~sa38;
         wire isr_intoTrap = sa39 & sa38;
         wire update_mpie = 
              write_to_mstatus    |
              isr_intoTrap        | 
              (isr_use_ij & B[1]) |
              (isr_use_ij & B[0]);
         wire value_new_mpie = 
              (write_to_mstatus & DAT_O[7]) | 
              (isr_intoTrap & r_mie)    |
              (isr_use_ij & B[1] )      |
              (isr_use_ij & B[0] & r_mie);
         always @(posedge clk)
           if ( update_mpie )
             r_mpie <= value_new_mpie;
         
         /* Register mie is involved.
          *   o The user code can write it.
          *     Here we must see if we have (writeIO & ADR_O[2])
          *   o When an interrupt is taken, mie <= 0
          *     Microcode sets sa[39:38] to isr_intoTrap
          *   o When a trap occurs, mie <= 0
          *     Microcode sets sa[39:38] to isr_intoTrap
          *   o When MRET is executed, mie <= mpie
          *     Instruction "ij" will have B[1] == 1 in this case, and sa[39:38] is isr_use_ij
          *   o When accessing an illegal CSR and transferring control to a trap, mie <= 0
          *     Instruction "ij" will have B[0] == 1 in this case, and sa[39:38] is isr_use_ij
          */
         wire update_mie = update_mpie;
         wire value_new_mie =
              (write_to_mstatus & DAT_O[3]) |
              (isr_intoTrap & 1'b0)     |
              (isr_use_ij & B[1] & r_mpie) |
              (isr_use_ij & B[0] & 1'b0);
         always @(posedge clk)
           if (update_mie)
             r_mie <= value_new_mie;
         
         /* An internal register is set while we are in a CSR emulation routine
          */
         always @(posedge clk)
           r_incsr <= isr_intoCSR | (r_incsr & ~isr_use_ij);
         
         /*                                               __     _
          * mie -----------------------------------------|  |---| |-- qualint
          * r_incsr ------------------------------------o|  |   >_|
          *                                    ____      |  |
          * mrinstretip --| |-----------------|    |-----|__|
          * mrinstretie --|&|  +--------------|    |
          *                    |  +-----------| or |
          * mtimeincip ---| |--+  |  +--------|    |
          * mtimeincie ---|&|     |  |  +-----|____|
          *                       |  |  |
          * meip ---------| |-----+  |  |
          * meie ---------|&|        |  |
          *                          |  |
          * mtip ---------| |--------+  |
          * mtie ---------|&|           |
          *                             |
          * msip ---------| |-----------+
          * msie ---------|&|
          */ 
         wire possible_interrupt = 
              (mrinstretip & mrinstretie) |        
              (mtimeincip  & mtimeincie ) |
              (meip        & meie       ) |
              (mtip        & mtie       ) |
              (msip        & msie       );  
         wire cmb_qualint = possible_interrupt & r_mie & ~r_incsr;
         reg  r_qualint;
         always @(posedge clk)
           r_qualint <= cmb_qualint;
         assign qualint = r_qualint;
         
         /* Registers that can be read by user code are output from this module
          */
         // In register mip
         // -----------------------------------------
         assign mrinstretip = the_r_minstrethip;
         assign mtimeincip  = r_mtimeincip;
         //     meip          comes from the outside
         assign mtip        = r_mtip;
         assign msip        = r_msip;
         // In register mie
         // -----------------------------------------
         assign mrinstretie= r_mrinstretie;
         assign mtimeincie = r_mtimeincie;
         assign meie       = r_meie;
         assign mtie       = r_mtie;
         assign msie       = r_msie;
         // In register mstatus
         // -----------------------------------------
         assign mpie       = r_mpie;
         assign mie        = r_mie;
         
      end else begin
         // =============================================================================
         // LOWLEVEL
         // =============================================================================
         reg  r_mie;

         
         /* mtimeincip is set when the cycle counter increments to (1<<MTIMETAP).
          * When user code writes mtime, mtimeincip is cleared
          */
         //wire       write_to_mtime = ctrlreg_we & ADR_O[13]; 
         //reg        r_mtimeincip;
         //always @(posedge clk)
         //  r_mtimeincip <= ( alu_tapout | r_mtimeincip)  & ~write_to_mtime;
         wire cmb_mtimeincip, r_mtimeincip;
         SB_LUT4 #(.LUT_INIT(16'h0eee)) mtimeincip_l( .O(cmb_mtimeincip), .I3(ctrlreg_we), .I2(ADR_O[13]), .I1(r_mtimeincip), .I0(alu_tapout));         
         SB_DFF mtimeincip_reg( .Q(r_mtimeincip), .C(clk), .D(cmb_mtimeincip) );
         
         /* minstrethip is set when the retired instruction counter overflows in 32 bits.
          * When user code write minstreth, minstretip is cleared
          */
//         wire       write_to_minstreth = ctrlreg_we & ADR_O[14];
//         wire       cmb_minstrethip = (alu_minstretofl | r_minstrethip ) & ~write_to_minstreth;
//         always @(posedge clk)         
//           r_minstrethip <= cmb_minstrethip;
         wire r_minstrethip;
         if ( HAS_EBR_MINSTRET || HAS_EBR_MINSTRET ) begin
            wire cmb_minstrethip;
            SB_LUT4 #(.LUT_INIT(16'h0eee)) minstrethip_l( .O(cmb_minstrethip), .I3(ctrlreg_we), .I2(ADR_O[14]), .I1(r_minstrethip), .I0(alu_minstretofl));         
            SB_DFF minstrethip_reg( .Q(r_minstrethip), .C(clk), .D(cmb_minstrethip) );
         end else begin
            assign r_minstrethip = 1'b0;
         end
         
         /* MTIP is set under software control, this should only be used
          * by the internal interrupt routine that increments {mtimeh,mtime}. 
          * It is cleared when mtimecmp or mtimecmph is written. 
          */
         // wire write_to_mtip      = ctrlreg_we & ADR_O[15];
         // wire write_to_mtimecmpx = ctrlreg_we & ADR_O[19];
         // wire cmb_mtip = (write_to_mtip | r_mtip) & ~write_to_mtimecmpx;
         // always @(posedge clk) begin
         //    r_mtip <= cmb_mtip;
         wire cmb_mtip,r_mtip;
         SB_LUT4 #(.LUT_INIT(16'h0caa)) mtip_l( .O(cmb_mtip), .I3(ctrlreg_we), .I2(ADR_O[19]), .I1(ADR_O[15]), .I0(r_mtip));         
         SB_DFF mtip_reg( .Q(r_mtip), .C(clk), .D(cmb_mtip) );
         
         /* MSIP is only under software control. This is possible because we have only one hart.
          */
         //wire       write_to_msip =  ctrlreg_we & ADR_O[18];
         //reg        r_msip;
         //always @(posedge clk)
         //  r_msip <= (~write_to_msip & r_msip) | (write_to_msip & DAT_O[3]);
         wire cmb_msip,r_msip;
         SB_LUT4 #(.LUT_INIT(16'hcaaa)) msip_l( .O(cmb_msip), .I3(ctrlreg_we), .I2(ADR_O[18]), .I1(DAT_O[3]), .I0(r_msip));         
         SB_DFF msip_reg( .Q(r_msip), .C(clk), .D(cmb_msip) );
         
         /* Selective interrupt enable bits in mie are implemented in a straight forward fashion
          */
         //wire       write_to_mie = ctrlreg_we & ADR_O[17];
         //reg        r_mrinstretie,r_mtimeincie,r_meie,r_mtie,r_msie;
         //always @(posedge clk) begin
         //   r_mrinstretie <= (~write_to_mie & r_mrinstretie) | ( write_to_mie & DAT_O[17] );
         //   r_mtimeincie  <= (~write_to_mie & r_mtimeincie ) | ( write_to_mie & DAT_O[16] );
         //   r_meie        <= (~write_to_mie & r_meie       ) | ( write_to_mie & DAT_O[11] );
         //   r_mtie        <= (~write_to_mie & r_mtie       ) | ( write_to_mie & DAT_O[7] );
         //   r_msie        <= (~write_to_mie & r_msie       ) | ( write_to_mie & DAT_O[3] );      
         //end
         wire r_mrinstretie,cmb_mrinstretie,r_mtimeincie,cmb_mtimeincie,r_meie,cmb_meie,r_mtie,cmb_mtie,r_msie,cmb_msie;         
         SB_LUT4 #(.LUT_INIT(16'hcaaa)) mrinstretie_l( .O(cmb_mrinstretie), .I3(ctrlreg_we), .I2(ADR_O[17]), .I1(DAT_O[17]), .I0(r_mrinstretie));         
         SB_LUT4 #(.LUT_INIT(16'hcaaa)) mtimeincie_l ( .O(cmb_mtimeincie ), .I3(ctrlreg_we), .I2(ADR_O[17]), .I1(DAT_O[16]), .I0(r_mtimeincie ));         
         SB_LUT4 #(.LUT_INIT(16'hcaaa)) meie_l       ( .O(cmb_meie       ), .I3(ctrlreg_we), .I2(ADR_O[17]), .I1(DAT_O[11]), .I0(r_meie       ));         
         SB_LUT4 #(.LUT_INIT(16'hcaaa)) mtie_l       ( .O(cmb_mtie       ), .I3(ctrlreg_we), .I2(ADR_O[17]), .I1(DAT_O[ 7]), .I0(r_mtie       ));         
         SB_LUT4 #(.LUT_INIT(16'hcaaa)) msie_l       ( .O(cmb_msie       ), .I3(ctrlreg_we), .I2(ADR_O[17]), .I1(DAT_O[ 3]), .I0(r_msie       ));         
         SB_DFF mrinstretie_reg( .Q(r_mrinstretie), .C(clk), .D(cmb_mrinstretie) );
         SB_DFF mtimeincie_reg ( .Q(r_mtimeincie ), .C(clk), .D(cmb_mtimeincie ) );
         SB_DFF meie_reg       ( .Q(r_meie       ), .C(clk), .D(cmb_meie       ) );
         SB_DFF mtie_reg       ( .Q(r_mtie       ), .C(clk), .D(cmb_mtie       ) );
         SB_DFF msie_reg       ( .Q(r_msie       ), .C(clk), .D(cmb_msie       ) );
         
         /* Register mpie is involved. 
          *   o The user code can write it.
          *     Here we must see if we have write to mstatus, ctrlreg_we & ADR_O[16]
          *   o When an interrupt is taken, mpie <= mie
          *     Microcode sets sa[39:38] to isr_intoTrap
          *   o When a trap occurs, mpie <= mie
          *     Microcode sets sa[39:38] to isr_intoTrap
          *   o When MRET is executed, mpie <= 1
          *     Instruction "ij" will have B[1] == 1 in this case, and sa[39:38] is isr_use_ij
          *   o When accessing an illegal CSR and transferring control to a trap, mpie <= mie
          *     Instruction "ij" will have B[0] == 1 in this case, and sa[39:38] is isr_use_ij
          */
         //wire write_to_mstatus = ctrlreg_we & ADR_O[16];
         //reg  r_mpie,r_mie;
         //wire isr_use_ij = ~sa39 & sa38;
         //wire isr_intoTrap = sa39 & sa38;
         //wire update_mpie = 
         //     write_to_mstatus    |
         //     isr_intoTrap        | 
         //     (isr_use_ij & B[1]) |
         //     (isr_use_ij & B[0]);
         //wire value_new_mpie = 
         //     (write_to_mstatus & DAT_O[7]) | 
         //     (isr_intoTrap & r_mie)    |
         //     (isr_use_ij & B[1] )      |
         //     (isr_use_ij & B[0] & r_mie);
         //always @(posedge clk)
         //  if ( update_mpie )
         //    r_mpie <= value_new_mpie;
         wire write_to_mstatus,isr_intoTrap,isr_use_ij;
         wire update_mie_mpie;
         SB_LUT4 #(.LUT_INIT(16'h8888)) write_to_mstatus_l(.O(write_to_mstatus), .I3(1'b0), .I2(1'b0), .I1(ctrlreg_we), .I0(ADR_O[16]));
         SB_LUT4 #(.LUT_INIT(16'h8888)) isr_intoTrap_l(.O(isr_intoTrap), .I3(1'b0), .I2(1'b0), .I1(sa39), .I0(sa38));
         SB_LUT4 #(.LUT_INIT(16'h2222)) isr_use_ij_l(  .O(isr_use_ij),   .I3(1'b0), .I2(1'b0), .I1(sa39), .I0(sa38));         
         wire tmp = B[1] | B[0];
         SB_LUT4 #(.LUT_INIT(16'hfeee)) update_mie_mpie_l(  .O(update_mie_mpie), .I3(tmp), .I2(isr_use_ij), .I1(isr_intoTrap), .I0(write_to_mstatus));         

         wire mpiea; //  = (isr_use_ij & B[1] ) | (isr_use_ij & B[0] & r_mie);
         wire mpieb; //  = (write_to_mstatus & DAT_O[7]) | (isr_intoTrap & r_mie);
         wire r_mpie; // if ( update_mie_mpie ) r_mpie = mpiea ? 1 : mpieb;
         SB_LUT4 #(.LUT_INIT(16'hf800)) mpiea_l(  .O(mpiea), .I3(isr_use_ij), .I2(B[1]), .I1(B[0]), .I0(r_mie));
         SB_LUT4 #(.LUT_INIT(16'hf888)) mpieb_l(  .O(mpieb), .I3(write_to_mstatus), .I2(DAT_O[7]), .I1(isr_intoTrap), .I0(r_mie));         
         SB_DFFESS reg_mpie( .Q(r_mpie), .C(clk), .E(update_mie_mpie), .S(mpiea), .D(mpieb));
         
         /* Register mie is involved.
          *   o The user code can write it.
          *     Here we must see if we have write to mstatus
          *   o When an interrupt is taken, mie <= 0
          *     Microcode sets sa[39:38] to isr_intoTrap
          *   o When a trap occurs, mie <= 0
          *     Microcode sets sa[39:38] to isr_intoTrap
          *   o When MRET is executed, mie <= mpie
          *     Instruction "ij" will have B[1] == 1 in this case, and sa[39:38] is isr_use_ij
          *   o When accessing an illegal CSR and transferring control to a trap, mie <= 0
          *     Instruction "ij" will have B[0] == 1 in this case, and sa[39:38] is isr_use_ij
          */
// With this: Size 361 LUTs
         wire value_new_mie =
              (write_to_mstatus & DAT_O[3]) |
              (isr_use_ij & B[1] & r_mpie);
         always @(posedge clk)
           if (update_mie_mpie)
             r_mie <= value_new_mie;
         
// With this: Size 365 LUTs even though it was a reverse engineering of the above.
// Completely baffeled here         
//         wire miea; // = isr_use_ij & B[1] & r_mpie;
//         wire mieb; // = miea | (write_to_mstatus & DAT_O[3]);
//         wire r_mie; // = if ( update_mie ) r_mie = mieb;
//         SB_LUT4 #(.LUT_INIT(16'hc000)) miea_l(  .O(miea), .I3(r_mpie), .I2(isr_use_ij), .I1(B[1]), .I0(update_mie_mpie));
//         SB_LUT4 #(.LUT_INIT(16'h8888)) mieb_l(  .O(mieb), .I3(1'b0), .I2(1'b0), .I1(write_to_mstatus), .I0(DAT_O[3]));         
//         SB_DFFESS reg_mie( .Q(r_mie), .C(clk), .E(update_mie_mpie), .S(miea), .D(mieb)); // Different PLB than SB_DFFESS above.
         
         
         /* An internal register is set while we are in a CSR emulation routine
          */
         //wire isr_intoCSR = sa39 & ~sa38;
         //always @(posedge clk)
         //  r_incsr <= isr_intoCSR | (r_incsr & ~isr_use_ij);
         wire cmb_incsr,rr_incsr;
         SB_LUT4 #(.LUT_INIT(16'h4f44)) incsr_l(  .O(cmb_incsr), .I3(sa39), .I2(sa38), .I1(rr_incsr), .I0(isr_use_ij));
         SB_DFF reg_incsr( .Q(rr_incsr), .C(clk), .D(cmb_incsr));
         always @(*)
           r_incsr = rr_incsr;
         /*                                               ___           __
          * mie -----------------------------------------|   |---------|  |-- qualint
          * r_incsr ------------------------------------o| & |         >__|
          * meip ---------| |-----------------|    |-----|___|          
          * meie ---------|&|         +-------| or |         
          *                           | +-----|____|
          * mrinstretip---| |----|  |-+ |
          * mrinstretie---|&|  +-|or|   |
          *                    |        |
          * mtimeincip ---| |--+        |
          * mtimeincie ---|&|           |
          *                             |
          * mtip ---------| |----|  |---+
          * mtie ---------|&|  +-|or|
          *                    |
          * msip ---------| |--+
          * msie ---------|&|
          */ 
         //wire possible_interrupt = 
         //     (mrinstretip & mrinstretie) |        
         //     (mtimeincip  & mtimeincie ) |
         //     (meip        & meie       ) |
         //     (mtip        & mtie       ) |
         //     (msip        & msie       );  
         //wire cmb_qualint = possible_interrupt & r_mie & ~r_incsr;
         //reg  r_qualint;
         //always @(posedge clk)
         //  r_qualint <= cmb_qualint;
         //assign qualint = r_qualint;
         wire pia,pib,pic,cmb_qualint;
         SB_LUT4 #(.LUT_INIT(16'hf888)) pia_l( .O(pia       ), .I3(msie      ), .I2(msip      ), .I1(mtip       ), .I0(mtie       ));         
         SB_LUT4 #(.LUT_INIT(16'hf888)) pib_l( .O(pib       ), .I3(mtimeincie), .I2(mtimeincip), .I1(mrinstretip), .I0(mrinstretie));
         SB_LUT4 #(.LUT_INIT(16'hfeee)) pic_l( .O(pic), .I3(meie), .I2(meip), .I1(pia), .I0(pib));
         SB_LUT4 #(.LUT_INIT(16'h4040)) qualint_l( .O(cmb_qualint), .I3(1'b0), .I2(pic), .I1(mie), .I0(r_incsr));         
         SB_DFF qualint_reg( .Q(qualint), .C(clk), .D(cmb_qualint) );
         
         
         /* Registers that can be read by user code are output from this module
          */
         // In register mip
         // -----------------------------------------
         assign mrinstretip = r_minstrethip;
         assign mtimeincip  = r_mtimeincip;
         //     meip          comes from the outside
         assign mtip        = r_mtip;
         assign msip        = r_msip;
         // In register mie
         // -----------------------------------------
         assign mrinstretie= r_mrinstretie;
         assign mtimeincie = r_mtimeincie;
         assign meie       = r_meie;
         assign mtie       = r_mtie;
         assign msie       = r_msie;
         // In register mstatus
         // -----------------------------------------
         assign mpie       = r_mpie;
         assign mie        = r_mie;
         
      end   
   endgenerate
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * ucode holds the microcode of midgetv in three EBRs, or two EBRs and some logic.
 * This module is a wrapper to assign control lines to a distinct data out of EBR.
 * 
 */
module m_ucode
  # ( parameter NO_UCODEOPT = 0,
      parameter MULDIV = 0,
      parameter RVC = 0,
      parameter HAS_MINSTRET = 0,
      parameter HAS_EBR_MINSTRET = 0
      )
   (
    input        clk,
    input [7:0]  minx,
    input        progress_ucode, // Hold when shifting
    output       sa00, // sa02,sa03,sa04,sa05,sa06,
    output [1:0] s_alu_carryin,
    output [2:0] s_alu,
    output [1:0] s_shift,
    output [1:0] s_cyclecnt,
    output       sa11,sa12, sa14,sa15,
    output       sa20,sa21,sa22,sa23,sa24,sa25,sa26,sa27,sa28,sa29,
    output       sa30, sa32,sa33,sa34, sa37,sa38,sa39,
    output       sa40,sa41,sa42,sa43,
    output       clrM,
    output       ceM,
    output       potentialMODbranch,
    output       ctrl_pcinc_by_2,
    output [7:0] rinx,
    output       ucode_killwarnings
    );
`ifdef verilator
   function [47:0] get_sa;
      // verilator public
      get_sa = d;
   endfunction
`endif
   localparam UCODETYPE =
                         (RVC    ? 8 : 0 ) +
                         (MULDIV ? 4 : 0 ) +
                         (HAS_MINSTRET ? 2 : 0 ) +
                         (HAS_EBR_MINSTRET ? 1 : 0 );
   
   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   wire [47:0]          d;                      // From inst_3ebr of m_3ebr.v, ...
   // End of automatics
   generate
      if ( NO_UCODEOPT == 1 ) begin
         m_3ebr #(.UCODETYPE(UCODETYPE)) inst_3ebr
           (/*AUTOINST*/
            // Outputs
            .d                          (d[47:0]),
            // Inputs
            .clk                        (clk),
            .minx                       (minx[7:0]),
            .progress_ucode             (progress_ucode));
      end else begin
         if ( UCODETYPE == 4'b0000 ) begin
            v0_m_2ebr inst_2ebr
              (/*AUTOINST*/
               // Outputs
               .d                       (d[47:0]),
               // Inputs
               .clk                     (clk),
               .minx                    (minx[7:0]),
               .progress_ucode          (progress_ucode));
         end else if ( UCODETYPE == 4'b0010 ) begin
            v2_m_2ebr inst_2ebr
              (/*AUTOINST*/
               // Outputs
               .d                       (d[47:0]),
               // Inputs
               .clk                     (clk),
               .minx                    (minx[7:0]),
               .progress_ucode          (progress_ucode));
         end else if ( UCODETYPE == 4'b0011 ) begin
            v3_m_2ebr inst_2ebr
              (/*AUTOINST*/
               // Outputs
               .d                       (d[47:0]),
               // Inputs
               .clk                     (clk),
               .minx                    (minx[7:0]),
               .progress_ucode          (progress_ucode));
         end else if ( UCODETYPE == 4'b0100 ) begin
            v4_m_2ebr inst_2ebr
              (/*AUTOINST*/
               // Outputs
               .d                       (d[47:0]),
               // Inputs
               .clk                     (clk),
               .minx                    (minx[7:0]),
               .progress_ucode          (progress_ucode));
         end else if ( UCODETYPE == 4'b0110 ) begin
            v6_m_2ebr inst_2ebr
              (/*AUTOINST*/
               // Outputs
               .d                       (d[47:0]),
               // Inputs
               .clk                     (clk),
               .minx                    (minx[7:0]),
               .progress_ucode          (progress_ucode));
         end else if ( UCODETYPE == 4'b0111 ) begin
            v7_m_2ebr inst_2ebr
              (/*AUTOINST*/
               // Outputs
               .d                       (d[47:0]),
               // Inputs
               .clk                     (clk),
               .minx                    (minx[7:0]),
               .progress_ucode          (progress_ucode));
         end else if ( UCODETYPE == 4'b1000 ) begin
            v8_m_2ebr inst_2ebr
              (/*AUTOINST*/
               // Outputs
               .d                       (d[47:0]),
               // Inputs
               .clk                     (clk),
               .minx                    (minx[7:0]),
               .progress_ucode          (progress_ucode));
         end else if ( UCODETYPE == 4'b1010 ) begin
            v10_m_2ebr inst_2ebr
              (/*AUTOINST*/
               // Outputs
               .d                       (d[47:0]),
               // Inputs
               .clk                     (clk),
               .minx                    (minx[7:0]),
               .progress_ucode          (progress_ucode));
         end else if ( UCODETYPE == 4'b1011 ) begin
            v11_m_2ebr inst_2ebr
              (/*AUTOINST*/
               // Outputs
               .d                       (d[47:0]),
               // Inputs
               .clk                     (clk),
               .minx                    (minx[7:0]),
               .progress_ucode          (progress_ucode));
         end else if ( UCODETYPE == 4'b1100 ) begin
            v12_m_2ebr inst_2ebr
              (/*AUTOINST*/
               // Outputs
               .d                       (d[47:0]),
               // Inputs
               .clk                     (clk),
               .minx                    (minx[7:0]),
               .progress_ucode          (progress_ucode));
         end else if ( UCODETYPE == 4'b1110 ) begin
            v14_m_2ebr inst_2ebr
              (/*AUTOINST*/
               // Outputs
               .d                       (d[47:0]),
               // Inputs
               .clk                     (clk),
               .minx                    (minx[7:0]),
               .progress_ucode          (progress_ucode));
         end else if ( UCODETYPE == 4'b1111 ) begin
            v15_m_2ebr inst_2ebr
              (/*AUTOINST*/
               // Outputs
               .d                       (d[47:0]),
               // Inputs
               .clk                     (clk),
               .minx                    (minx[7:0]),
               .progress_ucode          (progress_ucode));         
         end
      end
   endgenerate
   
   assign rinx = d[7:0];
   assign sa00 = d[ 8];
   assign s_alu_carryin = d[10:9]; //       Carry in select
   assign s_alu         = d[13:11]; //      Alu operation
   assign s_cyclecnt    = d[19:18]; //      rcount mix, +3/+4 mux
   assign s_shift       = {d[20],d[21]}; // Shift counter selection.
   
   
   assign sa11 = d[30]; // Immediate expand exactly when we use dinx.
   assign sa12 = d[15]; // u_io_i_latch
   assign sa14 = d[16]; // nReset Q
   assign sa15 = d[17]; // Part of enable to Q
   assign sa20 = d[22]; // | Governs read address mux
   assign sa21 = d[23]; // | Governs read address mux
   assign sa22 = d[24]; // | Governs read address mux
   assign sa23 = d[25]; // | Governs read address mux
   assign sa24 = d[26]; // | Governs write address mux
   assign sa25 = d[27]; // | Governs write address mux
   assign sa26 = d[28]; // | Governs write address mux
   assign sa27 = d[29]; // | Governs write address mux
   assign sa28 = d[30]; // use_dinx
   assign sa29 = d[31]; // Adr0Mustbe0
   assign sa30 = d[32]; // Adr1Mustbe0     
   assign sa32 = d[33]; // Part of enable to Q
   assign sa33 = d[34]; // Control freeze of control when shifting
   assign sa34 = d[35]; // Modify input mux.
   assign sa37 = d[14]; // use_brcond
   assign sa38 = d[36]; // | isr_none/isr_use_uj/isr_intoCSR/isr_intoTrap
   assign sa39 = d[37]; // |
   assign sa40 = d[38]; // Select signal for rai
   assign sa41 = d[39]; // Latch SEL signals etc
   assign sa42 = d[40]; // Possibly activate STB_O or sram_stb
   assign sa43 = d[41]; // Possibly activate WE_O next cycle

   generate
      if ( MULDIV == 0 && RVC == 1 ) begin
         assign ctrl_pcinc_by_2 = d[42]; // May perhaps combine with another controleq?
         assign clrM = d[43];               // Fake! R for M register. Also used to flag unsigned subtraction in DIV/DIVU/REM/REMU
         assign ceM  = d[44];               // Fake! CE for M register. Also used by m_condcode
         assign potentialMODbranch = d[45]; // Fake! Distinguish DIV or MOD
      end else begin
         assign clrM = d[42]; // R for M register. Also used to flag unsigned subtraction in DIV/DIVU/REM/REMU
         assign ceM  = d[43]; // CE for M register. Also used by m_condcode
         assign potentialMODbranch = d[44]; // Distinguish DIV or MOD
         assign ctrl_pcinc_by_2 = d[45]; // May perhaps combine with another controleq?
      end
   endgenerate
   assign ucode_killwarnings = &d[47:46]; // ???
endmodule

/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * Simply 3 EBRs used as a ROM for control equations. We could in theory use 
 * logic instead but that is a terrible idea. Note. Verilator not able to 
 * simulate this theoretic case either.
 */
module m_3ebr
  # (  parameter UCODETYPE = 0, EXPERIMENT_AVOID_EBR = 0 )
  (
   input         clk,
   input [7:0]   minx,
   input         progress_ucode,
   output [47:0] d
   );
   
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019-2020. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------
 * Automaticaly generated by ../bin/midgetv_genucode (based on ../code/ucode.h).
 * Do not edit.
 */
/*
 * =================================================
 * * Version 0.                                    *
 * =================================================
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       d2 LB_2       0010001010000000101111101100001xx1        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       be IJ_1       0110010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     e6 StdIncPc   0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     e6 StdIncPc   0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 LB_3       07 LB_4       0010000000000000011011101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * 07 LB_4       09 LB_5       0010000000000000010111101100011xx0        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 08 _L0x08     5a SB_1       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_5       8b LB_6       0010000000000000010111101100000xx0        q = D^0xffffffff^q = D^0x80                       00000000 
 * 0a _L0x0a     5a SB_1       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b JALR_2     86 JAL_2      0000000001101100001011101000011xx0        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001xx0 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      10 SUB_1      0010000000000000111011x01000xxxxx0 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 SUB_1      8b LB_6       0010000000000000111111101100000xx0        Q = ~RS2                                          00000000 
 * 11 AND_1      1a ANDI_1     0010000000000000111011101100000xx0        RS1^0xffffffff to Q                               00000000 
 * 12 _L0x12     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           00000000 
 * 13 condb_2    14 condb_3    0010000000000000111111101100000xx0        ~RS2 in Q                                         00000000 
 * 14 condb_3    15 condb_4    0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 15 condb_4    16 condb_5    0000000000001000110011101101001xx0        Branch on condition                               00000000 
 * 16 condb_5    de Fetch      0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 17 condb_5t   74 BrOpFet    0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 18 BEQ        13 condb_2    0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     41 JALR_1     0000000000001100101011101000100000 JALR   yy=RS1+imm                                        00000067 jalr    
 * 1a ANDI_1     e6 StdIncPc   0000000000000100001011101000011xx0        rd = Iimm & RS1                                   00000000 
 * 1b _L0x1b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   a6 ECAL_RET   0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d ORI_2      e6 StdIncPc   0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 1e aFault_1   d4 aFault_2   0010000000000000101011001100100110        Q = 4                                             00000000 
 * 1f IJ_2       b7 IJ_3       0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 20 LH_0       52 LH_1       0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 XORI_1     e6 StdIncPc   0000000000000100001011101000000xx0        rd = Iimm ^ RS1                                   00000000 
 * 22 _L0x22     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           0000100b close to ij
 * 23 _L0x23     e6 StdIncPc   0010000000000000001011x01000xxxxx0 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     35 SLLI_1     0010000000000000111100100x00110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011x00100xxxxx0 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 OR_1       27 OR_2       0000000000001000111011101000000xx0        RS1^0xffffffff to jj                              00000000 
 * 27 OR_2       1d ORI_2      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 28 _L0x28     96 SH_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 XOR_1      21 XORI_1     0010000000000000111011101100000xx0        Q = RS1^0xFFFFFFFF                                00000000 
 * 2a _L0x2a     96 SH_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b SLTIX_1    30 SLTIX_2    0010000000000000xxxx11101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 2c SLL_0      3e SLL_1      0010000000000000111011x00x00xxxxx0 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e unx2e         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 2e: Not in use                                           40001033 sloppy sll     
 * 2f _L0x2f     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SLTIX_2    e6 StdIncPc   0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 31 SLTX_1     2b SLTIX_1    0010000000000000111111101100000xx0        ~rs2 to Q                                         00000000 
 * 32 JAL_1      86 JAL_2      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 33 JAERR_1    81 JAERR_2    0000000000001111001011100x00100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 34 JAL_3      de Fetch      0100000010001010110111100100001xx0        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 35 SLLI_1     36 SLLI_2     0000000000000100101101101100001xx0        Register to shift to Q (and TRG for shift 0)      00000000 
 * 36 SLLI_2     03 _L0x03     0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 37 ECALL_2    d7 ECALL_3    0000000000001101xxxx11101001001xx0        mepc = pc, prep store 0 to mtval                  00000000 
 * 38 BNE        13 condb_2    0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 _L0x39     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           00001067 close to jalr
 * 3a SRxI_1     3d SRxI_2     0000000000000100101001101100001xx1        Register to shift to Q                            00000000 
 * 3b _L0x3b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    49 CSRRW_1    0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d SRxI_2     03 _L0x03     0000000100000100101001101100001xx1        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 3e SLL_1      35 SLLI_1     0010000000000000111100100x00001xx0        Shiftamount was in low 5 bits of RS2              00000000 
 * 3f SRx_1      3a SRxI_1     0010000000000000111100100x00001xx0        Shiftamount in low 5 bits of RS2                  00000000 
 * 40 LW_0       50 LW_1       0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 JALR_1     0b JALR_2     0010000000000000110011101100100110        Q=1                                               00000000 
 * 42 _L0x42     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           0000200b close to ij
 * 43 _L0x43     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           0000200f close to fence
 * 44 SLTI_0     2b SLTIX_1    0010000000000000111111101100010xx0 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 WFI_3      65 WFI_4      0010000000000000101011101100100110        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105        00000000 
 * 46 ILL_1      47 ILL_2      0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 47 ILL_2      8f ILL_3      0000000000001111101011101000001xx0        Store 0 to mtval                                  00000000 
 * 48 _L0x48     66 SW_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 CSRRW_1    4b CSRRW_2    0010000000000000001011101100100110        Construct PC storage adr                          00000000 
 * 4a _L0x4a     66 SW_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b CSRRW_2    b1 CSRRW_3    0000100000000011101011100100001xx0        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 4c SLT_0      31 SLTX_1     0010000000000000111011x01000xxxxx0 SLT    Set less than (signed)                            00002033 slt     
 * 4d unx4d         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 4d: Not in use                                           00000000 
 * 4e eILL0b     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40002033 sloppy slt     
 * 4f MRET_8     e6 StdIncPc   0010000000000000101011101100100110        Prep +4                                           00000000 
 * 50 LW_1       e6 StdIncPc   0001000010000100101111101000001xx0        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 51 LDAF_LW    da LDAF_a     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 52 LH_1       54 LH_2       0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 53 LDAF_LH    da LDAF_a     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 54 LH_2       eb LH_3       0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 55 aFaultb    1e aFault_1   0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 56 LH_4       57 LH_5       0010000000000000100011101100011xx0        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 57 LH_5       8b LB_6       0010000000000000100011101100000xx0        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 58 _L0x58     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           00002063 close to branch
 * 59 _L0x59     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           00002067 close to jalr
 * 5a SB_1       5d SB_2       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5b _L0x5b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    49 CSRRW_1    0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SB_2       fb SB_3       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 5e LHU_1      70 LHU_2      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 5f LDAF_LHU   da LDAF_a     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 60 _L0x60     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           00003003 close to load
 * 61 EBRKWFI2   f7 EBREAK_1   0000000000001000011011101001010xx0 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 62 _L0x62     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           0000300b close to ij
 * 63 _L0x63     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           0000300f close to fence
 * 64 SLTIU_0    2b SLTIX_1    0010000000000000111111101100010xx0 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 WFI_4      ef WFI_5      0010000000000000001011x01001xxxxx0        Prepare read PC                                   00000000 
 * 66 SW_1       f2 SW_2       0000000000000011111011100100001xx0        Write d to a+k until accepted                     00000000 
 * 67 SW_E1SWE   93 SW_E2      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 68 _L0x68     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           00003023 close to store
 * 69 unx69         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 69: Not in use                                           00000000 
 * 6a _L0x6a     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           40003023 close to store
 * 6b SB_4       7a SB_5       1110000000000010110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 6c SLTU_0     31 SLTX_1     0010000000000000111011x01000xxxxx0 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d unx6d         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 6d: Not in use                                           00000000 
 * 6e unx6e         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 6e: Not in use                                           40003033 sloppy sltu    
 * 6f MRET_6     cf MRET_7     0010000000000000xxxx11101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 70 LHU_2      ba LHU_3      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 71 aFaultc    1e aFault_1   0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 72 LBU_3      1a ANDI_1     0010000000000000011011101100010xx0        Invert q. Prepare read mask                       00000000 
 * 73 BAERR_1    76 BAERR_2    0000000000001111110011101000001xx0        Faultadr to mtval. Prepare get offset             00000000 
 * 74 BrOpFet    f4 Fetch2     0011001010000000101111101010110000 NewOp2 Read until instruction latched                    00000000 
 * 75 BAlignEr   73 BAERR_1    0010000000000000001011x00x00xxxxx0  Err   Branch target instruction address misaligned      00000000 
 * 76 BAERR_2    77 BAERR_3    0010000000000000001011101100000xx0        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 77 BAERR_3    7d BAERR_4    0000000000001101101011100x00100110        origPC to mepc. Prep read 0                       00000000 
 * 78 _L0x78     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           00003063 close to branch
 * 79 _L0x79     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           00003067 close to jalr
 * 7a SB_5       f2 SW_2       0000000000000010110011100100001xx0        Write d to a+k until accepted                     00000000 
 * 7b _L0x7b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    49 CSRRW_1    0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d BAERR_4    34 JAL_3      0000110000001110100111100x00001xx0        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 7e NMI_1      90 NMI_2      0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * 7f JALRE2     7d BAERR_4    0000000000001111101011100x00001xx0        mtval is target                                   00000000 
 * 80 LBU_0      85 LBU_1      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 JAERR_2    7d BAERR_4    0000000000001101101011100x00001xx0        Store PC to mepc                                  00000000 
 * 82 _L0x82     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           0000400b close to ij
 * 83 _L0x83     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           0000400f close to fence
 * 84 XORI_0     21 XORI_1     0010000000000000111111101100010xx0 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 LBU_1      f0 LBU_2      0010001010000000101111101100001xx1        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 86 JAL_2      9e JAL_25     0000000000000100001011000x00100110        Return address to TRG                             00000000 
 * 87 JALRE1     7f JALRE2     0000000000001101110011100x00001xx0  err   Store pc to mepc                                  00000000 
 * 88 _L0x88     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           00004023 close to store
 * 89 unx89         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 89: Not in use                                           00000000 
 * 8a _L0x8a     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           40004023 close to store
 * 8b LB_6       e6 StdIncPc   0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 8c XOR_0      29 XOR_1      0010000000000000111111x01000xxxxx0 XOR    xor                                               00004033 xor     
 * 8d unx8d         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 8d: Not in use                                           00000000 
 * 8e _LCSRRS_1  fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40004033 sloppy xor     
 * 8f ILL_3      a9 ILL_4      0010000000000000101011101100100110        Q = 1                                             00000000 
 * 90 NMI_2      34 JAL_3      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 91 LDAF_2     92 LDAF_3     0000110000001110001011000x00100110        Store 4 to mcause                                 00000000 
 * 92 LDAF_3     34 JAL_3      0000000000001101100111100x00001xx0        PC to mepc                                        00000000 
 * 93 SW_E2      95 SW_E3      0000000000001101101111101000001xx0        Store address that faulted                        00000000 
 * 94 SW_E4      34 JAL_3      0000110000001110100111100x00101000        Store 6 to mcause                                 00000000 
 * 95 SW_E3      94 SW_E4      0010000000000000101111001100100110        Q = 3                                             00000000 
 * 96 SH_1       bb SH_2       0000000000001100101101101100001xx0        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 97 SW_E1SWH   93 SW_E2      0000000000001111001011100x00110000        Store faulting address alignment to mtval         00000000 
 * 98 BLT        13 condb_2    0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           00004067 close to jalr
 * 9a ECALL_6    34 JAL_3      0000110000001110100111000x00100000        mcause = 11                                       00000000 
 * 9b SH_4       9f SH_5       1110000000000001110011101100001xx0        Address back to Q. Prepare get item to write      00000000 
 * 9c _L0x9c     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           00004073 close to csr/system 
 * 9d unx9d         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 9d: Not in use                                           00000000 
 * 9e JAL_25     34 JAL_3      0000000000001000110011100x00001xx0        Instr. adr. to jj in case of access error         00000000 
 * 9f SH_5       f2 SW_2       0000000000000001110011100100001xx0        Write d to a+k until accepted                     00000000 
 * a0 LHU_0      5e LHU_1      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_4    b6 ECALL_5    0010000000000000101011001100100110        Q = 4                                             00000000 
 * a2 _L0xa2     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           0000500b close to ij
 * a3 _L0xa3     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           0000500f close to fence
 * a4 SRxI_0     3a SRxI_1     0010000000000000111100100x00110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_3     af MRET_4     0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * a6 ECAL_RET   d0 ECALL_1    0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * a7 EBRKWFI1   61 EBRKWFI2   0010000000000000xxxx11101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * a8 _L0xa8     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           00005023 close to store
 * a9 ILL_4      34 JAL_3      0000110000001110100111100x00100110        Store 2 to mcause                                 00000000 
 * aa _L0xaa     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           40005023 close to store
 * ab EBREAK_2   9a ECALL_6    0000000000001101101011101000001xx0        pc to mepc                                        00000000 
 * ac _L0xac     3f SRx_1      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad unxad         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ad: Not in use                                           00000000 
 * ae _L0xae     3f SRx_1      0010000000000000111011x00x00xxxxx0 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_4     c5 MRET_5     0010000000000000xxxx11101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b0 aF_SW_3    92 LDAF_3     0000110000001110001011000x00100000        Store 7 to mcause                                 00000000 
 * b1 CSRRW_3    b2 CSRRW_4    0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b2 CSRRW_4    de Fetch      0100000010001000110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b3 unxb3         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx b3: Not in use                                           00000000 
 * b4 i0reserv      (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Not in use, reserved to allow LASTINCH                   00000000 
 * b5 SH_3       9b SH_4       0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b6 ECALL_5    9a ECALL_6    0010000000000000101011001100100110        Q = 8                                             00000000 
 * b7 IJ_3       bd IJ_4       0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b8 BGE        13 condb_2    0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 _L0xb9     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           00005067 close to jalr
 * ba LHU_3      1a ANDI_1     0010000000000000011111101100010xx0        Invert q. Prepare read mask                       00000000 
 * bb SH_2       b5 SH_3       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * bc CSRRWI_0   49 CSRRW_1    0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd IJ_4       de Fetch      0110000010000000110111100100011xx0        Mask and use as PC                                00000000 
 * be IJ_1       1f IJ_2       0010000010000000101111101100001xx0        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * bf IJT_1      c1 IJT_2      0010000010000000101111101100001xx0        Exit CSR, enter trap                              00000000 
 * c0 _L0xc0     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           00006003 close to load
 * c1 IJT_2      e9 IJT_3      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c2 _L0xc2     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           0000600b close to ij
 * c3 _L0xc3     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           0000600f close to fence
 * c4 ORI_0      e1 ORI_1      0000000000001000111111101000010xx0 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_5     6f MRET_6     0010000000000000000011101100010xx0        ~302                                              00000000 
 * c6 IJT_4      47 ILL_2      0000000000001101101011101100011xx0        Mask and store to mepc and Q for read of instr    00000000 
 * c7 QINT_1     cb QINT_2     0000000000001101xxxx11101000001xx0        Store pc to mepc.                                 00000000 
 * c8 _L0xc8     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           00006023 close to store
 * c9 MRET_2     a5 MRET_3     0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * ca _L0xca     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           40006023 close to store
 * cb QINT_2     e6 StdIncPc   0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * cc OR_0       26 OR_1       0010000000000000111111x01000xxxxx0 OR     or                                                00006033 or      
 * cd unxcd         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx cd: Not in use                                           00000000 
 * ce _LCSRRCI_1 fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40006033 sloppy or      
 * cf MRET_7     4f MRET_8     0010000000000000011011x01001xxxxx0        Prepare emulation entry point 0x104               00000000 
 * d0 ECALL_1    37 ECALL_2    0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * d1 MRET_1     c9 MRET_2     0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * d2 LB_2       06 LB_3       0010000100000000101001101100001xx1        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * d3 aFaultd    1e aFault_1   0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * d4 aFault_2   92 LDAF_3     0000110000001110001011100x00100110        Store 5 to mcause                                 00000000 
 * d5 unxd5         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx d5: Not in use                                           00000000 
 * d6 eILL0c     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 00000000 
 * d7 ECALL_3    a1 ECALL_4    0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * d8 BLTU       13 condb_2    0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 _L0xd9     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           00006067 close to jalr
 * da LDAF_a     91 LDAF_2     0010000000000000101011x01000xxxxx0        Extra cycle after error detected write mtval      00000000 
 * db jFault_1   92 LDAF_3     0000000000001110000011100x00100110        Store 1 to mcause                                 00000000 
 * dc CSRRSI_0   49 CSRRW_1    0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd aF_SW_1    e5 aF_SW_2    0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * de Fetch      f4 Fetch2     0000000000001010001111101010110000  Fr00  Read and latch instruction                        00000000 
 * df eFetch     f4 Fetch2     0001001010001010101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * e0 _L0xe0     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           00007003 close to load
 * e1 ORI_1      1d ORI_2      0010000000000000000011101100001xx0        Q = RS1                                           00000000 
 * e2 _L0xe2     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           0000700b close to ij
 * e3 _L0xe3     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           0000700f close to fence
 * e4 ANDI_0     1a ANDI_1     0010000000000000111111101100010xx0 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 aF_SW_2    b0 aF_SW_3    0010000000000000101011001100100110        Q = 4                                             00000000 
 * e6 StdIncPc   de Fetch      0100000010001000110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * e7 aFault     1e aFault_1   0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * e8 _L0xe8     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           00007023 close to store
 * e9 IJT_3      c6 IJT_4      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ea _L0xea     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           40007023 close to store
 * eb LH_3       56 LH_4       0010000000000000011111101100010xx0        q = ~mem[rs1+ofs]                                 00000000 
 * ec AND_0      11 AND_1      0010000000000000111111x01000xxxxx0 AND    And                                               00007033 and     
 * ed unxed         (use dinx) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ed: Not in use                                           00000000 
 * ee eILL0a     fe ILLe       0010000000000000xxxx11x00x00xxxxx0 Illegal instruction seen                                 40007033 sloppy and     
 * ef WFI_5      de Fetch      0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * f0 LBU_2      72 LBU_3      0010000100000000101001101100001xx1        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * f1 aFaulte    1e aFault_1   0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * f2 SW_2       e6 StdIncPc   0010000000000000001011x01000xxxxx0        Prepare read PC                                   00000000 
 * f3 aF_SW      dd aF_SW_1    0010000000000000xxxx11x00100xxxxx0  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * f4 Fetch2        (use dinx) 000000000xx11011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f5 jFault     db jFault_1   0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * f6 WFI_1      fa WFI_2      0010000000000000000011001100100110 WFI    Chk offset=0x105. Now=0xff. Prep 0xff+4 = 0x103   00000000 
 * f7 EBREAK_1   ab EBREAK_2   0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * f8 BGEU       13 condb_2    0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 _L0xf9     fe ILLe       0010000000000000xxxx11x00x00xxxxx0  Not in use (illegal as entry)                           00007067 close to jalr
 * fa WFI_2      45 WFI_3      0010000000000000101011101100100110        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104   00000000 
 * fb SB_3       6b SB_4       0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fc CSRRCI_0   49 CSRRW_1    0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      7e NMI_1      0010000000000000001011x01000xxxxx0 NMI    Get current PC                                    00000000 
 * fe ILLe       46 ILL_1      0010000000000000001011x00x00xxxxx0 Illegal                                                  00000000 
 * ff QINT_0     c7 QINT_1     0010000000000000001011x01000xxxxx0 INT    Get current PC                                    00000000 
 */
localparam v0_u0_0 = 256'h30e6001030e608041886205a008b205a18091007000420e600e620be09d22001;
localparam v0_u0_1 = 256'h30b726d438e630a6303218e620413013207436de48162615001400fe001a008b;
localparam v0_u0_2 = 256'h30e6000030e6003e2630209600212096201d00270004303500e600fe00e62052;
localparam v0_u0_3 = 256'h083a0835090330493032093d00fe301348d72803083608de20812086002b32e6;
localparam v0_u0_4 = 256'h26e600fe0000003108b12066264b2066088f08472665102b00fe00fe260b2050;
localparam v0_u0_5 = 256'h30da097028fb30493032085d00fe00fe008b1857301e09eb30da095430da08e6;
localparam v0_u0_6 = 256'h26cf000000000031087a00fe000000fe309308f240ef102b00fe00fe50f700fe;
localparam v0_u0_7 = 256'h087d089008343049303208f200fe00fe267d00770073b0f40876101a301e09ba;
localparam v0_u0_8 = 256'h26a900fe0000002926e600fe000000fe087f269e09f0102100fe00fe087d2085;
localparam v0_u0_9 = 256'h08f20834000000fe089f203400fe3013309308bb269428340895083426923034;
localparam v0_u0_A = 256'h26c5003f0000003f089a00fe263400fe206130d026af303a00fe00fe26b6205e;
localparam v0_u0_B = 256'h08c1081f18de304928b5101a00fe301320bd269a309b0000000026de26b22092;
localparam v0_u0_C = 256'h404f00fe0000002630e600fe20a500fe08cb1847106f10e100fe00fe30e900fe;
localparam v0_u0_D = 256'hb0f4b0f430e530492692009100fe301330a100fe00002692301e090630c92637;
localparam v0_u0_E = 256'h26de00fe00000011105600fe20c600fe301e26de26b0101a00fe00fe081d00fe;
localparam v0_u0_F = 256'h00c70046007e3049306b264500fe301330ab26fa30db200000dd00e6301e0972;
localparam v0_u1_0 = 256'h10ba03b210ba03bbb0ba23ab017b23ab017b01bb00b110ba00b2837b02fb036b;
localparam v0_u1_1 = 256'h32ba02b310ba82f980b910ba32ba33baab7b2b71233b00bb03fb003003bb03fb;
localparam v0_u1_2 = 256'h10ba000010ba03b0003aa3ab03bba3ab003b23ba00b103c800b2003010bab36b;
localparam v0_u1_3 = 256'h03c803c8129b31ba80b9129b003033ba343a12db12db2b793cb830ba03fb10ba;
localparam v0_u1_4 = 256'h02bb0030000003b20eb983bb00bb83bb3eba36b802bb03fb00300030033b837b;
localparam v0_u1_5 = 256'h3eb902fb32db31ba80b932db00300030023b023b3eba029b3eb902fb3eb912fa;
localparam v0_u1_6 = 256'h003b0000000003b20b3b0030000000303cb80fb900b203fb0030003021ba0030;
localparam v0_u1_7 = 256'h3eb8343a3a7831ba80b90b390030003036b800bb00b002fa3f3a01bb3eba029b;
localparam v0_u1_8 = 256'h02bb0030000003f210ba003000000030373810b002fb03fb0030003036b8036b;
localparam v0_u1_9 = 256'h0739233800000030073b3a70003033ba3cb832db02f33a7836fa367838b03d3a;
localparam v0_u1_A = 256'h003b03b0000003b036ba00303a780030003b82f901bb03c80030003002b3b36b;
localparam v0_u1_B = 256'h02fb02fb037931ba32db01fb003033ba033302b3003a00000000237102b338b0;
localparam v0_u1_C = 256'h01b20030000003f23d3a003001b30030343a36bb003b23fa0030003032ba0030;
localparam v0_u1_D = 256'h2afa28fa3eba31ba383802b2003033ba3eba0030000038b83eba029b21ba00bb;
localparam v0_u1_E = 256'h2b710030000003f201fb0030033300303eba237102b303fb00300030003b0030;
localparam v0_u1_F = 256'h00b200b000b231ba003a02bb003033ba3cba00333eba6fff003100b23eba029b;
localparam v0_u2_0 = 256'h00000080000000800001040000800400008000800080040000800590008a0580;
localparam v0_u2_1 = 256'h00000c8000000080008100000400000005010102000004800080008000800080;
localparam v0_u2_2 = 256'h0000000000000080048004000080040004800000008000800080008000000500;
localparam v0_u2_3 = 256'h0080008000040000008100000080000000000004000001020400040000800000;
localparam v0_u2_4 = 256'h0480008000000080002007810480078100000000048000800080008004800581;
localparam v0_u2_5 = 256'h0000008a00040000008100000080008000800080000000840000008a00000042;
localparam v0_u2_6 = 256'h0480000000000080038000800000008000000000008000800080008000000080;
localparam v0_u2_7 = 256'h0000000000300000008100000080008004000080008000ca0000008000000084;
localparam v0_u2_8 = 256'h00800080000000800c0000800000008000002c00008a00800080008000000580;
localparam v0_u2_9 = 256'h00000000000000800380043000800000000000000c800030000000000c300030;
localparam v0_u2_A = 256'h048000800000008000000080043000800480008104800080008000800c800500;
localparam v0_u2_B = 256'h0082008201820000000400800080000004800c800080000000000d020c800430;
localparam v0_u2_C = 256'h0080008000000080003000800480008000000000008000000080008000000080;
localparam v0_u2_D = 256'h004a000000000000040000800080000000000080000004300000008400000480;
localparam v0_u2_E = 256'h0d02008000000080008000800480008000000d020c8000800080008000800080;
localparam v0_u2_F = 256'h0080008000800000008004800080000000000c80000004000080008000000084;
/*
 * =================================================
 * * Version 2. MINSTRET                           *
 * =================================================
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       d2 LB_2       0010001010000000101111101100001001        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       be IJ_1       0110010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     e6 StdIncPc   0010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     e6 StdIncPc   0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 LB_3       07 LB_4       0010000000000000011011101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * 07 LB_4       09 LB_5       0010000000000000010111101100011000        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 08 _L0x08     5a SB_1       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_5       8b LB_6       0010000000000000010111101100000000        q = D^0xffffffff^q = D^0x80                       00000000 
 * 0a _L0x0a     5a SB_1       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b JALR_2     86 JAL_2      0000000001101100001011101000011000        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001000 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      10 SUB_1      0010000000000000111011001000000000 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 SUB_1      8b LB_6       0010000000000000111111101100000000        Q = ~RS2                                          00000000 
 * 11 AND_1      1a ANDI_1     0010000000000000111011101100000000        RS1^0xffffffff to Q                               00000000 
 * 12 _L0x12     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00000000 
 * 13 condb_2    14 condb_3    0010000000000000111111101100000000        ~RS2 in Q                                         00000000 
 * 14 condb_3    15 condb_4    0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 15 condb_4    16 condb_5    0000000000001000110011101101001000        Branch on condition                               00000000 
 * 16 condb_5    de Fetch      0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 17 condb_5t   74 BrOpFet    0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 18 BEQ        13 condb_2    0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     41 JALR_1     0000000000001100101011101000100000 JALR   yy=RS1+imm                                        00000067 jalr    
 * 1a ANDI_1     e6 StdIncPc   0000000000000100001011101000011000        rd = Iimm & RS1                                   00000000 
 * 1b _L0x1b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   a6 ECAL_RET   0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d ORI_2      e6 StdIncPc   0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 1e aFault_1   d4 aFault_2   0010000000000000101011001100100110        Q = 4                                             00000000 
 * 1f IJ_2       b7 IJ_3       0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 20 LH_0       52 LH_1       0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 XORI_1     e6 StdIncPc   0000000000000100001011101000000000        rd = Iimm ^ RS1                                   00000000 
 * 22 _L0x22     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000100b close to ij
 * 23 _L0x23     e6 StdIncPc   0010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     35 SLLI_1     0010000000000000111100100000110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 OR_1       27 OR_2       0000000000001000111011101000000000        RS1^0xffffffff to jj                              00000000 
 * 27 OR_2       1d ORI_2      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 28 _L0x28     96 SH_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 XOR_1      21 XORI_1     0010000000000000111011101100000000        Q = RS1^0xFFFFFFFF                                00000000 
 * 2a _L0x2a     96 SH_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b SLTIX_1    30 SLTIX_2    0010000000000000000011101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 2c SLL_0      3e SLL_1      0010000000000000111011000000000000 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e unx2e         (use dinx) 0000000000000000000000000000000000 2e: Not in use                                           40001033 sloppy sll     
 * 2f _L0x2f     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SLTIX_2    e6 StdIncPc   0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 31 SLTX_1     2b SLTIX_1    0010000000000000111111101100000000        ~rs2 to Q                                         00000000 
 * 32 JAL_1      86 JAL_2      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 33 JAERR_1    81 JAERR_2    0000000000001111001011100000100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 34 JAL_3      de Fetch      0100000010001010110111100100001000        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 35 SLLI_1     36 SLLI_2     0000000000000100101101101100001000        Register to shift to Q (and TRG for shift 0)      00000000 
 * 36 SLLI_2     03 _L0x03     0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 37 ECALL_2    d7 ECALL_3    0000000000001101000011101001001000        mepc = pc, prep store 0 to mtval                  00000000 
 * 38 BNE        13 condb_2    0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 _L0x39     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00001067 close to jalr
 * 3a SRxI_1     3d SRxI_2     0000000000000100101001101100001001        Register to shift to Q                            00000000 
 * 3b _L0x3b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    49 CSRRW_1    0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d SRxI_2     03 _L0x03     0000000100000100101001101100001001        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 3e SLL_1      35 SLLI_1     0010000000000000111100100000001000        Shiftamount was in low 5 bits of RS2              00000000 
 * 3f SRx_1      3a SRxI_1     0010000000000000111100100000001000        Shiftamount in low 5 bits of RS2                  00000000 
 * 40 LW_0       50 LW_1       0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 JALR_1     0b JALR_2     0010000000000000110011101100100110        Q=1                                               00000000 
 * 42 _L0x42     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000200b close to ij
 * 43 _L0x43     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000200f close to fence
 * 44 SLTI_0     2b SLTIX_1    0010000000000000111111101100010000 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 WFI_3      65 WFI_4      0010000000000000101011101100100110        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105        00000000 
 * 46 ILL_1      47 ILL_2      0000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 47 ILL_2      8f ILL_3      0000000000001111101011101000001000        Store 0 to mtval                                  00000000 
 * 48 _L0x48     66 SW_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 CSRRW_1    4b CSRRW_2    0010000000000000001011101100100110        Construct PC storage adr                          00000000 
 * 4a _L0x4a     66 SW_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b CSRRW_2    b1 CSRRW_3    0000100000000011101011100100001000        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 4c SLT_0      31 SLTX_1     0010000000000000111011001000000000 SLT    Set less than (signed)                            00002033 slt     
 * 4d unx4d         (use dinx) 0000000000000000000000000000000000 4d: Not in use                                           00000000 
 * 4e eILL0b     fe ILLe       0010000000000000000011000000000000 Illegal instruction seen                                 40002033 sloppy slt     
 * 4f MRET_8     e6 StdIncPc   0010000000000000101011101100100110        Prep +4                                           00000000 
 * 50 LW_1       e6 StdIncPc   0001000010000100101111101000001000        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 51 LDAF_LW    da LDAF_a     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 52 LH_1       54 LH_2       0010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 53 LDAF_LH    da LDAF_a     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 54 LH_2       eb LH_3       0010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 55 aFaultb    1e aFault_1   0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 56 LH_4       57 LH_5       0010000000000000100011101100011000        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 57 LH_5       8b LB_6       0010000000000000100011101100000000        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 58 _L0x58     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00002063 close to branch
 * 59 _L0x59     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00002067 close to jalr
 * 5a SB_1       5d SB_2       0000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5b _L0x5b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    49 CSRRW_1    0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SB_2       fb SB_3       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 5e LHU_1      70 LHU_2      0010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 5f LDAF_LHU   da LDAF_a     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 60 _L0x60     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00003003 close to load
 * 61 EBRKWFI2   f7 EBREAK_1   0000000000001000011011101001010000 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 62 _L0x62     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000300b close to ij
 * 63 _L0x63     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000300f close to fence
 * 64 SLTIU_0    2b SLTIX_1    0010000000000000111111101100010000 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 WFI_4      ef WFI_5      0010000000000000001011001001000000        Prepare read PC                                   00000000 
 * 66 SW_1       f2 SW_2       0000000000000011111011100100001000        Write d to a+k until accepted                     00000000 
 * 67 SW_E1SWE   93 SW_E2      0000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 68 _L0x68     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00003023 close to store
 * 69 unx69         (use dinx) 0000000000000000000000000000000000 69: Not in use                                           00000000 
 * 6a _L0x6a     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           40003023 close to store
 * 6b SB_4       7a SB_5       1110000000000010110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 6c SLTU_0     31 SLTX_1     0010000000000000111011001000000000 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d unx6d         (use dinx) 0000000000000000000000000000000000 6d: Not in use                                           00000000 
 * 6e unx6e         (use dinx) 0000000000000000000000000000000000 6e: Not in use                                           40003033 sloppy sltu    
 * 6f MRET_6     cf MRET_7     0010000000000000000011101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 70 LHU_2      ba LHU_3      0010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 71 aFaultc    1e aFault_1   0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 72 LBU_3      1a ANDI_1     0010000000000000011011101100010000        Invert q. Prepare read mask                       00000000 
 * 73 BAERR_1    76 BAERR_2    0000000000001111110011101000001000        Faultadr to mtval. Prepare get offset             00000000 
 * 74 BrOpFet    f4 Fetch2     0011001010000000101111101010110000 NewOp2 Read until instruction latched                    00000000 
 * 75 BAlignEr   73 BAERR_1    0010000000000000001011000000000000  Err   Branch target instruction address misaligned      00000000 
 * 76 BAERR_2    77 BAERR_3    0010000000000000001011101100000000        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 77 BAERR_3    7d BAERR_4    0000000000001101101011100000100110        origPC to mepc. Prep read 0                       00000000 
 * 78 _L0x78     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00003063 close to branch
 * 79 _L0x79     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00003067 close to jalr
 * 7a SB_5       f2 SW_2       0000000000000010110011100100001000        Write d to a+k until accepted                     00000000 
 * 7b _L0x7b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    49 CSRRW_1    0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d BAERR_4    34 JAL_3      0000110000001110100111100000001000        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 7e NMI_1      90 NMI_2      0000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * 7f JALRE2     7d BAERR_4    0000000000001111101011100000001000        mtval is target                                   00000000 
 * 80 LBU_0      85 LBU_1      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 JAERR_2    7d BAERR_4    0000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 82 _L0x82     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000400b close to ij
 * 83 _L0x83     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000400f close to fence
 * 84 XORI_0     21 XORI_1     0010000000000000111111101100010000 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 LBU_1      f0 LBU_2      0010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 86 JAL_2      9e JAL_25     0000000000000100001011000000100110        Return address to TRG                             00000000 
 * 87 JALRE1     7f JALRE2     0000000000001101110011100000001000  err   Store pc to mepc                                  00000000 
 * 88 _L0x88     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00004023 close to store
 * 89 unx89         (use dinx) 0000000000000000000000000000000000 89: Not in use                                           00000000 
 * 8a _L0x8a     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           40004023 close to store
 * 8b LB_6       e6 StdIncPc   0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 8c XOR_0      29 XOR_1      0010000000000000111111001000000000 XOR    xor                                               00004033 xor     
 * 8d unx8d         (use dinx) 0000000000000000000000000000000000 8d: Not in use                                           00000000 
 * 8e _LCSRRS_1  fe ILLe       0010000000000000000011000000000000 Illegal instruction seen                                 40004033 sloppy xor     
 * 8f ILL_3      a9 ILL_4      0010000000000000101011101100100110        Q = 1                                             00000000 
 * 90 NMI_2      34 JAL_3      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 91 LDAF_2     92 LDAF_3     0000110000001110001011000000100110        Store 4 to mcause                                 00000000 
 * 92 LDAF_3     34 JAL_3      0000000000001101100111100000001000        PC to mepc                                        00000000 
 * 93 SW_E2      95 SW_E3      0000000000001101101111101000001000        Store address that faulted                        00000000 
 * 94 SW_E4      34 JAL_3      0000110000001110100111100000101000        Store 6 to mcause                                 00000000 
 * 95 SW_E3      94 SW_E4      0010000000000000101111001100100110        Q = 3                                             00000000 
 * 96 SH_1       bb SH_2       0000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 97 SW_E1SWH   93 SW_E2      0000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 98 BLT        13 condb_2    0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00004067 close to jalr
 * 9a ECALL_6    34 JAL_3      0000110000001110100111000000100000        mcause = 11                                       00000000 
 * 9b SH_4       9f SH_5       1110000000000001110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 9c _L0x9c     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00004073 close to csr/system 
 * 9d unx9d         (use dinx) 0000000000000000000000000000000000 9d: Not in use                                           00000000 
 * 9e JAL_25     34 JAL_3      0000000000001000110011100000001000        Instr. adr. to jj in case of access error         00000000 
 * 9f SH_5       f2 SW_2       0000000000000001110011100100001000        Write d to a+k until accepted                     00000000 
 * a0 LHU_0      5e LHU_1      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_4    b6 ECALL_5    0010000000000000101011001100100110        Q = 4                                             00000000 
 * a2 _L0xa2     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000500b close to ij
 * a3 _L0xa3     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000500f close to fence
 * a4 SRxI_0     3a SRxI_1     0010000000000000111100100000110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_3     af MRET_4     0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * a6 ECAL_RET   d0 ECALL_1    0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * a7 EBRKWFI1   61 EBRKWFI2   0010000000000000000011101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * a8 _L0xa8     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00005023 close to store
 * a9 ILL_4      34 JAL_3      0000110000001110100111100000100110        Store 2 to mcause                                 00000000 
 * aa _L0xaa     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           40005023 close to store
 * ab EBREAK_2   9a ECALL_6    0000000000001101101011101000001000        pc to mepc                                        00000000 
 * ac _L0xac     3f SRx_1      0010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad unxad         (use dinx) 0000000000000000000000000000000000 ad: Not in use                                           00000000 
 * ae _L0xae     3f SRx_1      0010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_4     c5 MRET_5     0010000000000000000011101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b0 aF_SW_3    92 LDAF_3     0000110000001110001011000000100000        Store 7 to mcause                                 00000000 
 * b1 CSRRW_3    b2 CSRRW_4    0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b2 CSRRW_4    de Fetch      0100000010001000110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b3 unxb3         (use dinx) 0000000000000000000000000000000000 b3: Not in use                                           00000000 
 * b4 eFetch3       (use dinx) 0000000000011001111111101100100110  Fr10  Update minstret, Q=immediate. Use dinx            00000000 
 * b5 SH_3       9b SH_4       0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b6 ECALL_5    9a ECALL_6    0010000000000000101011001100100110        Q = 8                                             00000000 
 * b7 IJ_3       bd IJ_4       0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b8 BGE        13 condb_2    0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 _L0xb9     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00005067 close to jalr
 * ba LHU_3      1a ANDI_1     0010000000000000011111101100010000        Invert q. Prepare read mask                       00000000 
 * bb SH_2       b5 SH_3       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * bc CSRRWI_0   49 CSRRW_1    0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd IJ_4       de Fetch      0110000010000000110111100100011000        Mask and use as PC                                00000000 
 * be IJ_1       1f IJ_2       0010000010000000101111101100001000        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * bf IJT_1      c1 IJT_2      0010000010000000101111101100001000        Exit CSR, enter trap                              00000000 
 * c0 _L0xc0     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00006003 close to load
 * c1 IJT_2      e9 IJT_3      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c2 _L0xc2     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000600b close to ij
 * c3 _L0xc3     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000600f close to fence
 * c4 ORI_0      e1 ORI_1      0000000000001000111111101000010000 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_5     6f MRET_6     0010000000000000000011101100010000        ~302                                              00000000 
 * c6 IJT_4      47 ILL_2      0000000000001101101011101100011000        Mask and store to mepc and Q for read of instr    00000000 
 * c7 QINT_1     cb QINT_2     0000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * c8 _L0xc8     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00006023 close to store
 * c9 MRET_2     a5 MRET_3     0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * ca _L0xca     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           40006023 close to store
 * cb QINT_2     e6 StdIncPc   0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * cc OR_0       26 OR_1       0010000000000000111111001000000000 OR     or                                                00006033 or      
 * cd unxcd         (use dinx) 0000000000000000000000000000000000 cd: Not in use                                           00000000 
 * ce _LCSRRCI_1 fe ILLe       0010000000000000000011000000000000 Illegal instruction seen                                 40006033 sloppy or      
 * cf MRET_7     4f MRET_8     0010000000000000011011001001000000        Prepare emulation entry point 0x104               00000000 
 * d0 ECALL_1    37 ECALL_2    0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * d1 MRET_1     c9 MRET_2     0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * d2 LB_2       06 LB_3       0010000100000000101001101100001001        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * d3 aFaultd    1e aFault_1   0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * d4 aFault_2   92 LDAF_3     0000110000001110001011100000100110        Store 5 to mcause                                 00000000 
 * d5 eFetch2    b4 eFetch3    0000000000001011000111111000100000  Fr10  Update ttime                                      00000000 
 * d6 eILL0c     fe ILLe       0010000000000000000011000000000000 Illegal instruction seen                                 00000000 
 * d7 ECALL_3    a1 ECALL_4    0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * d8 BLTU       13 condb_2    0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 _L0xd9     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00006067 close to jalr
 * da LDAF_a     91 LDAF_2     0010000000000000101011001000000000        Extra cycle after error detected write mtval      00000000 
 * db jFault_1   92 LDAF_3     0000000000001110000011100000100110        Store 1 to mcause                                 00000000 
 * dc CSRRSI_0   49 CSRRW_1    0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd aF_SW_1    e5 aF_SW_2    0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * de Fetch      f4 Fetch2     0000000000001010001111101010110000  Fr10  Read and latch instruction                        00000000 
 * df eFetch     d5 eFetch2    0001001010001010101111101010110000  Fr10  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * e0 _L0xe0     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00007003 close to load
 * e1 ORI_1      1d ORI_2      0010000000000000000011101100001000        Q = RS1                                           00000000 
 * e2 _L0xe2     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000700b close to ij
 * e3 _L0xe3     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000700f close to fence
 * e4 ANDI_0     1a ANDI_1     0010000000000000111111101100010000 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 aF_SW_2    b0 aF_SW_3    0010000000000000101011001100100110        Q = 4                                             00000000 
 * e6 StdIncPc   de Fetch      0100000010001000110111000100100110  Fr10  IncPC, OpFetch                                    00000000 
 * e7 aFault     1e aFault_1   0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * e8 _L0xe8     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00007023 close to store
 * e9 IJT_3      c6 IJT_4      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ea _L0xea     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           40007023 close to store
 * eb LH_3       56 LH_4       0010000000000000011111101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * ec AND_0      11 AND_1      0010000000000000111111001000000000 AND    And                                               00007033 and     
 * ed unxed         (use dinx) 0000000000000000000000000000000000 ed: Not in use                                           00000000 
 * ee eILL0a     fe ILLe       0010000000000000000011000000000000 Illegal instruction seen                                 40007033 sloppy and     
 * ef WFI_5      de Fetch      0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * f0 LBU_2      72 LBU_3      0010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * f1 aFaulte    1e aFault_1   0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * f2 SW_2       e6 StdIncPc   0010000000000000001011001000000000        Prepare read PC                                   00000000 
 * f3 aF_SW      dd aF_SW_1    0010000000000000000011000100000000  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * f4 Fetch2        (use dinx) 0000000000011011111111111100100000  Fr10  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f5 jFault     db jFault_1   0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * f6 WFI_1      fa WFI_2      0010000000000000000011001100100110 WFI    Chk offset=0x105. Now=0xff. Prep 0xff+4 = 0x103   00000000 
 * f7 EBREAK_1   ab EBREAK_2   0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * f8 BGEU       13 condb_2    0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 _L0xf9     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00007067 close to jalr
 * fa WFI_2      45 WFI_3      0010000000000000101011101100100110        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104   00000000 
 * fb SB_3       6b SB_4       0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fc CSRRCI_0   49 CSRRW_1    0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      7e NMI_1      0010000000000000001011001000000000 NMI    Get current PC                                    00000000 
 * fe ILLe       46 ILL_1      0010000000000000001011000000000000 Illegal                                                  00000000 
 * ff QINT_0     c7 QINT_1     0010000000000000001011001000000000 INT    Get current PC                                    00000000 
 */
localparam v2_u0_0 = 256'h30e6001030e608041886205a008b205a18091007000420e600e620be09d22001;
localparam v2_u0_1 = 256'h30b726d438e630a6303218e620413013207436de48162615001400fe001a008b;
localparam v2_u0_2 = 256'h30e6000030e6003e2630209600212096201d00270004303500e600fe00e62052;
localparam v2_u0_3 = 256'h083a0835090330493032093d00fe301348d72803083608de20812086002b32e6;
localparam v2_u0_4 = 256'h26e600fe0000003108b12066264b2066088f08472665102b00fe00fe260b2050;
localparam v2_u0_5 = 256'h30da097028fb30493032085d00fe00fe008b1857301e09eb30da095430da08e6;
localparam v2_u0_6 = 256'h26cf000000000031087a00fe000000fe309308f240ef102b00fe00fe50f700fe;
localparam v2_u0_7 = 256'h087d089008343049303208f200fe00fe267d00770073b0f40876101a301e09ba;
localparam v2_u0_8 = 256'h26a900fe0000002926e600fe000000fe087f269e09f0102100fe00fe087d2085;
localparam v2_u0_9 = 256'h08f20834000000fe089f203400fe3013309308bb269428340895083426923034;
localparam v2_u0_A = 256'h26c5003f0000003f089a00fe263400fe206130d026af303a00fe00fe26b6205e;
localparam v2_u0_B = 256'h08c1081f18de304928b5101a00fe301320bd269a309b2600000026de26b22092;
localparam v2_u0_C = 256'h404f00fe0000002630e600fe20a500fe08cb1847106f10e100fe00fe30e900fe;
localparam v2_u0_D = 256'hb0d5b0f430e530492692009100fe301330a100fe20b42692301e090630c92637;
localparam v2_u0_E = 256'h26de00fe00000011105600fe20c600fe301e26de26b0101a00fe00fe081d00fe;
localparam v2_u0_F = 256'h00c70046007e3049306b264500fe301330ab26fa30db200000dd00e6301e0972;
localparam v2_u1_0 = 256'h10ba03b210ba03bbb0ba23ab017b23ab017b01bb00b110ba00b2837b02fb036b;
localparam v2_u1_1 = 256'h32ba02b310ba82f980b910ba32ba33baab7b2b71233b00bb03fb003003bb03fb;
localparam v2_u1_2 = 256'h10ba000010ba03b0003aa3ab03bba3ab003b23ba00b103c800b2003010bab36b;
localparam v2_u1_3 = 256'h03c803c8129b31ba80b9129b003033ba343a12db12db2b793cb830ba03fb10ba;
localparam v2_u1_4 = 256'h02bb0030000003b20eb983bb00bb83bb3eba36b802bb03fb00300030033b837b;
localparam v2_u1_5 = 256'h3eb902fb32db31ba80b932db00300030023b023b3eba029b3eb902fb3eb912fa;
localparam v2_u1_6 = 256'h003b0000000003b20b3b0030000000303cb80fb900b203fb0030003021ba0030;
localparam v2_u1_7 = 256'h3eb8343a3a7831ba80b90b390030003036b800bb00b002fa3f3a01bb3eba029b;
localparam v2_u1_8 = 256'h02bb0030000003f210ba003000000030373810b002fb03fb0030003036b8036b;
localparam v2_u1_9 = 256'h0739233800000030073b3a70003033ba3cb832db02f33a7836fa367838b03d3a;
localparam v2_u1_A = 256'h003b03b0000003b036ba00303a780030003b82f901bb03c80030003002b3b36b;
localparam v2_u1_B = 256'h02fb02fb037931ba32db01fb003033ba033302b3003a67fb0000237102b338b0;
localparam v2_u1_C = 256'h01b20030000003f23d3a003001b30030343a36bb003b23fa0030003032ba0030;
localparam v2_u1_D = 256'h2afa28fa3eba31ba383802b2003033ba3eba00302c7e38b83eba029b21ba00bb;
localparam v2_u1_E = 256'h2b710030000003f201fb0030033300303eba237102b303fb00300030003b0030;
localparam v2_u1_F = 256'h00b200b000b231ba003a02bb003033ba3cba00333eba6fff003100b23eba029b;
localparam v2_u2_0 = 256'h00000080000000800001040000800400008000800080040000800590008a0580;
localparam v2_u2_1 = 256'h00000c8000000080008100000400000005010102000004800080008000800080;
localparam v2_u2_2 = 256'h0000000000000080048004000080040004800000008000800080008000000500;
localparam v2_u2_3 = 256'h0080008000040000008100000080000000000004000001020400040000800000;
localparam v2_u2_4 = 256'h0480008000000080002007810480078100000000048000800080008004800581;
localparam v2_u2_5 = 256'h0000008a00040000008100000080008000800080000000840000008a00000042;
localparam v2_u2_6 = 256'h0480000000000080038000800000008000000000008000800080008000000080;
localparam v2_u2_7 = 256'h0000000000300000008100000080008004000080008000ca0000008000000084;
localparam v2_u2_8 = 256'h00800080000000800c0000800000008000002c00008a00800080008000000580;
localparam v2_u2_9 = 256'h00000000000000800380043000800000000000000c800030000000000c300030;
localparam v2_u2_A = 256'h048000800000008000000080043000800480008104800080008000800c800500;
localparam v2_u2_B = 256'h0082008201820000000400800080000004800c800080040000000d020c800430;
localparam v2_u2_C = 256'h0080008000000080003000800480008000000000008000000080008000000080;
localparam v2_u2_D = 256'h004a000000000000040000800080000000000080040004300000008400000480;
localparam v2_u2_E = 256'h0d02008000000080008000800480008000000d020c8000800080008000800080;
localparam v2_u2_F = 256'h0080008000800000008004800080000000000c80000004000080008000000084;
/*
 * =================================================
 * * Version 3. MINSTRET EBR_MINSTRET              *
 * =================================================
 *                             Microcode instruction
 * uPC           next uPC      44333333333322222222221111111111
 * || label      || next label 1098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ---------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       d2 LB_2       0010001010000000101111101100001001        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       be IJ_1       0110010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     e6 StdIncPc   0010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     e6 StdIncPc   0000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 LB_3       07 LB_4       0010000000000000011011101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * 07 LB_4       09 LB_5       0010000000000000010111101100011000        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 08 _L0x08     5a SB_1       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_5       8b LB_6       0010000000000000010111101100000000        q = D^0xffffffff^q = D^0x80                       00000000 
 * 0a _L0x0a     5a SB_1       0000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b JALR_2     86 JAL_2      0000000001101100001011101000011000        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 0c ADD_0      04 ADDI_0     0010000000000000111011101100001000 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      10 SUB_1      0010000000000000111011001000000000 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 SUB_1      8b LB_6       0010000000000000111111101100000000        Q = ~RS2                                          00000000 
 * 11 AND_1      1a ANDI_1     0010000000000000111011101100000000        RS1^0xffffffff to Q                               00000000 
 * 12 _L0x12     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00000000 
 * 13 condb_2    14 condb_3    0010000000000000111111101100000000        ~RS2 in Q                                         00000000 
 * 14 condb_3    15 condb_4    0010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 15 condb_4    16 condb_5    0000000000001000110011101101001000        Branch on condition                               00000000 
 * 16 condb_5    de Fetch      0100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 17 condb_5t   74 BrOpFet    0100000001101010110111101100100000        Branch taken.                                     00000000 
 * 18 BEQ        13 condb_2    0000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     41 JALR_1     0000000000001100101011101000100000 JALR   yy=RS1+imm                                        00000067 jalr    
 * 1a ANDI_1     e6 StdIncPc   0000000000000100001011101000011000        rd = Iimm & RS1                                   00000000 
 * 1b _L0x1b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   a6 ECAL_RET   0010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d ORI_2      e6 StdIncPc   0000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 1e aFault_1   d4 aFault_2   0010000000000000101011001100100110        Q = 4                                             00000000 
 * 1f IJ_2       b7 IJ_3       0000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 20 LH_0       52 LH_1       0100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 XORI_1     e6 StdIncPc   0000000000000100001011101000000000        rd = Iimm ^ RS1                                   00000000 
 * 22 _L0x22     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000100b close to ij
 * 23 _L0x23     e6 StdIncPc   0010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     35 SLLI_1     0010000000000000111100100000110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 OR_1       27 OR_2       0000000000001000111011101000000000        RS1^0xffffffff to jj                              00000000 
 * 27 OR_2       1d ORI_2      0010000000000000000011101100100000        Q = rs2                                           00000000 
 * 28 _L0x28     96 SH_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 XOR_1      21 XORI_1     0010000000000000111011101100000000        Q = RS1^0xFFFFFFFF                                00000000 
 * 2a _L0x2a     96 SH_1       0000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b SLTIX_1    30 SLTIX_2    0010000000000000000011101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 2c SLL_0      3e SLL_1      0010000000000000111011000000000000 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e unx2e         (use dinx) 0000000000000000000000000000000000 2e: Not in use                                           40001033 sloppy sll     
 * 2f _L0x2f     e6 StdIncPc   0000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SLTIX_2    e6 StdIncPc   0000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 31 SLTX_1     2b SLTIX_1    0010000000000000111111101100000000        ~rs2 to Q                                         00000000 
 * 32 JAL_1      86 JAL_2      0000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 33 JAERR_1    81 JAERR_2    0000000000001111001011100000100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 34 JAL_3      de Fetch      0100000010001010110111100100001000        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 35 SLLI_1     36 SLLI_2     0000000000000100101101101100001000        Register to shift to Q (and TRG for shift 0)      00000000 
 * 36 SLLI_2     03 _L0x03     0000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 37 ECALL_2    d7 ECALL_3    0000000000001101000011101001001000        mepc = pc, prep store 0 to mtval                  00000000 
 * 38 BNE        13 condb_2    0000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 _L0x39     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00001067 close to jalr
 * 3a SRxI_1     3d SRxI_2     0000000000000100101001101100001001        Register to shift to Q                            00000000 
 * 3b _L0x3b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    49 CSRRW_1    0000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d SRxI_2     03 _L0x03     0000000100000100101001101100001001        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 3e SLL_1      35 SLLI_1     0010000000000000111100100000001000        Shiftamount was in low 5 bits of RS2              00000000 
 * 3f SRx_1      3a SRxI_1     0010000000000000111100100000001000        Shiftamount in low 5 bits of RS2                  00000000 
 * 40 LW_0       50 LW_1       0110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 JALR_1     0b JALR_2     0010000000000000110011101100100110        Q=1                                               00000000 
 * 42 _L0x42     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000200b close to ij
 * 43 _L0x43     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000200f close to fence
 * 44 SLTI_0     2b SLTIX_1    0010000000000000111111101100010000 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 WFI_3      65 WFI_4      0010000000000000101011101100100110        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105        00000000 
 * 46 ILL_1      47 ILL_2      0000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 47 ILL_2      8f ILL_3      0000000000001111101011101000001000        Store 0 to mtval                                  00000000 
 * 48 _L0x48     66 SW_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 CSRRW_1    4b CSRRW_2    0010000000000000001011101100100110        Construct PC storage adr                          00000000 
 * 4a _L0x4a     66 SW_1       1110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b CSRRW_2    b1 CSRRW_3    0000100000000011101011100100001000        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 4c SLT_0      31 SLTX_1     0010000000000000111011001000000000 SLT    Set less than (signed)                            00002033 slt     
 * 4d unx4d         (use dinx) 0000000000000000000000000000000000 4d: Not in use                                           00000000 
 * 4e eILL0b     fe ILLe       0010000000000000000011000000000000 Illegal instruction seen                                 40002033 sloppy slt     
 * 4f MRET_8     e6 StdIncPc   0010000000000000101011101100100110        Prep +4                                           00000000 
 * 50 LW_1       e6 StdIncPc   0001000010000100101111101000001000        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 51 LDAF_LW    da LDAF_a     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 52 LH_1       54 LH_2       0010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 53 LDAF_LH    da LDAF_a     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 54 LH_2       eb LH_3       0010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 55 aFaultb    1e aFault_1   0000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 56 LH_4       57 LH_5       0010000000000000100011101100011000        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 57 LH_5       8b LB_6       0010000000000000100011101100000000        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 58 _L0x58     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00002063 close to branch
 * 59 _L0x59     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00002067 close to jalr
 * 5a SB_1       5d SB_2       0000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5b _L0x5b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    49 CSRRW_1    0000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SB_2       fb SB_3       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 5e LHU_1      70 LHU_2      0010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 5f LDAF_LHU   da LDAF_a     0000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 60 _L0x60     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00003003 close to load
 * 61 EBRKWFI2   f7 EBREAK_1   0000000000001000011011101001010000 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 62 _L0x62     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000300b close to ij
 * 63 _L0x63     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000300f close to fence
 * 64 SLTIU_0    2b SLTIX_1    0010000000000000111111101100010000 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 WFI_4      ef WFI_5      0010000000000000001011001001000000        Prepare read PC                                   00000000 
 * 66 SW_1       f2 SW_2       0000000000000011111011100100001000        Write d to a+k until accepted                     00000000 
 * 67 SW_E1SWE   93 SW_E2      0000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 68 _L0x68     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00003023 close to store
 * 69 unx69         (use dinx) 0000000000000000000000000000000000 69: Not in use                                           00000000 
 * 6a _L0x6a     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           40003023 close to store
 * 6b SB_4       7a SB_5       1110000000000010110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 6c SLTU_0     31 SLTX_1     0010000000000000111011001000000000 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d unx6d         (use dinx) 0000000000000000000000000000000000 6d: Not in use                                           00000000 
 * 6e unx6e         (use dinx) 0000000000000000000000000000000000 6e: Not in use                                           40003033 sloppy sltu    
 * 6f MRET_6     cf MRET_7     0010000000000000000011101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 70 LHU_2      ba LHU_3      0010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 71 aFaultc    1e aFault_1   0000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 72 LBU_3      1a ANDI_1     0010000000000000011011101100010000        Invert q. Prepare read mask                       00000000 
 * 73 BAERR_1    76 BAERR_2    0000000000001111110011101000001000        Faultadr to mtval. Prepare get offset             00000000 
 * 74 BrOpFet    f4 Fetch2     0011001010000000101111101010110000 NewOp2 Read until instruction latched                    00000000 
 * 75 BAlignEr   73 BAERR_1    0010000000000000001011000000000000  Err   Branch target instruction address misaligned      00000000 
 * 76 BAERR_2    77 BAERR_3    0010000000000000001011101100000000        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 77 BAERR_3    7d BAERR_4    0000000000001101101011100000100110        origPC to mepc. Prep read 0                       00000000 
 * 78 _L0x78     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00003063 close to branch
 * 79 _L0x79     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00003067 close to jalr
 * 7a SB_5       f2 SW_2       0000000000000010110011100100001000        Write d to a+k until accepted                     00000000 
 * 7b _L0x7b     32 JAL_1      0010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    49 CSRRW_1    0000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d BAERR_4    34 JAL_3      0000110000001110100111100000001000        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 7e NMI_1      90 NMI_2      0000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * 7f JALRE2     7d BAERR_4    0000000000001111101011100000001000        mtval is target                                   00000000 
 * 80 LBU_0      85 LBU_1      0110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 JAERR_2    7d BAERR_4    0000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 82 _L0x82     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000400b close to ij
 * 83 _L0x83     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000400f close to fence
 * 84 XORI_0     21 XORI_1     0010000000000000111111101100010000 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 LBU_1      f0 LBU_2      0010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 86 JAL_2      9e JAL_25     0000000000000100001011000000100110        Return address to TRG                             00000000 
 * 87 JALRE1     7f JALRE2     0000000000001101110011100000001000  err   Store pc to mepc                                  00000000 
 * 88 _L0x88     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00004023 close to store
 * 89 unx89         (use dinx) 0000000000000000000000000000000000 89: Not in use                                           00000000 
 * 8a _L0x8a     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           40004023 close to store
 * 8b LB_6       e6 StdIncPc   0000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 8c XOR_0      29 XOR_1      0010000000000000111111001000000000 XOR    xor                                               00004033 xor     
 * 8d unx8d         (use dinx) 0000000000000000000000000000000000 8d: Not in use                                           00000000 
 * 8e _LCSRRS_1  fe ILLe       0010000000000000000011000000000000 Illegal instruction seen                                 40004033 sloppy xor     
 * 8f ILL_3      a9 ILL_4      0010000000000000101011101100100110        Q = 1                                             00000000 
 * 90 NMI_2      34 JAL_3      0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 91 LDAF_2     92 LDAF_3     0000110000001110001011000000100110        Store 4 to mcause                                 00000000 
 * 92 LDAF_3     34 JAL_3      0000000000001101100111100000001000        PC to mepc                                        00000000 
 * 93 SW_E2      95 SW_E3      0000000000001101101111101000001000        Store address that faulted                        00000000 
 * 94 SW_E4      34 JAL_3      0000110000001110100111100000101000        Store 6 to mcause                                 00000000 
 * 95 SW_E3      94 SW_E4      0010000000000000101111001100100110        Q = 3                                             00000000 
 * 96 SH_1       bb SH_2       0000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 97 SW_E1SWH   93 SW_E2      0000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 98 BLT        13 condb_2    0000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00004067 close to jalr
 * 9a ECALL_6    34 JAL_3      0000110000001110100111000000100000        mcause = 11                                       00000000 
 * 9b SH_4       9f SH_5       1110000000000001110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 9c _L0x9c     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00004073 close to csr/system 
 * 9d unx9d         (use dinx) 0000000000000000000000000000000000 9d: Not in use                                           00000000 
 * 9e JAL_25     34 JAL_3      0000000000001000110011100000001000        Instr. adr. to jj in case of access error         00000000 
 * 9f SH_5       f2 SW_2       0000000000000001110011100100001000        Write d to a+k until accepted                     00000000 
 * a0 LHU_0      5e LHU_1      0100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_4    b6 ECALL_5    0010000000000000101011001100100110        Q = 4                                             00000000 
 * a2 _L0xa2     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000500b close to ij
 * a3 _L0xa3     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000500f close to fence
 * a4 SRxI_0     3a SRxI_1     0010000000000000111100100000110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_3     af MRET_4     0010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * a6 ECAL_RET   d0 ECALL_1    0010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * a7 EBRKWFI1   61 EBRKWFI2   0010000000000000000011101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * a8 _L0xa8     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00005023 close to store
 * a9 ILL_4      34 JAL_3      0000110000001110100111100000100110        Store 2 to mcause                                 00000000 
 * aa _L0xaa     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           40005023 close to store
 * ab EBREAK_2   9a ECALL_6    0000000000001101101011101000001000        pc to mepc                                        00000000 
 * ac _L0xac     3f SRx_1      0010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad unxad         (use dinx) 0000000000000000000000000000000000 ad: Not in use                                           00000000 
 * ae _L0xae     3f SRx_1      0010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_4     c5 MRET_5     0010000000000000000011101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b0 aF_SW_3    92 LDAF_3     0000110000001110001011000000100000        Store 7 to mcause                                 00000000 
 * b1 CSRRW_3    b2 CSRRW_4    0010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b2 CSRRW_4    de Fetch      0100000010001000110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b3 unxb3         (use dinx) 0000000000000000000000000000000000 b3: Not in use                                           00000000 
 * b4 eFetch3       (use dinx) 0000000000011001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * b5 SH_3       9b SH_4       0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b6 ECALL_5    9a ECALL_6    0010000000000000101011001100100110        Q = 8                                             00000000 
 * b7 IJ_3       bd IJ_4       0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b8 BGE        13 condb_2    0000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 _L0xb9     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00005067 close to jalr
 * ba LHU_3      1a ANDI_1     0010000000000000011111101100010000        Invert q. Prepare read mask                       00000000 
 * bb SH_2       b5 SH_3       0000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * bc CSRRWI_0   49 CSRRW_1    0000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd IJ_4       de Fetch      0110000010000000110111100100011000        Mask and use as PC                                00000000 
 * be IJ_1       1f IJ_2       0010000010000000101111101100001000        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * bf IJT_1      c1 IJT_2      0010000010000000101111101100001000        Exit CSR, enter trap                              00000000 
 * c0 _L0xc0     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00006003 close to load
 * c1 IJT_2      e9 IJT_3      0000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c2 _L0xc2     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000600b close to ij
 * c3 _L0xc3     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000600f close to fence
 * c4 ORI_0      e1 ORI_1      0000000000001000111111101000010000 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_5     6f MRET_6     0010000000000000000011101100010000        ~302                                              00000000 
 * c6 IJT_4      47 ILL_2      0000000000001101101011101100011000        Mask and store to mepc and Q for read of instr    00000000 
 * c7 QINT_1     cb QINT_2     0000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * c8 _L0xc8     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00006023 close to store
 * c9 MRET_2     a5 MRET_3     0010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * ca _L0xca     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           40006023 close to store
 * cb QINT_2     e6 StdIncPc   0000110000001111010011101000110000        mtval = 0.                                        00000000 
 * cc OR_0       26 OR_1       0010000000000000111111001000000000 OR     or                                                00006033 or      
 * cd unxcd         (use dinx) 0000000000000000000000000000000000 cd: Not in use                                           00000000 
 * ce _LCSRRCI_1 fe ILLe       0010000000000000000011000000000000 Illegal instruction seen                                 40006033 sloppy or      
 * cf MRET_7     4f MRET_8     0010000000000000011011001001000000        Prepare emulation entry point 0x104               00000000 
 * d0 ECALL_1    37 ECALL_2    0010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * d1 MRET_1     c9 MRET_2     0000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * d2 LB_2       06 LB_3       0010000100000000101001101100001001        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * d3 aFaultd    1e aFault_1   0000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * d4 aFault_2   92 LDAF_3     0000110000001110001011100000100110        Store 5 to mcause                                 00000000 
 * d5 unxd5         (use dinx) 0000000000000000000000000000000000 d5: Not in use                                           00000000 
 * d6 eILL0c     fe ILLe       0010000000000000000011000000000000 Illegal instruction seen                                 00000000 
 * d7 ECALL_3    a1 ECALL_4    0000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * d8 BLTU       13 condb_2    0000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 _L0xd9     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00006067 close to jalr
 * da LDAF_a     91 LDAF_2     0010000000000000101011001000000000        Extra cycle after error detected write mtval      00000000 
 * db jFault_1   92 LDAF_3     0000000000001110000011100000100110        Store 1 to mcause                                 00000000 
 * dc CSRRSI_0   49 CSRRW_1    0000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd aF_SW_1    e5 aF_SW_2    0000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * de Fetch      f4 Fetch2     0001001010001010101111101010110000  Fr11  Read and latch instruction                        00000000 
 * df eFetch     f4 Fetch2     0001001010001010101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * e0 _L0xe0     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00007003 close to load
 * e1 ORI_1      1d ORI_2      0010000000000000000011101100001000        Q = RS1                                           00000000 
 * e2 _L0xe2     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000700b close to ij
 * e3 _L0xe3     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           0000700f close to fence
 * e4 ANDI_0     1a ANDI_1     0010000000000000111111101100010000 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 aF_SW_2    b0 aF_SW_3    0010000000000000101011001100100110        Q = 4                                             00000000 
 * e6 StdIncPc   de Fetch      0100000010001000110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * e7 aFault     1e aFault_1   0000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * e8 _L0xe8     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00007023 close to store
 * e9 IJT_3      c6 IJT_4      0010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ea _L0xea     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           40007023 close to store
 * eb LH_3       56 LH_4       0010000000000000011111101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * ec AND_0      11 AND_1      0010000000000000111111001000000000 AND    And                                               00007033 and     
 * ed unxed         (use dinx) 0000000000000000000000000000000000 ed: Not in use                                           00000000 
 * ee eILL0a     fe ILLe       0010000000000000000011000000000000 Illegal instruction seen                                 40007033 sloppy and     
 * ef WFI_5      de Fetch      0100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * f0 LBU_2      72 LBU_3      0010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * f1 aFaulte    1e aFault_1   0000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * f2 SW_2       e6 StdIncPc   0010000000000000001011001000000000        Prepare read PC                                   00000000 
 * f3 aF_SW      dd aF_SW_1    0010000000000000000011000100000000  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * f4 Fetch2     b4 eFetch3    0000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f5 jFault     db jFault_1   0000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * f6 WFI_1      fa WFI_2      0010000000000000000011001100100110 WFI    Chk offset=0x105. Now=0xff. Prep 0xff+4 = 0x103   00000000 
 * f7 EBREAK_1   ab EBREAK_2   0000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * f8 BGEU       13 condb_2    0000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 _L0xf9     fe ILLe       0010000000000000000011000000000000  Not in use (illegal as entry)                           00007067 close to jalr
 * fa WFI_2      45 WFI_3      0010000000000000101011101100100110        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104   00000000 
 * fb SB_3       6b SB_4       0010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fc CSRRCI_0   49 CSRRW_1    0000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      7e NMI_1      0010000000000000001011001000000000 NMI    Get current PC                                    00000000 
 * fe ILLe       46 ILL_1      0010000000000000001011000000000000 Illegal                                                  00000000 
 * ff QINT_0     c7 QINT_1     0010000000000000001011001000000000 INT    Get current PC                                    00000000 
 */
localparam v3_u0_0 = 256'h30e6001030e608041886205a008b205a18091007000420e600e620be09d22001;
localparam v3_u0_1 = 256'h30b726d438e630a6303218e620413013207436de48162615001400fe001a008b;
localparam v3_u0_2 = 256'h30e6000030e6003e2630209600212096201d00270004303500e600fe00e62052;
localparam v3_u0_3 = 256'h083a0835090330493032093d00fe301348d72803083608de20812086002b32e6;
localparam v3_u0_4 = 256'h26e600fe0000003108b12066264b2066088f08472665102b00fe00fe260b2050;
localparam v3_u0_5 = 256'h30da097028fb30493032085d00fe00fe008b1857301e09eb30da095430da08e6;
localparam v3_u0_6 = 256'h26cf000000000031087a00fe000000fe309308f240ef102b00fe00fe50f700fe;
localparam v3_u0_7 = 256'h087d089008343049303208f200fe00fe267d00770073b0f40876101a301e09ba;
localparam v3_u0_8 = 256'h26a900fe0000002926e600fe000000fe087f269e09f0102100fe00fe087d2085;
localparam v3_u0_9 = 256'h08f20834000000fe089f203400fe3013309308bb269428340895083426923034;
localparam v3_u0_A = 256'h26c5003f0000003f089a00fe263400fe206130d026af303a00fe00fe26b6205e;
localparam v3_u0_B = 256'h08c1081f18de304928b5101a00fe301320bd269a309b2600000026de26b22092;
localparam v3_u0_C = 256'h404f00fe0000002630e600fe20a500fe08cb1847106f10e100fe00fe30e900fe;
localparam v3_u0_D = 256'hb0f4b0f430e530492692009100fe301330a100fe00002692301e090630c92637;
localparam v3_u0_E = 256'h26de00fe00000011105600fe20c600fe301e26de26b0101a00fe00fe081d00fe;
localparam v3_u0_F = 256'h00c70046007e3049306b264500fe301330ab26fa30db20b400dd00e6301e0972;
localparam v3_u1_0 = 256'h10ba03b210ba03bbb0ba23ab017b23ab017b01bb00b110ba00b2837b02fb036b;
localparam v3_u1_1 = 256'h32ba02b310ba82f980b910ba32ba33baab7b2b71233b00bb03fb003003bb03fb;
localparam v3_u1_2 = 256'h10ba000010ba03b0003aa3ab03bba3ab003b23ba00b103c800b2003010bab36b;
localparam v3_u1_3 = 256'h03c803c8129b31ba80b9129b003033ba343a12db12db2b793cb830ba03fb10ba;
localparam v3_u1_4 = 256'h02bb0030000003b20eb983bb00bb83bb3eba36b802bb03fb00300030033b837b;
localparam v3_u1_5 = 256'h3eb902fb32db31ba80b932db00300030023b023b3eba029b3eb902fb3eb912fa;
localparam v3_u1_6 = 256'h003b0000000003b20b3b0030000000303cb80fb900b203fb0030003021ba0030;
localparam v3_u1_7 = 256'h3eb8343a3a7831ba80b90b390030003036b800bb00b002fa3f3a01bb3eba029b;
localparam v3_u1_8 = 256'h02bb0030000003f210ba003000000030373810b002fb03fb0030003036b8036b;
localparam v3_u1_9 = 256'h0739233800000030073b3a70003033ba3cb832db02f33a7836fa367838b03d3a;
localparam v3_u1_A = 256'h003b03b0000003b036ba00303a780030003b82f901bb03c80030003002b3b36b;
localparam v3_u1_B = 256'h02fb02fb037931ba32db01fb003033ba033302b3003a67fb0000237102b338b0;
localparam v3_u1_C = 256'h01b20030000003f23d3a003001b30030343a36bb003b23fa0030003032ba0030;
localparam v3_u1_D = 256'h2afa2afa3eba31ba383802b2003033ba3eba0030000038b83eba029b21ba00bb;
localparam v3_u1_E = 256'h2b710030000003f201fb0030033300303eba237102b303fb00300030003b0030;
localparam v3_u1_F = 256'h00b200b000b231ba003a02bb003033ba3cba00333eba2c7e003100b23eba029b;
localparam v3_u2_0 = 256'h00000080000000800001040000800400008000800080040000800590008a0580;
localparam v3_u2_1 = 256'h00000c8000000080008100000400000005010102000004800080008000800080;
localparam v3_u2_2 = 256'h0000000000000080048004000080040004800000008000800080008000000500;
localparam v3_u2_3 = 256'h0080008000040000008100000080000000000004000001020400040000800000;
localparam v3_u2_4 = 256'h0480008000000080002007810480078100000000048000800080008004800581;
localparam v3_u2_5 = 256'h0000008a00040000008100000080008000800080000000840000008a00000042;
localparam v3_u2_6 = 256'h0480000000000080038000800000008000000000008000800080008000000080;
localparam v3_u2_7 = 256'h0000000000300000008100000080008004000080008000ca0000008000000084;
localparam v3_u2_8 = 256'h00800080000000800c0000800000008000002c00008a00800080008000000580;
localparam v3_u2_9 = 256'h00000000000000800380043000800000000000000c800030000000000c300030;
localparam v3_u2_A = 256'h048000800000008000000080043000800480008104800080008000800c800500;
localparam v3_u2_B = 256'h0082008201820000000400800080000004800c800080040000000d020c800430;
localparam v3_u2_C = 256'h0080008000000080003000800480008000000000008000000080008000000080;
localparam v3_u2_D = 256'h004a004a00000000040000800080000000000080000004300000008400000480;
localparam v3_u2_E = 256'h0d02008000000080008000800480008000000d020c8000800080008000800080;
localparam v3_u2_F = 256'h0080008000800000008004800080000000000c80000004000080008000000084;
/*
 * =================================================
 * * Version 4. MULDIV                             *
 * =================================================
 *                             Microcode instruction
 * uPC           next uPC      44444333333333322222222221111111111
 * || label      || next label 4321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       d2 LB_2       0000010001010000000101111101100001001        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       be IJ_1       0010110010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     e6 StdIncPc   0000010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     e6 StdIncPc   0010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0000010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 LB_3       07 LB_4       0000010000000000000011011101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * 07 LB_4       09 LB_5       0000010000000000000010111101100011000        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 08 _L0x08     5a SB_1       0010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_5       8b LB_6       0000010000000000000010111101100000000        q = D^0xffffffff^q = D^0x80                       00000000 
 * 0a _L0x0a     5a SB_1       0010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b JALR_2     86 JAL_2      0000000000001101100001011101000011000        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 0c ADD_0      04 ADDI_0     0000010000000000000111011101100001000 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      e2 MUL_1      0100010000000000000111011001000000000 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      10 SUB_1      0000010000000000000111011001000000000 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     e6 StdIncPc   0000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 SUB_1      8b LB_6       0000010000000000000111111101100000000        Q = ~RS2                                          00000000 
 * 11 AND_1      1a ANDI_1     0000010000000000000111011101100000000        RS1^0xffffffff to Q                               00000000 
 * 12 _L0x12     fe ILLe       0000010000000000000000011000000000000  Not in use (illegal as entry)                           00000000 
 * 13 condb_2    14 condb_3    0000010000000000000111111101100000000        ~RS2 in Q                                         00000000 
 * 14 condb_3    15 condb_4    0010010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 15 condb_4    16 condb_5    0000000000000001000110011101101001000        Branch on condition                               00000000 
 * 16 condb_5    de Fetch      0000100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 17 condb_5t   74 BrOpFet    0010100000001101010110111101100100000        Branch taken.                                     00000000 
 * 18 BEQ        13 condb_2    0000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     41 JALR_1     0010000000000001100101011101000100000 JALR   yy=RS1+imm                                        00000067 jalr    
 * 1a ANDI_1     e6 StdIncPc   0000000000000000100001011101000011000        rd = Iimm & RS1                                   00000000 
 * 1b _L0x1b     32 JAL_1      0000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   a6 ECAL_RET   0000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d ORI_2      e6 StdIncPc   0000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 1e aFault_1   d4 aFault_2   0110010000000000000101011001100100110        Q = 4                                             00000000 
 * 1f IJ_2       b7 IJ_3       0000000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 20 LH_0       52 LH_1       0010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 XORI_1     e6 StdIncPc   0000000000000000100001011101000000000        rd = Iimm ^ RS1                                   00000000 
 * 22 MULHU_6    39 MULHU_7    0000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      0000100b close to ij
 * 23 _L0x23     e6 StdIncPc   0000010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     35 SLLI_1     0000010000000000000111100100000110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0000010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 OR_1       27 OR_2       0000000000000001000111011101000000000        RS1^0xffffffff to jj                              00000000 
 * 27 OR_2       1d ORI_2      0010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 28 _L0x28     96 SH_1       0010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 XOR_1      21 XORI_1     0000010000000000000111011101100000000        Q = RS1^0xFFFFFFFF                                00000000 
 * 2a _L0x2a     96 SH_1       0010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b SLTIX_1    30 SLTIX_2    0010010000000000000000011101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 2c SLL_0      3e SLL_1      0000010000000000000111011000000000000 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     6a MULH_1     0000010000000000000101001101100001000 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e MULHU_1    42 MULHU_2    0100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                40001033 sloppy sll     
 * 2f _L0x2f     e6 StdIncPc   0000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SLTIX_2    e6 StdIncPc   0000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 31 SLTX_1     2b SLTIX_1    0000010000000000000111111101100000000        ~rs2 to Q                                         00000000 
 * 32 JAL_1      86 JAL_2      0010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 33 JAERR_1    81 JAERR_2    0010000000000001111001011100000100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 34 JAL_3      de Fetch      0000100000010001010110111100100001000        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 35 SLLI_1     36 SLLI_2     0000000000000000100101101101100001000        Register to shift to Q (and TRG for shift 0)      00000000 
 * 36 SLLI_2     03 _L0x03     0000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 37 ECALL_2    d7 ECALL_3    0000000000000001101000011101001001000        mepc = pc, prep store 0 to mtval                  00000000 
 * 38 BNE        13 condb_2    0000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 MULHU_7    e6 StdIncPc   0100000000000000100001011101000001000        Last shift.                                       00001067 close to jalr
 * 3a SRxI_1     3d SRxI_2     0000000000000000100101001101100001001        Register to shift to Q                            00000000 
 * 3b _L0x3b     32 JAL_1      0000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    49 CSRRW_1    0000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d SRxI_2     03 _L0x03     0000000000100000100101001101100001001        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 3e SLL_1      35 SLLI_1     0000010000000000000111100100000001000        Shiftamount was in low 5 bits of RS2              00000000 
 * 3f SRx_1      3a SRxI_1     0000010000000000000111100100000001000        Shiftamount in low 5 bits of RS2                  00000000 
 * 40 LW_0       50 LW_1       0010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 JALR_1     0b JALR_2     0010010000000000000110011101100100110        Q=1                                               00000000 
 * 42 MULHU_2    60 MULHU_3    0000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           0000200b close to ij
 * 43 MULHU_4    ea MULHU_5    0000010000000000000000011100100000000        Prepare read Rjj.                                 0000200f close to fence
 * 44 SLTI_0     2b SLTIX_1    0000010000000000000111111101100010000 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 WFI_3      65 WFI_4      0010010000000000000101011101100100110        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105        00000000 
 * 46 ILL_1      47 ILL_2      0000000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 47 ILL_2      8f ILL_3      0000000000000001111101011101000001000        Store 0 to mtval                                  00000000 
 * 48 _L0x48     66 SW_1       0011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 CSRRW_1    4b CSRRW_2    0010010000000000000001011101100100110        Construct PC storage adr                          00000000 
 * 4a _L0x4a     66 SW_1       0011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b CSRRW_2    b1 CSRRW_3    0000000100000000011101011100100001000        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 4c SLT_0      31 SLTX_1     0000010000000000000111011001000000000 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   2e MULHU_1    0000000000000001100111001101000001000 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e eILL0b     fe ILLe       0000010000000000000000011000000000000 Illegal instruction seen                                 40002033 sloppy slt     
 * 4f MRET_8     e6 StdIncPc   0010010000000000000101011101100100110        Prep +4                                           00000000 
 * 50 LW_1       e6 StdIncPc   0000001000010000100101111101000001000        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 51 LDAF_LW    da LDAF_a     0000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 52 LH_1       54 LH_2       0000010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 53 LDAF_LH    da LDAF_a     0000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 54 LH_2       eb LH_3       0000010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 55 aFaultb    1e aFault_1   0000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 56 LH_4       57 LH_5       0000010000000000000100011101100011000        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 57 LH_5       8b LB_6       0000010000000000000100011101100000000        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 58 DIV_A      6e DIV_C      0110010000000000000101111101100001001        Transfer rM to rDee                               00002063 close to branch
 * 59 DIV_B      9c DIV_10     0000000000000001100111111101000110000        REM = Q to yy                                     00002067 close to jalr
 * 5a SB_1       5d SB_2       0000000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5b _L0x5b     32 JAL_1      0000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    49 CSRRW_1    0000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SB_2       fb SB_3       0000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 5e LHU_1      70 LHU_2      0000010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 5f LDAF_LHU   da LDAF_a     0000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 60 MULHU_3    42 MULHU_2    0100010000000000000111111101100001000        Shift Q and rM. Prepare read rs1                  00003003 close to load
 * 61 EBRKWFI2   f7 EBREAK_1   0000000000000001000011011101001010000 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 62 DIV_8      c8 DIV_7      0010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIV_9      58 DIV_A      1010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    2b SLTIX_1    0000010000000000000111111101100010000 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 WFI_4      ef WFI_5      0000010000000000000001011001001000000        Prepare read PC                                   00000000 
 * 66 SW_1       f2 SW_2       0000000000000000011111011100100001000        Write d to a+k until accepted                     00000000 
 * 67 SW_E1SWE   93 SW_E2      0000000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 68 DIV_12     e6 StdIncPc   0000000000000000100001011101000001000        RS2 > 0, RS1 >= 0, yy is true result              00003023 close to store
 * 69 DIV_13     8b LB_6       0000010000000000000101011101100000000        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 6a MULH_1     f9 MULH_2     0000000000000001100101011101000000000        Store ~rs1 to Ryy. Prep construct 1.              40003023 close to store
 * 6b SB_4       7a SB_5       0001110000000000010110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 6c SLTU_0     31 SLTX_1     0000010000000000000111011001000000000 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    2e MULHU_1    0000000000000001100111001101000001000 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_C      b9 DIV_e      0000000000000001100111011100100001000        rM to yy. Q=ffffffff                              40003033 sloppy sltu    
 * 6f MRET_6     cf MRET_7     0010010000000000000000011101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 70 LHU_2      ba LHU_3      0000010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 71 aFaultc    1e aFault_1   0000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 72 LBU_3      1a ANDI_1     0000010000000000000011011101100010000        Invert q. Prepare read mask                       00000000 
 * 73 BAERR_1    76 BAERR_2    0000000000000001111110011101000001000        Faultadr to mtval. Prepare get offset             00000000 
 * 74 BrOpFet    f4 Fetch2     0000011001010000000101111101010110000 NewOp2 Read until instruction latched                    00000000 
 * 75 BAlignEr   73 BAERR_1    0000010000000000000001011000000000000  Err   Branch target instruction address misaligned      00000000 
 * 76 BAERR_2    77 BAERR_3    0000010000000000000001011101100000000        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 77 BAERR_3    7d BAERR_4    0010000000000001101101011100000100110        origPC to mepc. Prep read 0                       00000000 
 * 78 DIV_4      aa DIV_6      0000000000000001100000011101000110000        ~abs(divisor) to yy                               00003063 close to branch
 * 79 DIV_5      a8 DIV_3      0110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00003067 close to jalr
 * 7a SB_5       f2 SW_2       0000000000000000010110011100100001000        Write d to a+k until accepted                     00000000 
 * 7b _L0x7b     32 JAL_1      0000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    49 CSRRW_1    0000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d BAERR_4    34 JAL_3      0000000110000001110100111100000001000        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 7e NMI_1      90 NMI_2      0000000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * 7f JALRE2     7d BAERR_4    0000000000000001111101011100000001000        mtval is target                                   00000000 
 * 80 LBU_0      85 LBU_1      0010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 JAERR_2    7d BAERR_4    0000000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 82 DIV_1      a8 DIV_3      0000000000000001000111011101000000000        jj=abs(RS1). Next handle divisor                  0000400b close to ij
 * 83 DIV_2      82 DIV_1      0010010000000000000101011101100100000        Dividend negative, make RS1-1                     0000400f close to fence
 * 84 XORI_0     21 XORI_1     0000010000000000000111111101100010000 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 LBU_1      f0 LBU_2      0000010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 86 JAL_2      9e JAL_25     0110000000000000100001011000000100110        Return address to TRG                             00000000 
 * 87 JALRE1     7f JALRE2     0000000000000001101110011100000001000  err   Store pc to mepc                                  00000000 
 * 88 DIV_E      9c DIV_10     1100010000000000000111111000000000000        RS2 != 0. Check signs                             00004023 close to store
 * 89 DIV_F      e6 StdIncPc   0000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 8a DIVU_5     1a ANDI_1     0110010000000000000101111001000000001        Transfer rM to rDee                               40004023 close to store
 * 8b LB_6       e6 StdIncPc   0110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 8c XOR_0      29 XOR_1      0000010000000000000111111001000000000 XOR    xor                                               00004033 xor     
 * 8d DIV_0      82 DIV_1      1100010000000000000101101101100001000 DIV    Branch on sign dividend RS1                       00000000 
 * 8e _LCSRRS_1  fe ILLe       0000010000000000000000011000000000000 Illegal instruction seen                                 40004033 sloppy xor     
 * 8f ILL_3      a9 ILL_4      0000010000000000000101011101100100110        Q = 1                                             00000000 
 * 90 NMI_2      34 JAL_3      0000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 91 LDAF_2     92 LDAF_3     0110000110000001110001011000000100110        Store 4 to mcause                                 00000000 
 * 92 LDAF_3     34 JAL_3      0000000000000001101100111100000001000        PC to mepc                                        00000000 
 * 93 SW_E2      95 SW_E3      0000000000000001101101111101000001000        Store address that faulted                        00000000 
 * 94 SW_E4      34 JAL_3      0000000110000001110100111100000101000        Store 6 to mcause                                 00000000 
 * 95 SW_E3      94 SW_E4      0110010000000000000101111001100100110        Q = 3                                             00000000 
 * 96 SH_1       bb SH_2       0000000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 97 SW_E1SWH   93 SW_E2      0000000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 98 BLT        13 condb_2    0000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0000010000000000000000011000000000000  Not in use (illegal as entry)                           00004067 close to jalr
 * 9a ECALL_6    34 JAL_3      0010000110000001110100111000000100000        mcause = 11                                       00000000 
 * 9b SH_4       9f SH_5       0001110000000000001110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 9c DIV_10     68 DIV_12     1100010000000000000110011101000001000        RS2 > 0. Branch on sign of RS1                    00004073 close to csr/system 
 * 9d DIV_11     a2 DIV_14     1100010000000000000110011101000001000        RS2 < 0. Branch on sign of RS1                    00000000 
 * 9e JAL_25     34 JAL_3      0000000000000001000110011100000001000        Instr. adr. to jj in case of access error         00000000 
 * 9f SH_5       f2 SW_2       0000000000000000001110011100100001000        Write d to a+k until accepted                     00000000 
 * a0 LHU_0      5e LHU_1      0010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_4    b6 ECALL_5    0110010000000000000101011001100100110        Q = 4                                             00000000 
 * a2 DIV_14     8b LB_6       0000010000000000000101011101100000000        RS2 < 0, RS1 >= 0, change sign yy                 0000500b close to ij
 * a3 DIV_15     e6 StdIncPc   0000000000000000100001011101000001000        RS2 < 0, RS1 < 0, yy is true result               0000500f close to fence
 * a4 SRxI_0     3a SRxI_1     0000010000000000000111100100000110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_3     af MRET_4     0010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * a6 ECAL_RET   d0 ECALL_1    0000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * a7 EBRKWFI1   61 EBRKWFI2   0010010000000000000000011101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * a8 DIV_3      78 DIV_4      1100010000000000000101011101100000000        Branch on sign divisor RS2                        00005023 close to store
 * a9 ILL_4      34 JAL_3      0010000110000001110100111100000100110        Store 2 to mcause                                 00000000 
 * aa DIV_6      c8 DIV_7      0100010000000000000101111001000000000        Write M. Prepare shift                            40005023 close to store
 * ab EBREAK_2   9a ECALL_6    0000000000000001101101011101000001000        pc to mepc                                        00000000 
 * ac _L0xac     3f SRx_1      0000010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     e0 DIVU_1     0100010000000000000111001001000000000 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     3f SRx_1      0000010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_4     c5 MRET_5     0010010000000000000000011101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b0 aF_SW_3    92 LDAF_3     0010000110000001110001011000000100000        Store 7 to mcause                                 00000000 
 * b1 CSRRW_3    b2 CSRRW_4    0110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b2 CSRRW_4    de Fetch      0110100000010001000110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b3 unxb3         (use dinx) 0000000000000000000000000000000000000 b3: Not in use                                           00000000 
 * b4 i0reserv      (use dinx) 0000000000000000000000000000000000000 Not in use, reserved to allow LASTINCH                   00000000 
 * b5 SH_3       9b SH_4       0000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b6 ECALL_5    9a ECALL_6    0110010000000000000101011001100100110        Q = 8                                             00000000 
 * b7 IJ_3       bd IJ_4       0010010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b8 BGE        13 condb_2    0000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 DIV_e      c0 DIV_D      0000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00005067 close to jalr
 * ba LHU_3      1a ANDI_1     0000010000000000000011111101100010000        Invert q. Prepare read mask                       00000000 
 * bb SH_2       b5 SH_3       0000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * bc CSRRWI_0   49 CSRRW_1    0000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd IJ_4       de Fetch      0000110000010000000110111100100011000        Mask and use as PC                                00000000 
 * be IJ_1       1f IJ_2       0000010000010000000101111101100001000        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * bf IJT_1      c1 IJT_2      0000010000010000000101111101100001000        Exit CSR, enter trap                              00000000 
 * c0 DIV_D      88 DIV_E      0000010000000000000111011101101001000        Is RS2 == 0?                                      00006003 close to load
 * c1 IJT_2      e9 IJT_3      0000000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c2 DIVU_3     ca DIVU_2     0010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000600b close to ij
 * c3 DIVU_4     8a DIVU_5     1010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000600f close to fence
 * c4 ORI_0      e1 ORI_1      0000000000000001000111111101000010000 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_5     6f MRET_6     0000010000000000000000011101100010000        ~302                                              00000000 
 * c6 IJT_4      47 ILL_2      0000000000000001101101011101100011000        Mask and store to mepc and Q for read of instr    00000000 
 * c7 QINT_1     cb QINT_2     0000000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * c8 DIV_7      62 DIV_8      0100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00006023 close to store
 * c9 MRET_2     a5 MRET_3     0010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * ca DIVU_2     c2 DIVU_3     0100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            40006023 close to store
 * cb QINT_2     e6 StdIncPc   0000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * cc OR_0       26 OR_1       0000010000000000000111111001000000000 OR     or                                                00006033 or      
 * cd REM_0      82 DIV_1      1100010000000000000101101101100001000 REM    Branch on sign dividend RS1                       00000000 
 * ce _LCSRRCI_1 fe ILLe       0000010000000000000000011000000000000 Illegal instruction seen                                 40006033 sloppy or      
 * cf MRET_7     4f MRET_8     0000010000000000000011011001001000000        Prepare emulation entry point 0x104               00000000 
 * d0 ECALL_1    37 ECALL_2    0010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * d1 MRET_1     c9 MRET_2     0000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * d2 LB_2       06 LB_3       0000010000100000000101001101100001001        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * d3 aFaultd    1e aFault_1   0000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * d4 aFault_2   92 LDAF_3     0010000110000001110001011100000100110        Store 5 to mcause                                 00000000 
 * d5 unxd5         (use dinx) 0000000000000000000000000000000000000 d5: Not in use                                           00000000 
 * d6 eILL0c     fe ILLe       0000010000000000000000011000000000000 Illegal instruction seen                                 00000000 
 * d7 ECALL_3    a1 ECALL_4    0000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * d8 BLTU       13 condb_2    0000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MULH_3     42 MULHU_2    0100010000000000000111111001000000000        rM<=RS2, Q = 0. next read RS1. Join.              00006067 close to jalr
 * da LDAF_a     91 LDAF_2     0000010000000000000101011001000000000        Extra cycle after error detected write mtval      00000000 
 * db jFault_1   92 LDAF_3     0010000000000001110000011100000100110        Store 1 to mcause                                 00000000 
 * dc CSRRSI_0   49 CSRRW_1    0000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd aF_SW_1    e5 aF_SW_2    0000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * de Fetch      f4 Fetch2     0000000000000001010001111101010110000  Fr00  Read and latch instruction                        00000000 
 * df eFetch     f4 Fetch2     0000001001010001010101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * e0 DIVU_1     ca DIVU_2     0000000000000001100101111101000000000        Store inverted rs2 to yy. Prepare shift           00007003 close to load
 * e1 ORI_1      1d ORI_2      0000010000000000000000011101100001000        Q = RS1                                           00000000 
 * e2 MUL_1      e8 MUL_2      0000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           0000700b close to ij
 * e3 MUL_3      1a ANDI_1     0110010000000000000101111001000000001        Transfer rM to rDee                               0000700f close to fence
 * e4 ANDI_0     1a ANDI_1     0000010000000000000111111101100010000 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 aF_SW_2    b0 aF_SW_3    0110010000000000000101011001100100110        Q = 4                                             00000000 
 * e6 StdIncPc   de Fetch      0110100000010001000110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * e7 aFault     1e aFault_1   0000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * e8 MUL_2      e2 MUL_1      0100010000000000000111011101100001000        Shift Q and rM. Prepare read rs2                  00007023 close to store
 * e9 IJT_3      c6 IJT_4      0010010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ea MULHU_5    22 MULHU_6    0000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          40007023 close to store
 * eb LH_3       56 LH_4       0000010000000000000011111101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * ec AND_0      11 AND_1      0000010000000000000111111001000000000 AND    And                                               00007033 and     
 * ed REMU_0     e0 DIVU_1     0100010000000000000111001001000000000 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee eILL0a     fe ILLe       0000010000000000000000011000000000000 Illegal instruction seen                                 40007033 sloppy and     
 * ef WFI_5      de Fetch      0110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * f0 LBU_2      72 LBU_3      0000010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * f1 aFaulte    1e aFault_1   0000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * f2 SW_2       e6 StdIncPc   0000010000000000000001011001000000000        Prepare read PC                                   00000000 
 * f3 aF_SW      dd aF_SW_1    0000010000000000000000011000100000000  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * f4 Fetch2        (use dinx) 0010000000000011011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f5 jFault     db jFault_1   0000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * f6 WFI_1      fa WFI_2      0110010000000000000000011001100100110 WFI    Chk offset=0x105. Now=0xff. Prep 0xff+4 = 0x103   00000000 
 * f7 EBREAK_1   ab EBREAK_2   0000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * f8 BGEU       13 condb_2    0000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 MULH_2     d9 MULH_3     0010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00007067 close to jalr
 * fa WFI_2      45 WFI_3      0010010000000000000101011101100100110        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104   00000000 
 * fb SB_3       6b SB_4       0000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fc CSRRCI_0   49 CSRRW_1    0000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      7e NMI_1      0000010000000000000001011001000000000 NMI    Get current PC                                    00000000 
 * fe ILLe       46 ILL_1      0000010000000000000001011000000000000 Illegal                                                  00000000 
 * ff QINT_0     c7 QINT_1     0000010000000000000001011001000000000 INT    Get current PC                                    00000000 
 */
localparam v4_u0_0 = 256'h30e6001000e208041886205a008b205a18091007000420e600e620be09d22001;
localparam v4_u0_1 = 256'h30b726d438e630a6303218e620413013207436de48162615001400fe001a008b;
localparam v4_u0_2 = 256'h30e63042086a003e2630209600212096201d00270004303500e6213900e62052;
localparam v4_u0_3 = 256'h083a0835090330493032093d08e6301348d72803083608de20812086002b32e6;
localparam v4_u0_4 = 256'h26e600fe082e003108b12066264b2066088f08472665102b00ea2160260b2050;
localparam v4_u0_5 = 256'h30da097028fb30493032085d309c096e008b1857301e09eb30da095430da08e6;
localparam v4_u0_6 = 256'h26cf08b9082e0031087a00f9008b08e6309308f240ef102b265826c850f70842;
localparam v4_u0_7 = 256'h087d089008343049303208f226a830aa267d00770073b0f40876101a301e09ba;
localparam v4_u0_8 = 256'h26a900fe0882002926e6011a30e6009c087f269e09f01021208200a8087d2085;
localparam v4_u0_9 = 256'h08f2083408a20868089f203400fe3013309308bb269428340895083426923034;
localparam v4_u0_A = 256'h26c5003f00e0003f089a00c826340078206130d026af303a08e6008b26b6205e;
localparam v4_u0_B = 256'h08c1081f18de304928b5101a06c0301320bd269a309b0000000026de26b22092;
localparam v4_u0_C = 256'h404f00fe0882002630e62cc220a52c6208cb1847106f10e1268a26ca30e94888;
localparam v4_u0_D = 256'hb0f4b0f430e53049269200910042301330a100fe00002692301e090630c92637;
localparam v4_u0_E = 256'h26de00fe00e000111056202220c608e2301e26de26b0101a011a21e8081d00ca;
localparam v4_u0_F = 256'h00c70046007e3049306b264526d9301330ab26fa30db200000dd00e6301e0972;
localparam v4_u1_0 = 256'h10ba03b203b203bbb0ba23ab017b23ab017b01bb00b110ba00b2837b02fb036b;
localparam v4_u1_1 = 256'h32ba02b310ba82f980b910ba32ba33baab7b2b71233b00bb03fb003003bb03fb;
localparam v4_u1_2 = 256'h10ba23fa029b03b0003aa3ab03bba3ab003b23ba00b103c800b202bb10bab36b;
localparam v4_u1_3 = 256'h03c803c8129b31ba80b9129b10ba33ba343a12db12db2b793cb830ba03fb10ba;
localparam v4_u1_4 = 256'h02bb0030339a03b20eb983bb00bb83bb3eba36b802bb03fb0039029b033b837b;
localparam v4_u1_5 = 256'h3eb902fb32db31ba80b932db33fa02fb023b023b3eba029b3eb902fb3eb912fa;
localparam v4_u1_6 = 256'h003b33b9339a03b20b3b32ba02bb10ba3cb80fb900b203fb02fb02db21ba03fb;
localparam v4_u1_7 = 256'h3eb8343a3a7831ba80b90b3902bb303a36b800bb00b002fa3f3a01bb3eba029b;
localparam v4_u1_8 = 256'h02bb003002db03f210ba02f210ba03f0373810b002fb03fb02bb23ba36b8036b;
localparam v4_u1_9 = 256'h07392338033a033a073b3a70003033ba3cb832db02f33a7836fa367838b03d3a;
localparam v4_u1_A = 256'h003b03b0039203b036ba02f23a7802bb003b82f901bb03c810ba02bb02b3b36b;
localparam v4_u1_B = 256'h02fb02fb037931ba32db01fb033b33ba033302b3003a00000000237102b338b0;
localparam v4_u1_C = 256'h01b2003002db03f23d3a033b01b3033b343a36bb003b23fa02fb02db32ba03bb;
localparam v4_u1_D = 256'h2afa28fa3eba31ba383802b203f233ba3eba0030000038b83eba029b21ba00bb;
localparam v4_u1_E = 256'h2b710030039203f201fb033b033303bb3eba237102b303fb02f2029b003b32fa;
localparam v4_u1_F = 256'h00b200b000b231ba003a02bb23ba33ba3cba00333eba6fff003100b23eba029b;
localparam v4_u2_0 = 256'h00000080088000800001040000800400008000800080040000800590008a0580;
localparam v4_u2_1 = 256'h00000c8000000080008100000400000005010102000004800080008000800080;
localparam v4_u2_2 = 256'h0000080000800080048004000080040004800000008000800080008000000500;
localparam v4_u2_3 = 256'h0080008000040000008100000800000000000004000001020400040000800000;
localparam v4_u2_4 = 256'h0480008000000080002007810480078100000000048000800080008004800581;
localparam v4_u2_5 = 256'h0000008a000400000081000000000c8000800080000000840000008a00000042;
localparam v4_u2_6 = 256'h0480000000000080038000000080000000000000008000801480048000000880;
localparam v4_u2_7 = 256'h0000000000300000008100000c80000004000080008000ca0000008000000084;
localparam v4_u2_8 = 256'h00800080188000800c000c800000188000002c00008a00800480000000000580;
localparam v4_u2_9 = 256'h00000000188018800380043000800000000000000c800030000000000c300030;
localparam v4_u2_A = 256'h048000800880008000000880043018800480008104800080000000800c800500;
localparam v4_u2_B = 256'h0082008201820000000400800080000004800c800080000000000d020c800430;
localparam v4_u2_C = 256'h0080008018800080003008800480088000000000008000001480048000000080;
localparam v4_u2_D = 256'h004a000000000000040000800880000000000080000004300000008400000480;
localparam v4_u2_E = 256'h0d02008008800080008000800480088000000d020c8000800c80008000800000;
localparam v4_u2_F = 256'h0080008000800000008004800400000000000c80000004000080008000000084;
/*
 * =================================================
 * * Version 6. MULDIV MINSTRET                    *
 * =================================================
 *                             Microcode instruction
 * uPC           next uPC      44444333333333322222222221111111111
 * || label      || next label 4321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       d2 LB_2       0000010001010000000101111101100001001        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       be IJ_1       0010110010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     e6 StdIncPc   0000010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     e6 StdIncPc   0010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0000010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 LB_3       07 LB_4       0000010000000000000011011101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * 07 LB_4       09 LB_5       0000010000000000000010111101100011000        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 08 _L0x08     5a SB_1       0010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_5       8b LB_6       0000010000000000000010111101100000000        q = D^0xffffffff^q = D^0x80                       00000000 
 * 0a _L0x0a     5a SB_1       0010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b JALR_2     86 JAL_2      0000000000001101100001011101000011000        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 0c ADD_0      04 ADDI_0     0000010000000000000111011101100001000 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      e2 MUL_1      0100010000000000000111011001000000000 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      10 SUB_1      0000010000000000000111011001000000000 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     e6 StdIncPc   0000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 SUB_1      8b LB_6       0000010000000000000111111101100000000        Q = ~RS2                                          00000000 
 * 11 AND_1      1a ANDI_1     0000010000000000000111011101100000000        RS1^0xffffffff to Q                               00000000 
 * 12 _L0x12     fe ILLe       0000010000000000000000011000000000000  Not in use (illegal as entry)                           00000000 
 * 13 condb_2    14 condb_3    0000010000000000000111111101100000000        ~RS2 in Q                                         00000000 
 * 14 condb_3    15 condb_4    0010010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 15 condb_4    16 condb_5    0000000000000001000110011101101001000        Branch on condition                               00000000 
 * 16 condb_5    de Fetch      0000100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 17 condb_5t   74 BrOpFet    0010100000001101010110111101100100000        Branch taken.                                     00000000 
 * 18 BEQ        13 condb_2    0000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     41 JALR_1     0010000000000001100101011101000100000 JALR   yy=RS1+imm                                        00000067 jalr    
 * 1a ANDI_1     e6 StdIncPc   0000000000000000100001011101000011000        rd = Iimm & RS1                                   00000000 
 * 1b _L0x1b     32 JAL_1      0000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   a6 ECAL_RET   0000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d ORI_2      e6 StdIncPc   0000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 1e aFault_1   d4 aFault_2   0110010000000000000101011001100100110        Q = 4                                             00000000 
 * 1f IJ_2       b7 IJ_3       0000000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 20 LH_0       52 LH_1       0010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 XORI_1     e6 StdIncPc   0000000000000000100001011101000000000        rd = Iimm ^ RS1                                   00000000 
 * 22 MULHU_6    39 MULHU_7    0000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      0000100b close to ij
 * 23 _L0x23     e6 StdIncPc   0000010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     35 SLLI_1     0000010000000000000111100100000110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0000010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 OR_1       27 OR_2       0000000000000001000111011101000000000        RS1^0xffffffff to jj                              00000000 
 * 27 OR_2       1d ORI_2      0010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 28 _L0x28     96 SH_1       0010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 XOR_1      21 XORI_1     0000010000000000000111011101100000000        Q = RS1^0xFFFFFFFF                                00000000 
 * 2a _L0x2a     96 SH_1       0010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b SLTIX_1    30 SLTIX_2    0010010000000000000000011101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 2c SLL_0      3e SLL_1      0000010000000000000111011000000000000 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     6a MULH_1     0000010000000000000101001101100001000 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e MULHU_1    42 MULHU_2    0100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                40001033 sloppy sll     
 * 2f _L0x2f     e6 StdIncPc   0000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SLTIX_2    e6 StdIncPc   0000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 31 SLTX_1     2b SLTIX_1    0000010000000000000111111101100000000        ~rs2 to Q                                         00000000 
 * 32 JAL_1      86 JAL_2      0010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 33 JAERR_1    81 JAERR_2    0010000000000001111001011100000100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 34 JAL_3      de Fetch      0000100000010001010110111100100001000        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 35 SLLI_1     36 SLLI_2     0000000000000000100101101101100001000        Register to shift to Q (and TRG for shift 0)      00000000 
 * 36 SLLI_2     03 _L0x03     0000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 37 ECALL_2    d7 ECALL_3    0000000000000001101000011101001001000        mepc = pc, prep store 0 to mtval                  00000000 
 * 38 BNE        13 condb_2    0000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 MULHU_7    e6 StdIncPc   0100000000000000100001011101000001000        Last shift.                                       00001067 close to jalr
 * 3a SRxI_1     3d SRxI_2     0000000000000000100101001101100001001        Register to shift to Q                            00000000 
 * 3b _L0x3b     32 JAL_1      0000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    49 CSRRW_1    0000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d SRxI_2     03 _L0x03     0000000000100000100101001101100001001        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 3e SLL_1      35 SLLI_1     0000010000000000000111100100000001000        Shiftamount was in low 5 bits of RS2              00000000 
 * 3f SRx_1      3a SRxI_1     0000010000000000000111100100000001000        Shiftamount in low 5 bits of RS2                  00000000 
 * 40 LW_0       50 LW_1       0010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 JALR_1     0b JALR_2     0010010000000000000110011101100100110        Q=1                                               00000000 
 * 42 MULHU_2    60 MULHU_3    0000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           0000200b close to ij
 * 43 MULHU_4    ea MULHU_5    0000010000000000000000011100100000000        Prepare read Rjj.                                 0000200f close to fence
 * 44 SLTI_0     2b SLTIX_1    0000010000000000000111111101100010000 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 WFI_3      65 WFI_4      0010010000000000000101011101100100110        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105        00000000 
 * 46 ILL_1      47 ILL_2      0000000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 47 ILL_2      8f ILL_3      0000000000000001111101011101000001000        Store 0 to mtval                                  00000000 
 * 48 _L0x48     66 SW_1       0011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 CSRRW_1    4b CSRRW_2    0010010000000000000001011101100100110        Construct PC storage adr                          00000000 
 * 4a _L0x4a     66 SW_1       0011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b CSRRW_2    b1 CSRRW_3    0000000100000000011101011100100001000        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 4c SLT_0      31 SLTX_1     0000010000000000000111011001000000000 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   2e MULHU_1    0000000000000001100111001101000001000 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e eILL0b     fe ILLe       0000010000000000000000011000000000000 Illegal instruction seen                                 40002033 sloppy slt     
 * 4f MRET_8     e6 StdIncPc   0010010000000000000101011101100100110        Prep +4                                           00000000 
 * 50 LW_1       e6 StdIncPc   0000001000010000100101111101000001000        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 51 LDAF_LW    da LDAF_a     0000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 52 LH_1       54 LH_2       0000010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 53 LDAF_LH    da LDAF_a     0000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 54 LH_2       eb LH_3       0000010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 55 aFaultb    1e aFault_1   0000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 56 LH_4       57 LH_5       0000010000000000000100011101100011000        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 57 LH_5       8b LB_6       0000010000000000000100011101100000000        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 58 DIV_A      6e DIV_C      0110010000000000000101111101100001001        Transfer rM to rDee                               00002063 close to branch
 * 59 DIV_B      9c DIV_10     0000000000000001100111111101000110000        REM = Q to yy                                     00002067 close to jalr
 * 5a SB_1       5d SB_2       0000000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5b _L0x5b     32 JAL_1      0000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    49 CSRRW_1    0000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SB_2       fb SB_3       0000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 5e LHU_1      70 LHU_2      0000010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 5f LDAF_LHU   da LDAF_a     0000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 60 MULHU_3    42 MULHU_2    0100010000000000000111111101100001000        Shift Q and rM. Prepare read rs1                  00003003 close to load
 * 61 EBRKWFI2   f7 EBREAK_1   0000000000000001000011011101001010000 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 62 DIV_8      c8 DIV_7      0010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIV_9      58 DIV_A      1010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    2b SLTIX_1    0000010000000000000111111101100010000 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 WFI_4      ef WFI_5      0000010000000000000001011001001000000        Prepare read PC                                   00000000 
 * 66 SW_1       f2 SW_2       0000000000000000011111011100100001000        Write d to a+k until accepted                     00000000 
 * 67 SW_E1SWE   93 SW_E2      0000000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 68 DIV_12     e6 StdIncPc   0000000000000000100001011101000001000        RS2 > 0, RS1 >= 0, yy is true result              00003023 close to store
 * 69 DIV_13     8b LB_6       0000010000000000000101011101100000000        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 6a MULH_1     f9 MULH_2     0000000000000001100101011101000000000        Store ~rs1 to Ryy. Prep construct 1.              40003023 close to store
 * 6b SB_4       7a SB_5       0001110000000000010110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 6c SLTU_0     31 SLTX_1     0000010000000000000111011001000000000 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    2e MULHU_1    0000000000000001100111001101000001000 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_C      b9 DIV_e      0000000000000001100111011100100001000        rM to yy. Q=ffffffff                              40003033 sloppy sltu    
 * 6f MRET_6     cf MRET_7     0010010000000000000000011101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 70 LHU_2      ba LHU_3      0000010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 71 aFaultc    1e aFault_1   0000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 72 LBU_3      1a ANDI_1     0000010000000000000011011101100010000        Invert q. Prepare read mask                       00000000 
 * 73 BAERR_1    76 BAERR_2    0000000000000001111110011101000001000        Faultadr to mtval. Prepare get offset             00000000 
 * 74 BrOpFet    f4 Fetch2     0000011001010000000101111101010110000 NewOp2 Read until instruction latched                    00000000 
 * 75 BAlignEr   73 BAERR_1    0000010000000000000001011000000000000  Err   Branch target instruction address misaligned      00000000 
 * 76 BAERR_2    77 BAERR_3    0000010000000000000001011101100000000        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 77 BAERR_3    7d BAERR_4    0010000000000001101101011100000100110        origPC to mepc. Prep read 0                       00000000 
 * 78 DIV_4      aa DIV_6      0000000000000001100000011101000110000        ~abs(divisor) to yy                               00003063 close to branch
 * 79 DIV_5      a8 DIV_3      0110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00003067 close to jalr
 * 7a SB_5       f2 SW_2       0000000000000000010110011100100001000        Write d to a+k until accepted                     00000000 
 * 7b _L0x7b     32 JAL_1      0000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    49 CSRRW_1    0000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d BAERR_4    34 JAL_3      0000000110000001110100111100000001000        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 7e NMI_1      90 NMI_2      0000000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * 7f JALRE2     7d BAERR_4    0000000000000001111101011100000001000        mtval is target                                   00000000 
 * 80 LBU_0      85 LBU_1      0010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 JAERR_2    7d BAERR_4    0000000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 82 DIV_1      a8 DIV_3      0000000000000001000111011101000000000        jj=abs(RS1). Next handle divisor                  0000400b close to ij
 * 83 DIV_2      82 DIV_1      0010010000000000000101011101100100000        Dividend negative, make RS1-1                     0000400f close to fence
 * 84 XORI_0     21 XORI_1     0000010000000000000111111101100010000 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 LBU_1      f0 LBU_2      0000010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 86 JAL_2      9e JAL_25     0110000000000000100001011000000100110        Return address to TRG                             00000000 
 * 87 JALRE1     7f JALRE2     0000000000000001101110011100000001000  err   Store pc to mepc                                  00000000 
 * 88 DIV_E      9c DIV_10     1100010000000000000111111000000000000        RS2 != 0. Check signs                             00004023 close to store
 * 89 DIV_F      e6 StdIncPc   0000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 8a DIVU_5     1a ANDI_1     0110010000000000000101111001000000001        Transfer rM to rDee                               40004023 close to store
 * 8b LB_6       e6 StdIncPc   0110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 8c XOR_0      29 XOR_1      0000010000000000000111111001000000000 XOR    xor                                               00004033 xor     
 * 8d DIV_0      82 DIV_1      1100010000000000000101101101100001000 DIV    Branch on sign dividend RS1                       00000000 
 * 8e _LCSRRS_1  fe ILLe       0000010000000000000000011000000000000 Illegal instruction seen                                 40004033 sloppy xor     
 * 8f ILL_3      a9 ILL_4      0000010000000000000101011101100100110        Q = 1                                             00000000 
 * 90 NMI_2      34 JAL_3      0000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 91 LDAF_2     92 LDAF_3     0110000110000001110001011000000100110        Store 4 to mcause                                 00000000 
 * 92 LDAF_3     34 JAL_3      0000000000000001101100111100000001000        PC to mepc                                        00000000 
 * 93 SW_E2      95 SW_E3      0000000000000001101101111101000001000        Store address that faulted                        00000000 
 * 94 SW_E4      34 JAL_3      0000000110000001110100111100000101000        Store 6 to mcause                                 00000000 
 * 95 SW_E3      94 SW_E4      0110010000000000000101111001100100110        Q = 3                                             00000000 
 * 96 SH_1       bb SH_2       0000000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 97 SW_E1SWH   93 SW_E2      0000000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 98 BLT        13 condb_2    0000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0000010000000000000000011000000000000  Not in use (illegal as entry)                           00004067 close to jalr
 * 9a ECALL_6    34 JAL_3      0010000110000001110100111000000100000        mcause = 11                                       00000000 
 * 9b SH_4       9f SH_5       0001110000000000001110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 9c DIV_10     68 DIV_12     1100010000000000000110011101000001000        RS2 > 0. Branch on sign of RS1                    00004073 close to csr/system 
 * 9d DIV_11     a2 DIV_14     1100010000000000000110011101000001000        RS2 < 0. Branch on sign of RS1                    00000000 
 * 9e JAL_25     34 JAL_3      0000000000000001000110011100000001000        Instr. adr. to jj in case of access error         00000000 
 * 9f SH_5       f2 SW_2       0000000000000000001110011100100001000        Write d to a+k until accepted                     00000000 
 * a0 LHU_0      5e LHU_1      0010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_4    b6 ECALL_5    0110010000000000000101011001100100110        Q = 4                                             00000000 
 * a2 DIV_14     8b LB_6       0000010000000000000101011101100000000        RS2 < 0, RS1 >= 0, change sign yy                 0000500b close to ij
 * a3 DIV_15     e6 StdIncPc   0000000000000000100001011101000001000        RS2 < 0, RS1 < 0, yy is true result               0000500f close to fence
 * a4 SRxI_0     3a SRxI_1     0000010000000000000111100100000110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_3     af MRET_4     0010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * a6 ECAL_RET   d0 ECALL_1    0000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * a7 EBRKWFI1   61 EBRKWFI2   0010010000000000000000011101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * a8 DIV_3      78 DIV_4      1100010000000000000101011101100000000        Branch on sign divisor RS2                        00005023 close to store
 * a9 ILL_4      34 JAL_3      0010000110000001110100111100000100110        Store 2 to mcause                                 00000000 
 * aa DIV_6      c8 DIV_7      0100010000000000000101111001000000000        Write M. Prepare shift                            40005023 close to store
 * ab EBREAK_2   9a ECALL_6    0000000000000001101101011101000001000        pc to mepc                                        00000000 
 * ac _L0xac     3f SRx_1      0000010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     e0 DIVU_1     0100010000000000000111001001000000000 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     3f SRx_1      0000010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_4     c5 MRET_5     0010010000000000000000011101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b0 aF_SW_3    92 LDAF_3     0010000110000001110001011000000100000        Store 7 to mcause                                 00000000 
 * b1 CSRRW_3    b2 CSRRW_4    0110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b2 CSRRW_4    de Fetch      0110100000010001000110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b3 unxb3         (use dinx) 0000000000000000000000000000000000000 b3: Not in use                                           00000000 
 * b4 eFetch3       (use dinx) 0010000000000011001111111101100100110  Fr10  Update minstret, Q=immediate. Use dinx            00000000 
 * b5 SH_3       9b SH_4       0000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b6 ECALL_5    9a ECALL_6    0110010000000000000101011001100100110        Q = 8                                             00000000 
 * b7 IJ_3       bd IJ_4       0010010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b8 BGE        13 condb_2    0000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 DIV_e      c0 DIV_D      0000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00005067 close to jalr
 * ba LHU_3      1a ANDI_1     0000010000000000000011111101100010000        Invert q. Prepare read mask                       00000000 
 * bb SH_2       b5 SH_3       0000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * bc CSRRWI_0   49 CSRRW_1    0000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd IJ_4       de Fetch      0000110000010000000110111100100011000        Mask and use as PC                                00000000 
 * be IJ_1       1f IJ_2       0000010000010000000101111101100001000        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * bf IJT_1      c1 IJT_2      0000010000010000000101111101100001000        Exit CSR, enter trap                              00000000 
 * c0 DIV_D      88 DIV_E      0000010000000000000111011101101001000        Is RS2 == 0?                                      00006003 close to load
 * c1 IJT_2      e9 IJT_3      0000000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c2 DIVU_3     ca DIVU_2     0010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000600b close to ij
 * c3 DIVU_4     8a DIVU_5     1010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000600f close to fence
 * c4 ORI_0      e1 ORI_1      0000000000000001000111111101000010000 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_5     6f MRET_6     0000010000000000000000011101100010000        ~302                                              00000000 
 * c6 IJT_4      47 ILL_2      0000000000000001101101011101100011000        Mask and store to mepc and Q for read of instr    00000000 
 * c7 QINT_1     cb QINT_2     0000000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * c8 DIV_7      62 DIV_8      0100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00006023 close to store
 * c9 MRET_2     a5 MRET_3     0010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * ca DIVU_2     c2 DIVU_3     0100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            40006023 close to store
 * cb QINT_2     e6 StdIncPc   0000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * cc OR_0       26 OR_1       0000010000000000000111111001000000000 OR     or                                                00006033 or      
 * cd REM_0      82 DIV_1      1100010000000000000101101101100001000 REM    Branch on sign dividend RS1                       00000000 
 * ce _LCSRRCI_1 fe ILLe       0000010000000000000000011000000000000 Illegal instruction seen                                 40006033 sloppy or      
 * cf MRET_7     4f MRET_8     0000010000000000000011011001001000000        Prepare emulation entry point 0x104               00000000 
 * d0 ECALL_1    37 ECALL_2    0010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * d1 MRET_1     c9 MRET_2     0000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * d2 LB_2       06 LB_3       0000010000100000000101001101100001001        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * d3 aFaultd    1e aFault_1   0000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * d4 aFault_2   92 LDAF_3     0010000110000001110001011100000100110        Store 5 to mcause                                 00000000 
 * d5 eFetch2    b4 eFetch3    0010000000000001011000111111000100000  Fr10  Update ttime                                      00000000 
 * d6 eILL0c     fe ILLe       0000010000000000000000011000000000000 Illegal instruction seen                                 00000000 
 * d7 ECALL_3    a1 ECALL_4    0000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * d8 BLTU       13 condb_2    0000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MULH_3     42 MULHU_2    0100010000000000000111111001000000000        rM<=RS2, Q = 0. next read RS1. Join.              00006067 close to jalr
 * da LDAF_a     91 LDAF_2     0000010000000000000101011001000000000        Extra cycle after error detected write mtval      00000000 
 * db jFault_1   92 LDAF_3     0010000000000001110000011100000100110        Store 1 to mcause                                 00000000 
 * dc CSRRSI_0   49 CSRRW_1    0000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd aF_SW_1    e5 aF_SW_2    0000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * de Fetch      f4 Fetch2     0000000000000001010001111101010110000  Fr10  Read and latch instruction                        00000000 
 * df eFetch     d5 eFetch2    0000001001010001010101111101010110000  Fr10  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * e0 DIVU_1     ca DIVU_2     0000000000000001100101111101000000000        Store inverted rs2 to yy. Prepare shift           00007003 close to load
 * e1 ORI_1      1d ORI_2      0000010000000000000000011101100001000        Q = RS1                                           00000000 
 * e2 MUL_1      e8 MUL_2      0000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           0000700b close to ij
 * e3 MUL_3      1a ANDI_1     0110010000000000000101111001000000001        Transfer rM to rDee                               0000700f close to fence
 * e4 ANDI_0     1a ANDI_1     0000010000000000000111111101100010000 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 aF_SW_2    b0 aF_SW_3    0110010000000000000101011001100100110        Q = 4                                             00000000 
 * e6 StdIncPc   de Fetch      0110100000010001000110111000100100110  Fr10  IncPC, OpFetch                                    00000000 
 * e7 aFault     1e aFault_1   0000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * e8 MUL_2      e2 MUL_1      0100010000000000000111011101100001000        Shift Q and rM. Prepare read rs2                  00007023 close to store
 * e9 IJT_3      c6 IJT_4      0010010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ea MULHU_5    22 MULHU_6    0000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          40007023 close to store
 * eb LH_3       56 LH_4       0000010000000000000011111101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * ec AND_0      11 AND_1      0000010000000000000111111001000000000 AND    And                                               00007033 and     
 * ed REMU_0     e0 DIVU_1     0100010000000000000111001001000000000 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee eILL0a     fe ILLe       0000010000000000000000011000000000000 Illegal instruction seen                                 40007033 sloppy and     
 * ef WFI_5      de Fetch      0110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * f0 LBU_2      72 LBU_3      0000010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * f1 aFaulte    1e aFault_1   0000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * f2 SW_2       e6 StdIncPc   0000010000000000000001011001000000000        Prepare read PC                                   00000000 
 * f3 aF_SW      dd aF_SW_1    0000010000000000000000011000100000000  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * f4 Fetch2        (use dinx) 0010000000000011011111111111100100000  Fr10  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f5 jFault     db jFault_1   0000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * f6 WFI_1      fa WFI_2      0110010000000000000000011001100100110 WFI    Chk offset=0x105. Now=0xff. Prep 0xff+4 = 0x103   00000000 
 * f7 EBREAK_1   ab EBREAK_2   0000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * f8 BGEU       13 condb_2    0000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 MULH_2     d9 MULH_3     0010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00007067 close to jalr
 * fa WFI_2      45 WFI_3      0010010000000000000101011101100100110        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104   00000000 
 * fb SB_3       6b SB_4       0000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fc CSRRCI_0   49 CSRRW_1    0000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      7e NMI_1      0000010000000000000001011001000000000 NMI    Get current PC                                    00000000 
 * fe ILLe       46 ILL_1      0000010000000000000001011000000000000 Illegal                                                  00000000 
 * ff QINT_0     c7 QINT_1     0000010000000000000001011001000000000 INT    Get current PC                                    00000000 
 */
localparam v6_u0_0 = 256'h30e6001000e208041886205a008b205a18091007000420e600e620be09d22001;
localparam v6_u0_1 = 256'h30b726d438e630a6303218e620413013207436de48162615001400fe001a008b;
localparam v6_u0_2 = 256'h30e63042086a003e2630209600212096201d00270004303500e6213900e62052;
localparam v6_u0_3 = 256'h083a0835090330493032093d08e6301348d72803083608de20812086002b32e6;
localparam v6_u0_4 = 256'h26e600fe082e003108b12066264b2066088f08472665102b00ea2160260b2050;
localparam v6_u0_5 = 256'h30da097028fb30493032085d309c096e008b1857301e09eb30da095430da08e6;
localparam v6_u0_6 = 256'h26cf08b9082e0031087a00f9008b08e6309308f240ef102b265826c850f70842;
localparam v6_u0_7 = 256'h087d089008343049303208f226a830aa267d00770073b0f40876101a301e09ba;
localparam v6_u0_8 = 256'h26a900fe0882002926e6011a30e6009c087f269e09f01021208200a8087d2085;
localparam v6_u0_9 = 256'h08f2083408a20868089f203400fe3013309308bb269428340895083426923034;
localparam v6_u0_A = 256'h26c5003f00e0003f089a00c826340078206130d026af303a08e6008b26b6205e;
localparam v6_u0_B = 256'h08c1081f18de304928b5101a06c0301320bd269a309b2600000026de26b22092;
localparam v6_u0_C = 256'h404f00fe0882002630e62cc220a52c6208cb1847106f10e1268a26ca30e94888;
localparam v6_u0_D = 256'hb0d5b0f430e53049269200910042301330a100fe20b42692301e090630c92637;
localparam v6_u0_E = 256'h26de00fe00e000111056202220c608e2301e26de26b0101a011a21e8081d00ca;
localparam v6_u0_F = 256'h00c70046007e3049306b264526d9301330ab26fa30db200000dd00e6301e0972;
localparam v6_u1_0 = 256'h10ba03b203b203bbb0ba23ab017b23ab017b01bb00b110ba00b2837b02fb036b;
localparam v6_u1_1 = 256'h32ba02b310ba82f980b910ba32ba33baab7b2b71233b00bb03fb003003bb03fb;
localparam v6_u1_2 = 256'h10ba23fa029b03b0003aa3ab03bba3ab003b23ba00b103c800b202bb10bab36b;
localparam v6_u1_3 = 256'h03c803c8129b31ba80b9129b10ba33ba343a12db12db2b793cb830ba03fb10ba;
localparam v6_u1_4 = 256'h02bb0030339a03b20eb983bb00bb83bb3eba36b802bb03fb0039029b033b837b;
localparam v6_u1_5 = 256'h3eb902fb32db31ba80b932db33fa02fb023b023b3eba029b3eb902fb3eb912fa;
localparam v6_u1_6 = 256'h003b33b9339a03b20b3b32ba02bb10ba3cb80fb900b203fb02fb02db21ba03fb;
localparam v6_u1_7 = 256'h3eb8343a3a7831ba80b90b3902bb303a36b800bb00b002fa3f3a01bb3eba029b;
localparam v6_u1_8 = 256'h02bb003002db03f210ba02f210ba03f0373810b002fb03fb02bb23ba36b8036b;
localparam v6_u1_9 = 256'h07392338033a033a073b3a70003033ba3cb832db02f33a7836fa367838b03d3a;
localparam v6_u1_A = 256'h003b03b0039203b036ba02f23a7802bb003b82f901bb03c810ba02bb02b3b36b;
localparam v6_u1_B = 256'h02fb02fb037931ba32db01fb033b33ba033302b3003a67fb0000237102b338b0;
localparam v6_u1_C = 256'h01b2003002db03f23d3a033b01b3033b343a36bb003b23fa02fb02db32ba03bb;
localparam v6_u1_D = 256'h2afa28fa3eba31ba383802b203f233ba3eba00302c7e38b83eba029b21ba00bb;
localparam v6_u1_E = 256'h2b710030039203f201fb033b033303bb3eba237102b303fb02f2029b003b32fa;
localparam v6_u1_F = 256'h00b200b000b231ba003a02bb23ba33ba3cba00333eba6fff003100b23eba029b;
localparam v6_u2_0 = 256'h00000080088000800001040000800400008000800080040000800590008a0580;
localparam v6_u2_1 = 256'h00000c8000000080008100000400000005010102000004800080008000800080;
localparam v6_u2_2 = 256'h0000080000800080048004000080040004800000008000800080008000000500;
localparam v6_u2_3 = 256'h0080008000040000008100000800000000000004000001020400040000800000;
localparam v6_u2_4 = 256'h0480008000000080002007810480078100000000048000800080008004800581;
localparam v6_u2_5 = 256'h0000008a000400000081000000000c8000800080000000840000008a00000042;
localparam v6_u2_6 = 256'h0480000000000080038000000080000000000000008000801480048000000880;
localparam v6_u2_7 = 256'h0000000000300000008100000c80000004000080008000ca0000008000000084;
localparam v6_u2_8 = 256'h00800080188000800c000c800000188000002c00008a00800480000000000580;
localparam v6_u2_9 = 256'h00000000188018800380043000800000000000000c800030000000000c300030;
localparam v6_u2_A = 256'h048000800880008000000880043018800480008104800080000000800c800500;
localparam v6_u2_B = 256'h0082008201820000000400800080000004800c800080040000000d020c800430;
localparam v6_u2_C = 256'h0080008018800080003008800480088000000000008000001480048000000080;
localparam v6_u2_D = 256'h004a000000000000040000800880000000000080040004300000008400000480;
localparam v6_u2_E = 256'h0d02008008800080008000800480088000000d020c8000800c80008000800000;
localparam v6_u2_F = 256'h0080008000800000008004800400000000000c80000004000080008000000084;
/*
 * =================================================
 * * Version 7. MULDIV MINSTRET EBR_MINSTRET       *
 * =================================================
 *                             Microcode instruction
 * uPC           next uPC      44444333333333322222222221111111111
 * || label      || next label 4321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       0010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       d2 LB_2       0000010001010000000101111101100001001        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       be IJ_1       0010110010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     e6 StdIncPc   0000010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     e6 StdIncPc   0010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     0000010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 LB_3       07 LB_4       0000010000000000000011011101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * 07 LB_4       09 LB_5       0000010000000000000010111101100011000        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 08 _L0x08     5a SB_1       0010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_5       8b LB_6       0000010000000000000010111101100000000        q = D^0xffffffff^q = D^0x80                       00000000 
 * 0a _L0x0a     5a SB_1       0010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b JALR_2     86 JAL_2      0000000000001101100001011101000011000        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 0c ADD_0      04 ADDI_0     0000010000000000000111011101100001000 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      e2 MUL_1      0100010000000000000111011001000000000 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      10 SUB_1      0000010000000000000111011001000000000 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     e6 StdIncPc   0000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 SUB_1      8b LB_6       0000010000000000000111111101100000000        Q = ~RS2                                          00000000 
 * 11 AND_1      1a ANDI_1     0000010000000000000111011101100000000        RS1^0xffffffff to Q                               00000000 
 * 12 _L0x12     fe ILLe       0000010000000000000000011000000000000  Not in use (illegal as entry)                           00000000 
 * 13 condb_2    14 condb_3    0000010000000000000111111101100000000        ~RS2 in Q                                         00000000 
 * 14 condb_3    15 condb_4    0010010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 15 condb_4    16 condb_5    0000000000000001000110011101101001000        Branch on condition                               00000000 
 * 16 condb_5    de Fetch      0000100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 17 condb_5t   74 BrOpFet    0010100000001101010110111101100100000        Branch taken.                                     00000000 
 * 18 BEQ        13 condb_2    0000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     41 JALR_1     0010000000000001100101011101000100000 JALR   yy=RS1+imm                                        00000067 jalr    
 * 1a ANDI_1     e6 StdIncPc   0000000000000000100001011101000011000        rd = Iimm & RS1                                   00000000 
 * 1b _L0x1b     32 JAL_1      0000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   a6 ECAL_RET   0000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d ORI_2      e6 StdIncPc   0000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 1e aFault_1   d4 aFault_2   0110010000000000000101011001100100110        Q = 4                                             00000000 
 * 1f IJ_2       b7 IJ_3       0000000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 20 LH_0       52 LH_1       0010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 XORI_1     e6 StdIncPc   0000000000000000100001011101000000000        rd = Iimm ^ RS1                                   00000000 
 * 22 MULHU_6    39 MULHU_7    0000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      0000100b close to ij
 * 23 _L0x23     e6 StdIncPc   0000010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     35 SLLI_1     0000010000000000000111100100000110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     0000010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 OR_1       27 OR_2       0000000000000001000111011101000000000        RS1^0xffffffff to jj                              00000000 
 * 27 OR_2       1d ORI_2      0010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 28 _L0x28     96 SH_1       0010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 XOR_1      21 XORI_1     0000010000000000000111011101100000000        Q = RS1^0xFFFFFFFF                                00000000 
 * 2a _L0x2a     96 SH_1       0010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b SLTIX_1    30 SLTIX_2    0010010000000000000000011101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 2c SLL_0      3e SLL_1      0000010000000000000111011000000000000 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     6a MULH_1     0000010000000000000101001101100001000 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e MULHU_1    42 MULHU_2    0100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                40001033 sloppy sll     
 * 2f _L0x2f     e6 StdIncPc   0000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SLTIX_2    e6 StdIncPc   0000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 31 SLTX_1     2b SLTIX_1    0000010000000000000111111101100000000        ~rs2 to Q                                         00000000 
 * 32 JAL_1      86 JAL_2      0010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 33 JAERR_1    81 JAERR_2    0010000000000001111001011100000100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 34 JAL_3      de Fetch      0000100000010001010110111100100001000        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 35 SLLI_1     36 SLLI_2     0000000000000000100101101101100001000        Register to shift to Q (and TRG for shift 0)      00000000 
 * 36 SLLI_2     03 _L0x03     0000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 37 ECALL_2    d7 ECALL_3    0000000000000001101000011101001001000        mepc = pc, prep store 0 to mtval                  00000000 
 * 38 BNE        13 condb_2    0000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 MULHU_7    e6 StdIncPc   0100000000000000100001011101000001000        Last shift.                                       00001067 close to jalr
 * 3a SRxI_1     3d SRxI_2     0000000000000000100101001101100001001        Register to shift to Q                            00000000 
 * 3b _L0x3b     32 JAL_1      0000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    49 CSRRW_1    0000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d SRxI_2     03 _L0x03     0000000000100000100101001101100001001        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 3e SLL_1      35 SLLI_1     0000010000000000000111100100000001000        Shiftamount was in low 5 bits of RS2              00000000 
 * 3f SRx_1      3a SRxI_1     0000010000000000000111100100000001000        Shiftamount in low 5 bits of RS2                  00000000 
 * 40 LW_0       50 LW_1       0010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 JALR_1     0b JALR_2     0010010000000000000110011101100100110        Q=1                                               00000000 
 * 42 MULHU_2    60 MULHU_3    0000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           0000200b close to ij
 * 43 MULHU_4    ea MULHU_5    0000010000000000000000011100100000000        Prepare read Rjj.                                 0000200f close to fence
 * 44 SLTI_0     2b SLTIX_1    0000010000000000000111111101100010000 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 WFI_3      65 WFI_4      0010010000000000000101011101100100110        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105        00000000 
 * 46 ILL_1      47 ILL_2      0000000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 47 ILL_2      8f ILL_3      0000000000000001111101011101000001000        Store 0 to mtval                                  00000000 
 * 48 _L0x48     66 SW_1       0011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 CSRRW_1    4b CSRRW_2    0010010000000000000001011101100100110        Construct PC storage adr                          00000000 
 * 4a _L0x4a     66 SW_1       0011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b CSRRW_2    b1 CSRRW_3    0000000100000000011101011100100001000        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 4c SLT_0      31 SLTX_1     0000010000000000000111011001000000000 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   2e MULHU_1    0000000000000001100111001101000001000 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e eILL0b     fe ILLe       0000010000000000000000011000000000000 Illegal instruction seen                                 40002033 sloppy slt     
 * 4f MRET_8     e6 StdIncPc   0010010000000000000101011101100100110        Prep +4                                           00000000 
 * 50 LW_1       e6 StdIncPc   0000001000010000100101111101000001000        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 51 LDAF_LW    da LDAF_a     0000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 52 LH_1       54 LH_2       0000010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 53 LDAF_LH    da LDAF_a     0000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 54 LH_2       eb LH_3       0000010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 55 aFaultb    1e aFault_1   0000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 56 LH_4       57 LH_5       0000010000000000000100011101100011000        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 57 LH_5       8b LB_6       0000010000000000000100011101100000000        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 58 DIV_A      6e DIV_C      0110010000000000000101111101100001001        Transfer rM to rDee                               00002063 close to branch
 * 59 DIV_B      9c DIV_10     0000000000000001100111111101000110000        REM = Q to yy                                     00002067 close to jalr
 * 5a SB_1       5d SB_2       0000000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5b _L0x5b     32 JAL_1      0000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    49 CSRRW_1    0000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SB_2       fb SB_3       0000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 5e LHU_1      70 LHU_2      0000010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 5f LDAF_LHU   da LDAF_a     0000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 60 MULHU_3    42 MULHU_2    0100010000000000000111111101100001000        Shift Q and rM. Prepare read rs1                  00003003 close to load
 * 61 EBRKWFI2   f7 EBREAK_1   0000000000000001000011011101001010000 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 62 DIV_8      c8 DIV_7      0010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIV_9      58 DIV_A      1010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    2b SLTIX_1    0000010000000000000111111101100010000 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 WFI_4      ef WFI_5      0000010000000000000001011001001000000        Prepare read PC                                   00000000 
 * 66 SW_1       f2 SW_2       0000000000000000011111011100100001000        Write d to a+k until accepted                     00000000 
 * 67 SW_E1SWE   93 SW_E2      0000000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 68 DIV_12     e6 StdIncPc   0000000000000000100001011101000001000        RS2 > 0, RS1 >= 0, yy is true result              00003023 close to store
 * 69 DIV_13     8b LB_6       0000010000000000000101011101100000000        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 6a MULH_1     f9 MULH_2     0000000000000001100101011101000000000        Store ~rs1 to Ryy. Prep construct 1.              40003023 close to store
 * 6b SB_4       7a SB_5       0001110000000000010110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 6c SLTU_0     31 SLTX_1     0000010000000000000111011001000000000 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    2e MULHU_1    0000000000000001100111001101000001000 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_C      b9 DIV_e      0000000000000001100111011100100001000        rM to yy. Q=ffffffff                              40003033 sloppy sltu    
 * 6f MRET_6     cf MRET_7     0010010000000000000000011101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 70 LHU_2      ba LHU_3      0000010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 71 aFaultc    1e aFault_1   0000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 72 LBU_3      1a ANDI_1     0000010000000000000011011101100010000        Invert q. Prepare read mask                       00000000 
 * 73 BAERR_1    76 BAERR_2    0000000000000001111110011101000001000        Faultadr to mtval. Prepare get offset             00000000 
 * 74 BrOpFet    f4 Fetch2     0000011001010000000101111101010110000 NewOp2 Read until instruction latched                    00000000 
 * 75 BAlignEr   73 BAERR_1    0000010000000000000001011000000000000  Err   Branch target instruction address misaligned      00000000 
 * 76 BAERR_2    77 BAERR_3    0000010000000000000001011101100000000        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 77 BAERR_3    7d BAERR_4    0010000000000001101101011100000100110        origPC to mepc. Prep read 0                       00000000 
 * 78 DIV_4      aa DIV_6      0000000000000001100000011101000110000        ~abs(divisor) to yy                               00003063 close to branch
 * 79 DIV_5      a8 DIV_3      0110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00003067 close to jalr
 * 7a SB_5       f2 SW_2       0000000000000000010110011100100001000        Write d to a+k until accepted                     00000000 
 * 7b _L0x7b     32 JAL_1      0000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    49 CSRRW_1    0000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d BAERR_4    34 JAL_3      0000000110000001110100111100000001000        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 7e NMI_1      90 NMI_2      0000000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * 7f JALRE2     7d BAERR_4    0000000000000001111101011100000001000        mtval is target                                   00000000 
 * 80 LBU_0      85 LBU_1      0010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 JAERR_2    7d BAERR_4    0000000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 82 DIV_1      a8 DIV_3      0000000000000001000111011101000000000        jj=abs(RS1). Next handle divisor                  0000400b close to ij
 * 83 DIV_2      82 DIV_1      0010010000000000000101011101100100000        Dividend negative, make RS1-1                     0000400f close to fence
 * 84 XORI_0     21 XORI_1     0000010000000000000111111101100010000 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 LBU_1      f0 LBU_2      0000010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 86 JAL_2      9e JAL_25     0110000000000000100001011000000100110        Return address to TRG                             00000000 
 * 87 JALRE1     7f JALRE2     0000000000000001101110011100000001000  err   Store pc to mepc                                  00000000 
 * 88 DIV_E      9c DIV_10     1100010000000000000111111000000000000        RS2 != 0. Check signs                             00004023 close to store
 * 89 DIV_F      e6 StdIncPc   0000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 8a DIVU_5     1a ANDI_1     0110010000000000000101111001000000001        Transfer rM to rDee                               40004023 close to store
 * 8b LB_6       e6 StdIncPc   0110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 8c XOR_0      29 XOR_1      0000010000000000000111111001000000000 XOR    xor                                               00004033 xor     
 * 8d DIV_0      82 DIV_1      1100010000000000000101101101100001000 DIV    Branch on sign dividend RS1                       00000000 
 * 8e _LCSRRS_1  fe ILLe       0000010000000000000000011000000000000 Illegal instruction seen                                 40004033 sloppy xor     
 * 8f ILL_3      a9 ILL_4      0000010000000000000101011101100100110        Q = 1                                             00000000 
 * 90 NMI_2      34 JAL_3      0000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 91 LDAF_2     92 LDAF_3     0110000110000001110001011000000100110        Store 4 to mcause                                 00000000 
 * 92 LDAF_3     34 JAL_3      0000000000000001101100111100000001000        PC to mepc                                        00000000 
 * 93 SW_E2      95 SW_E3      0000000000000001101101111101000001000        Store address that faulted                        00000000 
 * 94 SW_E4      34 JAL_3      0000000110000001110100111100000101000        Store 6 to mcause                                 00000000 
 * 95 SW_E3      94 SW_E4      0110010000000000000101111001100100110        Q = 3                                             00000000 
 * 96 SH_1       bb SH_2       0000000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 97 SW_E1SWH   93 SW_E2      0000000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 98 BLT        13 condb_2    0000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       0000010000000000000000011000000000000  Not in use (illegal as entry)                           00004067 close to jalr
 * 9a ECALL_6    34 JAL_3      0010000110000001110100111000000100000        mcause = 11                                       00000000 
 * 9b SH_4       9f SH_5       0001110000000000001110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 9c DIV_10     68 DIV_12     1100010000000000000110011101000001000        RS2 > 0. Branch on sign of RS1                    00004073 close to csr/system 
 * 9d DIV_11     a2 DIV_14     1100010000000000000110011101000001000        RS2 < 0. Branch on sign of RS1                    00000000 
 * 9e JAL_25     34 JAL_3      0000000000000001000110011100000001000        Instr. adr. to jj in case of access error         00000000 
 * 9f SH_5       f2 SW_2       0000000000000000001110011100100001000        Write d to a+k until accepted                     00000000 
 * a0 LHU_0      5e LHU_1      0010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_4    b6 ECALL_5    0110010000000000000101011001100100110        Q = 4                                             00000000 
 * a2 DIV_14     8b LB_6       0000010000000000000101011101100000000        RS2 < 0, RS1 >= 0, change sign yy                 0000500b close to ij
 * a3 DIV_15     e6 StdIncPc   0000000000000000100001011101000001000        RS2 < 0, RS1 < 0, yy is true result               0000500f close to fence
 * a4 SRxI_0     3a SRxI_1     0000010000000000000111100100000110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_3     af MRET_4     0010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * a6 ECAL_RET   d0 ECALL_1    0000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * a7 EBRKWFI1   61 EBRKWFI2   0010010000000000000000011101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * a8 DIV_3      78 DIV_4      1100010000000000000101011101100000000        Branch on sign divisor RS2                        00005023 close to store
 * a9 ILL_4      34 JAL_3      0010000110000001110100111100000100110        Store 2 to mcause                                 00000000 
 * aa DIV_6      c8 DIV_7      0100010000000000000101111001000000000        Write M. Prepare shift                            40005023 close to store
 * ab EBREAK_2   9a ECALL_6    0000000000000001101101011101000001000        pc to mepc                                        00000000 
 * ac _L0xac     3f SRx_1      0000010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     e0 DIVU_1     0100010000000000000111001001000000000 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     3f SRx_1      0000010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_4     c5 MRET_5     0010010000000000000000011101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b0 aF_SW_3    92 LDAF_3     0010000110000001110001011000000100000        Store 7 to mcause                                 00000000 
 * b1 CSRRW_3    b2 CSRRW_4    0110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b2 CSRRW_4    de Fetch      0110100000010001000110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b3 unxb3         (use dinx) 0000000000000000000000000000000000000 b3: Not in use                                           00000000 
 * b4 eFetch3       (use dinx) 0010000000000011001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * b5 SH_3       9b SH_4       0000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b6 ECALL_5    9a ECALL_6    0110010000000000000101011001100100110        Q = 8                                             00000000 
 * b7 IJ_3       bd IJ_4       0010010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b8 BGE        13 condb_2    0000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 DIV_e      c0 DIV_D      0000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00005067 close to jalr
 * ba LHU_3      1a ANDI_1     0000010000000000000011111101100010000        Invert q. Prepare read mask                       00000000 
 * bb SH_2       b5 SH_3       0000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * bc CSRRWI_0   49 CSRRW_1    0000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd IJ_4       de Fetch      0000110000010000000110111100100011000        Mask and use as PC                                00000000 
 * be IJ_1       1f IJ_2       0000010000010000000101111101100001000        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * bf IJT_1      c1 IJT_2      0000010000010000000101111101100001000        Exit CSR, enter trap                              00000000 
 * c0 DIV_D      88 DIV_E      0000010000000000000111011101101001000        Is RS2 == 0?                                      00006003 close to load
 * c1 IJT_2      e9 IJT_3      0000000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c2 DIVU_3     ca DIVU_2     0010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000600b close to ij
 * c3 DIVU_4     8a DIVU_5     1010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000600f close to fence
 * c4 ORI_0      e1 ORI_1      0000000000000001000111111101000010000 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_5     6f MRET_6     0000010000000000000000011101100010000        ~302                                              00000000 
 * c6 IJT_4      47 ILL_2      0000000000000001101101011101100011000        Mask and store to mepc and Q for read of instr    00000000 
 * c7 QINT_1     cb QINT_2     0000000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * c8 DIV_7      62 DIV_8      0100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00006023 close to store
 * c9 MRET_2     a5 MRET_3     0010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * ca DIVU_2     c2 DIVU_3     0100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            40006023 close to store
 * cb QINT_2     e6 StdIncPc   0000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * cc OR_0       26 OR_1       0000010000000000000111111001000000000 OR     or                                                00006033 or      
 * cd REM_0      82 DIV_1      1100010000000000000101101101100001000 REM    Branch on sign dividend RS1                       00000000 
 * ce _LCSRRCI_1 fe ILLe       0000010000000000000000011000000000000 Illegal instruction seen                                 40006033 sloppy or      
 * cf MRET_7     4f MRET_8     0000010000000000000011011001001000000        Prepare emulation entry point 0x104               00000000 
 * d0 ECALL_1    37 ECALL_2    0010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * d1 MRET_1     c9 MRET_2     0000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * d2 LB_2       06 LB_3       0000010000100000000101001101100001001        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * d3 aFaultd    1e aFault_1   0000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * d4 aFault_2   92 LDAF_3     0010000110000001110001011100000100110        Store 5 to mcause                                 00000000 
 * d5 unxd5         (use dinx) 0000000000000000000000000000000000000 d5: Not in use                                           00000000 
 * d6 eILL0c     fe ILLe       0000010000000000000000011000000000000 Illegal instruction seen                                 00000000 
 * d7 ECALL_3    a1 ECALL_4    0000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * d8 BLTU       13 condb_2    0000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MULH_3     42 MULHU_2    0100010000000000000111111001000000000        rM<=RS2, Q = 0. next read RS1. Join.              00006067 close to jalr
 * da LDAF_a     91 LDAF_2     0000010000000000000101011001000000000        Extra cycle after error detected write mtval      00000000 
 * db jFault_1   92 LDAF_3     0010000000000001110000011100000100110        Store 1 to mcause                                 00000000 
 * dc CSRRSI_0   49 CSRRW_1    0000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd aF_SW_1    e5 aF_SW_2    0000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * de Fetch      f4 Fetch2     0000001001010001010101111101010110000  Fr11  Read and latch instruction                        00000000 
 * df eFetch     f4 Fetch2     0000001001010001010101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * e0 DIVU_1     ca DIVU_2     0000000000000001100101111101000000000        Store inverted rs2 to yy. Prepare shift           00007003 close to load
 * e1 ORI_1      1d ORI_2      0000010000000000000000011101100001000        Q = RS1                                           00000000 
 * e2 MUL_1      e8 MUL_2      0000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           0000700b close to ij
 * e3 MUL_3      1a ANDI_1     0110010000000000000101111001000000001        Transfer rM to rDee                               0000700f close to fence
 * e4 ANDI_0     1a ANDI_1     0000010000000000000111111101100010000 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 aF_SW_2    b0 aF_SW_3    0110010000000000000101011001100100110        Q = 4                                             00000000 
 * e6 StdIncPc   de Fetch      0110100000010001000110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * e7 aFault     1e aFault_1   0000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * e8 MUL_2      e2 MUL_1      0100010000000000000111011101100001000        Shift Q and rM. Prepare read rs2                  00007023 close to store
 * e9 IJT_3      c6 IJT_4      0010010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ea MULHU_5    22 MULHU_6    0000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          40007023 close to store
 * eb LH_3       56 LH_4       0000010000000000000011111101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * ec AND_0      11 AND_1      0000010000000000000111111001000000000 AND    And                                               00007033 and     
 * ed REMU_0     e0 DIVU_1     0100010000000000000111001001000000000 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee eILL0a     fe ILLe       0000010000000000000000011000000000000 Illegal instruction seen                                 40007033 sloppy and     
 * ef WFI_5      de Fetch      0110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * f0 LBU_2      72 LBU_3      0000010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * f1 aFaulte    1e aFault_1   0000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * f2 SW_2       e6 StdIncPc   0000010000000000000001011001000000000        Prepare read PC                                   00000000 
 * f3 aF_SW      dd aF_SW_1    0000010000000000000000011000100000000  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * f4 Fetch2     b4 eFetch3    0010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f5 jFault     db jFault_1   0000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * f6 WFI_1      fa WFI_2      0110010000000000000000011001100100110 WFI    Chk offset=0x105. Now=0xff. Prep 0xff+4 = 0x103   00000000 
 * f7 EBREAK_1   ab EBREAK_2   0000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * f8 BGEU       13 condb_2    0000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 MULH_2     d9 MULH_3     0010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00007067 close to jalr
 * fa WFI_2      45 WFI_3      0010010000000000000101011101100100110        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104   00000000 
 * fb SB_3       6b SB_4       0000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fc CSRRCI_0   49 CSRRW_1    0000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      7e NMI_1      0000010000000000000001011001000000000 NMI    Get current PC                                    00000000 
 * fe ILLe       46 ILL_1      0000010000000000000001011000000000000 Illegal                                                  00000000 
 * ff QINT_0     c7 QINT_1     0000010000000000000001011001000000000 INT    Get current PC                                    00000000 
 */
localparam v7_u0_0 = 256'h30e6001000e208041886205a008b205a18091007000420e600e620be09d22001;
localparam v7_u0_1 = 256'h30b726d438e630a6303218e620413013207436de48162615001400fe001a008b;
localparam v7_u0_2 = 256'h30e63042086a003e2630209600212096201d00270004303500e6213900e62052;
localparam v7_u0_3 = 256'h083a0835090330493032093d08e6301348d72803083608de20812086002b32e6;
localparam v7_u0_4 = 256'h26e600fe082e003108b12066264b2066088f08472665102b00ea2160260b2050;
localparam v7_u0_5 = 256'h30da097028fb30493032085d309c096e008b1857301e09eb30da095430da08e6;
localparam v7_u0_6 = 256'h26cf08b9082e0031087a00f9008b08e6309308f240ef102b265826c850f70842;
localparam v7_u0_7 = 256'h087d089008343049303208f226a830aa267d00770073b0f40876101a301e09ba;
localparam v7_u0_8 = 256'h26a900fe0882002926e6011a30e6009c087f269e09f01021208200a8087d2085;
localparam v7_u0_9 = 256'h08f2083408a20868089f203400fe3013309308bb269428340895083426923034;
localparam v7_u0_A = 256'h26c5003f00e0003f089a00c826340078206130d026af303a08e6008b26b6205e;
localparam v7_u0_B = 256'h08c1081f18de304928b5101a06c0301320bd269a309b2600000026de26b22092;
localparam v7_u0_C = 256'h404f00fe0882002630e62cc220a52c6208cb1847106f10e1268a26ca30e94888;
localparam v7_u0_D = 256'hb0f4b0f430e53049269200910042301330a100fe00002692301e090630c92637;
localparam v7_u0_E = 256'h26de00fe00e000111056202220c608e2301e26de26b0101a011a21e8081d00ca;
localparam v7_u0_F = 256'h00c70046007e3049306b264526d9301330ab26fa30db20b400dd00e6301e0972;
localparam v7_u1_0 = 256'h10ba03b203b203bbb0ba23ab017b23ab017b01bb00b110ba00b2837b02fb036b;
localparam v7_u1_1 = 256'h32ba02b310ba82f980b910ba32ba33baab7b2b71233b00bb03fb003003bb03fb;
localparam v7_u1_2 = 256'h10ba23fa029b03b0003aa3ab03bba3ab003b23ba00b103c800b202bb10bab36b;
localparam v7_u1_3 = 256'h03c803c8129b31ba80b9129b10ba33ba343a12db12db2b793cb830ba03fb10ba;
localparam v7_u1_4 = 256'h02bb0030339a03b20eb983bb00bb83bb3eba36b802bb03fb0039029b033b837b;
localparam v7_u1_5 = 256'h3eb902fb32db31ba80b932db33fa02fb023b023b3eba029b3eb902fb3eb912fa;
localparam v7_u1_6 = 256'h003b33b9339a03b20b3b32ba02bb10ba3cb80fb900b203fb02fb02db21ba03fb;
localparam v7_u1_7 = 256'h3eb8343a3a7831ba80b90b3902bb303a36b800bb00b002fa3f3a01bb3eba029b;
localparam v7_u1_8 = 256'h02bb003002db03f210ba02f210ba03f0373810b002fb03fb02bb23ba36b8036b;
localparam v7_u1_9 = 256'h07392338033a033a073b3a70003033ba3cb832db02f33a7836fa367838b03d3a;
localparam v7_u1_A = 256'h003b03b0039203b036ba02f23a7802bb003b82f901bb03c810ba02bb02b3b36b;
localparam v7_u1_B = 256'h02fb02fb037931ba32db01fb033b33ba033302b3003a67fb0000237102b338b0;
localparam v7_u1_C = 256'h01b2003002db03f23d3a033b01b3033b343a36bb003b23fa02fb02db32ba03bb;
localparam v7_u1_D = 256'h2afa2afa3eba31ba383802b203f233ba3eba0030000038b83eba029b21ba00bb;
localparam v7_u1_E = 256'h2b710030039203f201fb033b033303bb3eba237102b303fb02f2029b003b32fa;
localparam v7_u1_F = 256'h00b200b000b231ba003a02bb23ba33ba3cba00333eba2c7e003100b23eba029b;
localparam v7_u2_0 = 256'h00000080088000800001040000800400008000800080040000800590008a0580;
localparam v7_u2_1 = 256'h00000c8000000080008100000400000005010102000004800080008000800080;
localparam v7_u2_2 = 256'h0000080000800080048004000080040004800000008000800080008000000500;
localparam v7_u2_3 = 256'h0080008000040000008100000800000000000004000001020400040000800000;
localparam v7_u2_4 = 256'h0480008000000080002007810480078100000000048000800080008004800581;
localparam v7_u2_5 = 256'h0000008a000400000081000000000c8000800080000000840000008a00000042;
localparam v7_u2_6 = 256'h0480000000000080038000000080000000000000008000801480048000000880;
localparam v7_u2_7 = 256'h0000000000300000008100000c80000004000080008000ca0000008000000084;
localparam v7_u2_8 = 256'h00800080188000800c000c800000188000002c00008a00800480000000000580;
localparam v7_u2_9 = 256'h00000000188018800380043000800000000000000c800030000000000c300030;
localparam v7_u2_A = 256'h048000800880008000000880043018800480008104800080000000800c800500;
localparam v7_u2_B = 256'h0082008201820000000400800080000004800c800080040000000d020c800430;
localparam v7_u2_C = 256'h0080008018800080003008800480088000000000008000001480048000000080;
localparam v7_u2_D = 256'h004a004a00000000040000800880000000000080000004300000008400000480;
localparam v7_u2_E = 256'h0d02008008800080008000800480088000000d020c8000800c80008000800000;
localparam v7_u2_F = 256'h0080008000800000008004800400000000000c80000004000080008000000084;
/*
 * =================================================
 * * Version 8. RVC                                *
 * =================================================
 *                             Microcode instruction
 * uPC           next uPC      444333333333322222222221111111111
 * || label      || next label 21098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ----------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       10110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       d2 LB_2       00010001010000000101111101100001001        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       be IJ_1       10110010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     e6 StdIncPc   00010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     e6 StdIncPc   10000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 LB_3       07 LB_4       00010000000000000011011101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * 07 LB_4       09 LB_5       00010000000000000010111101100011000        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 08 _L0x08     5a SB_1       10000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_5       8b LB_6       00010000000000000010111101100000000        q = D^0xffffffff^q = D^0x80                       00000000 
 * 0a _L0x0a     5a SB_1       10000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b JALR_2     86 JAL_2      00000000001101100001011101000011000        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 0c ADD_0      04 ADDI_0     00010000000000000111011101100001000 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     e6 StdIncPc   00000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      10 SUB_1      00010000000000000111011001000000000 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     e6 StdIncPc   00000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 SUB_1      8b LB_6       00010000000000000111111101100000000        Q = ~RS2                                          00000000 
 * 11 AND_1      1a ANDI_1     00010000000000000111011101100000000        RS1^0xffffffff to Q                               00000000 
 * 12 _L0x12     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00000000 
 * 13 condb_2    14 condb_3    00010000000000000111111101100000000        ~RS2 in Q                                         00000000 
 * 14 condb_3    15 condb_4    10010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 15 condb_4    16 condb_5    00000000000001000110011101101001000        Branch on condition                               00000000 
 * 16 condb_5    de Fetch      00100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 17 condb_5t   74 BrOpFet    10100000001101010110111101100100000        Branch taken.                                     00000000 
 * 18 BEQ        13 condb_2    00000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     41 JALR_1     10000000000001100101011101000100000 JALR   yy=RS1+imm                                        00000067 jalr    
 * 1a ANDI_1     e6 StdIncPc   00000000000000100001011101000011000        rd = Iimm & RS1                                   00000000 
 * 1b _L0x1b     32 JAL_1      00010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   a6 ECAL_RET   00010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d ORI_2      e6 StdIncPc   00000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 1e aFault_1   d4 aFault_2   10010000000000000101011001100100110        Q = 4                                             00000000 
 * 1f IJ_2       b7 IJ_3       00000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 20 LH_0       52 LH_1       10100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 XORI_1     e6 StdIncPc   00000000000000100001011101000000000        rd = Iimm ^ RS1                                   00000000 
 * 22 _L0x22     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000100b close to ij
 * 23 _L0x23     e6 StdIncPc   00010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     35 SLLI_1     00010000000000000111100100000110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 OR_1       27 OR_2       00000000000001000111011101000000000        RS1^0xffffffff to jj                              00000000 
 * 27 OR_2       1d ORI_2      10010000000000000000011101100100000        Q = rs2                                           00000000 
 * 28 _L0x28     96 SH_1       10000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 XOR_1      21 XORI_1     00010000000000000111011101100000000        Q = RS1^0xFFFFFFFF                                00000000 
 * 2a _L0x2a     96 SH_1       10000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b SLTIX_1    30 SLTIX_2    10010000000000000000011101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 2c SLL_0      3e SLL_1      00010000000000000111011000000000000 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     e6 StdIncPc   00000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e unx2e         (use dinx) 00000000000000000000000000000000000 2e: Not in use                                           40001033 sloppy sll     
 * 2f _L0x2f     e6 StdIncPc   00000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SLTIX_2    e6 StdIncPc   00000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 31 SLTX_1     2b SLTIX_1    00010000000000000111111101100000000        ~rs2 to Q                                         00000000 
 * 32 JAL_1      86 JAL_2      10000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 33 JAERR_1    81 JAERR_2    10000000000001111001011100000100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 34 JAL_3      de Fetch      00100000010001010110111100100001000        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 35 SLLI_1     36 SLLI_2     00000000000000100101101101100001000        Register to shift to Q (and TRG for shift 0)      00000000 
 * 36 SLLI_2     03 _L0x03     00000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 37 ECALL_2    d7 ECALL_3    00000000000001101000011101001001000        mepc = pc, prep store 0 to mtval                  00000000 
 * 38 BNE        13 condb_2    00000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 _L0x39     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00001067 close to jalr
 * 3a SRxI_1     3d SRxI_2     00000000000000100101001101100001001        Register to shift to Q                            00000000 
 * 3b _L0x3b     32 JAL_1      00010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    49 CSRRW_1    00000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d SRxI_2     03 _L0x03     00000000100000100101001101100001001        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 3e SLL_1      35 SLLI_1     00010000000000000111100100000001000        Shiftamount was in low 5 bits of RS2              00000000 
 * 3f SRx_1      3a SRxI_1     00010000000000000111100100000001000        Shiftamount in low 5 bits of RS2                  00000000 
 * 40 LW_0       50 LW_1       10110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 JALR_1     0b JALR_2     10010000000000000110011101100100110        Q=1                                               00000000 
 * 42 _L0x42     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000200b close to ij
 * 43 _L0x43     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000200f close to fence
 * 44 SLTI_0     2b SLTIX_1    00010000000000000111111101100010000 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 WFI_3      65 WFI_4      10010000000000000101011101100100110        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105        00000000 
 * 46 ILL_1      47 ILL_2      00000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 47 ILL_2      8f ILL_3      00000000000001111101011101000001000        Store 0 to mtval                                  00000000 
 * 48 _L0x48     66 SW_1       11110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 CSRRW_1    4b CSRRW_2    10010000000000000001011101100100110        Construct PC storage adr                          00000000 
 * 4a _L0x4a     66 SW_1       11110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b CSRRW_2    b1 CSRRW_3    00000100000000011101011100100001000        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 4c SLT_0      31 SLTX_1     00010000000000000111011001000000000 SLT    Set less than (signed)                            00002033 slt     
 * 4d unx4d         (use dinx) 00000000000000000000000000000000000 4d: Not in use                                           00000000 
 * 4e eILL0b     fe ILLe       00010000000000000000011000000000000 Illegal instruction seen                                 40002033 sloppy slt     
 * 4f MRET_8     e6 StdIncPc   10010000000000000101011101100100110        Prep +4                                           00000000 
 * 50 LW_1       e6 StdIncPc   00001000010000100101111101000001000        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 51 LDAF_LW    da LDAF_a     00000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 52 LH_1       54 LH_2       00010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 53 LDAF_LH    da LDAF_a     00000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 54 LH_2       eb LH_3       00010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 55 aFaultb    1e aFault_1   00000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 56 LH_4       57 LH_5       00010000000000000100011101100011000        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 57 LH_5       8b LB_6       00010000000000000100011101100000000        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 58 _L0x58     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00002063 close to branch
 * 59 _L0x59     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00002067 close to jalr
 * 5a SB_1       5d SB_2       00000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5b _L0x5b     32 JAL_1      00010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    49 CSRRW_1    00000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SB_2       fb SB_3       00000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 5e LHU_1      70 LHU_2      00010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 5f LDAF_LHU   da LDAF_a     00000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 60 _L0x60     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00003003 close to load
 * 61 EBRKWFI2   f7 EBREAK_1   00000000000001000011011101001010000 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 62 _L0x62     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000300b close to ij
 * 63 _L0x63     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000300f close to fence
 * 64 SLTIU_0    2b SLTIX_1    00010000000000000111111101100010000 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 WFI_4      ef WFI_5      00010000000000000001011001001000000        Prepare read PC                                   00000000 
 * 66 SW_1       f2 SW_2       00000000000000011111011100100001000        Write d to a+k until accepted                     00000000 
 * 67 SW_E1SWE   93 SW_E2      00000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 68 _L0x68     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00003023 close to store
 * 69 unx69         (use dinx) 00000000000000000000000000000000000 69: Not in use                                           00000000 
 * 6a _L0x6a     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           40003023 close to store
 * 6b SB_4       7a SB_5       01110000000000010110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 6c SLTU_0     31 SLTX_1     00010000000000000111011001000000000 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d unx6d         (use dinx) 00000000000000000000000000000000000 6d: Not in use                                           00000000 
 * 6e unx6e         (use dinx) 00000000000000000000000000000000000 6e: Not in use                                           40003033 sloppy sltu    
 * 6f MRET_6     cf MRET_7     10010000000000000000011101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 70 LHU_2      ba LHU_3      00010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 71 aFaultc    1e aFault_1   00000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 72 LBU_3      1a ANDI_1     00010000000000000011011101100010000        Invert q. Prepare read mask                       00000000 
 * 73 BAERR_1    76 BAERR_2    00000000000001111110011101000001000        Faultadr to mtval. Prepare get offset             00000000 
 * 74 BrOpFet    f4 Fetch2     00011001010000000101111101010110000 NewOp2 Read until instruction latched                    00000000 
 * 75 BAlignEr   73 BAERR_1    00010000000000000001011000000000000  Err   Branch target instruction address misaligned      00000000 
 * 76 BAERR_2    77 BAERR_3    00010000000000000001011101100000000        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 77 BAERR_3    7d BAERR_4    10000000000001101101011100000100110        origPC to mepc. Prep read 0                       00000000 
 * 78 _L0x78     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00003063 close to branch
 * 79 _L0x79     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00003067 close to jalr
 * 7a SB_5       f2 SW_2       00000000000000010110011100100001000        Write d to a+k until accepted                     00000000 
 * 7b _L0x7b     32 JAL_1      00010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    49 CSRRW_1    00000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d BAERR_4    34 JAL_3      00000110000001110100111100000001000        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 7e NMI_1      90 NMI_2      00000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * 7f JALRE2     7d BAERR_4    00000000000001111101011100000001000        mtval is target                                   00000000 
 * 80 LBU_0      85 LBU_1      10110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 JAERR_2    7d BAERR_4    00000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 82 _L0x82     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000400b close to ij
 * 83 _L0x83     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000400f close to fence
 * 84 XORI_0     21 XORI_1     00010000000000000111111101100010000 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 LBU_1      f0 LBU_2      00010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 86 JAL_2      9e JAL_25     10000000000000100001011000000100110        Return address to TRG                             00000000 
 * 87 JALRE1     7f JALRE2     00000000000001101110011100000001000  err   Store pc to mepc                                  00000000 
 * 88 _L0x88     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00004023 close to store
 * 89 unx89         (use dinx) 00000000000000000000000000000000000 89: Not in use                                           00000000 
 * 8a _L0x8a     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           40004023 close to store
 * 8b LB_6       e6 StdIncPc   10000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 8c XOR_0      29 XOR_1      00010000000000000111111001000000000 XOR    xor                                               00004033 xor     
 * 8d unx8d         (use dinx) 00000000000000000000000000000000000 8d: Not in use                                           00000000 
 * 8e _LCSRRS_1  fe ILLe       00010000000000000000011000000000000 Illegal instruction seen                                 40004033 sloppy xor     
 * 8f ILL_3      a9 ILL_4      00010000000000000101011101100100110        Q = 1                                             00000000 
 * 90 NMI_2      34 JAL_3      00000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 91 LDAF_2     92 LDAF_3     10000110000001110001011000000100110        Store 4 to mcause                                 00000000 
 * 92 LDAF_3     34 JAL_3      00000000000001101100111100000001000        PC to mepc                                        00000000 
 * 93 SW_E2      95 SW_E3      00000000000001101101111101000001000        Store address that faulted                        00000000 
 * 94 SW_E4      34 JAL_3      00000110000001110100111100000101000        Store 6 to mcause                                 00000000 
 * 95 SW_E3      94 SW_E4      10010000000000000101111001100100110        Q = 3                                             00000000 
 * 96 SH_1       bb SH_2       00000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 97 SW_E1SWH   93 SW_E2      00000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 98 BLT        13 condb_2    00000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00004067 close to jalr
 * 9a ECALL_6    34 JAL_3      10000110000001110100111000000100000        mcause = 11                                       00000000 
 * 9b SH_4       9f SH_5       01110000000000001110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 9c _L0x9c     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00004073 close to csr/system 
 * 9d unx9d         (use dinx) 00000000000000000000000000000000000 9d: Not in use                                           00000000 
 * 9e JAL_25     34 JAL_3      00000000000001000110011100000001000        Instr. adr. to jj in case of access error         00000000 
 * 9f SH_5       f2 SW_2       00000000000000001110011100100001000        Write d to a+k until accepted                     00000000 
 * a0 LHU_0      5e LHU_1      10100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_4    b6 ECALL_5    10010000000000000101011001100100110        Q = 4                                             00000000 
 * a2 _L0xa2     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000500b close to ij
 * a3 _L0xa3     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000500f close to fence
 * a4 SRxI_0     3a SRxI_1     00010000000000000111100100000110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_3     af MRET_4     10010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * a6 ECAL_RET   d0 ECALL_1    00010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * a7 EBRKWFI1   61 EBRKWFI2   10010000000000000000011101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * a8 _L0xa8     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00005023 close to store
 * a9 ILL_4      34 JAL_3      10000110000001110100111100000100110        Store 2 to mcause                                 00000000 
 * aa _L0xaa     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           40005023 close to store
 * ab EBREAK_2   9a ECALL_6    00000000000001101101011101000001000        pc to mepc                                        00000000 
 * ac _L0xac     3f SRx_1      00010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad unxad         (use dinx) 00000000000000000000000000000000000 ad: Not in use                                           00000000 
 * ae _L0xae     3f SRx_1      00010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_4     c5 MRET_5     10010000000000000000011101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b0 aF_SW_3    92 LDAF_3     10000110000001110001011000000100000        Store 7 to mcause                                 00000000 
 * b1 CSRRW_3    b2 CSRRW_4    10010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b2 CSRRW_4    de Fetch      10100000010001000110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b3 unxb3         (use dinx) 00000000000000000000000000000000000 b3: Not in use                                           00000000 
 * b4 i0reserv      (use dinx) 00000000000000000000000000000000000 Not in use, reserved to allow LASTINCH                   00000000 
 * b5 SH_3       9b SH_4       00010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b6 ECALL_5    9a ECALL_6    10010000000000000101011001100100110        Q = 8                                             00000000 
 * b7 IJ_3       bd IJ_4       10010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b8 BGE        13 condb_2    00000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 _L0xb9     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00005067 close to jalr
 * ba LHU_3      1a ANDI_1     00010000000000000011111101100010000        Invert q. Prepare read mask                       00000000 
 * bb SH_2       b5 SH_3       00000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * bc CSRRWI_0   49 CSRRW_1    00000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd IJ_4       de Fetch      00110000010000000110111100100011000        Mask and use as PC                                00000000 
 * be IJ_1       1f IJ_2       00010000010000000101111101100001000        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * bf IJT_1      c1 IJT_2      00010000010000000101111101100001000        Exit CSR, enter trap                              00000000 
 * c0 _L0xc0     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00006003 close to load
 * c1 IJT_2      e9 IJT_3      00000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c2 _L0xc2     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000600b close to ij
 * c3 _L0xc3     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000600f close to fence
 * c4 ORI_0      e1 ORI_1      00000000000001000111111101000010000 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_5     6f MRET_6     00010000000000000000011101100010000        ~302                                              00000000 
 * c6 IJT_4      47 ILL_2      00000000000001101101011101100011000        Mask and store to mepc and Q for read of instr    00000000 
 * c7 QINT_1     cb QINT_2     00000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * c8 _L0xc8     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00006023 close to store
 * c9 MRET_2     a5 MRET_3     10010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * ca _L0xca     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           40006023 close to store
 * cb QINT_2     e6 StdIncPc   00000110000001111010011101000110000        mtval = 0.                                        00000000 
 * cc OR_0       26 OR_1       00010000000000000111111001000000000 OR     or                                                00006033 or      
 * cd unxcd         (use dinx) 00000000000000000000000000000000000 cd: Not in use                                           00000000 
 * ce _LCSRRCI_1 fe ILLe       00010000000000000000011000000000000 Illegal instruction seen                                 40006033 sloppy or      
 * cf MRET_7     4f MRET_8     00010000000000000011011001001000000        Prepare emulation entry point 0x104               00000000 
 * d0 ECALL_1    37 ECALL_2    10010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * d1 MRET_1     c9 MRET_2     00000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * d2 LB_2       06 LB_3       00010000100000000101001101100001001        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * d3 aFaultd    1e aFault_1   00000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * d4 aFault_2   92 LDAF_3     10000110000001110001011100000100110        Store 5 to mcause                                 00000000 
 * d5 unxd5         (use dinx) 00000000000000000000000000000000000 d5: Not in use                                           00000000 
 * d6 eILL0c     fe ILLe       00010000000000000000011000000000000 Illegal instruction seen                                 00000000 
 * d7 ECALL_3    a1 ECALL_4    00000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * d8 BLTU       13 condb_2    00000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 _L0xd9     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00006067 close to jalr
 * da LDAF_a     91 LDAF_2     00010000000000000101011001000000000        Extra cycle after error detected write mtval      00000000 
 * db jFault_1   92 LDAF_3     10000000000001110000011100000100110        Store 1 to mcause                                 00000000 
 * dc CSRRSI_0   49 CSRRW_1    00000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd aF_SW_1    e5 aF_SW_2    00000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * de Fetch      f4 Fetch2     00000000000001010001111101010110000  Fr00  Read and latch instruction                        00000000 
 * df eFetch     f4 Fetch2     00001001010001010101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * e0 _L0xe0     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00007003 close to load
 * e1 ORI_1      1d ORI_2      00010000000000000000011101100001000        Q = RS1                                           00000000 
 * e2 _L0xe2     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000700b close to ij
 * e3 _L0xe3     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000700f close to fence
 * e4 ANDI_0     1a ANDI_1     00010000000000000111111101100010000 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 aF_SW_2    b0 aF_SW_3    10010000000000000101011001100100110        Q = 4                                             00000000 
 * e6 StdIncPc   de Fetch      10100000010001000110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * e7 aFault     1e aFault_1   00000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * e8 _L0xe8     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00007023 close to store
 * e9 IJT_3      c6 IJT_4      10010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ea _L0xea     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           40007023 close to store
 * eb LH_3       56 LH_4       00010000000000000011111101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * ec AND_0      11 AND_1      00010000000000000111111001000000000 AND    And                                               00007033 and     
 * ed unxed         (use dinx) 00000000000000000000000000000000000 ed: Not in use                                           00000000 
 * ee eILL0a     fe ILLe       00010000000000000000011000000000000 Illegal instruction seen                                 40007033 sloppy and     
 * ef WFI_5      de Fetch      10100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * f0 LBU_2      72 LBU_3      00010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * f1 aFaulte    1e aFault_1   00000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * f2 SW_2       e6 StdIncPc   00010000000000000001011001000000000        Prepare read PC                                   00000000 
 * f3 aF_SW      dd aF_SW_1    00010000000000000000011000100000000  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * f4 Fetch2        (use dinx) 10000000000011011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f5 jFault     db jFault_1   00000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * f6 WFI_1      fa WFI_2      10010000000000000000011001100100110 WFI    Chk offset=0x105. Now=0xff. Prep 0xff+4 = 0x103   00000000 
 * f7 EBREAK_1   ab EBREAK_2   00000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * f8 BGEU       13 condb_2    00000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 _L0xf9     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00007067 close to jalr
 * fa WFI_2      45 WFI_3      10010000000000000101011101100100110        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104   00000000 
 * fb SB_3       6b SB_4       00010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fc CSRRCI_0   49 CSRRW_1    00000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      7e NMI_1      00010000000000000001011001000000000 NMI    Get current PC                                    00000000 
 * fe ILLe       46 ILL_1      00010000000000000001011000000000000 Illegal                                                  00000000 
 * ff QINT_0     c7 QINT_1     00010000000000000001011001000000000 INT    Get current PC                                    00000000 
 */
localparam v8_u0_0 = 256'h30e6001030e608041886205a008b205a18091007000420e600e620be09d22001;
localparam v8_u0_1 = 256'h30b726d438e630a6303218e620413013207436de48162615001400fe001a008b;
localparam v8_u0_2 = 256'h30e6000030e6003e2630209600212096201d00270004303500e600fe00e62052;
localparam v8_u0_3 = 256'h083a0835090330493032093d00fe301348d72803083608de20812086002b32e6;
localparam v8_u0_4 = 256'h26e600fe0000003108b12066264b2066088f08472665102b00fe00fe260b2050;
localparam v8_u0_5 = 256'h30da097028fb30493032085d00fe00fe008b1857301e09eb30da095430da08e6;
localparam v8_u0_6 = 256'h26cf000000000031087a00fe000000fe309308f240ef102b00fe00fe50f700fe;
localparam v8_u0_7 = 256'h087d089008343049303208f200fe00fe267d00770073b0f40876101a301e09ba;
localparam v8_u0_8 = 256'h26a900fe0000002926e600fe000000fe087f269e09f0102100fe00fe087d2085;
localparam v8_u0_9 = 256'h08f20834000000fe089f203400fe3013309308bb269428340895083426923034;
localparam v8_u0_A = 256'h26c5003f0000003f089a00fe263400fe206130d026af303a00fe00fe26b6205e;
localparam v8_u0_B = 256'h08c1081f18de304928b5101a00fe301320bd269a309b0000000026de26b22092;
localparam v8_u0_C = 256'h404f00fe0000002630e600fe20a500fe08cb1847106f10e100fe00fe30e900fe;
localparam v8_u0_D = 256'hb0f4b0f430e530492692009100fe301330a100fe00002692301e090630c92637;
localparam v8_u0_E = 256'h26de00fe00000011105600fe20c600fe301e26de26b0101a00fe00fe081d00fe;
localparam v8_u0_F = 256'h00c70046007e3049306b264500fe301330ab26fa30db200000dd00e6301e0972;
localparam v8_u1_0 = 256'h10ba03b210ba03bbb0ba23ab017b23ab017b01bb00b110ba00b2837b02fb036b;
localparam v8_u1_1 = 256'h32ba02b310ba82f980b910ba32ba33baab7b2b71233b00bb03fb003003bb03fb;
localparam v8_u1_2 = 256'h10ba000010ba03b0003aa3ab03bba3ab003b23ba00b103c800b2003010bab36b;
localparam v8_u1_3 = 256'h03c803c8129b31ba80b9129b003033ba343a12db12db2b793cb830ba03fb10ba;
localparam v8_u1_4 = 256'h02bb0030000003b20eb983bb00bb83bb3eba36b802bb03fb00300030033b837b;
localparam v8_u1_5 = 256'h3eb902fb32db31ba80b932db00300030023b023b3eba029b3eb902fb3eb912fa;
localparam v8_u1_6 = 256'h003b0000000003b20b3b0030000000303cb80fb900b203fb0030003021ba0030;
localparam v8_u1_7 = 256'h3eb8343a3a7831ba80b90b390030003036b800bb00b002fa3f3a01bb3eba029b;
localparam v8_u1_8 = 256'h02bb0030000003f210ba003000000030373810b002fb03fb0030003036b8036b;
localparam v8_u1_9 = 256'h0739233800000030073b3a70003033ba3cb832db02f33a7836fa367838b03d3a;
localparam v8_u1_A = 256'h003b03b0000003b036ba00303a780030003b82f901bb03c80030003002b3b36b;
localparam v8_u1_B = 256'h02fb02fb037931ba32db01fb003033ba033302b3003a00000000237102b338b0;
localparam v8_u1_C = 256'h01b20030000003f23d3a003001b30030343a36bb003b23fa0030003032ba0030;
localparam v8_u1_D = 256'h2afa28fa3eba31ba383802b2003033ba3eba0030000038b83eba029b21ba00bb;
localparam v8_u1_E = 256'h2b710030000003f201fb0030033300303eba237102b303fb00300030003b0030;
localparam v8_u1_F = 256'h00b200b000b231ba003a02bb003033ba3cba00333eba6fff003100b23eba029b;
localparam v8_u2_0 = 256'h00000080000000800001040000800400008000800080040000800590008a0580;
localparam v8_u2_1 = 256'h00000c8000000080008100000400000005010102000004800080008000800080;
localparam v8_u2_2 = 256'h0000000000000080048004000080040004800000008000800080008000000500;
localparam v8_u2_3 = 256'h0080008000040000008100000080000000000004000001020400040000800000;
localparam v8_u2_4 = 256'h0480008000000080002007810480078100000000048000800080008004800581;
localparam v8_u2_5 = 256'h0000008a00040000008100000080008000800080000000840000008a00000042;
localparam v8_u2_6 = 256'h0480000000000080038000800000008000000000008000800080008000000080;
localparam v8_u2_7 = 256'h0000000000300000008100000080008004000080008000ca0000008000000084;
localparam v8_u2_8 = 256'h00800080000000800c0000800000008000002c00008a00800080008000000580;
localparam v8_u2_9 = 256'h00000000000000800380043000800000000000000c800030000000000c300030;
localparam v8_u2_A = 256'h048000800000008000000080043000800480008104800080008000800c800500;
localparam v8_u2_B = 256'h0082008201820000000400800080000004800c800080000000000d020c800430;
localparam v8_u2_C = 256'h0080008000000080003000800480008000000000008000000080008000000080;
localparam v8_u2_D = 256'h004a000000000000040000800080000000000080000004300000008400000480;
localparam v8_u2_E = 256'h0d02008000000080008000800480008000000d020c8000800080008000800080;
localparam v8_u2_F = 256'h0080008000800000008004800080000000000c80000004000080008000000084;
/*
 * =================================================
 * * Version 10. RVC MINSTRET                      *
 * =================================================
 *                             Microcode instruction
 * uPC           next uPC      444333333333322222222221111111111
 * || label      || next label 21098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ----------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       10110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       d2 LB_2       00010001010000000101111101100001001        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       be IJ_1       10110010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     e6 StdIncPc   00010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     e6 StdIncPc   10000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 LB_3       07 LB_4       00010000000000000011011101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * 07 LB_4       09 LB_5       00010000000000000010111101100011000        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 08 _L0x08     5a SB_1       10000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_5       8b LB_6       00010000000000000010111101100000000        q = D^0xffffffff^q = D^0x80                       00000000 
 * 0a _L0x0a     5a SB_1       10000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b JALR_2     86 JAL_2      00000000001101100001011101000011000        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 0c ADD_0      04 ADDI_0     00010000000000000111011101100001000 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     e6 StdIncPc   00000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      10 SUB_1      00010000000000000111011001000000000 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     e6 StdIncPc   00000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 SUB_1      8b LB_6       00010000000000000111111101100000000        Q = ~RS2                                          00000000 
 * 11 AND_1      1a ANDI_1     00010000000000000111011101100000000        RS1^0xffffffff to Q                               00000000 
 * 12 _L0x12     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00000000 
 * 13 condb_2    14 condb_3    00010000000000000111111101100000000        ~RS2 in Q                                         00000000 
 * 14 condb_3    15 condb_4    10010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 15 condb_4    16 condb_5    00000000000001000110011101101001000        Branch on condition                               00000000 
 * 16 condb_5    de Fetch      00100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 17 condb_5t   74 BrOpFet    10100000001101010110111101100100000        Branch taken.                                     00000000 
 * 18 BEQ        13 condb_2    00000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     41 JALR_1     10000000000001100101011101000100000 JALR   yy=RS1+imm                                        00000067 jalr    
 * 1a ANDI_1     e6 StdIncPc   00000000000000100001011101000011000        rd = Iimm & RS1                                   00000000 
 * 1b _L0x1b     32 JAL_1      00010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   a6 ECAL_RET   00010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d ORI_2      e6 StdIncPc   00000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 1e aFault_1   d4 aFault_2   10010000000000000101011001100100110        Q = 4                                             00000000 
 * 1f IJ_2       b7 IJ_3       00000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 20 LH_0       52 LH_1       10100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 XORI_1     e6 StdIncPc   00000000000000100001011101000000000        rd = Iimm ^ RS1                                   00000000 
 * 22 _L0x22     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000100b close to ij
 * 23 _L0x23     e6 StdIncPc   00010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     35 SLLI_1     00010000000000000111100100000110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 OR_1       27 OR_2       00000000000001000111011101000000000        RS1^0xffffffff to jj                              00000000 
 * 27 OR_2       1d ORI_2      10010000000000000000011101100100000        Q = rs2                                           00000000 
 * 28 _L0x28     96 SH_1       10000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 XOR_1      21 XORI_1     00010000000000000111011101100000000        Q = RS1^0xFFFFFFFF                                00000000 
 * 2a _L0x2a     96 SH_1       10000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b SLTIX_1    30 SLTIX_2    10010000000000000000011101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 2c SLL_0      3e SLL_1      00010000000000000111011000000000000 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     e6 StdIncPc   00000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e unx2e         (use dinx) 00000000000000000000000000000000000 2e: Not in use                                           40001033 sloppy sll     
 * 2f _L0x2f     e6 StdIncPc   00000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SLTIX_2    e6 StdIncPc   00000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 31 SLTX_1     2b SLTIX_1    00010000000000000111111101100000000        ~rs2 to Q                                         00000000 
 * 32 JAL_1      86 JAL_2      10000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 33 JAERR_1    81 JAERR_2    10000000000001111001011100000100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 34 JAL_3      de Fetch      00100000010001010110111100100001000        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 35 SLLI_1     36 SLLI_2     00000000000000100101101101100001000        Register to shift to Q (and TRG for shift 0)      00000000 
 * 36 SLLI_2     03 _L0x03     00000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 37 ECALL_2    d7 ECALL_3    00000000000001101000011101001001000        mepc = pc, prep store 0 to mtval                  00000000 
 * 38 BNE        13 condb_2    00000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 _L0x39     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00001067 close to jalr
 * 3a SRxI_1     3d SRxI_2     00000000000000100101001101100001001        Register to shift to Q                            00000000 
 * 3b _L0x3b     32 JAL_1      00010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    49 CSRRW_1    00000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d SRxI_2     03 _L0x03     00000000100000100101001101100001001        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 3e SLL_1      35 SLLI_1     00010000000000000111100100000001000        Shiftamount was in low 5 bits of RS2              00000000 
 * 3f SRx_1      3a SRxI_1     00010000000000000111100100000001000        Shiftamount in low 5 bits of RS2                  00000000 
 * 40 LW_0       50 LW_1       10110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 JALR_1     0b JALR_2     10010000000000000110011101100100110        Q=1                                               00000000 
 * 42 _L0x42     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000200b close to ij
 * 43 _L0x43     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000200f close to fence
 * 44 SLTI_0     2b SLTIX_1    00010000000000000111111101100010000 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 WFI_3      65 WFI_4      10010000000000000101011101100100110        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105        00000000 
 * 46 ILL_1      47 ILL_2      00000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 47 ILL_2      8f ILL_3      00000000000001111101011101000001000        Store 0 to mtval                                  00000000 
 * 48 _L0x48     66 SW_1       11110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 CSRRW_1    4b CSRRW_2    10010000000000000001011101100100110        Construct PC storage adr                          00000000 
 * 4a _L0x4a     66 SW_1       11110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b CSRRW_2    b1 CSRRW_3    00000100000000011101011100100001000        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 4c SLT_0      31 SLTX_1     00010000000000000111011001000000000 SLT    Set less than (signed)                            00002033 slt     
 * 4d unx4d         (use dinx) 00000000000000000000000000000000000 4d: Not in use                                           00000000 
 * 4e eILL0b     fe ILLe       00010000000000000000011000000000000 Illegal instruction seen                                 40002033 sloppy slt     
 * 4f MRET_8     e6 StdIncPc   10010000000000000101011101100100110        Prep +4                                           00000000 
 * 50 LW_1       e6 StdIncPc   00001000010000100101111101000001000        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 51 LDAF_LW    da LDAF_a     00000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 52 LH_1       54 LH_2       00010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 53 LDAF_LH    da LDAF_a     00000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 54 LH_2       eb LH_3       00010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 55 aFaultb    1e aFault_1   00000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 56 LH_4       57 LH_5       00010000000000000100011101100011000        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 57 LH_5       8b LB_6       00010000000000000100011101100000000        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 58 _L0x58     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00002063 close to branch
 * 59 _L0x59     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00002067 close to jalr
 * 5a SB_1       5d SB_2       00000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5b _L0x5b     32 JAL_1      00010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    49 CSRRW_1    00000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SB_2       fb SB_3       00000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 5e LHU_1      70 LHU_2      00010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 5f LDAF_LHU   da LDAF_a     00000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 60 _L0x60     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00003003 close to load
 * 61 EBRKWFI2   f7 EBREAK_1   00000000000001000011011101001010000 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 62 _L0x62     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000300b close to ij
 * 63 _L0x63     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000300f close to fence
 * 64 SLTIU_0    2b SLTIX_1    00010000000000000111111101100010000 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 WFI_4      ef WFI_5      00010000000000000001011001001000000        Prepare read PC                                   00000000 
 * 66 SW_1       f2 SW_2       00000000000000011111011100100001000        Write d to a+k until accepted                     00000000 
 * 67 SW_E1SWE   93 SW_E2      00000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 68 _L0x68     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00003023 close to store
 * 69 unx69         (use dinx) 00000000000000000000000000000000000 69: Not in use                                           00000000 
 * 6a _L0x6a     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           40003023 close to store
 * 6b SB_4       7a SB_5       01110000000000010110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 6c SLTU_0     31 SLTX_1     00010000000000000111011001000000000 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d unx6d         (use dinx) 00000000000000000000000000000000000 6d: Not in use                                           00000000 
 * 6e unx6e         (use dinx) 00000000000000000000000000000000000 6e: Not in use                                           40003033 sloppy sltu    
 * 6f MRET_6     cf MRET_7     10010000000000000000011101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 70 LHU_2      ba LHU_3      00010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 71 aFaultc    1e aFault_1   00000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 72 LBU_3      1a ANDI_1     00010000000000000011011101100010000        Invert q. Prepare read mask                       00000000 
 * 73 BAERR_1    76 BAERR_2    00000000000001111110011101000001000        Faultadr to mtval. Prepare get offset             00000000 
 * 74 BrOpFet    f4 Fetch2     00011001010000000101111101010110000 NewOp2 Read until instruction latched                    00000000 
 * 75 BAlignEr   73 BAERR_1    00010000000000000001011000000000000  Err   Branch target instruction address misaligned      00000000 
 * 76 BAERR_2    77 BAERR_3    00010000000000000001011101100000000        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 77 BAERR_3    7d BAERR_4    10000000000001101101011100000100110        origPC to mepc. Prep read 0                       00000000 
 * 78 _L0x78     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00003063 close to branch
 * 79 _L0x79     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00003067 close to jalr
 * 7a SB_5       f2 SW_2       00000000000000010110011100100001000        Write d to a+k until accepted                     00000000 
 * 7b _L0x7b     32 JAL_1      00010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    49 CSRRW_1    00000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d BAERR_4    34 JAL_3      00000110000001110100111100000001000        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 7e NMI_1      90 NMI_2      00000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * 7f JALRE2     7d BAERR_4    00000000000001111101011100000001000        mtval is target                                   00000000 
 * 80 LBU_0      85 LBU_1      10110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 JAERR_2    7d BAERR_4    00000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 82 _L0x82     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000400b close to ij
 * 83 _L0x83     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000400f close to fence
 * 84 XORI_0     21 XORI_1     00010000000000000111111101100010000 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 LBU_1      f0 LBU_2      00010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 86 JAL_2      9e JAL_25     10000000000000100001011000000100110        Return address to TRG                             00000000 
 * 87 JALRE1     7f JALRE2     00000000000001101110011100000001000  err   Store pc to mepc                                  00000000 
 * 88 _L0x88     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00004023 close to store
 * 89 unx89         (use dinx) 00000000000000000000000000000000000 89: Not in use                                           00000000 
 * 8a _L0x8a     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           40004023 close to store
 * 8b LB_6       e6 StdIncPc   10000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 8c XOR_0      29 XOR_1      00010000000000000111111001000000000 XOR    xor                                               00004033 xor     
 * 8d unx8d         (use dinx) 00000000000000000000000000000000000 8d: Not in use                                           00000000 
 * 8e _LCSRRS_1  fe ILLe       00010000000000000000011000000000000 Illegal instruction seen                                 40004033 sloppy xor     
 * 8f ILL_3      a9 ILL_4      00010000000000000101011101100100110        Q = 1                                             00000000 
 * 90 NMI_2      34 JAL_3      00000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 91 LDAF_2     92 LDAF_3     10000110000001110001011000000100110        Store 4 to mcause                                 00000000 
 * 92 LDAF_3     34 JAL_3      00000000000001101100111100000001000        PC to mepc                                        00000000 
 * 93 SW_E2      95 SW_E3      00000000000001101101111101000001000        Store address that faulted                        00000000 
 * 94 SW_E4      34 JAL_3      00000110000001110100111100000101000        Store 6 to mcause                                 00000000 
 * 95 SW_E3      94 SW_E4      10010000000000000101111001100100110        Q = 3                                             00000000 
 * 96 SH_1       bb SH_2       00000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 97 SW_E1SWH   93 SW_E2      00000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 98 BLT        13 condb_2    00000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00004067 close to jalr
 * 9a ECALL_6    34 JAL_3      10000110000001110100111000000100000        mcause = 11                                       00000000 
 * 9b SH_4       9f SH_5       01110000000000001110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 9c _L0x9c     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00004073 close to csr/system 
 * 9d unx9d         (use dinx) 00000000000000000000000000000000000 9d: Not in use                                           00000000 
 * 9e JAL_25     34 JAL_3      00000000000001000110011100000001000        Instr. adr. to jj in case of access error         00000000 
 * 9f SH_5       f2 SW_2       00000000000000001110011100100001000        Write d to a+k until accepted                     00000000 
 * a0 LHU_0      5e LHU_1      10100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_4    b6 ECALL_5    10010000000000000101011001100100110        Q = 4                                             00000000 
 * a2 _L0xa2     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000500b close to ij
 * a3 _L0xa3     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000500f close to fence
 * a4 SRxI_0     3a SRxI_1     00010000000000000111100100000110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_3     af MRET_4     10010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * a6 ECAL_RET   d0 ECALL_1    00010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * a7 EBRKWFI1   61 EBRKWFI2   10010000000000000000011101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * a8 _L0xa8     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00005023 close to store
 * a9 ILL_4      34 JAL_3      10000110000001110100111100000100110        Store 2 to mcause                                 00000000 
 * aa _L0xaa     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           40005023 close to store
 * ab EBREAK_2   9a ECALL_6    00000000000001101101011101000001000        pc to mepc                                        00000000 
 * ac _L0xac     3f SRx_1      00010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad unxad         (use dinx) 00000000000000000000000000000000000 ad: Not in use                                           00000000 
 * ae _L0xae     3f SRx_1      00010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_4     c5 MRET_5     10010000000000000000011101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b0 aF_SW_3    92 LDAF_3     10000110000001110001011000000100000        Store 7 to mcause                                 00000000 
 * b1 CSRRW_3    b2 CSRRW_4    10010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b2 CSRRW_4    de Fetch      10100000010001000110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b3 unxb3         (use dinx) 00000000000000000000000000000000000 b3: Not in use                                           00000000 
 * b4 eFetch3       (use dinx) 10000000000011001111111101100100110  Fr10  Update minstret, Q=immediate. Use dinx            00000000 
 * b5 SH_3       9b SH_4       00010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b6 ECALL_5    9a ECALL_6    10010000000000000101011001100100110        Q = 8                                             00000000 
 * b7 IJ_3       bd IJ_4       10010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b8 BGE        13 condb_2    00000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 _L0xb9     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00005067 close to jalr
 * ba LHU_3      1a ANDI_1     00010000000000000011111101100010000        Invert q. Prepare read mask                       00000000 
 * bb SH_2       b5 SH_3       00000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * bc CSRRWI_0   49 CSRRW_1    00000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd IJ_4       de Fetch      00110000010000000110111100100011000        Mask and use as PC                                00000000 
 * be IJ_1       1f IJ_2       00010000010000000101111101100001000        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * bf IJT_1      c1 IJT_2      00010000010000000101111101100001000        Exit CSR, enter trap                              00000000 
 * c0 _L0xc0     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00006003 close to load
 * c1 IJT_2      e9 IJT_3      00000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c2 _L0xc2     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000600b close to ij
 * c3 _L0xc3     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000600f close to fence
 * c4 ORI_0      e1 ORI_1      00000000000001000111111101000010000 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_5     6f MRET_6     00010000000000000000011101100010000        ~302                                              00000000 
 * c6 IJT_4      47 ILL_2      00000000000001101101011101100011000        Mask and store to mepc and Q for read of instr    00000000 
 * c7 QINT_1     cb QINT_2     00000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * c8 _L0xc8     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00006023 close to store
 * c9 MRET_2     a5 MRET_3     10010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * ca _L0xca     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           40006023 close to store
 * cb QINT_2     e6 StdIncPc   00000110000001111010011101000110000        mtval = 0.                                        00000000 
 * cc OR_0       26 OR_1       00010000000000000111111001000000000 OR     or                                                00006033 or      
 * cd unxcd         (use dinx) 00000000000000000000000000000000000 cd: Not in use                                           00000000 
 * ce _LCSRRCI_1 fe ILLe       00010000000000000000011000000000000 Illegal instruction seen                                 40006033 sloppy or      
 * cf MRET_7     4f MRET_8     00010000000000000011011001001000000        Prepare emulation entry point 0x104               00000000 
 * d0 ECALL_1    37 ECALL_2    10010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * d1 MRET_1     c9 MRET_2     00000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * d2 LB_2       06 LB_3       00010000100000000101001101100001001        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * d3 aFaultd    1e aFault_1   00000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * d4 aFault_2   92 LDAF_3     10000110000001110001011100000100110        Store 5 to mcause                                 00000000 
 * d5 eFetch2    b4 eFetch3    10000000000001011000111111000100000  Fr10  Update ttime                                      00000000 
 * d6 eILL0c     fe ILLe       00010000000000000000011000000000000 Illegal instruction seen                                 00000000 
 * d7 ECALL_3    a1 ECALL_4    00000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * d8 BLTU       13 condb_2    00000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 _L0xd9     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00006067 close to jalr
 * da LDAF_a     91 LDAF_2     00010000000000000101011001000000000        Extra cycle after error detected write mtval      00000000 
 * db jFault_1   92 LDAF_3     10000000000001110000011100000100110        Store 1 to mcause                                 00000000 
 * dc CSRRSI_0   49 CSRRW_1    00000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd aF_SW_1    e5 aF_SW_2    00000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * de Fetch      f4 Fetch2     00000000000001010001111101010110000  Fr10  Read and latch instruction                        00000000 
 * df eFetch     d5 eFetch2    00001001010001010101111101010110000  Fr10  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * e0 _L0xe0     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00007003 close to load
 * e1 ORI_1      1d ORI_2      00010000000000000000011101100001000        Q = RS1                                           00000000 
 * e2 _L0xe2     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000700b close to ij
 * e3 _L0xe3     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000700f close to fence
 * e4 ANDI_0     1a ANDI_1     00010000000000000111111101100010000 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 aF_SW_2    b0 aF_SW_3    10010000000000000101011001100100110        Q = 4                                             00000000 
 * e6 StdIncPc   de Fetch      10100000010001000110111000100100110  Fr10  IncPC, OpFetch                                    00000000 
 * e7 aFault     1e aFault_1   00000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * e8 _L0xe8     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00007023 close to store
 * e9 IJT_3      c6 IJT_4      10010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ea _L0xea     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           40007023 close to store
 * eb LH_3       56 LH_4       00010000000000000011111101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * ec AND_0      11 AND_1      00010000000000000111111001000000000 AND    And                                               00007033 and     
 * ed unxed         (use dinx) 00000000000000000000000000000000000 ed: Not in use                                           00000000 
 * ee eILL0a     fe ILLe       00010000000000000000011000000000000 Illegal instruction seen                                 40007033 sloppy and     
 * ef WFI_5      de Fetch      10100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * f0 LBU_2      72 LBU_3      00010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * f1 aFaulte    1e aFault_1   00000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * f2 SW_2       e6 StdIncPc   00010000000000000001011001000000000        Prepare read PC                                   00000000 
 * f3 aF_SW      dd aF_SW_1    00010000000000000000011000100000000  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * f4 Fetch2        (use dinx) 10000000000011011111111111100100000  Fr10  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f5 jFault     db jFault_1   00000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * f6 WFI_1      fa WFI_2      10010000000000000000011001100100110 WFI    Chk offset=0x105. Now=0xff. Prep 0xff+4 = 0x103   00000000 
 * f7 EBREAK_1   ab EBREAK_2   00000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * f8 BGEU       13 condb_2    00000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 _L0xf9     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00007067 close to jalr
 * fa WFI_2      45 WFI_3      10010000000000000101011101100100110        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104   00000000 
 * fb SB_3       6b SB_4       00010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fc CSRRCI_0   49 CSRRW_1    00000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      7e NMI_1      00010000000000000001011001000000000 NMI    Get current PC                                    00000000 
 * fe ILLe       46 ILL_1      00010000000000000001011000000000000 Illegal                                                  00000000 
 * ff QINT_0     c7 QINT_1     00010000000000000001011001000000000 INT    Get current PC                                    00000000 
 */
localparam v10_u0_0 = 256'h30e6001030e608041886205a008b205a18091007000420e600e620be09d22001;
localparam v10_u0_1 = 256'h30b726d438e630a6303218e620413013207436de48162615001400fe001a008b;
localparam v10_u0_2 = 256'h30e6000030e6003e2630209600212096201d00270004303500e600fe00e62052;
localparam v10_u0_3 = 256'h083a0835090330493032093d00fe301348d72803083608de20812086002b32e6;
localparam v10_u0_4 = 256'h26e600fe0000003108b12066264b2066088f08472665102b00fe00fe260b2050;
localparam v10_u0_5 = 256'h30da097028fb30493032085d00fe00fe008b1857301e09eb30da095430da08e6;
localparam v10_u0_6 = 256'h26cf000000000031087a00fe000000fe309308f240ef102b00fe00fe50f700fe;
localparam v10_u0_7 = 256'h087d089008343049303208f200fe00fe267d00770073b0f40876101a301e09ba;
localparam v10_u0_8 = 256'h26a900fe0000002926e600fe000000fe087f269e09f0102100fe00fe087d2085;
localparam v10_u0_9 = 256'h08f20834000000fe089f203400fe3013309308bb269428340895083426923034;
localparam v10_u0_A = 256'h26c5003f0000003f089a00fe263400fe206130d026af303a00fe00fe26b6205e;
localparam v10_u0_B = 256'h08c1081f18de304928b5101a00fe301320bd269a309b2600000026de26b22092;
localparam v10_u0_C = 256'h404f00fe0000002630e600fe20a500fe08cb1847106f10e100fe00fe30e900fe;
localparam v10_u0_D = 256'hb0d5b0f430e530492692009100fe301330a100fe20b42692301e090630c92637;
localparam v10_u0_E = 256'h26de00fe00000011105600fe20c600fe301e26de26b0101a00fe00fe081d00fe;
localparam v10_u0_F = 256'h00c70046007e3049306b264500fe301330ab26fa30db200000dd00e6301e0972;
localparam v10_u1_0 = 256'h10ba03b210ba03bbb0ba23ab017b23ab017b01bb00b110ba00b2837b02fb036b;
localparam v10_u1_1 = 256'h32ba02b310ba82f980b910ba32ba33baab7b2b71233b00bb03fb003003bb03fb;
localparam v10_u1_2 = 256'h10ba000010ba03b0003aa3ab03bba3ab003b23ba00b103c800b2003010bab36b;
localparam v10_u1_3 = 256'h03c803c8129b31ba80b9129b003033ba343a12db12db2b793cb830ba03fb10ba;
localparam v10_u1_4 = 256'h02bb0030000003b20eb983bb00bb83bb3eba36b802bb03fb00300030033b837b;
localparam v10_u1_5 = 256'h3eb902fb32db31ba80b932db00300030023b023b3eba029b3eb902fb3eb912fa;
localparam v10_u1_6 = 256'h003b0000000003b20b3b0030000000303cb80fb900b203fb0030003021ba0030;
localparam v10_u1_7 = 256'h3eb8343a3a7831ba80b90b390030003036b800bb00b002fa3f3a01bb3eba029b;
localparam v10_u1_8 = 256'h02bb0030000003f210ba003000000030373810b002fb03fb0030003036b8036b;
localparam v10_u1_9 = 256'h0739233800000030073b3a70003033ba3cb832db02f33a7836fa367838b03d3a;
localparam v10_u1_A = 256'h003b03b0000003b036ba00303a780030003b82f901bb03c80030003002b3b36b;
localparam v10_u1_B = 256'h02fb02fb037931ba32db01fb003033ba033302b3003a67fb0000237102b338b0;
localparam v10_u1_C = 256'h01b20030000003f23d3a003001b30030343a36bb003b23fa0030003032ba0030;
localparam v10_u1_D = 256'h2afa28fa3eba31ba383802b2003033ba3eba00302c7e38b83eba029b21ba00bb;
localparam v10_u1_E = 256'h2b710030000003f201fb0030033300303eba237102b303fb00300030003b0030;
localparam v10_u1_F = 256'h00b200b000b231ba003a02bb003033ba3cba00333eba6fff003100b23eba029b;
localparam v10_u2_0 = 256'h00000080000000800001040000800400008000800080040000800590008a0580;
localparam v10_u2_1 = 256'h00000c8000000080008100000400000005010102000004800080008000800080;
localparam v10_u2_2 = 256'h0000000000000080048004000080040004800000008000800080008000000500;
localparam v10_u2_3 = 256'h0080008000040000008100000080000000000004000001020400040000800000;
localparam v10_u2_4 = 256'h0480008000000080002007810480078100000000048000800080008004800581;
localparam v10_u2_5 = 256'h0000008a00040000008100000080008000800080000000840000008a00000042;
localparam v10_u2_6 = 256'h0480000000000080038000800000008000000000008000800080008000000080;
localparam v10_u2_7 = 256'h0000000000300000008100000080008004000080008000ca0000008000000084;
localparam v10_u2_8 = 256'h00800080000000800c0000800000008000002c00008a00800080008000000580;
localparam v10_u2_9 = 256'h00000000000000800380043000800000000000000c800030000000000c300030;
localparam v10_u2_A = 256'h048000800000008000000080043000800480008104800080008000800c800500;
localparam v10_u2_B = 256'h0082008201820000000400800080000004800c800080040000000d020c800430;
localparam v10_u2_C = 256'h0080008000000080003000800480008000000000008000000080008000000080;
localparam v10_u2_D = 256'h004a000000000000040000800080000000000080040004300000008400000480;
localparam v10_u2_E = 256'h0d02008000000080008000800480008000000d020c8000800080008000800080;
localparam v10_u2_F = 256'h0080008000800000008004800080000000000c80000004000080008000000084;
/*
 * =================================================
 * * Version 11. RVC MINSTRET EBR_MINSTRET         *
 * =================================================
 *                             Microcode instruction
 * uPC           next uPC      444333333333322222222221111111111
 * || label      || next label 21098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- ----------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       10110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       d2 LB_2       00010001010000000101111101100001001        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       be IJ_1       10110010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     e6 StdIncPc   00010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     e6 StdIncPc   10000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 LB_3       07 LB_4       00010000000000000011011101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * 07 LB_4       09 LB_5       00010000000000000010111101100011000        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 08 _L0x08     5a SB_1       10000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_5       8b LB_6       00010000000000000010111101100000000        q = D^0xffffffff^q = D^0x80                       00000000 
 * 0a _L0x0a     5a SB_1       10000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b JALR_2     86 JAL_2      00000000001101100001011101000011000        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 0c ADD_0      04 ADDI_0     00010000000000000111011101100001000 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d _L0x0d     e6 StdIncPc   00000000000000100001011101000110000 LUI    q = imm20                                         00000037 lui     
 * 0e SUB_0      10 SUB_1      00010000000000000111011001000000000 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     e6 StdIncPc   00000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 SUB_1      8b LB_6       00010000000000000111111101100000000        Q = ~RS2                                          00000000 
 * 11 AND_1      1a ANDI_1     00010000000000000111011101100000000        RS1^0xffffffff to Q                               00000000 
 * 12 _L0x12     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00000000 
 * 13 condb_2    14 condb_3    00010000000000000111111101100000000        ~RS2 in Q                                         00000000 
 * 14 condb_3    15 condb_4    10010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 15 condb_4    16 condb_5    00000000000001000110011101101001000        Branch on condition                               00000000 
 * 16 condb_5    de Fetch      00100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 17 condb_5t   74 BrOpFet    10100000001101010110111101100100000        Branch taken.                                     00000000 
 * 18 BEQ        13 condb_2    00000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     41 JALR_1     10000000000001100101011101000100000 JALR   yy=RS1+imm                                        00000067 jalr    
 * 1a ANDI_1     e6 StdIncPc   00000000000000100001011101000011000        rd = Iimm & RS1                                   00000000 
 * 1b _L0x1b     32 JAL_1      00010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   a6 ECAL_RET   00010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d ORI_2      e6 StdIncPc   00000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 1e aFault_1   d4 aFault_2   10010000000000000101011001100100110        Q = 4                                             00000000 
 * 1f IJ_2       b7 IJ_3       00000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 20 LH_0       52 LH_1       10100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 XORI_1     e6 StdIncPc   00000000000000100001011101000000000        rd = Iimm ^ RS1                                   00000000 
 * 22 _L0x22     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000100b close to ij
 * 23 _L0x23     e6 StdIncPc   00010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     35 SLLI_1     00010000000000000111100100000110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 OR_1       27 OR_2       00000000000001000111011101000000000        RS1^0xffffffff to jj                              00000000 
 * 27 OR_2       1d ORI_2      10010000000000000000011101100100000        Q = rs2                                           00000000 
 * 28 _L0x28     96 SH_1       10000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 XOR_1      21 XORI_1     00010000000000000111011101100000000        Q = RS1^0xFFFFFFFF                                00000000 
 * 2a _L0x2a     96 SH_1       10000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b SLTIX_1    30 SLTIX_2    10010000000000000000011101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 2c SLL_0      3e SLL_1      00010000000000000111011000000000000 SLL    Shift left                                        00001033 sll     
 * 2d _L0x2d     e6 StdIncPc   00000000000000100001011101000110000 LUI    q = imm20                                         00001037 lui     
 * 2e unx2e         (use dinx) 00000000000000000000000000000000000 2e: Not in use                                           40001033 sloppy sll     
 * 2f _L0x2f     e6 StdIncPc   00000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SLTIX_2    e6 StdIncPc   00000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 31 SLTX_1     2b SLTIX_1    00010000000000000111111101100000000        ~rs2 to Q                                         00000000 
 * 32 JAL_1      86 JAL_2      10000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 33 JAERR_1    81 JAERR_2    10000000000001111001011100000100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 34 JAL_3      de Fetch      00100000010001010110111100100001000        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 35 SLLI_1     36 SLLI_2     00000000000000100101101101100001000        Register to shift to Q (and TRG for shift 0)      00000000 
 * 36 SLLI_2     03 _L0x03     00000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 37 ECALL_2    d7 ECALL_3    00000000000001101000011101001001000        mepc = pc, prep store 0 to mtval                  00000000 
 * 38 BNE        13 condb_2    00000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 _L0x39     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00001067 close to jalr
 * 3a SRxI_1     3d SRxI_2     00000000000000100101001101100001001        Register to shift to Q                            00000000 
 * 3b _L0x3b     32 JAL_1      00010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    49 CSRRW_1    00000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d SRxI_2     03 _L0x03     00000000100000100101001101100001001        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 3e SLL_1      35 SLLI_1     00010000000000000111100100000001000        Shiftamount was in low 5 bits of RS2              00000000 
 * 3f SRx_1      3a SRxI_1     00010000000000000111100100000001000        Shiftamount in low 5 bits of RS2                  00000000 
 * 40 LW_0       50 LW_1       10110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 JALR_1     0b JALR_2     10010000000000000110011101100100110        Q=1                                               00000000 
 * 42 _L0x42     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000200b close to ij
 * 43 _L0x43     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000200f close to fence
 * 44 SLTI_0     2b SLTIX_1    00010000000000000111111101100010000 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 WFI_3      65 WFI_4      10010000000000000101011101100100110        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105        00000000 
 * 46 ILL_1      47 ILL_2      00000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 47 ILL_2      8f ILL_3      00000000000001111101011101000001000        Store 0 to mtval                                  00000000 
 * 48 _L0x48     66 SW_1       11110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 CSRRW_1    4b CSRRW_2    10010000000000000001011101100100110        Construct PC storage adr                          00000000 
 * 4a _L0x4a     66 SW_1       11110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b CSRRW_2    b1 CSRRW_3    00000100000000011101011100100001000        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 4c SLT_0      31 SLTX_1     00010000000000000111011001000000000 SLT    Set less than (signed)                            00002033 slt     
 * 4d unx4d         (use dinx) 00000000000000000000000000000000000 4d: Not in use                                           00000000 
 * 4e eILL0b     fe ILLe       00010000000000000000011000000000000 Illegal instruction seen                                 40002033 sloppy slt     
 * 4f MRET_8     e6 StdIncPc   10010000000000000101011101100100110        Prep +4                                           00000000 
 * 50 LW_1       e6 StdIncPc   00001000010000100101111101000001000        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 51 LDAF_LW    da LDAF_a     00000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 52 LH_1       54 LH_2       00010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 53 LDAF_LH    da LDAF_a     00000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 54 LH_2       eb LH_3       00010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 55 aFaultb    1e aFault_1   00000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 56 LH_4       57 LH_5       00010000000000000100011101100011000        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 57 LH_5       8b LB_6       00010000000000000100011101100000000        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 58 _L0x58     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00002063 close to branch
 * 59 _L0x59     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00002067 close to jalr
 * 5a SB_1       5d SB_2       00000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5b _L0x5b     32 JAL_1      00010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    49 CSRRW_1    00000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SB_2       fb SB_3       00000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 5e LHU_1      70 LHU_2      00010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 5f LDAF_LHU   da LDAF_a     00000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 60 _L0x60     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00003003 close to load
 * 61 EBRKWFI2   f7 EBREAK_1   00000000000001000011011101001010000 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 62 _L0x62     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000300b close to ij
 * 63 _L0x63     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000300f close to fence
 * 64 SLTIU_0    2b SLTIX_1    00010000000000000111111101100010000 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 WFI_4      ef WFI_5      00010000000000000001011001001000000        Prepare read PC                                   00000000 
 * 66 SW_1       f2 SW_2       00000000000000011111011100100001000        Write d to a+k until accepted                     00000000 
 * 67 SW_E1SWE   93 SW_E2      00000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 68 _L0x68     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00003023 close to store
 * 69 unx69         (use dinx) 00000000000000000000000000000000000 69: Not in use                                           00000000 
 * 6a _L0x6a     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           40003023 close to store
 * 6b SB_4       7a SB_5       01110000000000010110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 6c SLTU_0     31 SLTX_1     00010000000000000111011001000000000 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d unx6d         (use dinx) 00000000000000000000000000000000000 6d: Not in use                                           00000000 
 * 6e unx6e         (use dinx) 00000000000000000000000000000000000 6e: Not in use                                           40003033 sloppy sltu    
 * 6f MRET_6     cf MRET_7     10010000000000000000011101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 70 LHU_2      ba LHU_3      00010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 71 aFaultc    1e aFault_1   00000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 72 LBU_3      1a ANDI_1     00010000000000000011011101100010000        Invert q. Prepare read mask                       00000000 
 * 73 BAERR_1    76 BAERR_2    00000000000001111110011101000001000        Faultadr to mtval. Prepare get offset             00000000 
 * 74 BrOpFet    f4 Fetch2     00011001010000000101111101010110000 NewOp2 Read until instruction latched                    00000000 
 * 75 BAlignEr   73 BAERR_1    00010000000000000001011000000000000  Err   Branch target instruction address misaligned      00000000 
 * 76 BAERR_2    77 BAERR_3    00010000000000000001011101100000000        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 77 BAERR_3    7d BAERR_4    10000000000001101101011100000100110        origPC to mepc. Prep read 0                       00000000 
 * 78 _L0x78     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00003063 close to branch
 * 79 _L0x79     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00003067 close to jalr
 * 7a SB_5       f2 SW_2       00000000000000010110011100100001000        Write d to a+k until accepted                     00000000 
 * 7b _L0x7b     32 JAL_1      00010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    49 CSRRW_1    00000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d BAERR_4    34 JAL_3      00000110000001110100111100000001000        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 7e NMI_1      90 NMI_2      00000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * 7f JALRE2     7d BAERR_4    00000000000001111101011100000001000        mtval is target                                   00000000 
 * 80 LBU_0      85 LBU_1      10110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 JAERR_2    7d BAERR_4    00000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 82 _L0x82     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000400b close to ij
 * 83 _L0x83     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000400f close to fence
 * 84 XORI_0     21 XORI_1     00010000000000000111111101100010000 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 LBU_1      f0 LBU_2      00010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 86 JAL_2      9e JAL_25     10000000000000100001011000000100110        Return address to TRG                             00000000 
 * 87 JALRE1     7f JALRE2     00000000000001101110011100000001000  err   Store pc to mepc                                  00000000 
 * 88 _L0x88     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00004023 close to store
 * 89 unx89         (use dinx) 00000000000000000000000000000000000 89: Not in use                                           00000000 
 * 8a _L0x8a     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           40004023 close to store
 * 8b LB_6       e6 StdIncPc   10000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 8c XOR_0      29 XOR_1      00010000000000000111111001000000000 XOR    xor                                               00004033 xor     
 * 8d unx8d         (use dinx) 00000000000000000000000000000000000 8d: Not in use                                           00000000 
 * 8e _LCSRRS_1  fe ILLe       00010000000000000000011000000000000 Illegal instruction seen                                 40004033 sloppy xor     
 * 8f ILL_3      a9 ILL_4      00010000000000000101011101100100110        Q = 1                                             00000000 
 * 90 NMI_2      34 JAL_3      00000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 91 LDAF_2     92 LDAF_3     10000110000001110001011000000100110        Store 4 to mcause                                 00000000 
 * 92 LDAF_3     34 JAL_3      00000000000001101100111100000001000        PC to mepc                                        00000000 
 * 93 SW_E2      95 SW_E3      00000000000001101101111101000001000        Store address that faulted                        00000000 
 * 94 SW_E4      34 JAL_3      00000110000001110100111100000101000        Store 6 to mcause                                 00000000 
 * 95 SW_E3      94 SW_E4      10010000000000000101111001100100110        Q = 3                                             00000000 
 * 96 SH_1       bb SH_2       00000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 97 SW_E1SWH   93 SW_E2      00000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 98 BLT        13 condb_2    00000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00004067 close to jalr
 * 9a ECALL_6    34 JAL_3      10000110000001110100111000000100000        mcause = 11                                       00000000 
 * 9b SH_4       9f SH_5       01110000000000001110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 9c _L0x9c     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00004073 close to csr/system 
 * 9d unx9d         (use dinx) 00000000000000000000000000000000000 9d: Not in use                                           00000000 
 * 9e JAL_25     34 JAL_3      00000000000001000110011100000001000        Instr. adr. to jj in case of access error         00000000 
 * 9f SH_5       f2 SW_2       00000000000000001110011100100001000        Write d to a+k until accepted                     00000000 
 * a0 LHU_0      5e LHU_1      10100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_4    b6 ECALL_5    10010000000000000101011001100100110        Q = 4                                             00000000 
 * a2 _L0xa2     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000500b close to ij
 * a3 _L0xa3     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000500f close to fence
 * a4 SRxI_0     3a SRxI_1     00010000000000000111100100000110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_3     af MRET_4     10010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * a6 ECAL_RET   d0 ECALL_1    00010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * a7 EBRKWFI1   61 EBRKWFI2   10010000000000000000011101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * a8 _L0xa8     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00005023 close to store
 * a9 ILL_4      34 JAL_3      10000110000001110100111100000100110        Store 2 to mcause                                 00000000 
 * aa _L0xaa     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           40005023 close to store
 * ab EBREAK_2   9a ECALL_6    00000000000001101101011101000001000        pc to mepc                                        00000000 
 * ac _L0xac     3f SRx_1      00010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad unxad         (use dinx) 00000000000000000000000000000000000 ad: Not in use                                           00000000 
 * ae _L0xae     3f SRx_1      00010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_4     c5 MRET_5     10010000000000000000011101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b0 aF_SW_3    92 LDAF_3     10000110000001110001011000000100000        Store 7 to mcause                                 00000000 
 * b1 CSRRW_3    b2 CSRRW_4    10010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b2 CSRRW_4    de Fetch      10100000010001000110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b3 unxb3         (use dinx) 00000000000000000000000000000000000 b3: Not in use                                           00000000 
 * b4 eFetch3       (use dinx) 10000000000011001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * b5 SH_3       9b SH_4       00010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b6 ECALL_5    9a ECALL_6    10010000000000000101011001100100110        Q = 8                                             00000000 
 * b7 IJ_3       bd IJ_4       10010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b8 BGE        13 condb_2    00000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 _L0xb9     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00005067 close to jalr
 * ba LHU_3      1a ANDI_1     00010000000000000011111101100010000        Invert q. Prepare read mask                       00000000 
 * bb SH_2       b5 SH_3       00000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * bc CSRRWI_0   49 CSRRW_1    00000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd IJ_4       de Fetch      00110000010000000110111100100011000        Mask and use as PC                                00000000 
 * be IJ_1       1f IJ_2       00010000010000000101111101100001000        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * bf IJT_1      c1 IJT_2      00010000010000000101111101100001000        Exit CSR, enter trap                              00000000 
 * c0 _L0xc0     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00006003 close to load
 * c1 IJT_2      e9 IJT_3      00000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c2 _L0xc2     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000600b close to ij
 * c3 _L0xc3     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000600f close to fence
 * c4 ORI_0      e1 ORI_1      00000000000001000111111101000010000 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_5     6f MRET_6     00010000000000000000011101100010000        ~302                                              00000000 
 * c6 IJT_4      47 ILL_2      00000000000001101101011101100011000        Mask and store to mepc and Q for read of instr    00000000 
 * c7 QINT_1     cb QINT_2     00000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * c8 _L0xc8     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00006023 close to store
 * c9 MRET_2     a5 MRET_3     10010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * ca _L0xca     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           40006023 close to store
 * cb QINT_2     e6 StdIncPc   00000110000001111010011101000110000        mtval = 0.                                        00000000 
 * cc OR_0       26 OR_1       00010000000000000111111001000000000 OR     or                                                00006033 or      
 * cd unxcd         (use dinx) 00000000000000000000000000000000000 cd: Not in use                                           00000000 
 * ce _LCSRRCI_1 fe ILLe       00010000000000000000011000000000000 Illegal instruction seen                                 40006033 sloppy or      
 * cf MRET_7     4f MRET_8     00010000000000000011011001001000000        Prepare emulation entry point 0x104               00000000 
 * d0 ECALL_1    37 ECALL_2    10010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * d1 MRET_1     c9 MRET_2     00000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * d2 LB_2       06 LB_3       00010000100000000101001101100001001        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * d3 aFaultd    1e aFault_1   00000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * d4 aFault_2   92 LDAF_3     10000110000001110001011100000100110        Store 5 to mcause                                 00000000 
 * d5 unxd5         (use dinx) 00000000000000000000000000000000000 d5: Not in use                                           00000000 
 * d6 eILL0c     fe ILLe       00010000000000000000011000000000000 Illegal instruction seen                                 00000000 
 * d7 ECALL_3    a1 ECALL_4    00000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * d8 BLTU       13 condb_2    00000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 _L0xd9     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00006067 close to jalr
 * da LDAF_a     91 LDAF_2     00010000000000000101011001000000000        Extra cycle after error detected write mtval      00000000 
 * db jFault_1   92 LDAF_3     10000000000001110000011100000100110        Store 1 to mcause                                 00000000 
 * dc CSRRSI_0   49 CSRRW_1    00000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd aF_SW_1    e5 aF_SW_2    00000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * de Fetch      f4 Fetch2     00001001010001010101111101010110000  Fr11  Read and latch instruction                        00000000 
 * df eFetch     f4 Fetch2     00001001010001010101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * e0 _L0xe0     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00007003 close to load
 * e1 ORI_1      1d ORI_2      00010000000000000000011101100001000        Q = RS1                                           00000000 
 * e2 _L0xe2     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000700b close to ij
 * e3 _L0xe3     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           0000700f close to fence
 * e4 ANDI_0     1a ANDI_1     00010000000000000111111101100010000 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 aF_SW_2    b0 aF_SW_3    10010000000000000101011001100100110        Q = 4                                             00000000 
 * e6 StdIncPc   de Fetch      10100000010001000110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * e7 aFault     1e aFault_1   00000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * e8 _L0xe8     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00007023 close to store
 * e9 IJT_3      c6 IJT_4      10010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ea _L0xea     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           40007023 close to store
 * eb LH_3       56 LH_4       00010000000000000011111101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * ec AND_0      11 AND_1      00010000000000000111111001000000000 AND    And                                               00007033 and     
 * ed unxed         (use dinx) 00000000000000000000000000000000000 ed: Not in use                                           00000000 
 * ee eILL0a     fe ILLe       00010000000000000000011000000000000 Illegal instruction seen                                 40007033 sloppy and     
 * ef WFI_5      de Fetch      10100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * f0 LBU_2      72 LBU_3      00010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * f1 aFaulte    1e aFault_1   00000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * f2 SW_2       e6 StdIncPc   00010000000000000001011001000000000        Prepare read PC                                   00000000 
 * f3 aF_SW      dd aF_SW_1    00010000000000000000011000100000000  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * f4 Fetch2     b4 eFetch3    10000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f5 jFault     db jFault_1   00000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * f6 WFI_1      fa WFI_2      10010000000000000000011001100100110 WFI    Chk offset=0x105. Now=0xff. Prep 0xff+4 = 0x103   00000000 
 * f7 EBREAK_1   ab EBREAK_2   00000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * f8 BGEU       13 condb_2    00000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 _L0xf9     fe ILLe       00010000000000000000011000000000000  Not in use (illegal as entry)                           00007067 close to jalr
 * fa WFI_2      45 WFI_3      10010000000000000101011101100100110        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104   00000000 
 * fb SB_3       6b SB_4       00010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fc CSRRCI_0   49 CSRRW_1    00000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      7e NMI_1      00010000000000000001011001000000000 NMI    Get current PC                                    00000000 
 * fe ILLe       46 ILL_1      00010000000000000001011000000000000 Illegal                                                  00000000 
 * ff QINT_0     c7 QINT_1     00010000000000000001011001000000000 INT    Get current PC                                    00000000 
 */
localparam v11_u0_0 = 256'h30e6001030e608041886205a008b205a18091007000420e600e620be09d22001;
localparam v11_u0_1 = 256'h30b726d438e630a6303218e620413013207436de48162615001400fe001a008b;
localparam v11_u0_2 = 256'h30e6000030e6003e2630209600212096201d00270004303500e600fe00e62052;
localparam v11_u0_3 = 256'h083a0835090330493032093d00fe301348d72803083608de20812086002b32e6;
localparam v11_u0_4 = 256'h26e600fe0000003108b12066264b2066088f08472665102b00fe00fe260b2050;
localparam v11_u0_5 = 256'h30da097028fb30493032085d00fe00fe008b1857301e09eb30da095430da08e6;
localparam v11_u0_6 = 256'h26cf000000000031087a00fe000000fe309308f240ef102b00fe00fe50f700fe;
localparam v11_u0_7 = 256'h087d089008343049303208f200fe00fe267d00770073b0f40876101a301e09ba;
localparam v11_u0_8 = 256'h26a900fe0000002926e600fe000000fe087f269e09f0102100fe00fe087d2085;
localparam v11_u0_9 = 256'h08f20834000000fe089f203400fe3013309308bb269428340895083426923034;
localparam v11_u0_A = 256'h26c5003f0000003f089a00fe263400fe206130d026af303a00fe00fe26b6205e;
localparam v11_u0_B = 256'h08c1081f18de304928b5101a00fe301320bd269a309b2600000026de26b22092;
localparam v11_u0_C = 256'h404f00fe0000002630e600fe20a500fe08cb1847106f10e100fe00fe30e900fe;
localparam v11_u0_D = 256'hb0f4b0f430e530492692009100fe301330a100fe00002692301e090630c92637;
localparam v11_u0_E = 256'h26de00fe00000011105600fe20c600fe301e26de26b0101a00fe00fe081d00fe;
localparam v11_u0_F = 256'h00c70046007e3049306b264500fe301330ab26fa30db20b400dd00e6301e0972;
localparam v11_u1_0 = 256'h10ba03b210ba03bbb0ba23ab017b23ab017b01bb00b110ba00b2837b02fb036b;
localparam v11_u1_1 = 256'h32ba02b310ba82f980b910ba32ba33baab7b2b71233b00bb03fb003003bb03fb;
localparam v11_u1_2 = 256'h10ba000010ba03b0003aa3ab03bba3ab003b23ba00b103c800b2003010bab36b;
localparam v11_u1_3 = 256'h03c803c8129b31ba80b9129b003033ba343a12db12db2b793cb830ba03fb10ba;
localparam v11_u1_4 = 256'h02bb0030000003b20eb983bb00bb83bb3eba36b802bb03fb00300030033b837b;
localparam v11_u1_5 = 256'h3eb902fb32db31ba80b932db00300030023b023b3eba029b3eb902fb3eb912fa;
localparam v11_u1_6 = 256'h003b0000000003b20b3b0030000000303cb80fb900b203fb0030003021ba0030;
localparam v11_u1_7 = 256'h3eb8343a3a7831ba80b90b390030003036b800bb00b002fa3f3a01bb3eba029b;
localparam v11_u1_8 = 256'h02bb0030000003f210ba003000000030373810b002fb03fb0030003036b8036b;
localparam v11_u1_9 = 256'h0739233800000030073b3a70003033ba3cb832db02f33a7836fa367838b03d3a;
localparam v11_u1_A = 256'h003b03b0000003b036ba00303a780030003b82f901bb03c80030003002b3b36b;
localparam v11_u1_B = 256'h02fb02fb037931ba32db01fb003033ba033302b3003a67fb0000237102b338b0;
localparam v11_u1_C = 256'h01b20030000003f23d3a003001b30030343a36bb003b23fa0030003032ba0030;
localparam v11_u1_D = 256'h2afa2afa3eba31ba383802b2003033ba3eba0030000038b83eba029b21ba00bb;
localparam v11_u1_E = 256'h2b710030000003f201fb0030033300303eba237102b303fb00300030003b0030;
localparam v11_u1_F = 256'h00b200b000b231ba003a02bb003033ba3cba00333eba2c7e003100b23eba029b;
localparam v11_u2_0 = 256'h00000080000000800001040000800400008000800080040000800590008a0580;
localparam v11_u2_1 = 256'h00000c8000000080008100000400000005010102000004800080008000800080;
localparam v11_u2_2 = 256'h0000000000000080048004000080040004800000008000800080008000000500;
localparam v11_u2_3 = 256'h0080008000040000008100000080000000000004000001020400040000800000;
localparam v11_u2_4 = 256'h0480008000000080002007810480078100000000048000800080008004800581;
localparam v11_u2_5 = 256'h0000008a00040000008100000080008000800080000000840000008a00000042;
localparam v11_u2_6 = 256'h0480000000000080038000800000008000000000008000800080008000000080;
localparam v11_u2_7 = 256'h0000000000300000008100000080008004000080008000ca0000008000000084;
localparam v11_u2_8 = 256'h00800080000000800c0000800000008000002c00008a00800080008000000580;
localparam v11_u2_9 = 256'h00000000000000800380043000800000000000000c800030000000000c300030;
localparam v11_u2_A = 256'h048000800000008000000080043000800480008104800080008000800c800500;
localparam v11_u2_B = 256'h0082008201820000000400800080000004800c800080040000000d020c800430;
localparam v11_u2_C = 256'h0080008000000080003000800480008000000000008000000080008000000080;
localparam v11_u2_D = 256'h004a004a00000000040000800080000000000080000004300000008400000480;
localparam v11_u2_E = 256'h0d02008000000080008000800480008000000d020c8000800080008000800080;
localparam v11_u2_F = 256'h0080008000800000008004800080000000000c80000004000080008000000084;
/*
 * =================================================
 * * Version 12. RVC MULDIV                        *
 * =================================================
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       d2 LB_2       00000010001010000000101111101100001001        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       be IJ_1       00010110010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     e6 StdIncPc   00000010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     e6 StdIncPc   00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 LB_3       07 LB_4       00000010000000000000011011101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * 07 LB_4       09 LB_5       00000010000000000000010111101100011000        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 08 _L0x08     5a SB_1       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_5       8b LB_6       00000010000000000000010111101100000000        q = D^0xffffffff^q = D^0x80                       00000000 
 * 0a _L0x0a     5a SB_1       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b JALR_2     86 JAL_2      00000000000001101100001011101000011000        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001000 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      e2 MUL_1      00100010000000000000111011001000000000 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      10 SUB_1      00000010000000000000111011001000000000 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     e6 StdIncPc   00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 SUB_1      8b LB_6       00000010000000000000111111101100000000        Q = ~RS2                                          00000000 
 * 11 AND_1      1a ANDI_1     00000010000000000000111011101100000000        RS1^0xffffffff to Q                               00000000 
 * 12 _L0x12     fe ILLe       00000010000000000000000011000000000000  Not in use (illegal as entry)                           00000000 
 * 13 condb_2    14 condb_3    00000010000000000000111111101100000000        ~RS2 in Q                                         00000000 
 * 14 condb_3    15 condb_4    00010010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 15 condb_4    16 condb_5    00000000000000001000110011101101001000        Branch on condition                               00000000 
 * 16 condb_5    de Fetch      00000100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 17 condb_5t   74 BrOpFet    00010100000001101010110111101100100000        Branch taken.                                     00000000 
 * 18 BEQ        13 condb_2    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     41 JALR_1     00010000000000001100101011101000100000 JALR   yy=RS1+imm                                        00000067 jalr    
 * 1a ANDI_1     e6 StdIncPc   00000000000000000100001011101000011000        rd = Iimm & RS1                                   00000000 
 * 1b _L0x1b     32 JAL_1      00000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   a6 ECAL_RET   00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d ORI_2      e6 StdIncPc   00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 1e aFault_1   d4 aFault_2   00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 1f IJ_2       b7 IJ_3       00000000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 20 LH_0       52 LH_1       00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 XORI_1     e6 StdIncPc   00000000000000000100001011101000000000        rd = Iimm ^ RS1                                   00000000 
 * 22 MULHU_6    39 MULHU_7    00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      0000100b close to ij
 * 23 _L0x23     e6 StdIncPc   00000010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     35 SLLI_1     00000010000000000000111100100000110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 OR_1       27 OR_2       00000000000000001000111011101000000000        RS1^0xffffffff to jj                              00000000 
 * 27 OR_2       1d ORI_2      00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 28 _L0x28     96 SH_1       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 XOR_1      21 XORI_1     00000010000000000000111011101100000000        Q = RS1^0xFFFFFFFF                                00000000 
 * 2a _L0x2a     96 SH_1       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b SLTIX_1    30 SLTIX_2    00010010000000000000000011101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 2c SLL_0      3e SLL_1      00000010000000000000111011000000000000 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     6a MULH_1     00000010000000000000101001101100001000 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e MULHU_1    42 MULHU_2    00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                40001033 sloppy sll     
 * 2f _L0x2f     e6 StdIncPc   00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SLTIX_2    e6 StdIncPc   00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 31 SLTX_1     2b SLTIX_1    00000010000000000000111111101100000000        ~rs2 to Q                                         00000000 
 * 32 JAL_1      86 JAL_2      00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 33 JAERR_1    81 JAERR_2    00010000000000001111001011100000100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 34 JAL_3      de Fetch      00000100000010001010110111100100001000        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 35 SLLI_1     36 SLLI_2     00000000000000000100101101101100001000        Register to shift to Q (and TRG for shift 0)      00000000 
 * 36 SLLI_2     03 _L0x03     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 37 ECALL_2    d7 ECALL_3    00000000000000001101000011101001001000        mepc = pc, prep store 0 to mtval                  00000000 
 * 38 BNE        13 condb_2    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 MULHU_7    e6 StdIncPc   00100000000000000100001011101000001000        Last shift.                                       00001067 close to jalr
 * 3a SRxI_1     3d SRxI_2     00000000000000000100101001101100001001        Register to shift to Q                            00000000 
 * 3b _L0x3b     32 JAL_1      00000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    49 CSRRW_1    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d SRxI_2     03 _L0x03     00000000000100000100101001101100001001        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 3e SLL_1      35 SLLI_1     00000010000000000000111100100000001000        Shiftamount was in low 5 bits of RS2              00000000 
 * 3f SRx_1      3a SRxI_1     00000010000000000000111100100000001000        Shiftamount in low 5 bits of RS2                  00000000 
 * 40 LW_0       50 LW_1       00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 JALR_1     0b JALR_2     00010010000000000000110011101100100110        Q=1                                               00000000 
 * 42 MULHU_2    60 MULHU_3    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           0000200b close to ij
 * 43 MULHU_4    ea MULHU_5    00000010000000000000000011100100000000        Prepare read Rjj.                                 0000200f close to fence
 * 44 SLTI_0     2b SLTIX_1    00000010000000000000111111101100010000 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 WFI_3      65 WFI_4      00010010000000000000101011101100100110        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105        00000000 
 * 46 ILL_1      47 ILL_2      00000000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 47 ILL_2      8f ILL_3      00000000000000001111101011101000001000        Store 0 to mtval                                  00000000 
 * 48 _L0x48     66 SW_1       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 CSRRW_1    4b CSRRW_2    00010010000000000000001011101100100110        Construct PC storage adr                          00000000 
 * 4a _L0x4a     66 SW_1       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b CSRRW_2    b1 CSRRW_3    00000000100000000011101011100100001000        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 4c SLT_0      31 SLTX_1     00000010000000000000111011001000000000 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   2e MULHU_1    00000000000000001100111001101000001000 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e eILL0b     fe ILLe       00000010000000000000000011000000000000 Illegal instruction seen                                 40002033 sloppy slt     
 * 4f MRET_8     e6 StdIncPc   00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 50 LW_1       e6 StdIncPc   00000001000010000100101111101000001000        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 51 LDAF_LW    da LDAF_a     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 52 LH_1       54 LH_2       00000010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 53 LDAF_LH    da LDAF_a     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 54 LH_2       eb LH_3       00000010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 55 aFaultb    1e aFault_1   00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 56 LH_4       57 LH_5       00000010000000000000100011101100011000        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 57 LH_5       8b LB_6       00000010000000000000100011101100000000        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 58 DIV_A      6e DIV_C      00110010000000000000101111101100001001        Transfer rM to rDee                               00002063 close to branch
 * 59 DIV_B      9c DIV_10     00000000000000001100111111101000110000        REM = Q to yy                                     00002067 close to jalr
 * 5a SB_1       5d SB_2       00000000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5b _L0x5b     32 JAL_1      00000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    49 CSRRW_1    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SB_2       fb SB_3       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 5e LHU_1      70 LHU_2      00000010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 5f LDAF_LHU   da LDAF_a     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 60 MULHU_3    42 MULHU_2    00100010000000000000111111101100001000        Shift Q and rM. Prepare read rs1                  00003003 close to load
 * 61 EBRKWFI2   f7 EBREAK_1   00000000000000001000011011101001010000 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 62 DIV_8      c8 DIV_7      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIV_9      58 DIV_A      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    2b SLTIX_1    00000010000000000000111111101100010000 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 WFI_4      ef WFI_5      00000010000000000000001011001001000000        Prepare read PC                                   00000000 
 * 66 SW_1       f2 SW_2       00000000000000000011111011100100001000        Write d to a+k until accepted                     00000000 
 * 67 SW_E1SWE   93 SW_E2      00000000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 68 DIV_12     e6 StdIncPc   00000000000000000100001011101000001000        RS2 > 0, RS1 >= 0, yy is true result              00003023 close to store
 * 69 DIV_13     8b LB_6       00000010000000000000101011101100000000        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 6a MULH_1     f9 MULH_2     00000000000000001100101011101000000000        Store ~rs1 to Ryy. Prep construct 1.              40003023 close to store
 * 6b SB_4       7a SB_5       00001110000000000010110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 6c SLTU_0     31 SLTX_1     00000010000000000000111011001000000000 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    2e MULHU_1    00000000000000001100111001101000001000 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_C      b9 DIV_e      00000000000000001100111011100100001000        rM to yy. Q=ffffffff                              40003033 sloppy sltu    
 * 6f MRET_6     cf MRET_7     00010010000000000000000011101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 70 LHU_2      ba LHU_3      00000010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 71 aFaultc    1e aFault_1   00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 72 LBU_3      1a ANDI_1     00000010000000000000011011101100010000        Invert q. Prepare read mask                       00000000 
 * 73 BAERR_1    76 BAERR_2    00000000000000001111110011101000001000        Faultadr to mtval. Prepare get offset             00000000 
 * 74 BrOpFet    f4 Fetch2     00000011001010000000101111101010110000 NewOp2 Read until instruction latched                    00000000 
 * 75 BAlignEr   73 BAERR_1    00000010000000000000001011000000000000  Err   Branch target instruction address misaligned      00000000 
 * 76 BAERR_2    77 BAERR_3    00000010000000000000001011101100000000        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 77 BAERR_3    7d BAERR_4    00010000000000001101101011100000100110        origPC to mepc. Prep read 0                       00000000 
 * 78 DIV_4      aa DIV_6      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00003063 close to branch
 * 79 DIV_5      a8 DIV_3      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00003067 close to jalr
 * 7a SB_5       f2 SW_2       00000000000000000010110011100100001000        Write d to a+k until accepted                     00000000 
 * 7b _L0x7b     32 JAL_1      00000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    49 CSRRW_1    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d BAERR_4    34 JAL_3      00000000110000001110100111100000001000        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 7e NMI_1      90 NMI_2      00000000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * 7f JALRE2     7d BAERR_4    00000000000000001111101011100000001000        mtval is target                                   00000000 
 * 80 LBU_0      85 LBU_1      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 JAERR_2    7d BAERR_4    00000000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 82 DIV_1      a8 DIV_3      00000000000000001000111011101000000000        jj=abs(RS1). Next handle divisor                  0000400b close to ij
 * 83 DIV_2      82 DIV_1      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     0000400f close to fence
 * 84 XORI_0     21 XORI_1     00000010000000000000111111101100010000 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 LBU_1      f0 LBU_2      00000010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 86 JAL_2      9e JAL_25     10110000000000000100001011000000100110        Return address to TRG                             00000000 
 * 87 JALRE1     7f JALRE2     00000000000000001101110011100000001000  err   Store pc to mepc                                  00000000 
 * 88 DIV_E      9c DIV_10     01100010000000000000111111000000000000        RS2 != 0. Check signs                             00004023 close to store
 * 89 DIV_F      e6 StdIncPc   00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 8a DIVU_5     1a ANDI_1     00110010000000000000101111001000000001        Transfer rM to rDee                               40004023 close to store
 * 8b LB_6       e6 StdIncPc   00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 8c XOR_0      29 XOR_1      00000010000000000000111111001000000000 XOR    xor                                               00004033 xor     
 * 8d DIV_0      82 DIV_1      01100010000000000000101101101100001000 DIV    Branch on sign dividend RS1                       00000000 
 * 8e _LCSRRS_1  fe ILLe       00000010000000000000000011000000000000 Illegal instruction seen                                 40004033 sloppy xor     
 * 8f ILL_3      a9 ILL_4      00000010000000000000101011101100100110        Q = 1                                             00000000 
 * 90 NMI_2      34 JAL_3      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 91 LDAF_2     92 LDAF_3     00110000110000001110001011000000100110        Store 4 to mcause                                 00000000 
 * 92 LDAF_3     34 JAL_3      00000000000000001101100111100000001000        PC to mepc                                        00000000 
 * 93 SW_E2      95 SW_E3      00000000000000001101101111101000001000        Store address that faulted                        00000000 
 * 94 SW_E4      34 JAL_3      00000000110000001110100111100000101000        Store 6 to mcause                                 00000000 
 * 95 SW_E3      94 SW_E4      00110010000000000000101111001100100110        Q = 3                                             00000000 
 * 96 SH_1       bb SH_2       00000000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 97 SW_E1SWH   93 SW_E2      00000000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 98 BLT        13 condb_2    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000000011000000000000  Not in use (illegal as entry)                           00004067 close to jalr
 * 9a ECALL_6    34 JAL_3      00010000110000001110100111000000100000        mcause = 11                                       00000000 
 * 9b SH_4       9f SH_5       00001110000000000001110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 9c DIV_10     68 DIV_12     01100010000000000000110011101000001000        RS2 > 0. Branch on sign of RS1                    00004073 close to csr/system 
 * 9d DIV_11     a2 DIV_14     01100010000000000000110011101000001000        RS2 < 0. Branch on sign of RS1                    00000000 
 * 9e JAL_25     34 JAL_3      00000000000000001000110011100000001000        Instr. adr. to jj in case of access error         00000000 
 * 9f SH_5       f2 SW_2       00000000000000000001110011100100001000        Write d to a+k until accepted                     00000000 
 * a0 LHU_0      5e LHU_1      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_4    b6 ECALL_5    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * a2 DIV_14     8b LB_6       00000010000000000000101011101100000000        RS2 < 0, RS1 >= 0, change sign yy                 0000500b close to ij
 * a3 DIV_15     e6 StdIncPc   00000000000000000100001011101000001000        RS2 < 0, RS1 < 0, yy is true result               0000500f close to fence
 * a4 SRxI_0     3a SRxI_1     00000010000000000000111100100000110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_3     af MRET_4     00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * a6 ECAL_RET   d0 ECALL_1    00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * a7 EBRKWFI1   61 EBRKWFI2   00010010000000000000000011101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * a8 DIV_3      78 DIV_4      01100010000000000000101011101100000000        Branch on sign divisor RS2                        00005023 close to store
 * a9 ILL_4      34 JAL_3      00010000110000001110100111100000100110        Store 2 to mcause                                 00000000 
 * aa DIV_6      c8 DIV_7      00100010000000000000101111001000000000        Write M. Prepare shift                            40005023 close to store
 * ab EBREAK_2   9a ECALL_6    00000000000000001101101011101000001000        pc to mepc                                        00000000 
 * ac _L0xac     3f SRx_1      00000010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     e0 DIVU_1     00100010000000000000111001001000000000 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     3f SRx_1      00000010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_4     c5 MRET_5     00010010000000000000000011101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b0 aF_SW_3    92 LDAF_3     00010000110000001110001011000000100000        Store 7 to mcause                                 00000000 
 * b1 CSRRW_3    b2 CSRRW_4    00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b2 CSRRW_4    de Fetch      00110100000010001000110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b3 unxb3         (use dinx) 00000000000000000000000000000000000000 b3: Not in use                                           00000000 
 * b4 i0reserv      (use dinx) 00000000000000000000000000000000000000 Not in use, reserved to allow LASTINCH                   00000000 
 * b5 SH_3       9b SH_4       00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b6 ECALL_5    9a ECALL_6    00110010000000000000101011001100100110        Q = 8                                             00000000 
 * b7 IJ_3       bd IJ_4       00010010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b8 BGE        13 condb_2    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 DIV_e      c0 DIV_D      00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00005067 close to jalr
 * ba LHU_3      1a ANDI_1     00000010000000000000011111101100010000        Invert q. Prepare read mask                       00000000 
 * bb SH_2       b5 SH_3       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * bc CSRRWI_0   49 CSRRW_1    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd IJ_4       de Fetch      00000110000010000000110111100100011000        Mask and use as PC                                00000000 
 * be IJ_1       1f IJ_2       00000010000010000000101111101100001000        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * bf IJT_1      c1 IJT_2      00000010000010000000101111101100001000        Exit CSR, enter trap                              00000000 
 * c0 DIV_D      88 DIV_E      00000010000000000000111011101101001000        Is RS2 == 0?                                      00006003 close to load
 * c1 IJT_2      e9 IJT_3      00000000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c2 DIVU_3     ca DIVU_2     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000600b close to ij
 * c3 DIVU_4     8a DIVU_5     01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000600f close to fence
 * c4 ORI_0      e1 ORI_1      00000000000000001000111111101000010000 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_5     6f MRET_6     00000010000000000000000011101100010000        ~302                                              00000000 
 * c6 IJT_4      47 ILL_2      00000000000000001101101011101100011000        Mask and store to mepc and Q for read of instr    00000000 
 * c7 QINT_1     cb QINT_2     00000000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * c8 DIV_7      62 DIV_8      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00006023 close to store
 * c9 MRET_2     a5 MRET_3     00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * ca DIVU_2     c2 DIVU_3     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            40006023 close to store
 * cb QINT_2     e6 StdIncPc   00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * cc OR_0       26 OR_1       00000010000000000000111111001000000000 OR     or                                                00006033 or      
 * cd REM_0      82 DIV_1      01100010000000000000101101101100001000 REM    Branch on sign dividend RS1                       00000000 
 * ce _LCSRRCI_1 fe ILLe       00000010000000000000000011000000000000 Illegal instruction seen                                 40006033 sloppy or      
 * cf MRET_7     4f MRET_8     00000010000000000000011011001001000000        Prepare emulation entry point 0x104               00000000 
 * d0 ECALL_1    37 ECALL_2    00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * d1 MRET_1     c9 MRET_2     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * d2 LB_2       06 LB_3       00000010000100000000101001101100001001        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * d3 aFaultd    1e aFault_1   00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * d4 aFault_2   92 LDAF_3     00010000110000001110001011100000100110        Store 5 to mcause                                 00000000 
 * d5 unxd5         (use dinx) 00000000000000000000000000000000000000 d5: Not in use                                           00000000 
 * d6 eILL0c     fe ILLe       00000010000000000000000011000000000000 Illegal instruction seen                                 00000000 
 * d7 ECALL_3    a1 ECALL_4    00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * d8 BLTU       13 condb_2    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MULH_3     42 MULHU_2    00100010000000000000111111001000000000        rM<=RS2, Q = 0. next read RS1. Join.              00006067 close to jalr
 * da LDAF_a     91 LDAF_2     00000010000000000000101011001000000000        Extra cycle after error detected write mtval      00000000 
 * db jFault_1   92 LDAF_3     00010000000000001110000011100000100110        Store 1 to mcause                                 00000000 
 * dc CSRRSI_0   49 CSRRW_1    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd aF_SW_1    e5 aF_SW_2    00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * de Fetch      f4 Fetch2     00000000000000001010001111101010110000  Fr00  Read and latch instruction                        00000000 
 * df eFetch     f4 Fetch2     00000001001010001010101111101010110000  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * e0 DIVU_1     ca DIVU_2     00000000000000001100101111101000000000        Store inverted rs2 to yy. Prepare shift           00007003 close to load
 * e1 ORI_1      1d ORI_2      00000010000000000000000011101100001000        Q = RS1                                           00000000 
 * e2 MUL_1      e8 MUL_2      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           0000700b close to ij
 * e3 MUL_3      1a ANDI_1     00110010000000000000101111001000000001        Transfer rM to rDee                               0000700f close to fence
 * e4 ANDI_0     1a ANDI_1     00000010000000000000111111101100010000 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 aF_SW_2    b0 aF_SW_3    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * e6 StdIncPc   de Fetch      00110100000010001000110111000100100110  Fr00  IncPC, OpFetch                                    00000000 
 * e7 aFault     1e aFault_1   00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * e8 MUL_2      e2 MUL_1      00100010000000000000111011101100001000        Shift Q and rM. Prepare read rs2                  00007023 close to store
 * e9 IJT_3      c6 IJT_4      00010010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ea MULHU_5    22 MULHU_6    00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          40007023 close to store
 * eb LH_3       56 LH_4       00000010000000000000011111101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * ec AND_0      11 AND_1      00000010000000000000111111001000000000 AND    And                                               00007033 and     
 * ed REMU_0     e0 DIVU_1     00100010000000000000111001001000000000 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee eILL0a     fe ILLe       00000010000000000000000011000000000000 Illegal instruction seen                                 40007033 sloppy and     
 * ef WFI_5      de Fetch      00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * f0 LBU_2      72 LBU_3      00000010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * f1 aFaulte    1e aFault_1   00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * f2 SW_2       e6 StdIncPc   00000010000000000000001011001000000000        Prepare read PC                                   00000000 
 * f3 aF_SW      dd aF_SW_1    00000010000000000000000011000100000000  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * f4 Fetch2        (use dinx) 00010000000000011011111111111100100000  Fr00  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f5 jFault     db jFault_1   00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * f6 WFI_1      fa WFI_2      00110010000000000000000011001100100110 WFI    Chk offset=0x105. Now=0xff. Prep 0xff+4 = 0x103   00000000 
 * f7 EBREAK_1   ab EBREAK_2   00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * f8 BGEU       13 condb_2    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 MULH_2     d9 MULH_3     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00007067 close to jalr
 * fa WFI_2      45 WFI_3      00010010000000000000101011101100100110        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104   00000000 
 * fb SB_3       6b SB_4       00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fc CSRRCI_0   49 CSRRW_1    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      7e NMI_1      00000010000000000000001011001000000000 NMI    Get current PC                                    00000000 
 * fe ILLe       46 ILL_1      00000010000000000000001011000000000000 Illegal                                                  00000000 
 * ff QINT_0     c7 QINT_1     00000010000000000000001011001000000000 INT    Get current PC                                    00000000 
 */
localparam v12_u0_0 = 256'h30e6001000e208041886205a008b205a18091007000420e600e620be09d22001;
localparam v12_u0_1 = 256'h30b726d438e630a6303218e620413013207436de48162615001400fe001a008b;
localparam v12_u0_2 = 256'h30e63042086a003e2630209600212096201d00270004303500e6213900e62052;
localparam v12_u0_3 = 256'h083a0835090330493032093d08e6301348d72803083608de20812086002b32e6;
localparam v12_u0_4 = 256'h26e600fe082e003108b12066264b2066088f08472665102b00ea2160260b2050;
localparam v12_u0_5 = 256'h30da097028fb30493032085d309c096e008b1857301e09eb30da095430da08e6;
localparam v12_u0_6 = 256'h26cf08b9082e0031087a00f9008b08e6309308f240ef102b265826c850f70842;
localparam v12_u0_7 = 256'h087d089008343049303208f226a830aa267d00770073b0f40876101a301e09ba;
localparam v12_u0_8 = 256'h26a900fe0882002926e6011a30e6009c087f269e09f01021208200a8087d2085;
localparam v12_u0_9 = 256'h08f2083408a20868089f203400fe3013309308bb269428340895083426923034;
localparam v12_u0_A = 256'h26c5003f00e0003f089a00c826340078206130d026af303a08e6008b26b6205e;
localparam v12_u0_B = 256'h08c1081f18de304928b5101a06c0301320bd269a309b0000000026de26b22092;
localparam v12_u0_C = 256'h404f00fe0882002630e62cc220a52c6208cb1847106f10e1268a26ca30e94888;
localparam v12_u0_D = 256'hb0f4b0f430e53049269200910042301330a100fe00002692301e090630c92637;
localparam v12_u0_E = 256'h26de00fe00e000111056202220c608e2301e26de26b0101a011a21e8081d00ca;
localparam v12_u0_F = 256'h00c70046007e3049306b264526d9301330ab26fa30db200000dd00e6301e0972;
localparam v12_u1_0 = 256'h10ba03b203b203bbb0ba23ab017b23ab017b01bb00b110ba00b2837b02fb036b;
localparam v12_u1_1 = 256'h32ba02b310ba82f980b910ba32ba33baab7b2b71233b00bb03fb003003bb03fb;
localparam v12_u1_2 = 256'h10ba23fa029b03b0003aa3ab03bba3ab003b23ba00b103c800b202bb10bab36b;
localparam v12_u1_3 = 256'h03c803c8129b31ba80b9129b10ba33ba343a12db12db2b793cb830ba03fb10ba;
localparam v12_u1_4 = 256'h02bb0030339a03b20eb983bb00bb83bb3eba36b802bb03fb0039029b033b837b;
localparam v12_u1_5 = 256'h3eb902fb32db31ba80b932db33fa02fb023b023b3eba029b3eb902fb3eb912fa;
localparam v12_u1_6 = 256'h003b33b9339a03b20b3b32ba02bb10ba3cb80fb900b203fb02fb02db21ba03fb;
localparam v12_u1_7 = 256'h3eb8343a3a7831ba80b90b3902bb303a36b800bb00b002fa3f3a01bb3eba029b;
localparam v12_u1_8 = 256'h02bb003002db03f210ba02f210ba03f0373810b002fb03fb02bb23ba36b8036b;
localparam v12_u1_9 = 256'h07392338033a033a073b3a70003033ba3cb832db02f33a7836fa367838b03d3a;
localparam v12_u1_A = 256'h003b03b0039203b036ba02f23a7802bb003b82f901bb03c810ba02bb02b3b36b;
localparam v12_u1_B = 256'h02fb02fb037931ba32db01fb033b33ba033302b3003a00000000237102b338b0;
localparam v12_u1_C = 256'h01b2003002db03f23d3a033b01b3033b343a36bb003b23fa02fb02db32ba03bb;
localparam v12_u1_D = 256'h2afa28fa3eba31ba383802b203f233ba3eba0030000038b83eba029b21ba00bb;
localparam v12_u1_E = 256'h2b710030039203f201fb033b033303bb3eba237102b303fb02f2029b003b32fa;
localparam v12_u1_F = 256'h00b200b000b231ba003a02bb23ba33ba3cba00333eba6fff003100b23eba029b;
localparam v12_u2_0 = 256'h00000080088000800001040000800400008000800080040000800590008a0580;
localparam v12_u2_1 = 256'h00000c8000000080008100000400000005010102000004800080008000800080;
localparam v12_u2_2 = 256'h0000080000800080048004000080040004800000008000800080008000000500;
localparam v12_u2_3 = 256'h0080008000040000008100000800000000000004000001020400040000800000;
localparam v12_u2_4 = 256'h0480008000000080002007810480078100000000048000800080008004800581;
localparam v12_u2_5 = 256'h0000008a000400000081000000000c8000800080000000840000008a00000042;
localparam v12_u2_6 = 256'h0480000000000080038000000080000000000000008000801480048000000880;
localparam v12_u2_7 = 256'h0000000000300000008100000c80000004000080008000ca0000008000000084;
localparam v12_u2_8 = 256'h00800080188000800c000c800000188000002c00008a00800480000000000580;
localparam v12_u2_9 = 256'h00000000188018800380043000800000000000000c800030000000000c300030;
localparam v12_u2_A = 256'h048000800880008000000880043018800480008104800080000000800c800500;
localparam v12_u2_B = 256'h0082008201820000000400800080000004800c800080000000000d020c800430;
localparam v12_u2_C = 256'h0080008018800080003008800480088000000000008000001480048000000080;
localparam v12_u2_D = 256'h004a000000000000040000800880000000000080000004300000008400000480;
localparam v12_u2_E = 256'h0d02008008800080008000800480088000000d020c8000800c80008000800000;
localparam v12_u2_F = 256'h0080008000800000008004800400000000000c80000004000080008000000084;
/*
 * =================================================
 * * Version 14. RVC MULDIV MINSTRET               *
 * =================================================
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       d2 LB_2       00000010001010000000101111101100001001        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       be IJ_1       00010110010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     e6 StdIncPc   00000010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     e6 StdIncPc   00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 LB_3       07 LB_4       00000010000000000000011011101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * 07 LB_4       09 LB_5       00000010000000000000010111101100011000        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 08 _L0x08     5a SB_1       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_5       8b LB_6       00000010000000000000010111101100000000        q = D^0xffffffff^q = D^0x80                       00000000 
 * 0a _L0x0a     5a SB_1       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b JALR_2     86 JAL_2      00000000000001101100001011101000011000        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001000 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      e2 MUL_1      00100010000000000000111011001000000000 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      10 SUB_1      00000010000000000000111011001000000000 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     e6 StdIncPc   00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 SUB_1      8b LB_6       00000010000000000000111111101100000000        Q = ~RS2                                          00000000 
 * 11 AND_1      1a ANDI_1     00000010000000000000111011101100000000        RS1^0xffffffff to Q                               00000000 
 * 12 _L0x12     fe ILLe       00000010000000000000000011000000000000  Not in use (illegal as entry)                           00000000 
 * 13 condb_2    14 condb_3    00000010000000000000111111101100000000        ~RS2 in Q                                         00000000 
 * 14 condb_3    15 condb_4    00010010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 15 condb_4    16 condb_5    00000000000000001000110011101101001000        Branch on condition                               00000000 
 * 16 condb_5    de Fetch      00000100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 17 condb_5t   74 BrOpFet    00010100000001101010110111101100100000        Branch taken.                                     00000000 
 * 18 BEQ        13 condb_2    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     41 JALR_1     00010000000000001100101011101000100000 JALR   yy=RS1+imm                                        00000067 jalr    
 * 1a ANDI_1     e6 StdIncPc   00000000000000000100001011101000011000        rd = Iimm & RS1                                   00000000 
 * 1b _L0x1b     32 JAL_1      00000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   a6 ECAL_RET   00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d ORI_2      e6 StdIncPc   00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 1e aFault_1   d4 aFault_2   00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 1f IJ_2       b7 IJ_3       00000000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 20 LH_0       52 LH_1       00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 XORI_1     e6 StdIncPc   00000000000000000100001011101000000000        rd = Iimm ^ RS1                                   00000000 
 * 22 MULHU_6    39 MULHU_7    00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      0000100b close to ij
 * 23 _L0x23     e6 StdIncPc   00000010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     35 SLLI_1     00000010000000000000111100100000110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 OR_1       27 OR_2       00000000000000001000111011101000000000        RS1^0xffffffff to jj                              00000000 
 * 27 OR_2       1d ORI_2      00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 28 _L0x28     96 SH_1       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 XOR_1      21 XORI_1     00000010000000000000111011101100000000        Q = RS1^0xFFFFFFFF                                00000000 
 * 2a _L0x2a     96 SH_1       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b SLTIX_1    30 SLTIX_2    00010010000000000000000011101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 2c SLL_0      3e SLL_1      00000010000000000000111011000000000000 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     6a MULH_1     00000010000000000000101001101100001000 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e MULHU_1    42 MULHU_2    00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                40001033 sloppy sll     
 * 2f _L0x2f     e6 StdIncPc   00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SLTIX_2    e6 StdIncPc   00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 31 SLTX_1     2b SLTIX_1    00000010000000000000111111101100000000        ~rs2 to Q                                         00000000 
 * 32 JAL_1      86 JAL_2      00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 33 JAERR_1    81 JAERR_2    00010000000000001111001011100000100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 34 JAL_3      de Fetch      00000100000010001010110111100100001000        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 35 SLLI_1     36 SLLI_2     00000000000000000100101101101100001000        Register to shift to Q (and TRG for shift 0)      00000000 
 * 36 SLLI_2     03 _L0x03     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 37 ECALL_2    d7 ECALL_3    00000000000000001101000011101001001000        mepc = pc, prep store 0 to mtval                  00000000 
 * 38 BNE        13 condb_2    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 MULHU_7    e6 StdIncPc   00100000000000000100001011101000001000        Last shift.                                       00001067 close to jalr
 * 3a SRxI_1     3d SRxI_2     00000000000000000100101001101100001001        Register to shift to Q                            00000000 
 * 3b _L0x3b     32 JAL_1      00000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    49 CSRRW_1    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d SRxI_2     03 _L0x03     00000000000100000100101001101100001001        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 3e SLL_1      35 SLLI_1     00000010000000000000111100100000001000        Shiftamount was in low 5 bits of RS2              00000000 
 * 3f SRx_1      3a SRxI_1     00000010000000000000111100100000001000        Shiftamount in low 5 bits of RS2                  00000000 
 * 40 LW_0       50 LW_1       00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 JALR_1     0b JALR_2     00010010000000000000110011101100100110        Q=1                                               00000000 
 * 42 MULHU_2    60 MULHU_3    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           0000200b close to ij
 * 43 MULHU_4    ea MULHU_5    00000010000000000000000011100100000000        Prepare read Rjj.                                 0000200f close to fence
 * 44 SLTI_0     2b SLTIX_1    00000010000000000000111111101100010000 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 WFI_3      65 WFI_4      00010010000000000000101011101100100110        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105        00000000 
 * 46 ILL_1      47 ILL_2      00000000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 47 ILL_2      8f ILL_3      00000000000000001111101011101000001000        Store 0 to mtval                                  00000000 
 * 48 _L0x48     66 SW_1       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 CSRRW_1    4b CSRRW_2    00010010000000000000001011101100100110        Construct PC storage adr                          00000000 
 * 4a _L0x4a     66 SW_1       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b CSRRW_2    b1 CSRRW_3    00000000100000000011101011100100001000        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 4c SLT_0      31 SLTX_1     00000010000000000000111011001000000000 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   2e MULHU_1    00000000000000001100111001101000001000 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e eILL0b     fe ILLe       00000010000000000000000011000000000000 Illegal instruction seen                                 40002033 sloppy slt     
 * 4f MRET_8     e6 StdIncPc   00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 50 LW_1       e6 StdIncPc   00000001000010000100101111101000001000        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 51 LDAF_LW    da LDAF_a     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 52 LH_1       54 LH_2       00000010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 53 LDAF_LH    da LDAF_a     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 54 LH_2       eb LH_3       00000010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 55 aFaultb    1e aFault_1   00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 56 LH_4       57 LH_5       00000010000000000000100011101100011000        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 57 LH_5       8b LB_6       00000010000000000000100011101100000000        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 58 DIV_A      6e DIV_C      00110010000000000000101111101100001001        Transfer rM to rDee                               00002063 close to branch
 * 59 DIV_B      9c DIV_10     00000000000000001100111111101000110000        REM = Q to yy                                     00002067 close to jalr
 * 5a SB_1       5d SB_2       00000000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5b _L0x5b     32 JAL_1      00000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    49 CSRRW_1    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SB_2       fb SB_3       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 5e LHU_1      70 LHU_2      00000010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 5f LDAF_LHU   da LDAF_a     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 60 MULHU_3    42 MULHU_2    00100010000000000000111111101100001000        Shift Q and rM. Prepare read rs1                  00003003 close to load
 * 61 EBRKWFI2   f7 EBREAK_1   00000000000000001000011011101001010000 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 62 DIV_8      c8 DIV_7      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIV_9      58 DIV_A      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    2b SLTIX_1    00000010000000000000111111101100010000 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 WFI_4      ef WFI_5      00000010000000000000001011001001000000        Prepare read PC                                   00000000 
 * 66 SW_1       f2 SW_2       00000000000000000011111011100100001000        Write d to a+k until accepted                     00000000 
 * 67 SW_E1SWE   93 SW_E2      00000000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 68 DIV_12     e6 StdIncPc   00000000000000000100001011101000001000        RS2 > 0, RS1 >= 0, yy is true result              00003023 close to store
 * 69 DIV_13     8b LB_6       00000010000000000000101011101100000000        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 6a MULH_1     f9 MULH_2     00000000000000001100101011101000000000        Store ~rs1 to Ryy. Prep construct 1.              40003023 close to store
 * 6b SB_4       7a SB_5       00001110000000000010110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 6c SLTU_0     31 SLTX_1     00000010000000000000111011001000000000 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    2e MULHU_1    00000000000000001100111001101000001000 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_C      b9 DIV_e      00000000000000001100111011100100001000        rM to yy. Q=ffffffff                              40003033 sloppy sltu    
 * 6f MRET_6     cf MRET_7     00010010000000000000000011101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 70 LHU_2      ba LHU_3      00000010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 71 aFaultc    1e aFault_1   00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 72 LBU_3      1a ANDI_1     00000010000000000000011011101100010000        Invert q. Prepare read mask                       00000000 
 * 73 BAERR_1    76 BAERR_2    00000000000000001111110011101000001000        Faultadr to mtval. Prepare get offset             00000000 
 * 74 BrOpFet    f4 Fetch2     00000011001010000000101111101010110000 NewOp2 Read until instruction latched                    00000000 
 * 75 BAlignEr   73 BAERR_1    00000010000000000000001011000000000000  Err   Branch target instruction address misaligned      00000000 
 * 76 BAERR_2    77 BAERR_3    00000010000000000000001011101100000000        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 77 BAERR_3    7d BAERR_4    00010000000000001101101011100000100110        origPC to mepc. Prep read 0                       00000000 
 * 78 DIV_4      aa DIV_6      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00003063 close to branch
 * 79 DIV_5      a8 DIV_3      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00003067 close to jalr
 * 7a SB_5       f2 SW_2       00000000000000000010110011100100001000        Write d to a+k until accepted                     00000000 
 * 7b _L0x7b     32 JAL_1      00000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    49 CSRRW_1    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d BAERR_4    34 JAL_3      00000000110000001110100111100000001000        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 7e NMI_1      90 NMI_2      00000000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * 7f JALRE2     7d BAERR_4    00000000000000001111101011100000001000        mtval is target                                   00000000 
 * 80 LBU_0      85 LBU_1      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 JAERR_2    7d BAERR_4    00000000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 82 DIV_1      a8 DIV_3      00000000000000001000111011101000000000        jj=abs(RS1). Next handle divisor                  0000400b close to ij
 * 83 DIV_2      82 DIV_1      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     0000400f close to fence
 * 84 XORI_0     21 XORI_1     00000010000000000000111111101100010000 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 LBU_1      f0 LBU_2      00000010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 86 JAL_2      9e JAL_25     10110000000000000100001011000000100110        Return address to TRG                             00000000 
 * 87 JALRE1     7f JALRE2     00000000000000001101110011100000001000  err   Store pc to mepc                                  00000000 
 * 88 DIV_E      9c DIV_10     01100010000000000000111111000000000000        RS2 != 0. Check signs                             00004023 close to store
 * 89 DIV_F      e6 StdIncPc   00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 8a DIVU_5     1a ANDI_1     00110010000000000000101111001000000001        Transfer rM to rDee                               40004023 close to store
 * 8b LB_6       e6 StdIncPc   00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 8c XOR_0      29 XOR_1      00000010000000000000111111001000000000 XOR    xor                                               00004033 xor     
 * 8d DIV_0      82 DIV_1      01100010000000000000101101101100001000 DIV    Branch on sign dividend RS1                       00000000 
 * 8e _LCSRRS_1  fe ILLe       00000010000000000000000011000000000000 Illegal instruction seen                                 40004033 sloppy xor     
 * 8f ILL_3      a9 ILL_4      00000010000000000000101011101100100110        Q = 1                                             00000000 
 * 90 NMI_2      34 JAL_3      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 91 LDAF_2     92 LDAF_3     00110000110000001110001011000000100110        Store 4 to mcause                                 00000000 
 * 92 LDAF_3     34 JAL_3      00000000000000001101100111100000001000        PC to mepc                                        00000000 
 * 93 SW_E2      95 SW_E3      00000000000000001101101111101000001000        Store address that faulted                        00000000 
 * 94 SW_E4      34 JAL_3      00000000110000001110100111100000101000        Store 6 to mcause                                 00000000 
 * 95 SW_E3      94 SW_E4      00110010000000000000101111001100100110        Q = 3                                             00000000 
 * 96 SH_1       bb SH_2       00000000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 97 SW_E1SWH   93 SW_E2      00000000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 98 BLT        13 condb_2    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000000011000000000000  Not in use (illegal as entry)                           00004067 close to jalr
 * 9a ECALL_6    34 JAL_3      00010000110000001110100111000000100000        mcause = 11                                       00000000 
 * 9b SH_4       9f SH_5       00001110000000000001110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 9c DIV_10     68 DIV_12     01100010000000000000110011101000001000        RS2 > 0. Branch on sign of RS1                    00004073 close to csr/system 
 * 9d DIV_11     a2 DIV_14     01100010000000000000110011101000001000        RS2 < 0. Branch on sign of RS1                    00000000 
 * 9e JAL_25     34 JAL_3      00000000000000001000110011100000001000        Instr. adr. to jj in case of access error         00000000 
 * 9f SH_5       f2 SW_2       00000000000000000001110011100100001000        Write d to a+k until accepted                     00000000 
 * a0 LHU_0      5e LHU_1      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_4    b6 ECALL_5    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * a2 DIV_14     8b LB_6       00000010000000000000101011101100000000        RS2 < 0, RS1 >= 0, change sign yy                 0000500b close to ij
 * a3 DIV_15     e6 StdIncPc   00000000000000000100001011101000001000        RS2 < 0, RS1 < 0, yy is true result               0000500f close to fence
 * a4 SRxI_0     3a SRxI_1     00000010000000000000111100100000110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_3     af MRET_4     00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * a6 ECAL_RET   d0 ECALL_1    00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * a7 EBRKWFI1   61 EBRKWFI2   00010010000000000000000011101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * a8 DIV_3      78 DIV_4      01100010000000000000101011101100000000        Branch on sign divisor RS2                        00005023 close to store
 * a9 ILL_4      34 JAL_3      00010000110000001110100111100000100110        Store 2 to mcause                                 00000000 
 * aa DIV_6      c8 DIV_7      00100010000000000000101111001000000000        Write M. Prepare shift                            40005023 close to store
 * ab EBREAK_2   9a ECALL_6    00000000000000001101101011101000001000        pc to mepc                                        00000000 
 * ac _L0xac     3f SRx_1      00000010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     e0 DIVU_1     00100010000000000000111001001000000000 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     3f SRx_1      00000010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_4     c5 MRET_5     00010010000000000000000011101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b0 aF_SW_3    92 LDAF_3     00010000110000001110001011000000100000        Store 7 to mcause                                 00000000 
 * b1 CSRRW_3    b2 CSRRW_4    00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b2 CSRRW_4    de Fetch      00110100000010001000110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b3 unxb3         (use dinx) 00000000000000000000000000000000000000 b3: Not in use                                           00000000 
 * b4 eFetch3       (use dinx) 00010000000000011001111111101100100110  Fr10  Update minstret, Q=immediate. Use dinx            00000000 
 * b5 SH_3       9b SH_4       00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b6 ECALL_5    9a ECALL_6    00110010000000000000101011001100100110        Q = 8                                             00000000 
 * b7 IJ_3       bd IJ_4       00010010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b8 BGE        13 condb_2    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 DIV_e      c0 DIV_D      00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00005067 close to jalr
 * ba LHU_3      1a ANDI_1     00000010000000000000011111101100010000        Invert q. Prepare read mask                       00000000 
 * bb SH_2       b5 SH_3       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * bc CSRRWI_0   49 CSRRW_1    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd IJ_4       de Fetch      00000110000010000000110111100100011000        Mask and use as PC                                00000000 
 * be IJ_1       1f IJ_2       00000010000010000000101111101100001000        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * bf IJT_1      c1 IJT_2      00000010000010000000101111101100001000        Exit CSR, enter trap                              00000000 
 * c0 DIV_D      88 DIV_E      00000010000000000000111011101101001000        Is RS2 == 0?                                      00006003 close to load
 * c1 IJT_2      e9 IJT_3      00000000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c2 DIVU_3     ca DIVU_2     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000600b close to ij
 * c3 DIVU_4     8a DIVU_5     01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000600f close to fence
 * c4 ORI_0      e1 ORI_1      00000000000000001000111111101000010000 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_5     6f MRET_6     00000010000000000000000011101100010000        ~302                                              00000000 
 * c6 IJT_4      47 ILL_2      00000000000000001101101011101100011000        Mask and store to mepc and Q for read of instr    00000000 
 * c7 QINT_1     cb QINT_2     00000000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * c8 DIV_7      62 DIV_8      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00006023 close to store
 * c9 MRET_2     a5 MRET_3     00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * ca DIVU_2     c2 DIVU_3     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            40006023 close to store
 * cb QINT_2     e6 StdIncPc   00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * cc OR_0       26 OR_1       00000010000000000000111111001000000000 OR     or                                                00006033 or      
 * cd REM_0      82 DIV_1      01100010000000000000101101101100001000 REM    Branch on sign dividend RS1                       00000000 
 * ce _LCSRRCI_1 fe ILLe       00000010000000000000000011000000000000 Illegal instruction seen                                 40006033 sloppy or      
 * cf MRET_7     4f MRET_8     00000010000000000000011011001001000000        Prepare emulation entry point 0x104               00000000 
 * d0 ECALL_1    37 ECALL_2    00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * d1 MRET_1     c9 MRET_2     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * d2 LB_2       06 LB_3       00000010000100000000101001101100001001        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * d3 aFaultd    1e aFault_1   00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * d4 aFault_2   92 LDAF_3     00010000110000001110001011100000100110        Store 5 to mcause                                 00000000 
 * d5 eFetch2    b4 eFetch3    00010000000000001011000111111000100000  Fr10  Update ttime                                      00000000 
 * d6 eILL0c     fe ILLe       00000010000000000000000011000000000000 Illegal instruction seen                                 00000000 
 * d7 ECALL_3    a1 ECALL_4    00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * d8 BLTU       13 condb_2    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MULH_3     42 MULHU_2    00100010000000000000111111001000000000        rM<=RS2, Q = 0. next read RS1. Join.              00006067 close to jalr
 * da LDAF_a     91 LDAF_2     00000010000000000000101011001000000000        Extra cycle after error detected write mtval      00000000 
 * db jFault_1   92 LDAF_3     00010000000000001110000011100000100110        Store 1 to mcause                                 00000000 
 * dc CSRRSI_0   49 CSRRW_1    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd aF_SW_1    e5 aF_SW_2    00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * de Fetch      f4 Fetch2     00000000000000001010001111101010110000  Fr10  Read and latch instruction                        00000000 
 * df eFetch     d5 eFetch2    00000001001010001010101111101010110000  Fr10  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * e0 DIVU_1     ca DIVU_2     00000000000000001100101111101000000000        Store inverted rs2 to yy. Prepare shift           00007003 close to load
 * e1 ORI_1      1d ORI_2      00000010000000000000000011101100001000        Q = RS1                                           00000000 
 * e2 MUL_1      e8 MUL_2      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           0000700b close to ij
 * e3 MUL_3      1a ANDI_1     00110010000000000000101111001000000001        Transfer rM to rDee                               0000700f close to fence
 * e4 ANDI_0     1a ANDI_1     00000010000000000000111111101100010000 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 aF_SW_2    b0 aF_SW_3    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * e6 StdIncPc   de Fetch      00110100000010001000110111000100100110  Fr10  IncPC, OpFetch                                    00000000 
 * e7 aFault     1e aFault_1   00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * e8 MUL_2      e2 MUL_1      00100010000000000000111011101100001000        Shift Q and rM. Prepare read rs2                  00007023 close to store
 * e9 IJT_3      c6 IJT_4      00010010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ea MULHU_5    22 MULHU_6    00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          40007023 close to store
 * eb LH_3       56 LH_4       00000010000000000000011111101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * ec AND_0      11 AND_1      00000010000000000000111111001000000000 AND    And                                               00007033 and     
 * ed REMU_0     e0 DIVU_1     00100010000000000000111001001000000000 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee eILL0a     fe ILLe       00000010000000000000000011000000000000 Illegal instruction seen                                 40007033 sloppy and     
 * ef WFI_5      de Fetch      00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * f0 LBU_2      72 LBU_3      00000010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * f1 aFaulte    1e aFault_1   00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * f2 SW_2       e6 StdIncPc   00000010000000000000001011001000000000        Prepare read PC                                   00000000 
 * f3 aF_SW      dd aF_SW_1    00000010000000000000000011000100000000  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * f4 Fetch2        (use dinx) 00010000000000011011111111111100100000  Fr10  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f5 jFault     db jFault_1   00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * f6 WFI_1      fa WFI_2      00110010000000000000000011001100100110 WFI    Chk offset=0x105. Now=0xff. Prep 0xff+4 = 0x103   00000000 
 * f7 EBREAK_1   ab EBREAK_2   00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * f8 BGEU       13 condb_2    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 MULH_2     d9 MULH_3     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00007067 close to jalr
 * fa WFI_2      45 WFI_3      00010010000000000000101011101100100110        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104   00000000 
 * fb SB_3       6b SB_4       00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fc CSRRCI_0   49 CSRRW_1    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      7e NMI_1      00000010000000000000001011001000000000 NMI    Get current PC                                    00000000 
 * fe ILLe       46 ILL_1      00000010000000000000001011000000000000 Illegal                                                  00000000 
 * ff QINT_0     c7 QINT_1     00000010000000000000001011001000000000 INT    Get current PC                                    00000000 
 */
localparam v14_u0_0 = 256'h30e6001000e208041886205a008b205a18091007000420e600e620be09d22001;
localparam v14_u0_1 = 256'h30b726d438e630a6303218e620413013207436de48162615001400fe001a008b;
localparam v14_u0_2 = 256'h30e63042086a003e2630209600212096201d00270004303500e6213900e62052;
localparam v14_u0_3 = 256'h083a0835090330493032093d08e6301348d72803083608de20812086002b32e6;
localparam v14_u0_4 = 256'h26e600fe082e003108b12066264b2066088f08472665102b00ea2160260b2050;
localparam v14_u0_5 = 256'h30da097028fb30493032085d309c096e008b1857301e09eb30da095430da08e6;
localparam v14_u0_6 = 256'h26cf08b9082e0031087a00f9008b08e6309308f240ef102b265826c850f70842;
localparam v14_u0_7 = 256'h087d089008343049303208f226a830aa267d00770073b0f40876101a301e09ba;
localparam v14_u0_8 = 256'h26a900fe0882002926e6011a30e6009c087f269e09f01021208200a8087d2085;
localparam v14_u0_9 = 256'h08f2083408a20868089f203400fe3013309308bb269428340895083426923034;
localparam v14_u0_A = 256'h26c5003f00e0003f089a00c826340078206130d026af303a08e6008b26b6205e;
localparam v14_u0_B = 256'h08c1081f18de304928b5101a06c0301320bd269a309b2600000026de26b22092;
localparam v14_u0_C = 256'h404f00fe0882002630e62cc220a52c6208cb1847106f10e1268a26ca30e94888;
localparam v14_u0_D = 256'hb0d5b0f430e53049269200910042301330a100fe20b42692301e090630c92637;
localparam v14_u0_E = 256'h26de00fe00e000111056202220c608e2301e26de26b0101a011a21e8081d00ca;
localparam v14_u0_F = 256'h00c70046007e3049306b264526d9301330ab26fa30db200000dd00e6301e0972;
localparam v14_u1_0 = 256'h10ba03b203b203bbb0ba23ab017b23ab017b01bb00b110ba00b2837b02fb036b;
localparam v14_u1_1 = 256'h32ba02b310ba82f980b910ba32ba33baab7b2b71233b00bb03fb003003bb03fb;
localparam v14_u1_2 = 256'h10ba23fa029b03b0003aa3ab03bba3ab003b23ba00b103c800b202bb10bab36b;
localparam v14_u1_3 = 256'h03c803c8129b31ba80b9129b10ba33ba343a12db12db2b793cb830ba03fb10ba;
localparam v14_u1_4 = 256'h02bb0030339a03b20eb983bb00bb83bb3eba36b802bb03fb0039029b033b837b;
localparam v14_u1_5 = 256'h3eb902fb32db31ba80b932db33fa02fb023b023b3eba029b3eb902fb3eb912fa;
localparam v14_u1_6 = 256'h003b33b9339a03b20b3b32ba02bb10ba3cb80fb900b203fb02fb02db21ba03fb;
localparam v14_u1_7 = 256'h3eb8343a3a7831ba80b90b3902bb303a36b800bb00b002fa3f3a01bb3eba029b;
localparam v14_u1_8 = 256'h02bb003002db03f210ba02f210ba03f0373810b002fb03fb02bb23ba36b8036b;
localparam v14_u1_9 = 256'h07392338033a033a073b3a70003033ba3cb832db02f33a7836fa367838b03d3a;
localparam v14_u1_A = 256'h003b03b0039203b036ba02f23a7802bb003b82f901bb03c810ba02bb02b3b36b;
localparam v14_u1_B = 256'h02fb02fb037931ba32db01fb033b33ba033302b3003a67fb0000237102b338b0;
localparam v14_u1_C = 256'h01b2003002db03f23d3a033b01b3033b343a36bb003b23fa02fb02db32ba03bb;
localparam v14_u1_D = 256'h2afa28fa3eba31ba383802b203f233ba3eba00302c7e38b83eba029b21ba00bb;
localparam v14_u1_E = 256'h2b710030039203f201fb033b033303bb3eba237102b303fb02f2029b003b32fa;
localparam v14_u1_F = 256'h00b200b000b231ba003a02bb23ba33ba3cba00333eba6fff003100b23eba029b;
localparam v14_u2_0 = 256'h00000080088000800001040000800400008000800080040000800590008a0580;
localparam v14_u2_1 = 256'h00000c8000000080008100000400000005010102000004800080008000800080;
localparam v14_u2_2 = 256'h0000080000800080048004000080040004800000008000800080008000000500;
localparam v14_u2_3 = 256'h0080008000040000008100000800000000000004000001020400040000800000;
localparam v14_u2_4 = 256'h0480008000000080002007810480078100000000048000800080008004800581;
localparam v14_u2_5 = 256'h0000008a000400000081000000000c8000800080000000840000008a00000042;
localparam v14_u2_6 = 256'h0480000000000080038000000080000000000000008000801480048000000880;
localparam v14_u2_7 = 256'h0000000000300000008100000c80000004000080008000ca0000008000000084;
localparam v14_u2_8 = 256'h00800080188000800c000c800000188000002c00008a00800480000000000580;
localparam v14_u2_9 = 256'h00000000188018800380043000800000000000000c800030000000000c300030;
localparam v14_u2_A = 256'h048000800880008000000880043018800480008104800080000000800c800500;
localparam v14_u2_B = 256'h0082008201820000000400800080000004800c800080040000000d020c800430;
localparam v14_u2_C = 256'h0080008018800080003008800480088000000000008000001480048000000080;
localparam v14_u2_D = 256'h004a000000000000040000800880000000000080040004300000008400000480;
localparam v14_u2_E = 256'h0d02008008800080008000800480088000000d020c8000800c80008000800000;
localparam v14_u2_F = 256'h0080008000800000008004800400000000000c80000004000080008000000084;
/*
 * =================================================
 * * Version 15. RVC MULDIV MINSTRET EBR_MINSTRET  *
 * =================================================
 *                             Microcode instruction
 * uPC           next uPC      444444333333333322222222221111111111
 * || label      || next label 54321098765432109876543210987654321098 Purpose                                                  Simulated entrypoint
 * -- ---------- -- ---------- -------------------------------------- -------------------------------------------------------- -----------
 * 00 LB_0       01 LB_1       00010110000000000000110110101100100000 LB     Load byte. q = rdadr=RS1+0fs                      00000003 lb      
 * 01 LB_1       d2 LB_2       00000010001010000000101111101100001001        Read until q=mem[rs1+ofs) & ~3u]                  00000000 
 * 02 IJ_0       be IJ_1       00010110010000100000110111101100100000 IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0               0000000b ij       
 * 03 _L0x03     e6 StdIncPc   00000010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000000f fence   
 * 04 ADDI_0     e6 StdIncPc   00010000000000000100001011101000100000 ADDI   Add immediate. rd =RS1+Iimm (or joined)           00000013 addi    
 * 05 _L0x05     04 ADDI_0     00000010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00000017 auipc   
 * 06 LB_3       07 LB_4       00000010000000000000011011101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * 07 LB_4       09 LB_5       00000010000000000000010111101100011000        q = (uint8_t) mem[rs1+Iimm]                       00000000 
 * 08 _L0x08     5a SB_1       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    00000023 sb      
 * 09 LB_5       8b LB_6       00000010000000000000010111101100000000        q = D^0xffffffff^q = D^0x80                       00000000 
 * 0a _L0x0a     5a SB_1       00010000000000001000111010101100100000 SB     Store byte. wjj=wradr=RS1+Simm                    40000023 sb      
 * 0b JALR_2     86 JAL_2      00000000000001101100001011101000011000        Q = (RS1+imn) & 0xfffffffe                        00000000 
 * 0c ADD_0      04 ADDI_0     00000010000000000000111011101100001000 ADD    add     Addition Q = RS1                          00000033 add 
 * 0d MUL_0      e2 MUL_1      00100010000000000000111011001000000000 MUL    Store rs1 tp rM. Next read rs2. Q clear           00000037 lui     
 * 0e SUB_0      10 SUB_1      00000010000000000000111011001000000000 SUB    Subtraction                                       40000033 sub 
 * 0f _L0x0f     e6 StdIncPc   00000000000000000100001011101000110000 LUI    q = imm20                                         40000037 lui     
 * 10 SUB_1      8b LB_6       00000010000000000000111111101100000000        Q = ~RS2                                          00000000 
 * 11 AND_1      1a ANDI_1     00000010000000000000111011101100000000        RS1^0xffffffff to Q                               00000000 
 * 12 _L0x12     fe ILLe       00000010000000000000000011000000000000  Not in use (illegal as entry)                           00000000 
 * 13 condb_2    14 condb_3    00000010000000000000111111101100000000        ~RS2 in Q                                         00000000 
 * 14 condb_3    15 condb_4    00010010000000000000001011101100100110        Calculate RS1+~RS2+1                              00000000 
 * 15 condb_4    16 condb_5    00000000000000001000110011101101001000        Branch on condition                               00000000 
 * 16 condb_5    de Fetch      00000100000010001010110111000100110110        Branch not taken.                                 00000000 
 * 17 condb_5t   74 BrOpFet    00010100000001101010110111101100100000        Branch taken.                                     00000000 
 * 18 BEQ        13 condb_2    00000000000000001100111011101000110000 BEQ    Conditional Branch. Offset to Ryy                 00000063 beq     
 * 19 JALR_0     41 JALR_1     00010000000000001100101011101000100000 JALR   yy=RS1+imm                                        00000067 jalr    
 * 1a ANDI_1     e6 StdIncPc   00000000000000000100001011101000011000        rd = Iimm & RS1                                   00000000 
 * 1b _L0x1b     32 JAL_1      00000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000006f jal     
 * 1c ECAL_BRK   a6 ECAL_RET   00000010000000100000101111100100110000 ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI      00000073 ecall/ebreak/mret/wfi
 * 1d ORI_2      e6 StdIncPc   00000000000000000100001011101000111000        rd = Iimm | RS1                                   00000000 
 * 1e aFault_1   d4 aFault_2   00110010000000000000101011001100100110        Q = 4                                             00000000 
 * 1f IJ_2       b7 IJ_3       00000000000000001100101011101000110000        Read word is to be masked with 2 lsb = 00         00000000 
 * 20 LH_0       52 LH_1       00010100000000101100110110101100100000 LH     Load hword. Q = rdadr=RS1+Iimm.                   00001003 lh      
 * 21 XORI_1     e6 StdIncPc   00000000000000000100001011101000000000        rd = Iimm ^ RS1                                   00000000 
 * 22 MULHU_6    39 MULHU_7    00000010000000000000101011101100100001        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar      0000100b close to ij
 * 23 _L0x23     e6 StdIncPc   00000010000000000000001011001000000000 FENCE  Prepare read PC (FENCE/FENCE.I)                   0000100f fence.i 
 * 24 SLLI_0     35 SLLI_1     00000010000000000000111100100000110000 SLLI   Shift left immediate.                             00001013 slli    
 * 25 _L0x25     04 ADDI_0     00000010000000000000001011000100000000 AUIPC  q = imm20 (copy x/2)                              00001017 auipc   
 * 26 OR_1       27 OR_2       00000000000000001000111011101000000000        RS1^0xffffffff to jj                              00000000 
 * 27 OR_2       1d ORI_2      00010010000000000000000011101100100000        Q = rs2                                           00000000 
 * 28 _L0x28     96 SH_1       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                00001023 sh      
 * 29 XOR_1      21 XORI_1     00000010000000000000111011101100000000        Q = RS1^0xFFFFFFFF                                00000000 
 * 2a _L0x2a     96 SH_1       00010000000000101000111010101100100000 SH     Store halfword. jjw=wradr=RS1+Simm                40001023 sh      
 * 2b SLTIX_1    30 SLTIX_2    00010010000000000000000011101000100110        RS1 - imm / RS1 - RS2                             00000000 
 * 2c SLL_0      3e SLL_1      00000010000000000000111011000000000000 SLL    Shift left                                        00001033 sll     
 * 2d MULH_0     6a MULH_1     00000010000000000000101001101100001000 MULH   Store rs1 to Q. Prep read 0, shcnt--              00001037 lui     
 * 2e MULHU_1    42 MULHU_2    00100000000000001000111111101000110000        rM<=RS2,  Rjj<=Q=0. next read RS1.                40001033 sloppy sll     
 * 2f _L0x2f     e6 StdIncPc   00000000000000000100001011101000110000 LUI    q = imm20                                         40001037 lui     
 * 30 SLTIX_2    e6 StdIncPc   00000000000000000100001011101000110010        Registered ALU flag to rd                         00000000 
 * 31 SLTX_1     2b SLTIX_1    00000010000000000000111111101100000000        ~rs2 to Q                                         00000000 
 * 32 JAL_1      86 JAL_2      00010000000000001100001011101000100000        Target adr to yy                                  00000000 
 * 33 JAERR_1    81 JAERR_2    00010000000000001111001011100000100000  Err   JAL target adr misaligned, store to mtval         00000000 
 * 34 JAL_3      de Fetch      00000100000010001010110111100100001000        PC+imm/trap entrypt to PC. OpFetch                00000000 
 * 35 SLLI_1     36 SLLI_2     00000000000000000100101101101100001000        Register to shift to Q (and TRG for shift 0)      00000000 
 * 36 SLLI_2     03 _L0x03     00000000000100000100101101101100101000        Repeat Q = Q+Q until shregcnt == 0                00000000 
 * 37 ECALL_2    d7 ECALL_3    00000000000000001101000011101001001000        mepc = pc, prep store 0 to mtval                  00000000 
 * 38 BNE        13 condb_2    00000000000000001100111011101000110000 BNE    Conditional Branch. Offset to Ryy                 00001063 bne     
 * 39 MULHU_7    e6 StdIncPc   00100000000000000100001011101000001000        Last shift.                                       00001067 close to jalr
 * 3a SRxI_1     3d SRxI_2     00000000000000000100101001101100001001        Register to shift to Q                            00000000 
 * 3b _L0x3b     32 JAL_1      00000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000106f jal     
 * 3c CSRRW_0    49 CSRRW_1    00000000000000001100011011101000110000 CSRRW  Decoded CSR adr in yy                             00001073 csrrw
 * 3d SRxI_2     03 _L0x03     00000000000100000100101001101100001001        Repeat Q >>= 1 until shregcnt == 0                00000000 
 * 3e SLL_1      35 SLLI_1     00000010000000000000111100100000001000        Shiftamount was in low 5 bits of RS2              00000000 
 * 3f SRx_1      3a SRxI_1     00000010000000000000111100100000001000        Shiftamount in low 5 bits of RS2                  00000000 
 * 40 LW_0       50 LW_1       00010110000001100000110111101100100000 LW     Load word. Q=yy=rdadr=RS1+Iimm                    00002003 lw      
 * 41 JALR_1     0b JALR_2     00010010000000000000110011101100100110        Q=1                                               00000000 
 * 42 MULHU_2    60 MULHU_3    00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar           0000200b close to ij
 * 43 MULHU_4    ea MULHU_5    00000010000000000000000011100100000000        Prepare read Rjj.                                 0000200f close to fence
 * 44 SLTI_0     2b SLTIX_1    00000010000000000000111111101100010000 SLTI   Set less than immediate (signed)                  00002013 slti    
 * 45 WFI_3      65 WFI_4      00010010000000000000101011101100100110        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105        00000000 
 * 46 ILL_1      47 ILL_2      00000000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 47 ILL_2      8f ILL_3      00000000000000001111101011101000001000        Store 0 to mtval                                  00000000 
 * 48 _L0x48     66 SW_1       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      00002023 sw      
 * 49 CSRRW_1    4b CSRRW_2    00010010000000000000001011101100100110        Construct PC storage adr                          00000000 
 * 4a _L0x4a     66 SW_1       00011110000001100000111011101100100000 SW     Store word. Q=wradr=RS1+Simm                      40002023 sw      
 * 4b CSRRW_2    b1 CSRRW_3    00000000100000000011101011100100001000        Write PC to 0x100 start Prep emulation entrypt    00000000 
 * 4c SLT_0      31 SLTX_1     00000010000000000000111011001000000000 SLT    Set less than (signed)                            00002033 slt     
 * 4d MULHSU_0   2e MULHU_1    00000000000000001100111001101000001000 MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--       00000000 
 * 4e eILL0b     fe ILLe       00000010000000000000000011000000000000 Illegal instruction seen                                 40002033 sloppy slt     
 * 4f MRET_8     e6 StdIncPc   00010010000000000000101011101100100110        Prep +4                                           00000000 
 * 50 LW_1       e6 StdIncPc   00000001000010000100101111101000001000        Read until d=mem[(rs1+ofs) & ~3u]                 00000000 
 * 51 LDAF_LW    da LDAF_a     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 52 LH_1       54 LH_2       00000010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 53 LDAF_LH    da LDAF_a     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 54 LH_2       eb LH_3       00000010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 55 aFaultb    1e aFault_1   00000000000000001111101011101000110000  err   LH Load access fault. Faulting adr to mtval       00000000 
 * 56 LH_4       57 LH_5       00000010000000000000100011101100011000        q = (uint16_t) mem[rs1+Iimm]                      00000000 
 * 57 LH_5       8b LB_6       00000010000000000000100011101100000000        q = D^0xffffffff^q = D ^ 0x00008000               00000000 
 * 58 DIV_A      6e DIV_C      00110010000000000000101111101100001001        Transfer rM to rDee                               00002063 close to branch
 * 59 DIV_B      9c DIV_10     00000000000000001100111111101000110000        REM = Q to yy                                     00002067 close to jalr
 * 5a SB_1       5d SB_2       00000000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 5b _L0x5b     32 JAL_1      00000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000206f jal     
 * 5c CSRRS_0    49 CSRRW_1    00000000000000001100011011101000110000 CSRRS  Decoded CSR adr in yy                             00002073 csrrs
 * 5d SB_2       fb SB_3       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8,16 or 24 times)   00000000 
 * 5e LHU_1      70 LHU_2      00000010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 5f LDAF_LHU   da LDAF_a     00000000000000001111101011100100110000  err   LD AlignFault. Faulting adr to mtval              00000000 
 * 60 MULHU_3    42 MULHU_2    00100010000000000000111111101100001000        Shift Q and rM. Prepare read rs1                  00003003 close to load
 * 61 EBRKWFI2   f7 EBREAK_1   00000000000000001000011011101001010000 EBREAK/WFI2 Select EBREAK or WFI                         00000000 
 * 62 DIV_8      c8 DIV_7      00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000300b close to ij
 * 63 DIV_9      58 DIV_A      01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000300f close to fence
 * 64 SLTIU_0    2b SLTIX_1    00000010000000000000111111101100010000 SLTIU  Set less than immediate (unsigned)                00003013 sltiu   
 * 65 WFI_4      ef WFI_5      00000010000000000000001011001001000000        Prepare read PC                                   00000000 
 * 66 SW_1       f2 SW_2       00000000000000000011111011100100001000        Write d to a+k until accepted                     00000000 
 * 67 SW_E1SWE   93 SW_E2      00000000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 68 DIV_12     e6 StdIncPc   00000000000000000100001011101000001000        RS2 > 0, RS1 >= 0, yy is true result              00003023 close to store
 * 69 DIV_13     8b LB_6       00000010000000000000101011101100000000        RS2 > 0, RS1 < 0, change sign yy                  00000000 
 * 6a MULH_1     f9 MULH_2     00000000000000001100101011101000000000        Store ~rs1 to Ryy. Prep construct 1.              40003023 close to store
 * 6b SB_4       7a SB_5       00001110000000000010110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 6c SLTU_0     31 SLTX_1     00000010000000000000111011001000000000 SLTU   Set less than (unsigned)                          00003033 sltu    
 * 6d MULHU_0    2e MULHU_1    00000000000000001100111001101000001000 MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--     00000000 
 * 6e DIV_C      b9 DIV_e      00000000000000001100111011100100001000        rM to yy. Q=ffffffff                              40003033 sloppy sltu    
 * 6f MRET_6     cf MRET_7     00010010000000000000000011101100100110        ~302 + origImm + 1 for branch decision            00000000 
 * 70 LHU_2      ba LHU_3      00000010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * 71 aFaultc    1e aFault_1   00000000000000001111101011101000110000  err   LHU Load access fault. Faulting adr to mtval      00000000 
 * 72 LBU_3      1a ANDI_1     00000010000000000000011011101100010000        Invert q. Prepare read mask                       00000000 
 * 73 BAERR_1    76 BAERR_2    00000000000000001111110011101000001000        Faultadr to mtval. Prepare get offset             00000000 
 * 74 BrOpFet    f4 Fetch2     00000011001010000000101111101010110000 NewOp2 Read until instruction latched                    00000000 
 * 75 BAlignEr   73 BAERR_1    00000010000000000000001011000000000000  Err   Branch target instruction address misaligned      00000000 
 * 76 BAERR_2    77 BAERR_3    00000010000000000000001011101100000000        ~offset to Q. Prep read (origPC+offset)           00000000 
 * 77 BAERR_3    7d BAERR_4    00010000000000001101101011100000100110        origPC to mepc. Prep read 0                       00000000 
 * 78 DIV_4      aa DIV_6      00000000000000001100000011101000110000        ~abs(divisor) to yy                               00003063 close to branch
 * 79 DIV_5      a8 DIV_3      00110010000000000000101011101100100110        Kluge to let add1 work in DIV instr               00003067 close to jalr
 * 7a SB_5       f2 SW_2       00000000000000000010110011100100001000        Write d to a+k until accepted                     00000000 
 * 7b _L0x7b     32 JAL_1      00000010000001100000001011100100110000 JAL    J-imm is in q. Branch on alignfault               0000306f jal     
 * 7c CSRRC_0    49 CSRRW_1    00000000000000001100011011101000110000 CSRRC  Decoded CSR adr in yy                             00003073 csrrc
 * 7d BAERR_4    34 JAL_3      00000000110000001110100111100000001000        Store 0 to mcause. Prep get trap entry pont       00000000 
 * 7e NMI_1      90 NMI_2      00000000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * 7f JALRE2     7d BAERR_4    00000000000000001111101011100000001000        mtval is target                                   00000000 
 * 80 LBU_0      85 LBU_1      00010110000000000000110110101100100000 LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.           00004003 lbu     
 * 81 JAERR_2    7d BAERR_4    00000000000000001101101011100000001000        Store PC to mepc                                  00000000 
 * 82 DIV_1      a8 DIV_3      00000000000000001000111011101000000000        jj=abs(RS1). Next handle divisor                  0000400b close to ij
 * 83 DIV_2      82 DIV_1      00010010000000000000101011101100100000        Dividend negative, make RS1-1                     0000400f close to fence
 * 84 XORI_0     21 XORI_1     00000010000000000000111111101100010000 XORI   Xor immediate. Q=~Iimm                            00004013 xori    
 * 85 LBU_1      f0 LBU_2      00000010001010000000101111101100001001        Read until q=mem[(rs1+ofs) & ~3u]                 00000000 
 * 86 JAL_2      9e JAL_25     10110000000000000100001011000000100110        Return address to TRG                             00000000 
 * 87 JALRE1     7f JALRE2     00000000000000001101110011100000001000  err   Store pc to mepc                                  00000000 
 * 88 DIV_E      9c DIV_10     01100010000000000000111111000000000000        RS2 != 0. Check signs                             00004023 close to store
 * 89 DIV_F      e6 StdIncPc   00000000000000000100001011101000110000        RS2 == 0, return 0xffffffff                       00000000 
 * 8a DIVU_5     1a ANDI_1     00110010000000000000101111001000000001        Transfer rM to rDee                               40004023 close to store
 * 8b LB_6       e6 StdIncPc   00110000000000000100001011101000100110        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80          00000000 
 * 8c XOR_0      29 XOR_1      00000010000000000000111111001000000000 XOR    xor                                               00004033 xor     
 * 8d DIV_0      82 DIV_1      01100010000000000000101101101100001000 DIV    Branch on sign dividend RS1                       00000000 
 * 8e _LCSRRS_1  fe ILLe       00000010000000000000000011000000000000 Illegal instruction seen                                 40004033 sloppy xor     
 * 8f ILL_3      a9 ILL_4      00000010000000000000101011101100100110        Q = 1                                             00000000 
 * 90 NMI_2      34 JAL_3      00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * 91 LDAF_2     92 LDAF_3     00110000110000001110001011000000100110        Store 4 to mcause                                 00000000 
 * 92 LDAF_3     34 JAL_3      00000000000000001101100111100000001000        PC to mepc                                        00000000 
 * 93 SW_E2      95 SW_E3      00000000000000001101101111101000001000        Store address that faulted                        00000000 
 * 94 SW_E4      34 JAL_3      00000000110000001110100111100000101000        Store 6 to mcause                                 00000000 
 * 95 SW_E3      94 SW_E4      00110010000000000000101111001100100110        Q = 3                                             00000000 
 * 96 SH_1       bb SH_2       00000000000000001100101101101100001000        Write d to Q and yy (for sh 0). Prep shift        00000000 
 * 97 SW_E1SWH   93 SW_E2      00000000000000001111001011100000110000        Store faulting address alignment to mtval         00000000 
 * 98 BLT        13 condb_2    00000000000000001100111011101000110000 BLT    Conditional Branch. Offset to Ryy                 00004063 blt     
 * 99 _L0x99     fe ILLe       00000010000000000000000011000000000000  Not in use (illegal as entry)                           00004067 close to jalr
 * 9a ECALL_6    34 JAL_3      00010000110000001110100111000000100000        mcause = 11                                       00000000 
 * 9b SH_4       9f SH_5       00001110000000000001110011101100001000        Address back to Q. Prepare get item to write      00000000 
 * 9c DIV_10     68 DIV_12     01100010000000000000110011101000001000        RS2 > 0. Branch on sign of RS1                    00004073 close to csr/system 
 * 9d DIV_11     a2 DIV_14     01100010000000000000110011101000001000        RS2 < 0. Branch on sign of RS1                    00000000 
 * 9e JAL_25     34 JAL_3      00000000000000001000110011100000001000        Instr. adr. to jj in case of access error         00000000 
 * 9f SH_5       f2 SW_2       00000000000000000001110011100100001000        Write d to a+k until accepted                     00000000 
 * a0 LHU_0      5e LHU_1      00010100000000101100110110101100100000 LHU    Load unsigned hword. Q = rdadr=RS1+Iimm           00005003 lhu     
 * a1 ECALL_4    b6 ECALL_5    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * a2 DIV_14     8b LB_6       00000010000000000000101011101100000000        RS2 < 0, RS1 >= 0, change sign yy                 0000500b close to ij
 * a3 DIV_15     e6 StdIncPc   00000000000000000100001011101000001000        RS2 < 0, RS1 < 0, yy is true result               0000500f close to fence
 * a4 SRxI_0     3a SRxI_1     00000010000000000000111100100000110000 SRxI   Shift Right immediate (both logic/arith here)     00005013 sr(l/a)i
 * a5 MRET_3     af MRET_4     00010010000000000000011011101100100110        0x102 + 0xff + 1 = 0x202                          00000000 
 * a6 ECAL_RET   d0 ECALL_1    00000010000001100000101111100100110000 ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET              00000000 
 * a7 EBRKWFI1   61 EBRKWFI2   00010010000000000000000011101100100000 EBREAK/WFI1 Prepare select EBREAK or WFI                 00000000 
 * a8 DIV_3      78 DIV_4      01100010000000000000101011101100000000        Branch on sign divisor RS2                        00005023 close to store
 * a9 ILL_4      34 JAL_3      00010000110000001110100111100000100110        Store 2 to mcause                                 00000000 
 * aa DIV_6      c8 DIV_7      00100010000000000000101111001000000000        Write M. Prepare shift                            40005023 close to store
 * ab EBREAK_2   9a ECALL_6    00000000000000001101101011101000001000        pc to mepc                                        00000000 
 * ac _L0xac     3f SRx_1      00000010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    00005033 srl     
 * ad DIVU_0     e0 DIVU_1     00100010000000000000111001001000000000 DIVU   Store rs1 to rM. Q=0. Prepare invert rs2          00000000 
 * ae _L0xae     3f SRx_1      00000010000000000000111011000000000000 SRx    Shift Right (both SRL and SRA)                    40005033 sra
 * af MRET_4     c5 MRET_5     00010010000000000000000011101100100110        0x202 + 0xff + 1 = 0x302                          00000000 
 * b0 aF_SW_3    92 LDAF_3     00010000110000001110001011000000100000        Store 7 to mcause                                 00000000 
 * b1 CSRRW_3    b2 CSRRW_4    00110010000000000000101011001100100110        Prep emulation entrypt 0x108, here Q to 0x104     00000000 
 * b2 CSRRW_4    de Fetch      00110100000010001000110111000100100110        IncPC, OpFetch, but force +4                      00000000 
 * b3 unxb3         (use dinx) 00000000000000000000000000000000000000 b3: Not in use                                           00000000 
 * b4 eFetch3       (use dinx) 00010000000000011001111111101100100110  Fr11  Write minstret. Update I. Q=immediate, use dinx   00000000 
 * b5 SH_3       9b SH_4       00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * b6 ECALL_5    9a ECALL_6    00110010000000000000101011001100100110        Q = 8                                             00000000 
 * b7 IJ_3       bd IJ_4       00010010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * b8 BGE        13 condb_2    00000000000000001100111011101000110000 BGE    Conditional Branch. Offset to Ryy                 00005063 bge     
 * b9 DIV_e      c0 DIV_D      00000010000000000000110011101100000110        Calc carry of RS2+0xFFFFFFFF                      00005067 close to jalr
 * ba LHU_3      1a ANDI_1     00000010000000000000011111101100010000        Invert q. Prepare read mask                       00000000 
 * bb SH_2       b5 SH_3       00000000000100001100101101101100101000        Repeat shl until shreg = 0 (0,8 or 24 times)      00000000 
 * bc CSRRWI_0   49 CSRRW_1    00000000000000001100011011101000110000 CSRRWI Decoded CSR adr in yy                             00005073 csrrwi
 * bd IJ_4       de Fetch      00000110000010000000110111100100011000        Mask and use as PC                                00000000 
 * be IJ_1       1f IJ_2       00000010000010000000101111101100001000        Read until q=mem[(rs1+ofs)&~3u]                   00000000 
 * bf IJT_1      c1 IJT_2      00000010000010000000101111101100001000        Exit CSR, enter trap                              00000000 
 * c0 DIV_D      88 DIV_E      00000010000000000000111011101101001000        Is RS2 == 0?                                      00006003 close to load
 * c1 IJT_2      e9 IJT_3      00000000000000001100101011101000110000        Read word is to be masked with ~3u                00000000 
 * c2 DIVU_3     ca DIVU_2     00010010000000000000101101101100100110        Conditionally subtract rs2. Update M[0]           0000600b close to ij
 * c3 DIVU_4     8a DIVU_5     01010010000000000000101111101100100110        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]    0000600f close to fence
 * c4 ORI_0      e1 ORI_1      00000000000000001000111111101000010000 ORI    Or immediate. jj=~Iimm                            00006013 ori     
 * c5 MRET_5     6f MRET_6     00000010000000000000000011101100010000        ~302                                              00000000 
 * c6 IJT_4      47 ILL_2      00000000000000001101101011101100011000        Mask and store to mepc and Q for read of instr    00000000 
 * c7 QINT_1     cb QINT_2     00000000000000001101000011101000001000        Store pc to mepc.                                 00000000 
 * c8 DIV_7      62 DIV_8      00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            00006023 close to store
 * c9 MRET_2     a5 MRET_3     00010010000000000000011011001100100000        0xff+3 = 0x102                                    00000000 
 * ca DIVU_2     c2 DIVU_3     00100010000000000000110011101100101100        Shift (Q,M) left. Prepare unsigned sub            40006023 close to store
 * cb QINT_2     e6 StdIncPc   00000000110000001111010011101000110000        mtval = 0.                                        00000000 
 * cc OR_0       26 OR_1       00000010000000000000111111001000000000 OR     or                                                00006033 or      
 * cd REM_0      82 DIV_1      01100010000000000000101101101100001000 REM    Branch on sign dividend RS1                       00000000 
 * ce _LCSRRCI_1 fe ILLe       00000010000000000000000011000000000000 Illegal instruction seen                                 40006033 sloppy or      
 * cf MRET_7     4f MRET_8     00000010000000000000011011001001000000        Prepare emulation entry point 0x104               00000000 
 * d0 ECALL_1    37 ECALL_2    00010010000000000000001011101100100110 ECALL  Verify Imm==0x000                                 00000000 
 * d1 MRET_1     c9 MRET_2     00000000000000001000011011101000110000 MRET   First save Imm, start build constant for check    00000000 
 * d2 LB_2       06 LB_3       00000010000100000000101001101100001001        Repeat shr until shreg == 0 (0,8,16,24 times)     00000000 
 * d3 aFaultd    1e aFault_1   00000000000000001111101011101000110000  err   LB Load access fault. Faulting adr to mtval       00000000 
 * d4 aFault_2   92 LDAF_3     00010000110000001110001011100000100110        Store 5 to mcause                                 00000000 
 * d5 unxd5         (use dinx) 00000000000000000000000000000000000000 d5: Not in use                                           00000000 
 * d6 eILL0c     fe ILLe       00000010000000000000000011000000000000 Illegal instruction seen                                 00000000 
 * d7 ECALL_3    a1 ECALL_4    00000000000000001111101011101000110000        mtval = 0, now start the chore of 11 to mcause    00000000 
 * d8 BLTU       13 condb_2    00000000000000001100111011101000110000 BLTU   Conditional Branch. Offset to Ryy                 00006063 bltu    
 * d9 MULH_3     42 MULHU_2    00100010000000000000111111001000000000        rM<=RS2, Q = 0. next read RS1. Join.              00006067 close to jalr
 * da LDAF_a     91 LDAF_2     00000010000000000000101011001000000000        Extra cycle after error detected write mtval      00000000 
 * db jFault_1   92 LDAF_3     00010000000000001110000011100000100110        Store 1 to mcause                                 00000000 
 * dc CSRRSI_0   49 CSRRW_1    00000000000000001100011011101000110000 CSRRSI Decoded CSR adr in yy                             00006073 csrrsi
 * dd aF_SW_1    e5 aF_SW_2    00000000000000001111101011101000110000  err   SW Store access fault. Faulting adr to mtval      00000000 
 * de Fetch      f4 Fetch2     00000001001010001010101111101010110000  Fr11  Read and latch instruction                        00000000 
 * df eFetch     f4 Fetch2     00000001001010001010101111101010110000  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]             00000000 
 * e0 DIVU_1     ca DIVU_2     00000000000000001100101111101000000000        Store inverted rs2 to yy. Prepare shift           00007003 close to load
 * e1 ORI_1      1d ORI_2      00000010000000000000000011101100001000        Q = RS1                                           00000000 
 * e2 MUL_1      e8 MUL_2      00000010000000000000101001101100100001        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar           0000700b close to ij
 * e3 MUL_3      1a ANDI_1     00110010000000000000101111001000000001        Transfer rM to rDee                               0000700f close to fence
 * e4 ANDI_0     1a ANDI_1     00000010000000000000111111101100010000 ANDI   And immediate. Q=~Iimm                            00007013 andi    
 * e5 aF_SW_2    b0 aF_SW_3    00110010000000000000101011001100100110        Q = 4                                             00000000 
 * e6 StdIncPc   de Fetch      00110100000010001000110111000100100110  Fr11  IncPC, OpFetch                                    00000000 
 * e7 aFault     1e aFault_1   00000000000000001111101011101000110000  err   Load access fault. Faulting adr to mtval          00000000 
 * e8 MUL_2      e2 MUL_1      00100010000000000000111011101100001000        Shift Q and rM. Prepare read rs2                  00007023 close to store
 * e9 IJT_3      c6 IJT_4      00010010000000000000110011001100100000        Construct Q = 3                                   00000000 
 * ea MULHU_5    22 MULHU_6    00000010000000000000110011101100100000        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy          40007023 close to store
 * eb LH_3       56 LH_4       00000010000000000000011111101100010000        q = ~mem[rs1+ofs]                                 00000000 
 * ec AND_0      11 AND_1      00000010000000000000111111001000000000 AND    And                                               00007033 and     
 * ed REMU_0     e0 DIVU_1     00100010000000000000111001001000000000 REMU   Store dividend to rM. Prepare read divisor.Q=0    00000000 
 * ee eILL0a     fe ILLe       00000010000000000000000011000000000000 Illegal instruction seen                                 40007033 sloppy and     
 * ef WFI_5      de Fetch      00110100000010001010110111000100100110        IncPC, OpFetch                                    00000000 
 * f0 LBU_2      72 LBU_3      00000010000100000000101001101100001001        Repeat shr until shreg = 0 (0, 8 or 16 times)     00000000 
 * f1 aFaulte    1e aFault_1   00000000000000001111101011101000110000  err   LBU Load access fault. Faulting adr to mtval      00000000 
 * f2 SW_2       e6 StdIncPc   00000010000000000000001011001000000000        Prepare read PC                                   00000000 
 * f3 aF_SW      dd aF_SW_1    00000010000000000000000011000100000000  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf     00000000 
 * f4 Fetch2     b4 eFetch3    00010000000000001011000111111000100000  Fr11  Update ttime. Update I. Q=immediate. Use dinx     00000000 
 * f5 jFault     db jFault_1   00000000000000001111101011101000110000  err   Fetch access fault. Faulting adr to mtval         00000000 
 * f6 WFI_1      fa WFI_2      00110010000000000000000011001100100110 WFI    Chk offset=0x105. Now=0xff. Prep 0xff+4 = 0x103   00000000 
 * f7 EBREAK_1   ab EBREAK_2   00000000000000001111001011101000110000 EBREAK mepc = pc, store 0 to mtval                       00000000 
 * f8 BGEU       13 condb_2    00000000000000001100111011101000110000 BGEU   Conditional Branch. Offset to Ryy                 00007063 bgeu    
 * f9 MULH_2     d9 MULH_3     00010000000000001000111011101000100110        Store 1 to Rjj. next read rs2, Q=0                00007067 close to jalr
 * fa WFI_2      45 WFI_3      00010010000000000000101011101100100110        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104   00000000 
 * fb SB_3       6b SB_4       00000010000000000000000011101000110000        Prepare get back address to use                   00000000 
 * fc CSRRCI_0   49 CSRRW_1    00000000000000001100011011101000110000 CSRRCI Decoded CSR adr in yy                             00007073 csrrci
 * fd NMI_0      7e NMI_1      00000010000000000000001011001000000000 NMI    Get current PC                                    00000000 
 * fe ILLe       46 ILL_1      00000010000000000000001011000000000000 Illegal                                                  00000000 
 * ff QINT_0     c7 QINT_1     00000010000000000000001011001000000000 INT    Get current PC                                    00000000 
 */
localparam v15_u0_0 = 256'h30e6001000e208041886205a008b205a18091007000420e600e620be09d22001;
localparam v15_u0_1 = 256'h30b726d438e630a6303218e620413013207436de48162615001400fe001a008b;
localparam v15_u0_2 = 256'h30e63042086a003e2630209600212096201d00270004303500e6213900e62052;
localparam v15_u0_3 = 256'h083a0835090330493032093d08e6301348d72803083608de20812086002b32e6;
localparam v15_u0_4 = 256'h26e600fe082e003108b12066264b2066088f08472665102b00ea2160260b2050;
localparam v15_u0_5 = 256'h30da097028fb30493032085d309c096e008b1857301e09eb30da095430da08e6;
localparam v15_u0_6 = 256'h26cf08b9082e0031087a00f9008b08e6309308f240ef102b265826c850f70842;
localparam v15_u0_7 = 256'h087d089008343049303208f226a830aa267d00770073b0f40876101a301e09ba;
localparam v15_u0_8 = 256'h26a900fe0882002926e6011a30e6009c087f269e09f01021208200a8087d2085;
localparam v15_u0_9 = 256'h08f2083408a20868089f203400fe3013309308bb269428340895083426923034;
localparam v15_u0_A = 256'h26c5003f00e0003f089a00c826340078206130d026af303a08e6008b26b6205e;
localparam v15_u0_B = 256'h08c1081f18de304928b5101a06c0301320bd269a309b2600000026de26b22092;
localparam v15_u0_C = 256'h404f00fe0882002630e62cc220a52c6208cb1847106f10e1268a26ca30e94888;
localparam v15_u0_D = 256'hb0f4b0f430e53049269200910042301330a100fe00002692301e090630c92637;
localparam v15_u0_E = 256'h26de00fe00e000111056202220c608e2301e26de26b0101a011a21e8081d00ca;
localparam v15_u0_F = 256'h00c70046007e3049306b264526d9301330ab26fa30db20b400dd00e6301e0972;
localparam v15_u1_0 = 256'h10ba03b203b203bbb0ba23ab017b23ab017b01bb00b110ba00b2837b02fb036b;
localparam v15_u1_1 = 256'h32ba02b310ba82f980b910ba32ba33baab7b2b71233b00bb03fb003003bb03fb;
localparam v15_u1_2 = 256'h10ba23fa029b03b0003aa3ab03bba3ab003b23ba00b103c800b202bb10bab36b;
localparam v15_u1_3 = 256'h03c803c8129b31ba80b9129b10ba33ba343a12db12db2b793cb830ba03fb10ba;
localparam v15_u1_4 = 256'h02bb0030339a03b20eb983bb00bb83bb3eba36b802bb03fb0039029b033b837b;
localparam v15_u1_5 = 256'h3eb902fb32db31ba80b932db33fa02fb023b023b3eba029b3eb902fb3eb912fa;
localparam v15_u1_6 = 256'h003b33b9339a03b20b3b32ba02bb10ba3cb80fb900b203fb02fb02db21ba03fb;
localparam v15_u1_7 = 256'h3eb8343a3a7831ba80b90b3902bb303a36b800bb00b002fa3f3a01bb3eba029b;
localparam v15_u1_8 = 256'h02bb003002db03f210ba02f210ba03f0373810b002fb03fb02bb23ba36b8036b;
localparam v15_u1_9 = 256'h07392338033a033a073b3a70003033ba3cb832db02f33a7836fa367838b03d3a;
localparam v15_u1_A = 256'h003b03b0039203b036ba02f23a7802bb003b82f901bb03c810ba02bb02b3b36b;
localparam v15_u1_B = 256'h02fb02fb037931ba32db01fb033b33ba033302b3003a67fb0000237102b338b0;
localparam v15_u1_C = 256'h01b2003002db03f23d3a033b01b3033b343a36bb003b23fa02fb02db32ba03bb;
localparam v15_u1_D = 256'h2afa2afa3eba31ba383802b203f233ba3eba0030000038b83eba029b21ba00bb;
localparam v15_u1_E = 256'h2b710030039203f201fb033b033303bb3eba237102b303fb02f2029b003b32fa;
localparam v15_u1_F = 256'h00b200b000b231ba003a02bb23ba33ba3cba00333eba2c7e003100b23eba029b;
localparam v15_u2_0 = 256'h00000080088000800001040000800400008000800080040000800590008a0580;
localparam v15_u2_1 = 256'h00000c8000000080008100000400000005010102000004800080008000800080;
localparam v15_u2_2 = 256'h0000080000800080048004000080040004800000008000800080008000000500;
localparam v15_u2_3 = 256'h0080008000040000008100000800000000000004000001020400040000800000;
localparam v15_u2_4 = 256'h0480008000000080002007810480078100000000048000800080008004800581;
localparam v15_u2_5 = 256'h0000008a000400000081000000000c8000800080000000840000008a00000042;
localparam v15_u2_6 = 256'h0480000000000080038000000080000000000000008000801480048000000880;
localparam v15_u2_7 = 256'h0000000000300000008100000c80000004000080008000ca0000008000000084;
localparam v15_u2_8 = 256'h00800080188000800c000c800000188000002c00008a00800480000000000580;
localparam v15_u2_9 = 256'h00000000188018800380043000800000000000000c800030000000000c300030;
localparam v15_u2_A = 256'h048000800880008000000880043018800480008104800080000000800c800500;
localparam v15_u2_B = 256'h0082008201820000000400800080000004800c800080040000000d020c800430;
localparam v15_u2_C = 256'h0080008018800080003008800480088000000000008000001480048000000080;
localparam v15_u2_D = 256'h004a004a00000000040000800880000000000080000004300000008400000480;
localparam v15_u2_E = 256'h0d02008008800080008000800480088000000d020c8000800c80008000800000;
localparam v15_u2_F = 256'h0080008000800000008004800400000000000c80000004000080008000000084;
localparam u0_0 = (UCODETYPE == 0) ? v0_u0_0 : (UCODETYPE == 2) ? v2_u0_0 : (UCODETYPE == 3) ? v3_u0_0 : (UCODETYPE == 4) ? v4_u0_0 : (UCODETYPE == 6) ? v6_u0_0 : (UCODETYPE == 7) ? v7_u0_0 : (UCODETYPE == 8) ? v8_u0_0 : (UCODETYPE == 10) ? v10_u0_0 : (UCODETYPE == 11) ? v11_u0_0 : (UCODETYPE == 12) ? v12_u0_0 : (UCODETYPE == 14) ? v14_u0_0 : (UCODETYPE == 15) ? v15_u0_0 : 0;
localparam u0_1 = (UCODETYPE == 0) ? v0_u0_1 : (UCODETYPE == 2) ? v2_u0_1 : (UCODETYPE == 3) ? v3_u0_1 : (UCODETYPE == 4) ? v4_u0_1 : (UCODETYPE == 6) ? v6_u0_1 : (UCODETYPE == 7) ? v7_u0_1 : (UCODETYPE == 8) ? v8_u0_1 : (UCODETYPE == 10) ? v10_u0_1 : (UCODETYPE == 11) ? v11_u0_1 : (UCODETYPE == 12) ? v12_u0_1 : (UCODETYPE == 14) ? v14_u0_1 : (UCODETYPE == 15) ? v15_u0_1 : 0;
localparam u0_2 = (UCODETYPE == 0) ? v0_u0_2 : (UCODETYPE == 2) ? v2_u0_2 : (UCODETYPE == 3) ? v3_u0_2 : (UCODETYPE == 4) ? v4_u0_2 : (UCODETYPE == 6) ? v6_u0_2 : (UCODETYPE == 7) ? v7_u0_2 : (UCODETYPE == 8) ? v8_u0_2 : (UCODETYPE == 10) ? v10_u0_2 : (UCODETYPE == 11) ? v11_u0_2 : (UCODETYPE == 12) ? v12_u0_2 : (UCODETYPE == 14) ? v14_u0_2 : (UCODETYPE == 15) ? v15_u0_2 : 0;
localparam u0_3 = (UCODETYPE == 0) ? v0_u0_3 : (UCODETYPE == 2) ? v2_u0_3 : (UCODETYPE == 3) ? v3_u0_3 : (UCODETYPE == 4) ? v4_u0_3 : (UCODETYPE == 6) ? v6_u0_3 : (UCODETYPE == 7) ? v7_u0_3 : (UCODETYPE == 8) ? v8_u0_3 : (UCODETYPE == 10) ? v10_u0_3 : (UCODETYPE == 11) ? v11_u0_3 : (UCODETYPE == 12) ? v12_u0_3 : (UCODETYPE == 14) ? v14_u0_3 : (UCODETYPE == 15) ? v15_u0_3 : 0;
localparam u0_4 = (UCODETYPE == 0) ? v0_u0_4 : (UCODETYPE == 2) ? v2_u0_4 : (UCODETYPE == 3) ? v3_u0_4 : (UCODETYPE == 4) ? v4_u0_4 : (UCODETYPE == 6) ? v6_u0_4 : (UCODETYPE == 7) ? v7_u0_4 : (UCODETYPE == 8) ? v8_u0_4 : (UCODETYPE == 10) ? v10_u0_4 : (UCODETYPE == 11) ? v11_u0_4 : (UCODETYPE == 12) ? v12_u0_4 : (UCODETYPE == 14) ? v14_u0_4 : (UCODETYPE == 15) ? v15_u0_4 : 0;
localparam u0_5 = (UCODETYPE == 0) ? v0_u0_5 : (UCODETYPE == 2) ? v2_u0_5 : (UCODETYPE == 3) ? v3_u0_5 : (UCODETYPE == 4) ? v4_u0_5 : (UCODETYPE == 6) ? v6_u0_5 : (UCODETYPE == 7) ? v7_u0_5 : (UCODETYPE == 8) ? v8_u0_5 : (UCODETYPE == 10) ? v10_u0_5 : (UCODETYPE == 11) ? v11_u0_5 : (UCODETYPE == 12) ? v12_u0_5 : (UCODETYPE == 14) ? v14_u0_5 : (UCODETYPE == 15) ? v15_u0_5 : 0;
localparam u0_6 = (UCODETYPE == 0) ? v0_u0_6 : (UCODETYPE == 2) ? v2_u0_6 : (UCODETYPE == 3) ? v3_u0_6 : (UCODETYPE == 4) ? v4_u0_6 : (UCODETYPE == 6) ? v6_u0_6 : (UCODETYPE == 7) ? v7_u0_6 : (UCODETYPE == 8) ? v8_u0_6 : (UCODETYPE == 10) ? v10_u0_6 : (UCODETYPE == 11) ? v11_u0_6 : (UCODETYPE == 12) ? v12_u0_6 : (UCODETYPE == 14) ? v14_u0_6 : (UCODETYPE == 15) ? v15_u0_6 : 0;
localparam u0_7 = (UCODETYPE == 0) ? v0_u0_7 : (UCODETYPE == 2) ? v2_u0_7 : (UCODETYPE == 3) ? v3_u0_7 : (UCODETYPE == 4) ? v4_u0_7 : (UCODETYPE == 6) ? v6_u0_7 : (UCODETYPE == 7) ? v7_u0_7 : (UCODETYPE == 8) ? v8_u0_7 : (UCODETYPE == 10) ? v10_u0_7 : (UCODETYPE == 11) ? v11_u0_7 : (UCODETYPE == 12) ? v12_u0_7 : (UCODETYPE == 14) ? v14_u0_7 : (UCODETYPE == 15) ? v15_u0_7 : 0;
localparam u0_8 = (UCODETYPE == 0) ? v0_u0_8 : (UCODETYPE == 2) ? v2_u0_8 : (UCODETYPE == 3) ? v3_u0_8 : (UCODETYPE == 4) ? v4_u0_8 : (UCODETYPE == 6) ? v6_u0_8 : (UCODETYPE == 7) ? v7_u0_8 : (UCODETYPE == 8) ? v8_u0_8 : (UCODETYPE == 10) ? v10_u0_8 : (UCODETYPE == 11) ? v11_u0_8 : (UCODETYPE == 12) ? v12_u0_8 : (UCODETYPE == 14) ? v14_u0_8 : (UCODETYPE == 15) ? v15_u0_8 : 0;
localparam u0_9 = (UCODETYPE == 0) ? v0_u0_9 : (UCODETYPE == 2) ? v2_u0_9 : (UCODETYPE == 3) ? v3_u0_9 : (UCODETYPE == 4) ? v4_u0_9 : (UCODETYPE == 6) ? v6_u0_9 : (UCODETYPE == 7) ? v7_u0_9 : (UCODETYPE == 8) ? v8_u0_9 : (UCODETYPE == 10) ? v10_u0_9 : (UCODETYPE == 11) ? v11_u0_9 : (UCODETYPE == 12) ? v12_u0_9 : (UCODETYPE == 14) ? v14_u0_9 : (UCODETYPE == 15) ? v15_u0_9 : 0;
localparam u0_A = (UCODETYPE == 0) ? v0_u0_A : (UCODETYPE == 2) ? v2_u0_A : (UCODETYPE == 3) ? v3_u0_A : (UCODETYPE == 4) ? v4_u0_A : (UCODETYPE == 6) ? v6_u0_A : (UCODETYPE == 7) ? v7_u0_A : (UCODETYPE == 8) ? v8_u0_A : (UCODETYPE == 10) ? v10_u0_A : (UCODETYPE == 11) ? v11_u0_A : (UCODETYPE == 12) ? v12_u0_A : (UCODETYPE == 14) ? v14_u0_A : (UCODETYPE == 15) ? v15_u0_A : 0;
localparam u0_B = (UCODETYPE == 0) ? v0_u0_B : (UCODETYPE == 2) ? v2_u0_B : (UCODETYPE == 3) ? v3_u0_B : (UCODETYPE == 4) ? v4_u0_B : (UCODETYPE == 6) ? v6_u0_B : (UCODETYPE == 7) ? v7_u0_B : (UCODETYPE == 8) ? v8_u0_B : (UCODETYPE == 10) ? v10_u0_B : (UCODETYPE == 11) ? v11_u0_B : (UCODETYPE == 12) ? v12_u0_B : (UCODETYPE == 14) ? v14_u0_B : (UCODETYPE == 15) ? v15_u0_B : 0;
localparam u0_C = (UCODETYPE == 0) ? v0_u0_C : (UCODETYPE == 2) ? v2_u0_C : (UCODETYPE == 3) ? v3_u0_C : (UCODETYPE == 4) ? v4_u0_C : (UCODETYPE == 6) ? v6_u0_C : (UCODETYPE == 7) ? v7_u0_C : (UCODETYPE == 8) ? v8_u0_C : (UCODETYPE == 10) ? v10_u0_C : (UCODETYPE == 11) ? v11_u0_C : (UCODETYPE == 12) ? v12_u0_C : (UCODETYPE == 14) ? v14_u0_C : (UCODETYPE == 15) ? v15_u0_C : 0;
localparam u0_D = (UCODETYPE == 0) ? v0_u0_D : (UCODETYPE == 2) ? v2_u0_D : (UCODETYPE == 3) ? v3_u0_D : (UCODETYPE == 4) ? v4_u0_D : (UCODETYPE == 6) ? v6_u0_D : (UCODETYPE == 7) ? v7_u0_D : (UCODETYPE == 8) ? v8_u0_D : (UCODETYPE == 10) ? v10_u0_D : (UCODETYPE == 11) ? v11_u0_D : (UCODETYPE == 12) ? v12_u0_D : (UCODETYPE == 14) ? v14_u0_D : (UCODETYPE == 15) ? v15_u0_D : 0;
localparam u0_E = (UCODETYPE == 0) ? v0_u0_E : (UCODETYPE == 2) ? v2_u0_E : (UCODETYPE == 3) ? v3_u0_E : (UCODETYPE == 4) ? v4_u0_E : (UCODETYPE == 6) ? v6_u0_E : (UCODETYPE == 7) ? v7_u0_E : (UCODETYPE == 8) ? v8_u0_E : (UCODETYPE == 10) ? v10_u0_E : (UCODETYPE == 11) ? v11_u0_E : (UCODETYPE == 12) ? v12_u0_E : (UCODETYPE == 14) ? v14_u0_E : (UCODETYPE == 15) ? v15_u0_E : 0;
localparam u0_F = (UCODETYPE == 0) ? v0_u0_F : (UCODETYPE == 2) ? v2_u0_F : (UCODETYPE == 3) ? v3_u0_F : (UCODETYPE == 4) ? v4_u0_F : (UCODETYPE == 6) ? v6_u0_F : (UCODETYPE == 7) ? v7_u0_F : (UCODETYPE == 8) ? v8_u0_F : (UCODETYPE == 10) ? v10_u0_F : (UCODETYPE == 11) ? v11_u0_F : (UCODETYPE == 12) ? v12_u0_F : (UCODETYPE == 14) ? v14_u0_F : (UCODETYPE == 15) ? v15_u0_F : 0;
localparam u1_0 = (UCODETYPE == 0) ? v0_u1_0 : (UCODETYPE == 2) ? v2_u1_0 : (UCODETYPE == 3) ? v3_u1_0 : (UCODETYPE == 4) ? v4_u1_0 : (UCODETYPE == 6) ? v6_u1_0 : (UCODETYPE == 7) ? v7_u1_0 : (UCODETYPE == 8) ? v8_u1_0 : (UCODETYPE == 10) ? v10_u1_0 : (UCODETYPE == 11) ? v11_u1_0 : (UCODETYPE == 12) ? v12_u1_0 : (UCODETYPE == 14) ? v14_u1_0 : (UCODETYPE == 15) ? v15_u1_0 : 0;
localparam u1_1 = (UCODETYPE == 0) ? v0_u1_1 : (UCODETYPE == 2) ? v2_u1_1 : (UCODETYPE == 3) ? v3_u1_1 : (UCODETYPE == 4) ? v4_u1_1 : (UCODETYPE == 6) ? v6_u1_1 : (UCODETYPE == 7) ? v7_u1_1 : (UCODETYPE == 8) ? v8_u1_1 : (UCODETYPE == 10) ? v10_u1_1 : (UCODETYPE == 11) ? v11_u1_1 : (UCODETYPE == 12) ? v12_u1_1 : (UCODETYPE == 14) ? v14_u1_1 : (UCODETYPE == 15) ? v15_u1_1 : 0;
localparam u1_2 = (UCODETYPE == 0) ? v0_u1_2 : (UCODETYPE == 2) ? v2_u1_2 : (UCODETYPE == 3) ? v3_u1_2 : (UCODETYPE == 4) ? v4_u1_2 : (UCODETYPE == 6) ? v6_u1_2 : (UCODETYPE == 7) ? v7_u1_2 : (UCODETYPE == 8) ? v8_u1_2 : (UCODETYPE == 10) ? v10_u1_2 : (UCODETYPE == 11) ? v11_u1_2 : (UCODETYPE == 12) ? v12_u1_2 : (UCODETYPE == 14) ? v14_u1_2 : (UCODETYPE == 15) ? v15_u1_2 : 0;
localparam u1_3 = (UCODETYPE == 0) ? v0_u1_3 : (UCODETYPE == 2) ? v2_u1_3 : (UCODETYPE == 3) ? v3_u1_3 : (UCODETYPE == 4) ? v4_u1_3 : (UCODETYPE == 6) ? v6_u1_3 : (UCODETYPE == 7) ? v7_u1_3 : (UCODETYPE == 8) ? v8_u1_3 : (UCODETYPE == 10) ? v10_u1_3 : (UCODETYPE == 11) ? v11_u1_3 : (UCODETYPE == 12) ? v12_u1_3 : (UCODETYPE == 14) ? v14_u1_3 : (UCODETYPE == 15) ? v15_u1_3 : 0;
localparam u1_4 = (UCODETYPE == 0) ? v0_u1_4 : (UCODETYPE == 2) ? v2_u1_4 : (UCODETYPE == 3) ? v3_u1_4 : (UCODETYPE == 4) ? v4_u1_4 : (UCODETYPE == 6) ? v6_u1_4 : (UCODETYPE == 7) ? v7_u1_4 : (UCODETYPE == 8) ? v8_u1_4 : (UCODETYPE == 10) ? v10_u1_4 : (UCODETYPE == 11) ? v11_u1_4 : (UCODETYPE == 12) ? v12_u1_4 : (UCODETYPE == 14) ? v14_u1_4 : (UCODETYPE == 15) ? v15_u1_4 : 0;
localparam u1_5 = (UCODETYPE == 0) ? v0_u1_5 : (UCODETYPE == 2) ? v2_u1_5 : (UCODETYPE == 3) ? v3_u1_5 : (UCODETYPE == 4) ? v4_u1_5 : (UCODETYPE == 6) ? v6_u1_5 : (UCODETYPE == 7) ? v7_u1_5 : (UCODETYPE == 8) ? v8_u1_5 : (UCODETYPE == 10) ? v10_u1_5 : (UCODETYPE == 11) ? v11_u1_5 : (UCODETYPE == 12) ? v12_u1_5 : (UCODETYPE == 14) ? v14_u1_5 : (UCODETYPE == 15) ? v15_u1_5 : 0;
localparam u1_6 = (UCODETYPE == 0) ? v0_u1_6 : (UCODETYPE == 2) ? v2_u1_6 : (UCODETYPE == 3) ? v3_u1_6 : (UCODETYPE == 4) ? v4_u1_6 : (UCODETYPE == 6) ? v6_u1_6 : (UCODETYPE == 7) ? v7_u1_6 : (UCODETYPE == 8) ? v8_u1_6 : (UCODETYPE == 10) ? v10_u1_6 : (UCODETYPE == 11) ? v11_u1_6 : (UCODETYPE == 12) ? v12_u1_6 : (UCODETYPE == 14) ? v14_u1_6 : (UCODETYPE == 15) ? v15_u1_6 : 0;
localparam u1_7 = (UCODETYPE == 0) ? v0_u1_7 : (UCODETYPE == 2) ? v2_u1_7 : (UCODETYPE == 3) ? v3_u1_7 : (UCODETYPE == 4) ? v4_u1_7 : (UCODETYPE == 6) ? v6_u1_7 : (UCODETYPE == 7) ? v7_u1_7 : (UCODETYPE == 8) ? v8_u1_7 : (UCODETYPE == 10) ? v10_u1_7 : (UCODETYPE == 11) ? v11_u1_7 : (UCODETYPE == 12) ? v12_u1_7 : (UCODETYPE == 14) ? v14_u1_7 : (UCODETYPE == 15) ? v15_u1_7 : 0;
localparam u1_8 = (UCODETYPE == 0) ? v0_u1_8 : (UCODETYPE == 2) ? v2_u1_8 : (UCODETYPE == 3) ? v3_u1_8 : (UCODETYPE == 4) ? v4_u1_8 : (UCODETYPE == 6) ? v6_u1_8 : (UCODETYPE == 7) ? v7_u1_8 : (UCODETYPE == 8) ? v8_u1_8 : (UCODETYPE == 10) ? v10_u1_8 : (UCODETYPE == 11) ? v11_u1_8 : (UCODETYPE == 12) ? v12_u1_8 : (UCODETYPE == 14) ? v14_u1_8 : (UCODETYPE == 15) ? v15_u1_8 : 0;
localparam u1_9 = (UCODETYPE == 0) ? v0_u1_9 : (UCODETYPE == 2) ? v2_u1_9 : (UCODETYPE == 3) ? v3_u1_9 : (UCODETYPE == 4) ? v4_u1_9 : (UCODETYPE == 6) ? v6_u1_9 : (UCODETYPE == 7) ? v7_u1_9 : (UCODETYPE == 8) ? v8_u1_9 : (UCODETYPE == 10) ? v10_u1_9 : (UCODETYPE == 11) ? v11_u1_9 : (UCODETYPE == 12) ? v12_u1_9 : (UCODETYPE == 14) ? v14_u1_9 : (UCODETYPE == 15) ? v15_u1_9 : 0;
localparam u1_A = (UCODETYPE == 0) ? v0_u1_A : (UCODETYPE == 2) ? v2_u1_A : (UCODETYPE == 3) ? v3_u1_A : (UCODETYPE == 4) ? v4_u1_A : (UCODETYPE == 6) ? v6_u1_A : (UCODETYPE == 7) ? v7_u1_A : (UCODETYPE == 8) ? v8_u1_A : (UCODETYPE == 10) ? v10_u1_A : (UCODETYPE == 11) ? v11_u1_A : (UCODETYPE == 12) ? v12_u1_A : (UCODETYPE == 14) ? v14_u1_A : (UCODETYPE == 15) ? v15_u1_A : 0;
localparam u1_B = (UCODETYPE == 0) ? v0_u1_B : (UCODETYPE == 2) ? v2_u1_B : (UCODETYPE == 3) ? v3_u1_B : (UCODETYPE == 4) ? v4_u1_B : (UCODETYPE == 6) ? v6_u1_B : (UCODETYPE == 7) ? v7_u1_B : (UCODETYPE == 8) ? v8_u1_B : (UCODETYPE == 10) ? v10_u1_B : (UCODETYPE == 11) ? v11_u1_B : (UCODETYPE == 12) ? v12_u1_B : (UCODETYPE == 14) ? v14_u1_B : (UCODETYPE == 15) ? v15_u1_B : 0;
localparam u1_C = (UCODETYPE == 0) ? v0_u1_C : (UCODETYPE == 2) ? v2_u1_C : (UCODETYPE == 3) ? v3_u1_C : (UCODETYPE == 4) ? v4_u1_C : (UCODETYPE == 6) ? v6_u1_C : (UCODETYPE == 7) ? v7_u1_C : (UCODETYPE == 8) ? v8_u1_C : (UCODETYPE == 10) ? v10_u1_C : (UCODETYPE == 11) ? v11_u1_C : (UCODETYPE == 12) ? v12_u1_C : (UCODETYPE == 14) ? v14_u1_C : (UCODETYPE == 15) ? v15_u1_C : 0;
localparam u1_D = (UCODETYPE == 0) ? v0_u1_D : (UCODETYPE == 2) ? v2_u1_D : (UCODETYPE == 3) ? v3_u1_D : (UCODETYPE == 4) ? v4_u1_D : (UCODETYPE == 6) ? v6_u1_D : (UCODETYPE == 7) ? v7_u1_D : (UCODETYPE == 8) ? v8_u1_D : (UCODETYPE == 10) ? v10_u1_D : (UCODETYPE == 11) ? v11_u1_D : (UCODETYPE == 12) ? v12_u1_D : (UCODETYPE == 14) ? v14_u1_D : (UCODETYPE == 15) ? v15_u1_D : 0;
localparam u1_E = (UCODETYPE == 0) ? v0_u1_E : (UCODETYPE == 2) ? v2_u1_E : (UCODETYPE == 3) ? v3_u1_E : (UCODETYPE == 4) ? v4_u1_E : (UCODETYPE == 6) ? v6_u1_E : (UCODETYPE == 7) ? v7_u1_E : (UCODETYPE == 8) ? v8_u1_E : (UCODETYPE == 10) ? v10_u1_E : (UCODETYPE == 11) ? v11_u1_E : (UCODETYPE == 12) ? v12_u1_E : (UCODETYPE == 14) ? v14_u1_E : (UCODETYPE == 15) ? v15_u1_E : 0;
localparam u1_F = (UCODETYPE == 0) ? v0_u1_F : (UCODETYPE == 2) ? v2_u1_F : (UCODETYPE == 3) ? v3_u1_F : (UCODETYPE == 4) ? v4_u1_F : (UCODETYPE == 6) ? v6_u1_F : (UCODETYPE == 7) ? v7_u1_F : (UCODETYPE == 8) ? v8_u1_F : (UCODETYPE == 10) ? v10_u1_F : (UCODETYPE == 11) ? v11_u1_F : (UCODETYPE == 12) ? v12_u1_F : (UCODETYPE == 14) ? v14_u1_F : (UCODETYPE == 15) ? v15_u1_F : 0;
localparam u2_0 = (UCODETYPE == 0) ? v0_u2_0 : (UCODETYPE == 2) ? v2_u2_0 : (UCODETYPE == 3) ? v3_u2_0 : (UCODETYPE == 4) ? v4_u2_0 : (UCODETYPE == 6) ? v6_u2_0 : (UCODETYPE == 7) ? v7_u2_0 : (UCODETYPE == 8) ? v8_u2_0 : (UCODETYPE == 10) ? v10_u2_0 : (UCODETYPE == 11) ? v11_u2_0 : (UCODETYPE == 12) ? v12_u2_0 : (UCODETYPE == 14) ? v14_u2_0 : (UCODETYPE == 15) ? v15_u2_0 : 0;
localparam u2_1 = (UCODETYPE == 0) ? v0_u2_1 : (UCODETYPE == 2) ? v2_u2_1 : (UCODETYPE == 3) ? v3_u2_1 : (UCODETYPE == 4) ? v4_u2_1 : (UCODETYPE == 6) ? v6_u2_1 : (UCODETYPE == 7) ? v7_u2_1 : (UCODETYPE == 8) ? v8_u2_1 : (UCODETYPE == 10) ? v10_u2_1 : (UCODETYPE == 11) ? v11_u2_1 : (UCODETYPE == 12) ? v12_u2_1 : (UCODETYPE == 14) ? v14_u2_1 : (UCODETYPE == 15) ? v15_u2_1 : 0;
localparam u2_2 = (UCODETYPE == 0) ? v0_u2_2 : (UCODETYPE == 2) ? v2_u2_2 : (UCODETYPE == 3) ? v3_u2_2 : (UCODETYPE == 4) ? v4_u2_2 : (UCODETYPE == 6) ? v6_u2_2 : (UCODETYPE == 7) ? v7_u2_2 : (UCODETYPE == 8) ? v8_u2_2 : (UCODETYPE == 10) ? v10_u2_2 : (UCODETYPE == 11) ? v11_u2_2 : (UCODETYPE == 12) ? v12_u2_2 : (UCODETYPE == 14) ? v14_u2_2 : (UCODETYPE == 15) ? v15_u2_2 : 0;
localparam u2_3 = (UCODETYPE == 0) ? v0_u2_3 : (UCODETYPE == 2) ? v2_u2_3 : (UCODETYPE == 3) ? v3_u2_3 : (UCODETYPE == 4) ? v4_u2_3 : (UCODETYPE == 6) ? v6_u2_3 : (UCODETYPE == 7) ? v7_u2_3 : (UCODETYPE == 8) ? v8_u2_3 : (UCODETYPE == 10) ? v10_u2_3 : (UCODETYPE == 11) ? v11_u2_3 : (UCODETYPE == 12) ? v12_u2_3 : (UCODETYPE == 14) ? v14_u2_3 : (UCODETYPE == 15) ? v15_u2_3 : 0;
localparam u2_4 = (UCODETYPE == 0) ? v0_u2_4 : (UCODETYPE == 2) ? v2_u2_4 : (UCODETYPE == 3) ? v3_u2_4 : (UCODETYPE == 4) ? v4_u2_4 : (UCODETYPE == 6) ? v6_u2_4 : (UCODETYPE == 7) ? v7_u2_4 : (UCODETYPE == 8) ? v8_u2_4 : (UCODETYPE == 10) ? v10_u2_4 : (UCODETYPE == 11) ? v11_u2_4 : (UCODETYPE == 12) ? v12_u2_4 : (UCODETYPE == 14) ? v14_u2_4 : (UCODETYPE == 15) ? v15_u2_4 : 0;
localparam u2_5 = (UCODETYPE == 0) ? v0_u2_5 : (UCODETYPE == 2) ? v2_u2_5 : (UCODETYPE == 3) ? v3_u2_5 : (UCODETYPE == 4) ? v4_u2_5 : (UCODETYPE == 6) ? v6_u2_5 : (UCODETYPE == 7) ? v7_u2_5 : (UCODETYPE == 8) ? v8_u2_5 : (UCODETYPE == 10) ? v10_u2_5 : (UCODETYPE == 11) ? v11_u2_5 : (UCODETYPE == 12) ? v12_u2_5 : (UCODETYPE == 14) ? v14_u2_5 : (UCODETYPE == 15) ? v15_u2_5 : 0;
localparam u2_6 = (UCODETYPE == 0) ? v0_u2_6 : (UCODETYPE == 2) ? v2_u2_6 : (UCODETYPE == 3) ? v3_u2_6 : (UCODETYPE == 4) ? v4_u2_6 : (UCODETYPE == 6) ? v6_u2_6 : (UCODETYPE == 7) ? v7_u2_6 : (UCODETYPE == 8) ? v8_u2_6 : (UCODETYPE == 10) ? v10_u2_6 : (UCODETYPE == 11) ? v11_u2_6 : (UCODETYPE == 12) ? v12_u2_6 : (UCODETYPE == 14) ? v14_u2_6 : (UCODETYPE == 15) ? v15_u2_6 : 0;
localparam u2_7 = (UCODETYPE == 0) ? v0_u2_7 : (UCODETYPE == 2) ? v2_u2_7 : (UCODETYPE == 3) ? v3_u2_7 : (UCODETYPE == 4) ? v4_u2_7 : (UCODETYPE == 6) ? v6_u2_7 : (UCODETYPE == 7) ? v7_u2_7 : (UCODETYPE == 8) ? v8_u2_7 : (UCODETYPE == 10) ? v10_u2_7 : (UCODETYPE == 11) ? v11_u2_7 : (UCODETYPE == 12) ? v12_u2_7 : (UCODETYPE == 14) ? v14_u2_7 : (UCODETYPE == 15) ? v15_u2_7 : 0;
localparam u2_8 = (UCODETYPE == 0) ? v0_u2_8 : (UCODETYPE == 2) ? v2_u2_8 : (UCODETYPE == 3) ? v3_u2_8 : (UCODETYPE == 4) ? v4_u2_8 : (UCODETYPE == 6) ? v6_u2_8 : (UCODETYPE == 7) ? v7_u2_8 : (UCODETYPE == 8) ? v8_u2_8 : (UCODETYPE == 10) ? v10_u2_8 : (UCODETYPE == 11) ? v11_u2_8 : (UCODETYPE == 12) ? v12_u2_8 : (UCODETYPE == 14) ? v14_u2_8 : (UCODETYPE == 15) ? v15_u2_8 : 0;
localparam u2_9 = (UCODETYPE == 0) ? v0_u2_9 : (UCODETYPE == 2) ? v2_u2_9 : (UCODETYPE == 3) ? v3_u2_9 : (UCODETYPE == 4) ? v4_u2_9 : (UCODETYPE == 6) ? v6_u2_9 : (UCODETYPE == 7) ? v7_u2_9 : (UCODETYPE == 8) ? v8_u2_9 : (UCODETYPE == 10) ? v10_u2_9 : (UCODETYPE == 11) ? v11_u2_9 : (UCODETYPE == 12) ? v12_u2_9 : (UCODETYPE == 14) ? v14_u2_9 : (UCODETYPE == 15) ? v15_u2_9 : 0;
localparam u2_A = (UCODETYPE == 0) ? v0_u2_A : (UCODETYPE == 2) ? v2_u2_A : (UCODETYPE == 3) ? v3_u2_A : (UCODETYPE == 4) ? v4_u2_A : (UCODETYPE == 6) ? v6_u2_A : (UCODETYPE == 7) ? v7_u2_A : (UCODETYPE == 8) ? v8_u2_A : (UCODETYPE == 10) ? v10_u2_A : (UCODETYPE == 11) ? v11_u2_A : (UCODETYPE == 12) ? v12_u2_A : (UCODETYPE == 14) ? v14_u2_A : (UCODETYPE == 15) ? v15_u2_A : 0;
localparam u2_B = (UCODETYPE == 0) ? v0_u2_B : (UCODETYPE == 2) ? v2_u2_B : (UCODETYPE == 3) ? v3_u2_B : (UCODETYPE == 4) ? v4_u2_B : (UCODETYPE == 6) ? v6_u2_B : (UCODETYPE == 7) ? v7_u2_B : (UCODETYPE == 8) ? v8_u2_B : (UCODETYPE == 10) ? v10_u2_B : (UCODETYPE == 11) ? v11_u2_B : (UCODETYPE == 12) ? v12_u2_B : (UCODETYPE == 14) ? v14_u2_B : (UCODETYPE == 15) ? v15_u2_B : 0;
localparam u2_C = (UCODETYPE == 0) ? v0_u2_C : (UCODETYPE == 2) ? v2_u2_C : (UCODETYPE == 3) ? v3_u2_C : (UCODETYPE == 4) ? v4_u2_C : (UCODETYPE == 6) ? v6_u2_C : (UCODETYPE == 7) ? v7_u2_C : (UCODETYPE == 8) ? v8_u2_C : (UCODETYPE == 10) ? v10_u2_C : (UCODETYPE == 11) ? v11_u2_C : (UCODETYPE == 12) ? v12_u2_C : (UCODETYPE == 14) ? v14_u2_C : (UCODETYPE == 15) ? v15_u2_C : 0;
localparam u2_D = (UCODETYPE == 0) ? v0_u2_D : (UCODETYPE == 2) ? v2_u2_D : (UCODETYPE == 3) ? v3_u2_D : (UCODETYPE == 4) ? v4_u2_D : (UCODETYPE == 6) ? v6_u2_D : (UCODETYPE == 7) ? v7_u2_D : (UCODETYPE == 8) ? v8_u2_D : (UCODETYPE == 10) ? v10_u2_D : (UCODETYPE == 11) ? v11_u2_D : (UCODETYPE == 12) ? v12_u2_D : (UCODETYPE == 14) ? v14_u2_D : (UCODETYPE == 15) ? v15_u2_D : 0;
localparam u2_E = (UCODETYPE == 0) ? v0_u2_E : (UCODETYPE == 2) ? v2_u2_E : (UCODETYPE == 3) ? v3_u2_E : (UCODETYPE == 4) ? v4_u2_E : (UCODETYPE == 6) ? v6_u2_E : (UCODETYPE == 7) ? v7_u2_E : (UCODETYPE == 8) ? v8_u2_E : (UCODETYPE == 10) ? v10_u2_E : (UCODETYPE == 11) ? v11_u2_E : (UCODETYPE == 12) ? v12_u2_E : (UCODETYPE == 14) ? v14_u2_E : (UCODETYPE == 15) ? v15_u2_E : 0;
localparam u2_F = (UCODETYPE == 0) ? v0_u2_F : (UCODETYPE == 2) ? v2_u2_F : (UCODETYPE == 3) ? v3_u2_F : (UCODETYPE == 4) ? v4_u2_F : (UCODETYPE == 6) ? v6_u2_F : (UCODETYPE == 7) ? v7_u2_F : (UCODETYPE == 8) ? v8_u2_F : (UCODETYPE == 10) ? v10_u2_F : (UCODETYPE == 11) ? v11_u2_F : (UCODETYPE == 12) ? v12_u2_F : (UCODETYPE == 14) ? v14_u2_F : (UCODETYPE == 15) ? v15_u2_F : 0;

   generate
      if ( EXPERIMENT_AVOID_EBR != 1 ) begin
`ifdef verilator
         /* verilator lint_off UNUSED */
         wire [15:0]   sim_a;
         wire [15:0]   sim_b;
         wire [15:0]   sim_c;
         /* verilator lint_on UNUSED */
`endif
         
         SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                         .INIT_0(u0_0), .INIT_1(u0_1), .INIT_2(u0_2), .INIT_3(u0_3),
                         .INIT_4(u0_4), .INIT_5(u0_5), .INIT_6(u0_6), .INIT_7(u0_7),
                         .INIT_8(u0_8), .INIT_9(u0_9), .INIT_A(u0_A), .INIT_B(u0_B),
                         .INIT_C(u0_C), .INIT_D(u0_D), .INIT_E(u0_E), .INIT_F(u0_F)
                         ) ucode0
           (
            .RDATA( d[15:0]             ),
            .RADDR( {3'h0,minx}         ),
            .RCLK(  clk                 ),
            .RCLKE( 1'b1                ),
            .RE(    progress_ucode      ),
            .WADDR( 11'h0               ),
            .WCLK(  1'b0                ),
            .WCLKE( 1'b0                ),
            .WDATA( 16'h0               ),
            .WE(    1'b0                ),
            .MASK(  16'h0               )
            );
         
         SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                         .INIT_0(u1_0), .INIT_1(u1_1), .INIT_2(u1_2), .INIT_3(u1_3),
                         .INIT_4(u1_4), .INIT_5(u1_5), .INIT_6(u1_6), .INIT_7(u1_7),
                         .INIT_8(u1_8), .INIT_9(u1_9), .INIT_A(u1_A), .INIT_B(u1_B),
                         .INIT_C(u1_C), .INIT_D(u1_D), .INIT_E(u1_E), .INIT_F(u1_F)
                         ) ucode1
           (
            .RDATA( d[31:16]            ),
            .RADDR( {3'h0,minx}         ),
            .RCLK(  clk                 ),
            .RCLKE( 1'b1                ),
            .RE(    progress_ucode      ),
            .WADDR( 11'h0               ),
            .WCLK(  1'b0                ),
            .WCLKE( 1'b0                ),
            .WDATA( 16'h0               ),
            .WE(    1'b0                ),
            .MASK(  16'h0               )
            );
         
         SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                         .INIT_0(u2_0), .INIT_1(u2_1), .INIT_2(u2_2), .INIT_3(u2_3),
                         .INIT_4(u2_4), .INIT_5(u2_5), .INIT_6(u2_6), .INIT_7(u2_7),
                         .INIT_8(u2_8), .INIT_9(u2_9), .INIT_A(u2_A), .INIT_B(u2_B),
                         .INIT_C(u2_C), .INIT_D(u2_D), .INIT_E(u2_E), .INIT_F(u2_F)
                         ) ucode2
           (
            .RDATA( d[47:32]            ),
            .RADDR( {3'h0,minx}         ),
            .RCLK(  clk                 ),
            .RCLKE( 1'b1                ),
            .RE(    progress_ucode      ),
            .WADDR( 11'h0               ),
            .WCLK(  1'b0                ),
            .WCLKE( 1'b0                ),
            .WDATA( 16'h0               ),
            .WE(    1'b0                ),
            .MASK(  16'h0               )
            );
      end else begin

         /* Purely an experiment. What would happen if we used logic instead of EBR
          * for the control equations?
          * The iceblink example that compiles to 247 SB_LUTS, 4 EBRs here compiles to
          * 1101 LUTs, 2 EBRs, speed 45 MHz  (Lattice LSE).
          * 1175 LUTs, 2 EBRs, speed ? MHz (Synplify Pro, placement failed).
          */
         genvar k;
         wire [47:0] cmb /* synthesis syn_romstyle = "logic" */;
         reg [47:0]  thereg /* synthesis syn_romstyle = "logic" */;
         localparam [4095:0] param_u0 = {u0_F,u0_E,u0_D,u0_C,u0_B,u0_A,u0_9,u0_8,u0_7,u0_6,u0_5,u0_4,u0_3,u0_2,u0_1,u0_0};
         localparam [4095:0] param_u1 = {u1_F,u1_E,u1_D,u1_C,u1_B,u1_A,u1_9,u1_8,u1_7,u1_6,u1_5,u1_4,u1_3,u1_2,u1_1,u1_0};
         localparam [4095:0] param_u2 = {u2_F,u2_E,u2_D,u2_C,u2_B,u2_A,u2_9,u2_8,u2_7,u2_6,u2_5,u2_4,u2_3,u2_2,u2_1,u2_0};
         for ( k = 0; k < 16; k = k + 1 ) begin
            assign cmb[k+ 0] = ((param_u0 >> minx) >> k) & 1'b1;
            assign cmb[k+16] = ((param_u1 >> minx) >> k) & 1'b1;
            assign cmb[k+32] = ((param_u2 >> minx) >> k) & 1'b1;
         end
         always @(posedge clk) begin
            if ( progress_ucode )
              thereg <= cmb;
         end
         assign d = thereg;
      end
   endgenerate
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019-2020. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * Automatically generated from ../code/ucode.h by midgetv_indirectEBR.c.
 * Do not edit.
 * Optiones for this variant:
 *   No RVC
 *   No MULDIV
 *   minstret not implemented
 */
/* Using LUTSIZE=4. Using 2 EBRs. Initial table has 42 columns
 * Removed:  000000000001000000000001000000000000000000 These are removed from consideration, replaced with hand-crafted Verilog code in the output stage
 * Reserved: 000000000000000000000000000000000000000000 Columns to be represented directly, not part of optimalization
 * Total columns to represent in EBRs: 42
 * 169 distinct lines in remaining untreated columns
 * c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 * 169 169 169 169 169 169 169 169 169 169 169   x 169 169 167 169 168 169 169 168 169 169 168   x 169 169 169 169 166 166 168 169 168 169 168 169 168 169 169 168 168 168  kill col 13  Tbl  39 cols 000000000001000000000001000010000000000000 has 166 unique lines.
 * 166 166 166 166 166 166 166 166 166 166 166   x 166 166 164 166 165 166 166 165 166 166 165   x 166 166 166 166     163 164 166 165 166 165 166 165 166 166 165 165 165  kill col 12  Tbl  38 cols 000000000001000000000001000011000000000000 has 163 unique lines.
 * 163 163 163 163 163 163 163 163 163 163 163   x 163 163 161 163 161 163 163 160 163 163 162   x 163 163 163 163         159 162 162 163 162 163 162 163 163 162 162 162  kill col 11  Tbl  37 cols 000000000001000000000001000011100000000000 has 159 unique lines.
 * 159 159 159 159 159 159 159 159 159 159 159   x 159 159 157 159 157 159 159 156 159 159 157   x 159 159 159 159             158 158 159 158 159 158 159 159 158 158 158  kill col 22  Tbl  36 cols 000000000001000000010001000011100000000000 has 156 unique lines.
 * 156 156 156 156 156 156 156 156 156 156 156   x 156 156 154 156 155 156 156     156 156 154   x 156 156 156 156             155 155 155 155 155 154 155 156 155 155 154  kill col 27  Tbl  35 cols 000000000001001000010001000011100000000000 has 154 unique lines.
 * 154 154 154 154 154 154 154 154 154 154 154   x 154 154     153 153 154 153     154 154 152   x 154 154 154 154             153 153 153 153 153 152 153 154 153 153 152  kill col 19  Tbl  34 cols 000000000001001000010011000011100000000000 has 152 unique lines.
 * 152 152 152 152 152 152 152 152 152 152 152   x 152 152     151 151 152 151     152 152       x 152 152 152 152             151 151 151 151 151 150 151 152 151 151 150  kill col  5  Tbl  33 cols 000000000001001000010011000011100000100000 has 150 unique lines.
 * 150 150 150 150 150 150 150 150 150 150 150   x 150 150     149 149 150 149     150 150       x 150 150 150 150             149 149 149 148 149     149 149 147 146 147  kill col  1  Tbl  32 cols 000000000001001000010011000011100000100010 has 146 unique lines.
 * 146 146 146 146 146 146 146 146 146 146 146   x 146 146     144 145 146 145     146 146       x 146 144 146 146             145 145 145 142 145     143 143 144     143  kill col  7  Tbl  31 cols 000000000001001000010011000011100010100010 has 142 unique lines.
 * 142 142 142 142 142 142 142 142 142 142 142   x 142 141     140 141 140 141     142 142       x 140 139 142 142             141 141 141     141     139 138 138     138  kill col  3  Tbl  30 cols 000000000001001000010011000011100010101010 has 138 unique lines.
 * 138 138 138 138 138 138 138 138 138 138 138   x 138 137     136 135 136 137     138 138       x 135 133 138 137             137 137 137     135     131     130     133  kill col  2  Tbl  29 cols 000000000001001000010011000011100010101110 has 130 unique lines.
 * 130 130 130 130 130 130 130 128 130 130 130   x 130 129     127 125 127 126     130 130       x 124 124 130 129             129 129 129     121     120             122  kill col  4  Tbl  28 cols 000000000001001000010011000011100010111110 has 120 unique lines.
 * 120 120 120 120 120 120 120 117 120 120 120   x 119 118     117 111 114 113     120 120       x 113 114 120 117             119 119 119     105                     108  kill col  6  Tbl  27 cols 000000000001001000010011000011100011111110 has 105 unique lines.
 * 105 105 105 105 105 105 105 103 105 104 104   x 103 103     103  94  98  96     105 105       x  97  98 105 102             104 104 104                              92  kill col  0  Tbl  26 cols 000000000001001000010011000011100011111111 has  92 unique lines.
 *  92  92  92  92  92  92  92  89  92  91  91   x  89  90      88  81  83  82      92  92       x  82  84  92  89              91  91  90                                  kill col 25  Tbl  25 cols 000000000001001010010011000011100011111111 has  81 unique lines.
 *  81  81  81  81  81  81  81  78  80  80  79   x  78  80      78      71  69      81  81       x  71  73  81  77              80  80  79                                  kill col 23  Tbl  24 cols 000000000001001010110011000011100011111111 has  69 unique lines.
 *  68  69  69  69  69  69  69  66  68  68  67   x  65  68      64      61          69  69       x  61  62  69  65              68  68  67                                  kill col 24  Tbl  23 cols 000000000001001011110011000011100011111111 has  61 unique lines.
 *  60  61  59  61  60  61  61  58  60  60  59   x  57  59      57                  61  61       x  55  55  60  58              60  60  59                                  kill col 17  Tbl  22 cols 000000000001001011110011100011100011111111 has  55 unique lines.
 *  54  53  53  55  54  55  55  52  54  54  53   x  50  53      50                  55  55       x      51  54  52              54  54  53                                  kill col 29  Tbl  21 cols 000000000001101011110011100011100011111111 has  50 unique lines.
 *  49  48  43  50  49  50  50  48  49  49  48   x      48      45                  50  49       x      45  49  46              49  49  48                                  kill col 39  Tbl  20 cols 001000000001101011110011100011100011111111 has  43 unique lines.
 *  42  40      43  42  43  43  41  42  42  41   x      39      38                  43  41       x      39  42  40              42  42  41                                  kill col 26  Tbl  19 cols 001000000001101111110011100011100011111111 has  38 unique lines.
 *  37  35      38  37  38  38  36  37  37  36   x      33                          37  36       x      34  37  35              37  37  36                                  kill col 28  Tbl  18 cols 001000000001111111110011100011100011111111 has  33 unique lines.
 *  32  29      33  32  33  33  31  32  32  30   x                                  32  31       x      29  32  31              32  32  31                                  kill col 40  Tbl  17 cols 011000000001111111110011100011100011111111 has  29 unique lines.
 *  27          29  28  28  29  27  27  28  27   x                                  28  27       x      25  28  27              28  28  27                                  kill col 16  Tbl  16 cols 011000000001111111110011110011100011111111 has  25 unique lines.
 *  23          24  24  23  25  23  23  24  23   x                                  23  22       x          24  24              24  24  23                                  kill col 20  Tbl  15 cols 011000000001111111110111110011100011111111 has  22 unique lines.
 *  20          21  21  20  22  20  20  21  21   x                                  21           x          21  21              21  21  20                                  kill col 41  Tbl  14 cols 111000000001111111110111110011100011111111 has  20 unique lines.
 *              19  19  18  20  18  18  19  19   x                                  19           x          19  19              19  19  18                                  kill col 36  Tbl  13 cols 111001000001111111110111110011100011111111 has  18 unique lines.
 *              17  16      18  16  16  17  17   x                                  17           x          17  17              17  17  16                                  kill col 37  Tbl  12 cols 111011000001111111110111110011100011111111 has  16 unique lines.
Possible good candidates for removal, columns : 8 33 34 
 *
 * Round 1: 000100111110000000001000001100011100000000  4 columns for indexes to table representing 12 original columns (uses 16 of 16 lines in indirect table).
 * Direct:  111011000000111111110110110011100011111111 28 columns
 * Success. Use 2 EBRs, 12 LUTs.
 */

module v0_m_2ebr
  (
   input         clk,
   input [7:0]   minx,
   input         progress_ucode,
/* verilator lint_off UNOPTFLAT */
   output [47:0] d
/* verilator lint_on UNOPTFLAT */
   );
   /*
    * inx         next     indirect index 0
    * || ucode    ucode    | direct representation
    * 00 LB_0     LB_1     0 0110000001101011110000000001| LB     Load byte. q = rdadr=RS1+0fs
    * 01 LB_1     LB_2     1 0010000001011111100111010010|        Read until q=mem[rs1+ofs) & ~3u]
    * 02 IJ_0     IJ_1     2 0110100001101111110010111110| IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0
    * 03 _L0x03   StdIncPc 0 00100000000101x10xxx11100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 04 ADDI_0   StdIncPc 0 0000001000010111010011100110| ADDI   Add immediate. rd =RS1+Iimm (or joined)
    * 05 _L0x05   ADDI_0   0 00100000000101x01xxx00000100| AUIPC  q = imm20 (copy x/2)
    * 06 LB_3     LB_4     0 0010000000110111101000000111|        q = ~mem[rs1+ofs]
    * 07 LB_4     LB_5     0 0010000000101111101100001001|        q = (uint8_t) mem[rs1+Iimm]
    * 08 _L0x08   SB_1     0 0000010001110011110001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 09 LB_5     LB_6     0 0010000000101111100010001011|        q = D^0xffffffff^q = D^0x80
    * 0a _L0x0a   SB_1     0 0000010001110011110001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 0b JALR_2   JAL_2    3 0000011000010111001110000110|        Q = (RS1+imn) & 0xfffffffe
    * 0c ADD_0    ADDI_0   0 0010000001110111100100000100| ADD    add     Addition Q = RS1
    * 0d _L0x0d   StdIncPc 0 0000001000010111011011100110| LUI    q = imm20
    * 0e SUB_0    SUB_1    0 00100000011101x10xxx00010000| SUB    Subtraction
    * 0f _L0x0f   StdIncPc 0 0000001000010111011011100110| LUI    q = imm20
    * 10 SUB_1    LB_6     0 0010000001111111100010001011|        Q = ~RS2
    * 11 AND_1    ANDI_1   0 0010000001110111100000011010|        RS1^0xffffffff to Q
    * 12 _L0x12   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 13 condb_2  condb_3  0 0010000001111111100000010100|        ~RS2 in Q
    * 14 condb_3  condb_4  4 0010000000010111110000010101|        Calculate RS1+~RS2+1
    * 15 condb_4  condb_5  5 0000010001100111100100010110|        Branch on condition
    * 16 condb_5  Fetch    6 0100010101101100111011011110|        Branch not taken.
    * 17 condb_5t BrOpFet  3 0100010101101111110001110100|        Branch taken.
    * 18 BEQ      condb_2  0 0000011001110111011000010011| BEQ    Conditional Branch. Offset to Ryy
    * 19 JALR_0   JALR_1   0 0000011001010111010001000001| JALR   yy=RS1+imm
    * 1a ANDI_1   StdIncPc 0 0000001000010111001111100110|        rd = Iimm & RS1
    * 1b _L0x1b   JAL_1    3 0010000000010110111000110010| JAL    J-imm is in q. Branch on alignfault
    * 1c ECAL_BRK ECAL_RET 2 0010000001011110111010100110| ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI
    * 1d ORI_2    StdIncPc 0 0000001000010111011111100110|        rd = Iimm | RS1
    * 1e aFault_1 aFault_2 4 0010000001010101110011010100|        Q = 4
    * 1f IJ_2     IJ_3     0 0000011001010111011010110111|        Read word is to be masked with 2 lsb = 00
    * 20 LH_0     LH_1     2 0100011001101011110001010010| LH     Load hword. Q = rdadr=RS1+Iimm.
    * 21 XORI_1   StdIncPc 0 0000001000010111000011100110|        rd = Iimm ^ RS1
    * 22 _L0x22   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 23 _L0x23   StdIncPc 0 00100000000101x10xxx11100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 24 SLLI_0   SLLI_1   7 0010000001111010x11000110101| SLLI   Shift left immediate.
    * 25 _L0x25   ADDI_0   0 00100000000101x01xxx00000100| AUIPC  q = imm20 (copy x/2)
    * 26 OR_1     OR_2     0 0000010001110111000000100111|        RS1^0xffffffff to jj
    * 27 OR_2     ORI_2    0 0010000000000111110000011101|        Q = rs2
    * 28 _L0x28   SH_1     2 0000010001110011110010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 29 XOR_1    XORI_1   0 0010000001110111100000100001|        Q = RS1^0xFFFFFFFF
    * 2a _L0x2a   SH_1     2 0000010001110011110010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 2b SLTIX_1  SLTIX_2  4 001000000xxxx111010000110000|        RS1 - imm / RS1 - RS2
    * 2c SLL_0    SLL_1    0 00100000011101x0xxxx00111110| SLL    Shift left
    * 2d _L0x2d   StdIncPc 0 0000001000010111011011100110| LUI    q = imm20
    * 2e unx2e             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| 2e: Not in use 
    * 2f _L0x2f   StdIncPc 0 0000001000010111011011100110| LUI    q = imm20
    * 30 SLTIX_2  StdIncPc 8 0000001000010111011011100110|        Registered ALU flag to rd
    * 31 SLTX_1   SLTIX_1  0 0010000001111111100000101011|        ~rs2 to Q
    * 32 JAL_1    JAL_2    0 0000011000010111010010000110|        Target adr to yy
    * 33 JAERR_1  JAERR_2  0 0000011110010110x10010000001|  Err   JAL target adr misaligned, store to mtval
    * 34 JAL_3    Fetch    9 0100010101101110100111011110|        PC+imm/trap entrypt to PC. OpFetch
    * 35 SLLI_1   SLLI_2   7 0000001001011111100100110110|        Register to shift to Q (and TRG for shift 0)
    * 36 SLLI_2   _L0x03   a 0000001001011111110100000011|        Repeat Q = Q+Q until shregcnt == 0
    * 37 ECALL_2  ECALL_3  5 000001101xxxx111000111010111|        mepc = pc, prep store 0 to mtval
    * 38 BNE      condb_2  0 0000011001110111011000010011| BNE    Conditional Branch. Offset to Ryy
    * 39 _L0x39   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 3a SRxI_1   SRxI_2   b 0000001001010111100100111101|        Register to shift to Q
    * 3b _L0x3b   JAL_1    3 0010000000010110111000110010| JAL    J-imm is in q. Branch on alignfault
    * 3c CSRRW_0  CSRRW_1  0 0000011000110111011001001001| CSRRW  Decoded CSR adr in yy
    * 3d SRxI_2   _L0x03   c 0000001001010111100100000011|        Repeat Q >>= 1 until shregcnt == 0
    * 3e SLL_1    SLLI_1   7 0010000001111010x00100110101|        Shiftamount was in low 5 bits of RS2
    * 3f SRx_1    SRxI_1   7 0010000001111010x00100111010|        Shiftamount in low 5 bits of RS2
    * 40 LW_0     LW_1     3 0110000001101111110001010000| LW     Load word. Q=yy=rdadr=RS1+Iimm
    * 41 JALR_1   JALR_2   4 0010000001100111110000001011|        Q=1
    * 42 _L0x42   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 43 _L0x43   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 44 SLTI_0   SLTIX_1  0 0010000001111111101000101011| SLTI   Set less than immediate (signed)
    * 45 WFI_3    WFI_4    4 0010000001010111110001100101|        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105
    * 46 ILL_1    ILL_2    0 0000011011010110x00101000111|        Store PC to mepc
    * 47 ILL_2    ILL_3    0 0000011111010111000110001111|        Store 0 to mtval
    * 48 _L0x48   SW_1     3 1110000001110111110001100110| SW     Store word. Q=wradr=RS1+Simm
    * 49 CSRRW_1  CSRRW_2  4 0010000000010111110001001011|        Construct PC storage adr
    * 4a _L0x4a   SW_1     3 1110000001110111110001100110| SW     Store word. Q=wradr=RS1+Simm
    * 4b CSRRW_2  CSRRW_3  0 0001000111010110100110110001|        Write PC to 0x100 start Prep emulation entrypt
    * 4c SLT_0    SLTX_1   0 00100000011101x10xxx00110001| SLT    Set less than (signed)
    * 4d unx4d             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| 4d: Not in use 
    * 4e eILL0b   ILLe     0 001000000xxxx1x0xxxx11111110| Illegal instruction seen
    * 4f MRET_8   StdIncPc 4 0010000001010111110011100110|        Prep +4
    * 50 LW_1     StdIncPc d 0000001001011111000111100110|        Read until d=mem[(rs1+ofs) & ~3u]
    * 51 LDAF_LW  LDAF_a   0 0000011111010110111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 52 LH_1     LH_2     1 0010000001011111100101010100|        Read until q=mem[(rs1+ofs) & ~3u]
    * 53 LDAF_LH  LDAF_a   0 0000011111010110111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 54 LH_2     LH_3     c 0010000001010111100111101011|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 55 aFaultb  aFault_1 0 0000011111010111011000011110|  err   LH Load access fault. Faulting adr to mtval
    * 56 LH_4     LH_5     0 0010000001000111101101010111|        q = (uint16_t) mem[rs1+Iimm]
    * 57 LH_5     LB_6     0 0010000001000111100010001011|        q = D^0xffffffff^q = D ^ 0x00008000
    * 58 _L0x58   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 59 _L0x59   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 5a SB_1     SB_2     7 0000011001011111100101011101|        Write d to Q and yy (for sh 0). Prep shift
    * 5b _L0x5b   JAL_1    3 0010000000010110111000110010| JAL    J-imm is in q. Branch on alignfault
    * 5c CSRRS_0  CSRRW_1  0 0000011000110111011001001001| CSRRS  Decoded CSR adr in yy
    * 5d SB_2     SB_3     a 0000011001011111110111111011|        Repeat shl until shreg = 0 (0,8,16 or 24 times)
    * 5e LHU_1    LHU_2    1 0010000001011111100101110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 5f LDAF_LHU LDAF_a   0 0000011111010110111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 60 _L0x60   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 61 EBRKWFI2 EBREAK_1 5 0000010000110111001011110111| EBREAK/WFI2 Select EBREAK or WFI
    * 62 _L0x62   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 63 _L0x63   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 64 SLTIU_0  SLTIX_1  0 0010000001111111101000101011| SLTIU  Set less than immediate (unsigned)
    * 65 WFI_4    WFI_5    5 00100000000101x10xxx11101111|        Prepare read PC
    * 66 SW_1     SW_2     0 0000000111110110100111110010|        Write d to a+k until accepted
    * 67 SW_E1SWE SW_E2    0 0000011110010110x11010010011|        Store faulting address alignment to mtval
    * 68 _L0x68   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 69 unx69             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| 69: Not in use 
    * 6a _L0x6a   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 6b SB_4     SB_5     0 1110000101100111100101111010|        Address back to Q. Prepare get item to write
    * 6c SLTU_0   SLTX_1   0 00100000011101x10xxx00110001| SLTU   Set less than (unsigned)
    * 6d unx6d             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| 6d: Not in use 
    * 6e unx6e             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| 6e: Not in use 
    * 6f MRET_6   MRET_7   4 001000000xxxx111110011001111|        ~302 + origImm + 1 for branch decision
    * 70 LHU_2    LHU_3    c 0010000001010111100110111010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 71 aFaultc  aFault_1 0 0000011111010111011000011110|  err   LHU Load access fault. Faulting adr to mtval
    * 72 LBU_3    ANDI_1   0 0010000000110111101000011010|        Invert q. Prepare read mask
    * 73 BAERR_1  BAERR_2  0 0000011111100111000101110110|        Faultadr to mtval. Prepare get offset
    * 74 BrOpFet  Fetch2   e 0010000001011111011011110100| NewOp2 Read until instruction latched
    * 75 BAlignEr BAERR_1  0 00100000000101x0xxxx01110011|  Err   Branch target instruction address misaligned
    * 76 BAERR_2  BAERR_3  0 0010000000010111100001110111|        ~offset to Q. Prep read (origPC+offset)
    * 77 BAERR_3  BAERR_4  4 0000011011010110x10001111101|        origPC to mepc. Prep read 0
    * 78 _L0x78   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 79 _L0x79   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 7a SB_5     SW_2     0 0000000101100110100111110010|        Write d to a+k until accepted
    * 7b _L0x7b   JAL_1    3 0010000000010110111000110010| JAL    J-imm is in q. Branch on alignfault
    * 7c CSRRC_0  CSRRW_1  0 0000011000110111011001001001| CSRRC  Decoded CSR adr in yy
    * 7d BAERR_4  JAL_3    0 0001111101001110x00100110100|        Store 0 to mcause. Prep get trap entry pont
    * 7e NMI_1    NMI_2    0 000001101xxxx111000110010000|        Store pc to mepc.
    * 7f JALRE2   BAERR_4  0 0000011111010110x00101111101|        mtval is target
    * 80 LBU_0    LBU_1    0 0110000001101011110010000101| LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.
    * 81 JAERR_2  BAERR_4  0 0000011011010110x00101111101|        Store PC to mepc
    * 82 _L0x82   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 83 _L0x83   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 84 XORI_0   XORI_1   0 0010000001111111101000100001| XORI   Xor immediate. Q=~Iimm
    * 85 LBU_1    LBU_2    1 0010000001011111100111110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 86 JAL_2    JAL_25   4 0000001000010100x10010011110|        Return address to TRG
    * 87 JALRE1   JALRE2   0 0000011011100110x00101111111|  err   Store pc to mepc
    * 88 _L0x88   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 89 unx89             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| 89: Not in use 
    * 8a _L0x8a   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 8b LB_6     StdIncPc 4 0000001000010111010011100110|        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80
    * 8c XOR_0    XOR_1    0 00100000011111x10xxx00101001| XOR    xor
    * 8d unx8d             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| 8d: Not in use 
    * 8e _LCSRRS_1 ILLe     0 001000000xxxx1x0xxxx11111110| Illegal instruction seen
    * 8f ILL_3    ILL_4    4 0010000001010111110010101001|        Q = 1
    * 90 NMI_2    JAL_3    0 0001111110100111011000110100|        mtval = 0.
    * 91 LDAF_2   LDAF_3   4 0001111100010100x10010010010|        Store 4 to mcause
    * 92 LDAF_3   JAL_3    0 0000011011001110x00100110100|        PC to mepc
    * 93 SW_E2    SW_E3    0 0000011011011111000110010101|        Store address that faulted
    * 94 SW_E4    JAL_3    0 0001111101001110x10100110100|        Store 6 to mcause
    * 95 SW_E3    SW_E4    4 0010000001011101110010010100|        Q = 3
    * 96 SH_1     SH_2     7 0000011001011111100110111011|        Write d to Q and yy (for sh 0). Prep shift
    * 97 SW_E1SWH SW_E2    0 0000011110010110x11010010011|        Store faulting address alignment to mtval
    * 98 BLT      condb_2  0 0000011001110111011000010011| BLT    Conditional Branch. Offset to Ryy
    * 99 _L0x99   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 9a ECALL_6  JAL_3    0 0001111101001100x10000110100|        mcause = 11
    * 9b SH_4     SH_5     0 1110000011100111100110011111|        Address back to Q. Prepare get item to write
    * 9c _L0x9c   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 9d unx9d             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| 9d: Not in use 
    * 9e JAL_25   JAL_3    0 0000010001100110x00100110100|        Instr. adr. to jj in case of access error
    * 9f SH_5     SW_2     0 0000000011100110100111110010|        Write d to a+k until accepted
    * a0 LHU_0    LHU_1    2 0100011001101011110001011110| LHU    Load unsigned hword. Q = rdadr=RS1+Iimm
    * a1 ECALL_4  ECALL_5  4 0010000001010101110010110110|        Q = 4
    * a2 _L0xa2   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * a3 _L0xa3   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * a4 SRxI_0   SRxI_1   7 0010000001111010x11000111010| SRxI   Shift Right immediate (both logic/arith here)
    * a5 MRET_3   MRET_4   4 0010000000110111110010101111|        0x102 + 0xff + 1 = 0x202
    * a6 ECAL_RET ECALL_1  3 0010000001011110111011010000| ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET
    * a7 EBRKWFI1 EBRKWFI2 0 001000000xxxx111110001100001| EBREAK/WFI1 Prepare select EBREAK or WFI
    * a8 _L0xa8   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * a9 ILL_4    JAL_3    4 0001111101001110x10000110100|        Store 2 to mcause
    * aa _L0xaa   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * ab EBREAK_2 ECALL_6  0 0000011011010111000110011010|        pc to mepc
    * ac _L0xac   SRx_1    0 00100000011101x0xxxx00111111| SRx    Shift Right (both SRL and SRA)
    * ad unxad             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| ad: Not in use 
    * ae _L0xae   SRx_1    0 00100000011101x0xxxx00111111| SRx    Shift Right (both SRL and SRA)
    * af MRET_4   MRET_5   4 001000000xxxx111110011000101|        0x202 + 0xff + 1 = 0x302
    * b0 aF_SW_3  LDAF_3   0 0001111100010100x10010010010|        Store 7 to mcause
    * b1 CSRRW_3  CSRRW_4  4 0010000001010101110010110010|        Prep emulation entrypt 0x108, here Q to 0x104
    * b2 CSRRW_4  Fetch    6 0100010001101100110011011110|        IncPC, OpFetch, but force +4
    * b3 unxb3             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| b3: Not in use 
    * b4 i0reserv          7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| Not in use, reserved to allow LASTINCH
    * b5 SH_3     SH_4     0 0010000000000111011010011011|        Prepare get back address to use 
    * b6 ECALL_5  ECALL_6  4 0010000001010101110010011010|        Q = 8
    * b7 IJ_3     IJ_4     0 0010000001100101110010111101|        Construct Q = 3
    * b8 BGE      condb_2  0 0000011001110111011000010011| BGE    Conditional Branch. Offset to Ryy
    * b9 _L0xb9   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * ba LHU_3    ANDI_1   0 0010000000111111101000011010|        Invert q. Prepare read mask
    * bb SH_2     SH_3     a 0000011001011111110110110101|        Repeat shl until shreg = 0 (0,8 or 24 times)
    * bc CSRRWI_0 CSRRW_1  0 0000011000110111011001001001| CSRRWI Decoded CSR adr in yy
    * bd IJ_4     Fetch    9 0110000001101110101111011110|        Mask and use as PC
    * be IJ_1     IJ_2     9 0010000001011111100100011111|        Read until q=mem[(rs1+ofs)&~3u]
    * bf IJT_1    IJT_2    9 0010000001011111100111000001|        Exit CSR, enter trap
    * c0 _L0xc0   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * c1 IJT_2    IJT_3    0 0000011001010111011011101001|        Read word is to be masked with ~3u
    * c2 _L0xc2   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * c3 _L0xc3   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * c4 ORI_0    ORI_1    0 0000010001111111001011100001| ORI    Or immediate. jj=~Iimm
    * c5 MRET_5   MRET_6   0 0010000000000111101001101111|        ~302
    * c6 IJT_4    ILL_2    0 0000011011010111101101000111|        Mask and store to mepc and Q for read of instr
    * c7 QINT_1   QINT_2   0 000001101xxxx111000111001011|        Store pc to mepc.
    * c8 _L0xc8   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * c9 MRET_2   MRET_3   0 0010000000110101110010100101|        0xff+3 = 0x102
    * ca _L0xca   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * cb QINT_2   StdIncPc 0 0001111110100111011011100110|        mtval = 0.
    * cc OR_0     OR_1     0 00100000011111x10xxx00100110| OR     or
    * cd unxcd             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| cd: Not in use 
    * ce _LCSRRCI_1 ILLe     0 001000000xxxx1x0xxxx11111110| Illegal instruction seen
    * cf MRET_7   MRET_8   5 00100000001101x10xxx01001111|        Prepare emulation entry point 0x104
    * d0 ECALL_1  ECALL_2  4 0010000000010111110000110111| ECALL  Verify Imm==0x000
    * d1 MRET_1   MRET_2   0 0000010000110111011011001001| MRET   First save Imm, start build constant for check
    * d2 LB_2     LB_3     c 0010000001010111100100000110|        Repeat shr until shreg == 0 (0,8,16,24 times)
    * d3 aFaultd  aFault_1 0 0000011111010111011000011110|  err   LB Load access fault. Faulting adr to mtval
    * d4 aFault_2 LDAF_3   4 0001111100010110x10010010010|        Store 5 to mcause
    * d5 unxd5             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| d5: Not in use
    * d6 eILL0c   ILLe     0 001000000xxxx1x0xxxx11111110| Illegal instruction seen
    * d7 ECALL_3  ECALL_4  0 0000011111010111011010100001|        mtval = 0, now start the chore of 11 to mcause
    * d8 BLTU     condb_2  0 0000011001110111011000010011| BLTU   Conditional Branch. Offset to Ryy
    * d9 _L0xd9   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * da LDAF_a   LDAF_2   0 00100000010101x10xxx10010001|        Extra cycle after error detected write mtval
    * db jFault_1 LDAF_3   4 0000011100000110x10010010010|        Store 1 to mcause
    * dc CSRRSI_0 CSRRW_1  0 0000011000110111011001001001| CSRRSI Decoded CSR adr in yy
    * dd aF_SW_1  aF_SW_2  0 0000011111010111011011100101|  err   SW Store access fault. Faulting adr to mtval
    * de Fetch    Fetch2   f 0000010100011111011011110100|  Fr00  Read and latch instruction
    * df eFetch   Fetch2   e 0000010101011111011011110100|  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]
    * e0 _L0xe0   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * e1 ORI_1    ORI_2    0 0010000000000111100100011101|        Q = RS1
    * e2 _L0xe2   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * e3 _L0xe3   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * e4 ANDI_0   ANDI_1   0 0010000001111111101000011010| ANDI   And immediate. Q=~Iimm
    * e5 aF_SW_2  aF_SW_3  4 0010000001010101110010110000|        Q = 4
    * e6 StdIncPc Fetch    6 0100010001101100110011011110|  Fr00  IncPC, OpFetch
    * e7 aFault   aFault_1 0 0000011111010111011000011110|  err   Load access fault. Faulting adr to mtval
    * e8 _L0xe8   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * e9 IJT_3    IJT_4    0 0010000001100101110011000110|        Construct Q = 3
    * ea _L0xea   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * eb LH_3     LH_4     0 0010000000111111101001010110|        q = ~mem[rs1+ofs]
    * ec AND_0    AND_1    0 00100000011111x10xxx00010001| AND    And 
    * ed unxed             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| ed: Not in use
    * ee eILL0a   ILLe     0 001000000xxxx1x0xxxx11111110| Illegal instruction seen
    * ef WFI_5    Fetch    6 0100010101101100110011011110|        IncPC, OpFetch
    * f0 LBU_2    LBU_3    c 0010000001010111100101110010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * f1 aFaulte  aFault_1 0 0000011111010111011000011110|  err   LBU Load access fault. Faulting adr to mtval
    * f2 SW_2     StdIncPc 0 00100000000101x10xxx11100110|        Prepare read PC
    * f3 aF_SW    aF_SW_1  0 001000000xxxx1x01xxx11011101|  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf
    * f4 Fetch2            0 0000010111111111110000000000|  Fr00  Update ttime. Update I. Q=immediate. Use dinx
    * f5 jFault   jFault_1 0 0000011111010111011011011011|  err   Fetch access fault. Faulting adr to mtval
    * f6 WFI_1    WFI_2    4 0010000000000101110011111010| WFI    Chk offset=0x105. Now=0xff. Prep 0xff+4 = 0x103
    * f7 EBREAK_1 EBREAK_2 0 0000011110010111011010101011| EBREAK mepc = pc, store 0 to mtval
    * f8 BGEU     condb_2  0 0000011001110111011000010011| BGEU   Conditional Branch. Offset to Ryy
    * f9 _L0xf9   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * fa WFI_2    WFI_3    4 0010000001010111110001000101|        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104
    * fb SB_3     SB_4     0 0010000000000111011001101011|        Prepare get back address to use 
    * fc CSRRCI_0 CSRRW_1  0 0000011000110111011001001001| CSRRCI Decoded CSR adr in yy
    * fd NMI_0    NMI_1    0 00100000000101x10xxx01111110| NMI    Get current PC
    * fe ILLe     ILL_1    0 00100000000101x0xxxx01000110| Illegal
    * ff QINT_0   QINT_1   0 00100000000101x10xxx11000111| INT    Get current PC
    */
   localparam u0_0 = 256'h76e6501076e6790473863c5af88b3c5afb097a07480474e650e6fcbef9d2bc01;
   localparam u0_1 = 256'h76b75cd477e6eea66e3273e674417613fc74cede79167c15f81440fe781af88b;
   localparam u0_2 = 256'h76e6000076e6403e74303c9678213c967c1d70274804a63550e640fe70e6bc52;
   localparam u0_3 = 256'ha13aa135790376496e32793d40fe761371d7fd03f936e9de64817486f82b76e6;
   localparam u0_4 = 256'h7ce640fe0000503169b17c667c4b7c66718f61477c65fa2b40fe40fe7c0bfc50;
   localparam u0_5 = 256'h6edaf970fdfb76496e32f95d40fe40fe788b7b57761e79eb6edaf9546edaf1e6;
   localparam u0_6 = 256'h7ccf000000005031797a40fe000040fe669369f250effa2b40fe40fe72f740fe;
   localparam u0_7 = 256'h617d7190e13476496e3269f240fe40fe647d78774073f6f471767a1a761e79ba;
   localparam u0_8 = 256'h7ca940fe0000d02974e640fe000040fe617f449ef9f0fa2140fe40fe617dbc85;
   localparam u0_9 = 256'h69f26134000040fe799fc43440fe76136693f9bbdc94e534f195e13444927634;
   localparam u0_A = 256'h7cc5403f0000403f719a40fee43440fe7c61eed07cafa63a40fe40fe5cb6bc5e;
   localparam u0_B = 256'hf9c1f91febde7649fdb5fa1a40fe76135cbd5c9a769b00000000ccde5cb24492;
   localparam u0_C = 256'h504f40fe0000d02676e640fe5ca540fe71cb7b477a6ff2e140fe40fe76e940fe;
   localparam u0_D = 256'hf6f4f6f476e576496492509140fe761376a140fe00006492761e790676c97c37;
   localparam u0_E = 256'hccde40fe0000d011fa5640fe5cc640fe761eccde5cb0fa1a40fe40fe791d40fe;
   localparam u0_F = 256'h50c74046507e7649766b7c4540fe761376ab5cfa76dbfc0048dd50e6761e7972;
   localparam u1_0 = 256'h0021020700210207306100470202004702020203020100210201268612050606;
   localparam u1_1 = 256'h0065420500212205320100210065006734566456504642010207020002070207;
   localparam u1_2 = 256'h0021700000210207420020470207204702000047020172070201020000212466;
   localparam u1_3 = 256'h72077207c02500633201b025020000675068a025702594560079006102078021;
   localparam u1_4 = 256'h4205020070000207011d3e0742013e07007d006d420502070200020042063606;
   localparam u1_5 = 256'h007d1205a0650063320170650200020002040204007dc205007d1205007dd025;
   localparam u1_6 = 256'h42007000700002070e160200700002000079001f520102070200020050430200;
   localparam u1_7 = 256'h007d006801f400633201001602000200406d02010201e205007e0203007dc205;
   localparam u1_8 = 256'h42050200700002074021020070000200006e40211205020702000200006d0606;
   localparam u1_9 = 256'h000e0046700002000e0e01f40200006700797065420501f4006d006c41f101fa;
   localparam u1_A = 256'h4200020770000207006d020041f4020002003205420372070200020042052466;
   localparam u1_B = 256'h9205920596060063a065020302000067020642050200700070006446420501f1;
   localparam u1_C = 256'h520302007000020701fa0200020302000068006d020000470200020000650200;
   localparam u1_D = 256'he055f051007d00634070020502000067007d0200700041f1007dc20500434201;
   localparam u1_E = 256'h64560200700002070203020002060200007d6446420502070200020002000200;
   localparam u1_F = 256'h0201020102010063020042050200006700794200007d005f02000201007dc205;
   wire [31:0]   indir;
`ifdef verilator
   /* verilator lint_off UNUSED */
   wire [15:0]   sim_a;
   wire [15:0]   sim_b;
   /* verilator lint_on UNUSED */
`endif
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u0_0), .INIT_1(u0_1), .INIT_2(u0_2), .INIT_3(u0_3),
                   .INIT_4(u0_4), .INIT_5(u0_5), .INIT_6(u0_6), .INIT_7(u0_7),
                   .INIT_8(u0_8), .INIT_9(u0_9), .INIT_A(u0_A), .INIT_B(u0_B),
                   .INIT_C(u0_C), .INIT_D(u0_D), .INIT_E(u0_E), .INIT_F(u0_F)
                   ) ucode0
     (
      .RDATA( indir[15:0]         ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u1_0), .INIT_1(u1_1), .INIT_2(u1_2), .INIT_3(u1_3),
                   .INIT_4(u1_4), .INIT_5(u1_5), .INIT_6(u1_6), .INIT_7(u1_7),
                   .INIT_8(u1_8), .INIT_9(u1_9), .INIT_A(u1_A), .INIT_B(u1_B),
                   .INIT_C(u1_C), .INIT_D(u1_D), .INIT_E(u1_E), .INIT_F(u1_F)
                   ) ucode1
     (
      .RDATA( indir[31:16]        ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );

   assign d[0] = indir[0];
   assign d[1] = indir[1];
   assign d[2] = indir[2];
   assign d[3] = indir[3];
   assign d[4] = indir[4];
   assign d[5] = indir[5];
   assign d[6] = indir[6];
   assign d[7] = indir[7];
   assign d[11] = indir[8];
   assign d[12] = indir[9];
   assign d[13] = indir[10];
   assign d[16] = indir[11];
   assign d[17] = indir[12];
   assign d[19] = indir[13];
   assign d[20] = indir[14];
   assign d[22] = indir[15];
   assign d[23] = indir[16];
   assign d[24] = indir[17];
   assign d[25] = indir[18];
   assign d[26] = indir[19];
   assign d[27] = indir[20];
   assign d[28] = indir[21];
   assign d[29] = indir[22];
   assign d[36] = indir[23];
   assign d[37] = indir[24];
   assign d[39] = indir[25];
   assign d[40] = indir[26];
   assign d[41] = indir[27];
   // replaces = 000100111110000000001000001100011100000000
   SB_LUT4 #(.LUT_INIT(16'h1802)) cmb_d08(.O(d[8]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0150)) cmb_d09(.O(d[9]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0050)) cmb_d10(.O(d[10]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0020)) cmb_d14(.O(d[14]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'hc000)) cmb_d15(.O(d[15]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'he37f)) cmb_d21(.O(d[21]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h000c)) cmb_d31(.O(d[31]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0008)) cmb_d32(.O(d[32]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h6242)) cmb_d33(.O(d[33]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h1400)) cmb_d34(.O(d[34]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h4002)) cmb_d35(.O(d[35]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h6000)) cmb_d38(.O(d[38]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   assign d[42] = 1'b0;
   assign d[43] = 1'b0;
   assign d[44] = 1'b0;
   assign d[45] = 1'b0;
   assign d[46] = 1'b0;
   assign d[47] = 1'b0;
wire instr0100,instr1x110100;            bn_l4v #(.I(16'h0010)) leq0100(     .o(instr0100),     .i({minx[3:0]}));    bn_l4v #(.I(16'h8000)) leq1x110100( .o(instr1x110100), .i({minx[7],minx[5:4],instr0100}));    SB_DFFE reg_d18( .Q(d[18]), .C(clk), .E(progress_ucode), .D(instr1x110100));    assign d[30] = d[18];
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019-2020. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * Automatically generated from ../code/ucode.h by midgetv_indirectEBR.c.
 * Do not edit.
 * Optiones for this variant:
 *   No RVC
 *   No MULDIV
 *   minstret for instructions in SRAM
 */
/* Using LUTSIZE=4. Using 2 EBRs. Initial table has 42 columns
 * Removed:  000000000001000000000000000000000000000000 These are removed from consideration, replaced with hand-crafted Verilog code in the output stage
 * Reserved: 000000000000000000000000000000000000000000 Columns to be represented directly, not part of optimalization
 * Total columns to represent in EBRs: 42
 * 171 distinct lines in remaining untreated columns
 * c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 * 171 171 171 171 171 171 171 171 171 171 171   x 171 171 169 171 170 171 171 170 171 171 170 171 171 171 171 171 168 168 170 171 170 171 170 171 170 171 171 170 170 170  kill col 13  Tbl  40 cols 000000000001000000000000000010000000000000 has 168 unique lines.
 * 168 168 168 168 168 168 168 168 168 168 168   x 168 168 166 168 167 168 168 167 168 168 167 168 168 168 168 168     165 166 168 167 168 167 168 167 168 168 167 167 167  kill col 12  Tbl  39 cols 000000000001000000000000000011000000000000 has 165 unique lines.
 * 165 165 165 165 165 165 165 165 165 165 165   x 165 165 163 165 163 165 165 162 165 165 164 165 165 165 165 165         161 164 164 165 164 165 164 165 165 164 164 164  kill col 11  Tbl  38 cols 000000000001000000000000000011100000000000 has 161 unique lines.
 * 161 161 161 161 161 161 161 161 161 161 161   x 161 161 159 161 159 161 161 158 161 161 159 161 161 161 161 161             160 160 161 160 161 160 161 161 160 160 160  kill col 22  Tbl  37 cols 000000000001000000010000000011100000000000 has 158 unique lines.
 * 158 158 158 158 158 158 158 158 158 158 158   x 158 158 156 158 157 158 158     158 158 156 158 158 158 158 158             157 157 157 157 157 156 157 158 157 157 156  kill col 27  Tbl  36 cols 000000000001001000010000000011100000000000 has 156 unique lines.
 * 156 156 156 156 156 156 156 156 156 156 156   x 156 156     155 155 156 155     156 156 154 156 156 156 156 156             155 155 155 155 155 154 155 156 155 155 154  kill col 19  Tbl  35 cols 000000000001001000010010000011100000000000 has 154 unique lines.
 * 154 154 154 154 154 154 154 154 154 154 154   x 154 154     153 153 154 153     154 154     154 154 154 154 154             153 153 153 153 153 152 153 154 153 153 152  kill col  5  Tbl  34 cols 000000000001001000010010000011100000100000 has 152 unique lines.
 * 152 152 152 152 152 152 152 152 152 152 152   x 152 152     151 151 152 151     152 152     152 152 152 152 152             151 151 151 150 151     151 151 149 148 149  kill col  1  Tbl  33 cols 000000000001001000010010000011100000100010 has 148 unique lines.
 * 148 148 148 148 148 148 148 148 148 148 148   x 148 148     146 147 148 147     148 148     148 148 146 148 148             147 147 147 144 147     145 145 146     145  kill col  7  Tbl  32 cols 000000000001001000010010000011100010100010 has 144 unique lines.
 * 144 144 144 144 144 144 144 144 144 144 144   x 144 143     142 143 142 143     144 144     144 142 141 144 144             143 143 143     143     141 140 140     140  kill col  3  Tbl  31 cols 000000000001001000010010000011100010101010 has 140 unique lines.
 * 140 140 140 140 140 140 140 140 140 140 140   x 140 139     138 137 138 139     140 140     140 137 135 140 139             139 139 139     137     133     132     135  kill col  2  Tbl  30 cols 000000000001001000010010000011100010101110 has 132 unique lines.
 * 132 132 132 132 132 132 132 130 132 132 132   x 132 131     129 127 129 128     132 132     132 126 126 132 131             131 131 131     123     122             124  kill col  4  Tbl  29 cols 000000000001001000010010000011100010111110 has 122 unique lines.
 * 122 122 122 122 122 122 122 119 122 122 122   x 121 120     119 113 116 115     122 122     122 115 116 122 119             121 121 121     107                     110  kill col  6  Tbl  28 cols 000000000001001000010010000011100011111110 has 107 unique lines.
 * 107 107 107 107 107 107 107 105 107 106 106   x 105 105     105  96 100  98     107 107     107  99 100 107 104             106 106 106                              94  kill col  0  Tbl  27 cols 000000000001001000010010000011100011111111 has  94 unique lines.
 *  94  94  94  94  94  94  94  91  94  93  93   x  91  92      90  83  85  84      94  94      94  84  86  94  91              93  93  92                                  kill col 25  Tbl  26 cols 000000000001001010010010000011100011111111 has  83 unique lines.
 *  83  83  83  83  83  83  83  80  82  82  81   x  80  82      80      73  71      83  83      83  73  75  83  79              82  82  81                                  kill col 23  Tbl  25 cols 000000000001001010110010000011100011111111 has  71 unique lines.
 *  70  71  71  71  71  71  71  68  70  70  69   x  67  70      66      63          71  71      71  63  64  71  67              70  70  69                                  kill col 24  Tbl  24 cols 000000000001001011110010000011100011111111 has  63 unique lines.
 *  62  63  61  63  62  63  63  60  62  62  61   x  59  62      59                  63  63      63  57  56  62  60              62  62  61                                  kill col 16  Tbl  23 cols 000000000001001011110010010011100011111111 has  56 unique lines.
 *  55  56  54  56  55  56  56  53  55  55  54   x  51  55      52                  54  55      56  52      55  53              55  55  54                                  kill col 29  Tbl  22 cols 000000000001101011110010010011100011111111 has  51 unique lines.
 *  50  51  44  51  50  51  51  49  50  50  49   x      49      47                  50  50      51  47      50  48              50  50  49                                  kill col 39  Tbl  21 cols 001000000001101011110010010011100011111111 has  44 unique lines.
 *  43  43      44  43  44  44  42  43  43  42   x      40      39                  43  43      44  41      43  42              43  43  42                                  kill col 26  Tbl  20 cols 001000000001101111110010010011100011111111 has  39 unique lines.
 *  38  38      39  38  39  39  37  38  38  37   x      34                          38  38      38  35      38  37              38  38  37                                  kill col 28  Tbl  19 cols 001000000001111111110010010011100011111111 has  34 unique lines.
 *  33  31      33  33  33  34  32  33  33  31   x                                  33  33      33  30      33  33              33  33  32                                  kill col 17  Tbl  18 cols 001000000001111111110010110011100011111111 has  30 unique lines.
 *  29  26      29  29  29  30  28  29  29  27   x                                  28  27      29          29  29              29  29  28                                  kill col 40  Tbl  17 cols 011000000001111111110010110011100011111111 has  26 unique lines.
 *  24          25  25  24  26  24  24  25  24   x                                  24  23      25          25  25              25  25  24                                  kill col 20  Tbl  16 cols 011000000001111111110110110011100011111111 has  23 unique lines.
 *  21          22  22  21  23  21  21  22  22   x                                  22          22          22  22              22  22  21                                  kill col 41  Tbl  15 cols 111000000001111111110110110011100011111111 has  21 unique lines.
 *              20  20  19  21  19  19  20  20   x                                  20          20          20  20              20  20  19                                  kill col 36  Tbl  14 cols 111001000001111111110110110011100011111111 has  19 unique lines.
 *              18  17      19  17  17  18  18   x                                  18          18          18  18              18  18  17                                  kill col 37  Tbl  13 cols 111011000001111111110110110011100011111111 has  17 unique lines.
 *              16          17  15  15  16  16   x                                  16          16          16  16              16  16  15                                  kill col 34  Tbl  12 cols 111011010001111111110110110011100011111111 has  15 unique lines.
Possible good candidates for removal, columns : 8 33 
 *
 * Round 1: 000100101110000000001001001100011100000000  4 columns for indexes to table representing 12 original columns (uses 15 of 16 lines in indirect table).
 * Total columns to represent in EBRs: 34
 * 168 distinct lines in remaining untreated columns
 * c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 * 168 168 168   x 168 168   x 168   x   x   x   x 168 168 165 168 167 168 168 167   x 168 166   x 168 168   x   x 165 165 166   x   x   x 167 168 167 168 168 167 167 167  kill col 27  Tbl  28 cols 000100101111001000001001001100011100000000 has 165 unique lines.
 * 165 165 165   x 165 165   x 165   x   x   x   x 165 165     164 164 165 164 164   x 165 163   x 165 165   x   x 162 162 163   x   x   x 164 165 164 165 165 164 164 164  kill col 13  Tbl  27 cols 000100101111001000001001001110011100000000 has 162 unique lines.
 * 162 162 162   x 162 162   x 162   x   x   x   x 162 162     161 161 162 161 160   x 162 160   x 162 162   x   x     159 158   x   x   x 161 161 161 162 162 161 161 161  kill col 11  Tbl  26 cols 000100101111001000001001001110111100000000 has 158 unique lines.
 * 158 158 158   x 158 158   x 158   x   x   x   x 158 158     157 157 158 157 156   x 158 155   x 158 158   x   x     152       x   x   x 157 157 157 158 158 157 157 157  kill col 12  Tbl  25 cols 000100101111001000001001001111111100000000 has 152 unique lines.
 * 152 152 152   x 152 152   x 152   x   x   x   x 152 152     151 150 152 151 148   x 152 149   x 152 152   x   x               x   x   x 151 151 151 152 152 151 151 151  kill col 22  Tbl  24 cols 000100101111001000011001001111111100000000 has 148 unique lines.
 * 148 148 148   x 148 148   x 148   x   x   x   x 148 148     147 146 148 147       x 148 145   x 148 148   x   x               x   x   x 147 146 146 147 148 147 147 146  kill col 19  Tbl  23 cols 000100101111001000011011001111111100000000 has 145 unique lines.
 * 145 145 145   x 145 145   x 145   x   x   x   x 145 145     144 143 145 144       x 145       x 145 145   x   x               x   x   x 143 142 143 144 145 144 144 143  kill col  6  Tbl  22 cols 000100101111001000011011001111111101000000 has 142 unique lines.
 * 142 142 142   x 142 142   x 141   x   x   x   x 142 142     141 140 141 141       x 142       x 141 142   x   x               x   x   x 140     139 140 141 140 141 139  kill col  5  Tbl  21 cols 000100101111001000011011001111111101100000 has 139 unique lines.
 * 139 139 139   x 139 139   x 137   x   x   x   x 137 139     138 137 138 136       x 139       x 137 138   x   x               x   x   x 135         136 136 135 136 135  kill col  7  Tbl  20 cols 000100101111001000011011001111111111100000 has 135 unique lines.
 * 135 135 135   x 135 135   x 131   x   x   x   x 133 134     133 132 129 132       x 135       x 131 133   x   x               x   x   x             131 129 128 130 131  kill col  2  Tbl  19 cols 000100101111001000011011001111111111100100 has 128 unique lines.
 * 128 128 128   x 128 128   x 124   x   x   x   x 126 126     126 121 118 122       x 127       x 124 123   x   x               x   x   x             122 119     122 121  kill col 24  Tbl  18 cols 000100101111001001011011001111111111100100 has 118 unique lines.
 * 118 118 118   x 118 118   x 113   x   x   x   x 116 115     116 108     110       x 117       x 113 111   x   x               x   x   x             107 108     110 111  kill col  4  Tbl  17 cols 000100101111001001011011001111111111110100 has 107 unique lines.
 * 107 107 107   x 107 107   x 103   x   x   x   x 105 103     105  93      98       x 106       x 101  95   x   x               x   x   x                  93      94  94  kill col 25  Tbl  16 cols 000100101111001011011011001111111111110100 has  93 unique lines.
 *  93  93  93   x  93  93   x  89   x   x   x   x  91  89      91          82       x  92       x  83  82   x   x               x   x   x                  75      78  78  kill col  3  Tbl  15 cols 000100101111001011011011001111111111111100 has  75 unique lines.
 *  75  75  75   x  75  75   x  71   x   x   x   x  72  72      70          64       x  74       x  65  65   x   x               x   x   x                          61  64  kill col  1  Tbl  14 cols 000100101111001011011011001111111111111110 has  61 unique lines.
 *  60  59  61   x  61  60   x  57   x   x   x   x  58  57      56          50       x  59       x  50  53   x   x               x   x   x                              48  kill col  0  Tbl  13 cols 000100101111001011011011001111111111111111 has  48 unique lines.
 *  47  45  47   x  47  47   x  45   x   x   x   x  45  44      43          39       x  46       x  38  40   x   x               x   x   x                                  kill col 17  Tbl  12 cols 000100101111001011011011101111111111111111 has  38 unique lines.
 *  37  36  37   x  37  37   x  35   x   x   x   x  33  34      31          30       x  36       x      32   x   x               x   x   x                                  kill col 23  Tbl  11 cols 000100101111001011111011101111111111111111 has  30 unique lines.
 *  29  28  28   x  29  29   x  27   x   x   x   x  25  25      23                   x  27       x      24   x   x               x   x   x                                  kill col 26  Tbl  10 cols 000100101111001111111011101111111111111111 has  23 unique lines.
 *  22  21  21   x  22  22   x  20   x   x   x   x  19  20                           x  20       x      19   x   x               x   x   x                                  kill col 29  Tbl   9 cols 000100101111101111111011101111111111111111 has  19 unique lines.
 *  18  17  15   x  18  18   x  17   x   x   x   x      17                           x  15       x      15   x   x               x   x   x                                  kill col 39  Tbl   8 cols 001100101111101111111011101111111111111111 has  15 unique lines.
Possible good candidates for removal, columns : 16 20 
 *
 * Round 2: 110011010000010000000100010000000000000000  4 columns for indexes to table representing  8 original columns (uses 15 of 16 lines in indirect table).
 * Direct:  001000000000101111110010100011100011111111 21 columns
 * Can even chose 3 more columns to be represented directly.
 * Success. Use 2 EBRs, 17 LUTs.
 */

module v2_m_2ebr
  (
   input         clk,
   input [7:0]   minx,
   input         progress_ucode,
/* verilator lint_off UNOPTFLAT */
   output [47:0] d
/* verilator lint_on UNOPTFLAT */
   );
   /*
    *                      indirect_index 1
    * inx         next     | indirect index 0
    * || ucode    ucode    | | direct representation
    * 00 LB_0     LB_1     0 0 100011011110000000000001| LB     Load byte. q = rdadr=RS1+0fs
    * 01 LB_1     LB_2     1 1 1000101111001xx111010010|        Read until q=mem[rs1+ofs) & ~3u]
    * 02 IJ_0     IJ_1     2 2 100011011110000010111110| IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0
    * 03 _L0x03   StdIncPc 3 0 10000010x1xxxxx011100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 04 ADDI_0   StdIncPc 4 0 000000101110000011100110| ADDI   Add immediate. rd =RS1+Iimm (or joined)
    * 05 _L0x05   ADDI_0   1 0 10000010x0xxxxx000000100| AUIPC  q = imm20 (copy x/2)
    * 06 LB_3     LB_4     1 0 1000011011010xx000000111|        q = ~mem[rs1+ofs]
    * 07 LB_4     LB_5     1 0 1000010111011xx000001001|        q = (uint8_t) mem[rs1+Iimm]
    * 08 _L0x08   SB_1     5 0 010011101110000001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 09 LB_5     LB_6     1 0 1000010111000xx010001011|        q = D^0xffffffff^q = D^0x80
    * 0a _L0x0a   SB_1     5 0 010011101110000001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 0b JALR_2   JAL_2    4 3 0100001011011xx010000110|        Q = (RS1+imn) & 0xfffffffe
    * 0c ADD_0    ADDI_0   1 0 1000111011001xx000000100| ADD    add     Addition Q = RS1
    * 0d _L0x0d   StdIncPc 4 0 000000101111000011100110| LUI    q = imm20
    * 0e SUB_0    SUB_1    3 0 10001110x1xxxxx000010000| SUB    Subtraction
    * 0f _L0x0f   StdIncPc 4 0 000000101111000011100110| LUI    q = imm20
    * 10 SUB_1    LB_6     1 0 1000111111000xx010001011|        Q = ~RS2
    * 11 AND_1    ANDI_1   1 0 1000111011000xx000011010|        RS1^0xffffffff to Q
    * 12 _L0x12   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 13 condb_2  condb_3  1 0 1000111111000xx000010100|        ~RS2 in Q
    * 14 condb_3  condb_4  1 4 100000101110011000010101|        Calculate RS1+~RS2+1
    * 15 condb_4  condb_5  1 5 0100110011001xx000010110|        Branch on condition
    * 16 condb_5  Fetch    6 6 011011010011011011011110|        Branch not taken.
    * 17 condb_5t BrOpFet  6 3 011011011110000001110100|        Branch taken.
    * 18 BEQ      condb_2  4 0 010011101111000000010011| BEQ    Conditional Branch. Offset to Ryy
    * 19 JALR_0   JALR_1   4 0 010010101110000001000001| JALR   yy=RS1+imm
    * 1a ANDI_1   StdIncPc 4 0 0000001011011xx011100110|        rd = Iimm & RS1
    * 1b _L0x1b   JAL_1    1 3 100000101011000000110010| JAL    J-imm is in q. Branch on alignfault
    * 1c ECAL_BRK ECAL_RET 1 2 100010111011000010100110| ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI
    * 1d ORI_2    StdIncPc 4 0 000000101111100011100110|        rd = Iimm | RS1
    * 1e aFault_1 aFault_2 1 4 100010100110011011010100|        Q = 4
    * 1f IJ_2     IJ_3     4 0 010010101111000010110111|        Read word is to be masked with 2 lsb = 00
    * 20 LH_0     LH_1     7 2 010011011110000001010010| LH     Load hword. Q = rdadr=RS1+Iimm.
    * 21 XORI_1   StdIncPc 4 0 0000001011000xx011100110|        rd = Iimm ^ RS1
    * 22 _L0x22   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 23 _L0x23   StdIncPc 3 0 10000010x1xxxxx011100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 24 SLLI_0   SLLI_1   8 7 100011111011000000110101| SLLI   Shift left immediate.
    * 25 _L0x25   ADDI_0   1 0 10000010x0xxxxx000000100| AUIPC  q = imm20 (copy x/2)
    * 26 OR_1     OR_2     3 0 0100111011000xx000100111|        RS1^0xffffffff to jj
    * 27 OR_2     ORI_2    1 0 100000001110000000011101|        Q = rs2
    * 28 _L0x28   SH_1     5 2 010011101110000010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 29 XOR_1    XORI_1   1 0 1000111011000xx000100001|        Q = RS1^0xFFFFFFFF
    * 2a _L0x2a   SH_1     5 2 010011101110000010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 2b SLTIX_1  SLTIX_2  3 4 1000xxxx1110011000110000|        RS1 - imm / RS1 - RS2
    * 2c SLL_0    SLL_1    3 0 10001110x0xxxxx000111110| SLL    Shift left
    * 2d _L0x2d   StdIncPc 4 0 000000101111000011100110| LUI    q = imm20
    * 2e unx2e             8 7 xxxxxxxxxxxxxxxxxxxxxxxx| 2e: Not in use 
    * 2f _L0x2f   StdIncPc 4 0 000000101111000011100110| LUI    q = imm20
    * 30 SLTIX_2  StdIncPc 4 8 000000101111001011100110|        Registered ALU flag to rd
    * 31 SLTX_1   SLTIX_1  1 0 1000111111000xx000101011|        ~rs2 to Q
    * 32 JAL_1    JAL_2    4 0 010000101110000010000110|        Target adr to yy
    * 33 JAERR_1  JAERR_2  4 0 011100101010000010000001|  Err   JAL target adr misaligned, store to mtval
    * 34 JAL_3    Fetch    6 9 0110110110001xx011011110|        PC+imm/trap entrypt to PC. OpFetch
    * 35 SLLI_1   SLLI_2   9 7 0000101111001xx000110110|        Register to shift to Q (and TRG for shift 0)
    * 36 SLLI_2   _L0x03   a 7 000010111110100000000011|        Repeat Q = Q+Q until shregcnt == 0
    * 37 ECALL_2  ECALL_3  4 5 0101xxxx11001xx011010111|        mepc = pc, prep store 0 to mtval
    * 38 BNE      condb_2  4 0 010011101111000000010011| BNE    Conditional Branch. Offset to Ryy
    * 39 _L0x39   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 3a SRxI_1   SRxI_2   9 a 0000101011001xx100111101|        Register to shift to Q
    * 3b _L0x3b   JAL_1    1 3 100000101011000000110010| JAL    J-imm is in q. Branch on alignfault
    * 3c CSRRW_0  CSRRW_1  4 0 010001101111000001001001| CSRRW  Decoded CSR adr in yy
    * 3d SRxI_2   _L0x03   a a 0000101011001xx100000011|        Repeat Q >>= 1 until shregcnt == 0
    * 3e SLL_1    SLLI_1   8 7 1000111110001xx000110101|        Shiftamount was in low 5 bits of RS2
    * 3f SRx_1    SRxI_1   8 7 1000111110001xx000111010|        Shiftamount in low 5 bits of RS2
    * 40 LW_0     LW_1     6 3 100011011110000001010000| LW     Load word. Q=yy=rdadr=RS1+Iimm
    * 41 JALR_1   JALR_2   1 4 100011001110011000001011|        Q=1
    * 42 _L0x42   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 43 _L0x43   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 44 SLTI_0   SLTIX_1  1 0 1000111111010xx000101011| SLTI   Set less than immediate (signed)
    * 45 WFI_3    WFI_4    1 4 100010101110011001100101|        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105
    * 46 ILL_1    ILL_2    4 0 0101101010001xx001000111|        Store PC to mepc
    * 47 ILL_2    ILL_3    4 0 0111101011001xx010001111|        Store 0 to mtval
    * 48 _L0x48   SW_1     b 3 100011101110000001100110| SW     Store word. Q=wradr=RS1+Simm
    * 49 CSRRW_1  CSRRW_2  1 4 100000101110011001001011|        Construct PC storage adr
    * 4a _L0x4a   SW_1     b 3 100011101110000001100110| SW     Store word. Q=wradr=RS1+Simm
    * 4b CSRRW_2  CSRRW_3  c 0 0011101010001xx010110001|        Write PC to 0x100 start Prep emulation entrypt
    * 4c SLT_0    SLTX_1   3 0 10001110x1xxxxx000110001| SLT    Set less than (signed)
    * 4d unx4d             8 7 xxxxxxxxxxxxxxxxxxxxxxxx| 4d: Not in use 
    * 4e eILL0b   ILLe     3 0 1000xxxxx0xxxxx011111110| Illegal instruction seen
    * 4f MRET_8   StdIncPc 1 4 100010101110011011100110|        Prep +4
    * 50 LW_1     StdIncPc 4 b 0000101111001xx011100110|        Read until d=mem[(rs1+ofs) & ~3u]
    * 51 LDAF_LW  LDAF_a   9 0 011110101011000011011010|  err   LD AlignFault. Faulting adr to mtval
    * 52 LH_1     LH_2     1 1 1000101111001xx101010100|        Read until q=mem[(rs1+ofs) & ~3u]
    * 53 LDAF_LH  LDAF_a   9 0 011110101011000011011010|  err   LD AlignFault. Faulting adr to mtval
    * 54 LH_2     LH_3     d a 1000101011001xx111101011|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 55 aFaultb  aFault_1 4 0 011110101111000000011110|  err   LH Load access fault. Faulting adr to mtval
    * 56 LH_4     LH_5     1 0 1000100011011xx001010111|        q = (uint16_t) mem[rs1+Iimm]
    * 57 LH_5     LB_6     1 0 1000100011000xx010001011|        q = D^0xffffffff^q = D ^ 0x00008000
    * 58 _L0x58   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 59 _L0x59   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 5a SB_1     SB_2     9 7 0100101111001xx001011101|        Write d to Q and yy (for sh 0). Prep shift
    * 5b _L0x5b   JAL_1    1 3 100000101011000000110010| JAL    J-imm is in q. Branch on alignfault
    * 5c CSRRS_0  CSRRW_1  4 0 010001101111000001001001| CSRRS  Decoded CSR adr in yy
    * 5d SB_2     SB_3     a 7 010010111110100011111011|        Repeat shl until shreg = 0 (0,8,16 or 24 times)
    * 5e LHU_1    LHU_2    1 1 1000101111001xx101110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 5f LDAF_LHU LDAF_a   9 0 011110101011000011011010|  err   LD AlignFault. Faulting adr to mtval
    * 60 _L0x60   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 61 EBRKWFI2 EBREAK_1 3 5 0100011011010xx011110111| EBREAK/WFI2 Select EBREAK or WFI
    * 62 _L0x62   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 63 _L0x63   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 64 SLTIU_0  SLTIX_1  1 0 1000111111010xx000101011| SLTIU  Set less than immediate (unsigned)
    * 65 WFI_4    WFI_5    3 5 10000010x1xxxxx011101111|        Prepare read PC
    * 66 SW_1     SW_2     1 0 0011111010001xx011110010|        Write d to a+k until accepted
    * 67 SW_E1SWE SW_E2    4 0 011100101011000010010011|        Store faulting address alignment to mtval
    * 68 _L0x68   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 69 unx69             8 7 xxxxxxxxxxxxxxxxxxxxxxxx| 69: Not in use 
    * 6a _L0x6a   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 6b SB_4     SB_5     b 0 1010110011001xx001111010|        Address back to Q. Prepare get item to write
    * 6c SLTU_0   SLTX_1   3 0 10001110x1xxxxx000110001| SLTU   Set less than (unsigned)
    * 6d unx6d             8 7 xxxxxxxxxxxxxxxxxxxxxxxx| 6d: Not in use 
    * 6e unx6e             8 7 xxxxxxxxxxxxxxxxxxxxxxxx| 6e: Not in use 
    * 6f MRET_6   MRET_7   1 4 1000xxxx1110011011001111|        ~302 + origImm + 1 for branch decision
    * 70 LHU_2    LHU_3    d a 1000101011001xx110111010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 71 aFaultc  aFault_1 4 0 011110101111000000011110|  err   LHU Load access fault. Faulting adr to mtval
    * 72 LBU_3    ANDI_1   1 0 1000011011010xx000011010|        Invert q. Prepare read mask
    * 73 BAERR_1  BAERR_2  4 0 0111110011001xx001110110|        Faultadr to mtval. Prepare get offset
    * 74 BrOpFet  Fetch2   3 c 100010111111000011110100| NewOp2 Read until instruction latched
    * 75 BAlignEr BAERR_1  3 0 10000010x0xxxxx001110011|  Err   Branch target instruction address misaligned
    * 76 BAERR_2  BAERR_3  1 0 1000001011000xx001110111|        ~offset to Q. Prep read (origPC+offset)
    * 77 BAERR_3  BAERR_4  4 4 010110101010011001111101|        origPC to mepc. Prep read 0
    * 78 _L0x78   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 79 _L0x79   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 7a SB_5     SW_2     1 0 0010110010001xx011110010|        Write d to a+k until accepted
    * 7b _L0x7b   JAL_1    1 3 100000101011000000110010| JAL    J-imm is in q. Branch on alignfault
    * 7c CSRRC_0  CSRRW_1  4 0 010001101111000001001001| CSRRC  Decoded CSR adr in yy
    * 7d BAERR_4  JAL_3    e 0 0110100110001xx000110100|        Store 0 to mcause. Prep get trap entry pont
    * 7e NMI_1    NMI_2    4 0 0101xxxx11001xx010010000|        Store pc to mepc.
    * 7f JALRE2   BAERR_4  4 0 0111101010001xx001111101|        mtval is target
    * 80 LBU_0    LBU_1    0 0 100011011110000010000101| LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.
    * 81 JAERR_2  BAERR_4  4 0 0101101010001xx001111101|        Store PC to mepc
    * 82 _L0x82   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 83 _L0x83   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 84 XORI_0   XORI_1   1 0 1000111111010xx000100001| XORI   Xor immediate. Q=~Iimm
    * 85 LBU_1    LBU_2    1 1 1000101111001xx111110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 86 JAL_2    JAL_25   4 4 000000100010011010011110|        Return address to TRG
    * 87 JALRE1   JALRE2   4 0 0101110010001xx001111111|  err   Store pc to mepc
    * 88 _L0x88   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 89 unx89             8 7 xxxxxxxxxxxxxxxxxxxxxxxx| 89: Not in use 
    * 8a _L0x8a   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 8b LB_6     StdIncPc 4 4 000000101110011011100110|        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80
    * 8c XOR_0    XOR_1    3 0 10001111x1xxxxx000101001| XOR    xor
    * 8d unx8d             8 7 xxxxxxxxxxxxxxxxxxxxxxxx| 8d: Not in use 
    * 8e _LCSRRS_1 ILLe     3 0 1000xxxxx0xxxxx011111110| Illegal instruction seen
    * 8f ILL_3    ILL_4    1 4 100010101110011010101001|        Q = 1
    * 90 NMI_2    JAL_3    e 0 011101001111000000110100|        mtval = 0.
    * 91 LDAF_2   LDAF_3   e 4 011000100010011010010010|        Store 4 to mcause
    * 92 LDAF_3   JAL_3    4 0 0101100110001xx000110100|        PC to mepc
    * 93 SW_E2    SW_E3    4 0 0101101111001xx010010101|        Store address that faulted
    * 94 SW_E4    JAL_3    e 0 011010011010100000110100|        Store 6 to mcause
    * 95 SW_E3    SW_E4    1 4 100010110110011010010100|        Q = 3
    * 96 SH_1     SH_2     9 7 0100101111001xx010111011|        Write d to Q and yy (for sh 0). Prep shift
    * 97 SW_E1SWH SW_E2    4 0 011100101011000010010011|        Store faulting address alignment to mtval
    * 98 BLT      condb_2  4 0 010011101111000000010011| BLT    Conditional Branch. Offset to Ryy
    * 99 _L0x99   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 9a ECALL_6  JAL_3    e 0 011010010010000000110100|        mcause = 11
    * 9b SH_4     SH_5     b 0 1001110011001xx010011111|        Address back to Q. Prepare get item to write
    * 9c _L0x9c   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * 9d unx9d             8 7 xxxxxxxxxxxxxxxxxxxxxxxx| 9d: Not in use 
    * 9e JAL_25   JAL_3    3 0 0100110010001xx000110100|        Instr. adr. to jj in case of access error
    * 9f SH_5     SW_2     1 0 0001110010001xx011110010|        Write d to a+k until accepted
    * a0 LHU_0    LHU_1    7 2 010011011110000001011110| LHU    Load unsigned hword. Q = rdadr=RS1+Iimm
    * a1 ECALL_4  ECALL_5  1 4 100010100110011010110110|        Q = 4
    * a2 _L0xa2   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * a3 _L0xa3   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * a4 SRxI_0   SRxI_1   8 7 100011111011000000111010| SRxI   Shift Right immediate (both logic/arith here)
    * a5 MRET_3   MRET_4   1 4 100001101110011010101111|        0x102 + 0xff + 1 = 0x202
    * a6 ECAL_RET ECALL_1  1 3 100010111011000011010000| ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET
    * a7 EBRKWFI1 EBRKWFI2 1 0 1000xxxx1110000001100001| EBREAK/WFI1 Prepare select EBREAK or WFI
    * a8 _L0xa8   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * a9 ILL_4    JAL_3    e 4 011010011010011000110100|        Store 2 to mcause
    * aa _L0xaa   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * ab EBREAK_2 ECALL_6  4 0 0101101011001xx010011010|        pc to mepc
    * ac _L0xac   SRx_1    3 0 10001110x0xxxxx000111111| SRx    Shift Right (both SRL and SRA)
    * ad unxad             8 7 xxxxxxxxxxxxxxxxxxxxxxxx| ad: Not in use 
    * ae _L0xae   SRx_1    3 0 10001110x0xxxxx000111111| SRx    Shift Right (both SRL and SRA)
    * af MRET_4   MRET_5   1 4 1000xxxx1110011011000101|        0x202 + 0xff + 1 = 0x302
    * b0 aF_SW_3  LDAF_3   e 0 011000100010000010010010|        Store 7 to mcause
    * b1 CSRRW_3  CSRRW_4  1 4 100010100110011010110010|        Prep emulation entrypt 0x108, here Q to 0x104
    * b2 CSRRW_4  Fetch    6 6 010011010010011011011110|        IncPC, OpFetch, but force +4
    * b3 unxb3             8 7 xxxxxxxxxxxxxxxxxxxxxxxx| b3: Not in use 
    * b4 eFetch3           1 4 010111111110011000000000|  Fr10  Update minstret, Q=immediate. Use dinx
    * b5 SH_3     SH_4     3 0 100000001111000010011011|        Prepare get back address to use 
    * b6 ECALL_5  ECALL_6  1 4 100010100110011010011010|        Q = 8
    * b7 IJ_3     IJ_4     1 0 100011000110000010111101|        Construct Q = 3
    * b8 BGE      condb_2  4 0 010011101111000000010011| BGE    Conditional Branch. Offset to Ryy
    * b9 _L0xb9   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * ba LHU_3    ANDI_1   1 0 1000011111010xx000011010|        Invert q. Prepare read mask
    * bb SH_2     SH_3     a 7 010010111110100010110101|        Repeat shl until shreg = 0 (0,8 or 24 times)
    * bc CSRRWI_0 CSRRW_1  4 0 010001101111000001001001| CSRRWI Decoded CSR adr in yy
    * bd IJ_4     Fetch    6 9 1000110110011xx011011110|        Mask and use as PC
    * be IJ_1     IJ_2     1 9 1000101111001xx000011111|        Read until q=mem[(rs1+ofs)&~3u]
    * bf IJT_1    IJT_2    1 9 1000101111001xx011000001|        Exit CSR, enter trap
    * c0 _L0xc0   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * c1 IJT_2    IJT_3    4 0 010010101111000011101001|        Read word is to be masked with ~3u
    * c2 _L0xc2   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * c3 _L0xc3   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * c4 ORI_0    ORI_1    3 0 0100111111010xx011100001| ORI    Or immediate. jj=~Iimm
    * c5 MRET_5   MRET_6   1 0 1000000011010xx001101111|        ~302
    * c6 IJT_4    ILL_2    9 0 0101101011011xx001000111|        Mask and store to mepc and Q for read of instr
    * c7 QINT_1   QINT_2   4 0 0101xxxx11001xx011001011|        Store pc to mepc.
    * c8 _L0xc8   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * c9 MRET_2   MRET_3   1 0 100001100110000010100101|        0xff+3 = 0x102
    * ca _L0xca   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * cb QINT_2   StdIncPc e 0 011101001111000011100110|        mtval = 0.
    * cc OR_0     OR_1     3 0 10001111x1xxxxx000100110| OR     or
    * cd unxcd             8 7 xxxxxxxxxxxxxxxxxxxxxxxx| cd: Not in use 
    * ce _LCSRRCI_1 ILLe     3 0 1000xxxxx0xxxxx011111110| Illegal instruction seen
    * cf MRET_7   MRET_8   3 5 10000110x1xxxxx001001111|        Prepare emulation entry point 0x104
    * d0 ECALL_1  ECALL_2  1 4 100000101110011000110111| ECALL  Verify Imm==0x000
    * d1 MRET_1   MRET_2   3 0 010001101111000011001001| MRET   First save Imm, start build constant for check
    * d2 LB_2     LB_3     d a 1000101011001xx100000110|        Repeat shr until shreg == 0 (0,8,16,24 times)
    * d3 aFaultd  aFault_1 4 0 011110101111000000011110|  err   LB Load access fault. Faulting adr to mtval
    * d4 aFault_2 LDAF_3   e 4 011000101010011010010010|        Store 5 to mcause
    * d5 eFetch2  eFetch3  3 d 011100011110000010110100|  Fr10  Update ttime
    * d6 eILL0c   ILLe     3 0 1000xxxxx0xxxxx011111110| Illegal instruction seen
    * d7 ECALL_3  ECALL_4  4 0 011110101111000010100001|        mtval = 0, now start the chore of 11 to mcause
    * d8 BLTU     condb_2  4 0 010011101111000000010011| BLTU   Conditional Branch. Offset to Ryy
    * d9 _L0xd9   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * da LDAF_a   LDAF_2   3 0 10001010x1xxxxx010010001|        Extra cycle after error detected write mtval
    * db jFault_1 LDAF_3   4 4 011000001010011010010010|        Store 1 to mcause
    * dc CSRRSI_0 CSRRW_1  4 0 010001101111000001001001| CSRRSI Decoded CSR adr in yy
    * dd aF_SW_1  aF_SW_2  4 0 011110101111000011100101|  err   SW Store access fault. Faulting adr to mtval
    * de Fetch    Fetch2   3 e 011000111111000011110100|  Fr10  Read and latch instruction
    * df eFetch   eFetch2  3 c 011010111111000011010101|  Fr10  rep Read until d=mem[(rs1+ofs) & ~3u]
    * e0 _L0xe0   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * e1 ORI_1    ORI_2    1 0 1000000011001xx000011101|        Q = RS1
    * e2 _L0xe2   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * e3 _L0xe3   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * e4 ANDI_0   ANDI_1   1 0 1000111111010xx000011010| ANDI   And immediate. Q=~Iimm
    * e5 aF_SW_2  aF_SW_3  1 4 100010100110011010110000|        Q = 4
    * e6 StdIncPc Fetch    6 6 010011010010011011011110|  Fr10  IncPC, OpFetch
    * e7 aFault   aFault_1 4 0 011110101111000000011110|  err   Load access fault. Faulting adr to mtval
    * e8 _L0xe8   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * e9 IJT_3    IJT_4    1 0 100011000110000011000110|        Construct Q = 3
    * ea _L0xea   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * eb LH_3     LH_4     1 0 1000011111010xx001010110|        q = ~mem[rs1+ofs]
    * ec AND_0    AND_1    3 0 10001111x1xxxxx000010001| AND    And 
    * ed unxed             8 7 xxxxxxxxxxxxxxxxxxxxxxxx| ed: Not in use
    * ee eILL0a   ILLe     3 0 1000xxxxx0xxxxx011111110| Illegal instruction seen
    * ef WFI_5    Fetch    6 6 011011010010011011011110|        IncPC, OpFetch
    * f0 LBU_2    LBU_3    d a 1000101011001xx101110010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * f1 aFaulte  aFault_1 4 0 011110101111000000011110|  err   LBU Load access fault. Faulting adr to mtval
    * f2 SW_2     StdIncPc 3 0 10000010x1xxxxx011100110|        Prepare read PC
    * f3 aF_SW    aF_SW_1  1 0 1000xxxxx0xxxxx011011101|  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf
    * f4 Fetch2            1 d 011111111110000000000000|  Fr10  Update ttime. Update I. Q=immediate. Use dinx
    * f5 jFault   jFault_1 4 0 011110101111000011011011|  err   Fetch access fault. Faulting adr to mtval
    * f6 WFI_1    WFI_2    1 4 100000000110011011111010| WFI    Chk offset=0x105. Now=0xff. Prep 0xff+4 = 0x103
    * f7 EBREAK_1 EBREAK_2 4 0 011100101111000010101011| EBREAK mepc = pc, store 0 to mtval
    * f8 BGEU     condb_2  4 0 010011101111000000010011| BGEU   Conditional Branch. Offset to Ryy
    * f9 _L0xf9   ILLe     3 0 1000xxxxx0xxxxx011111110|  Not in use (illegal as entry)
    * fa WFI_2    WFI_3    1 4 100010101110011001000101|        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104
    * fb SB_3     SB_4     3 0 100000001111000001101011|        Prepare get back address to use 
    * fc CSRRCI_0 CSRRW_1  4 0 010001101111000001001001| CSRRCI Decoded CSR adr in yy
    * fd NMI_0    NMI_1    3 0 10000010x1xxxxx001111110| NMI    Get current PC
    * fe ILLe     ILL_1    3 0 10000010x0xxxxx001000110| Illegal
    * ff QINT_0   QINT_1   3 0 10000010x1xxxxx011000111| INT    Get current PC
    */
   localparam u0_0 = 256'hf0e64010f0e6c804d886e05ac08be05ad809d0070004e0e640e6e0bec9d2e001;
   localparam u0_1 = 256'hf0b766d4f8e6b0a6b032d8e6e041f013e07436dec816e615c01400fec01ac08b;
   localparam u0_2 = 256'hf0e60000f0e6003ee630e096c021e096e01dc0270004b03540e600fec0e6e052;
   localparam u0_3 = 256'h883a8835c903f049b032c93d00fef013c8d7e803c83688dea081e086c02bf2e6;
   localparam u0_4 = 256'he6e600fe0000403188b1e066e64be066c88f8847e665d02b00fe00fee60be050;
   localparam u0_5 = 256'hb0dac970e8fbf049b032c85d00fe00fec08bd857f01ec9ebb0dac954b0dac8e6;
   localparam u0_6 = 256'he6cf000000004031c87a00fe000000feb09388f240efd02b00fe00fed0f700fe;
   localparam u0_7 = 256'h887dc8908834f049b03288f200fe00fea67dc0770073f0f4c876d01af01ec9ba;
   localparam u0_8 = 256'he6a900fe00004029e6e600fe000000fe887f269ec9f0d02100fe00fe887de085;
   localparam u0_9 = 256'h88f28834000000fec89f203400fef013b093c8bb6694a834c89588342692f034;
   localparam u0_A = 256'he6c5003f0000003fc89a00fea63400fee061b0d0e6afb03a00fe00fe66b6e05e;
   localparam u0_B = 256'hc8c1c81f98def049e8b5d01a00fef01360bd669af09be600000026de66b22092;
   localparam u0_C = 256'h404f00fe00004026f0e600fe60a500fec8cbd847d06fd0e100fe00fef0e900fe;
   localparam u0_D = 256'hf0d5f0f4f0e5f049a692409100fef013f0a100fee0b4a692f01ec906f0c9e637;
   localparam u0_E = 256'h26de00fe00004011d05600fe60c600fef01e26de66b0d01a00fe00fec81d00fe;
   localparam u0_F = 256'h40c70046407ef049f06be64500fef013f0ab66faf0dbe00000dd40e6f01ec972;
   localparam u1_0 = 256'h4002308e4002108e4342504e1085504e10851086108240023082228d118b008d;
   localparam u1_1 = 256'h404a148a4002128b13824002404a404e636d666d154c1482108f3080108e108f;
   localparam u1_2 = 256'h400287004002308e3480524e108e524e1080304e1082878f308230804002724d;
   localparam u1_3 = 256'h878f878faa0a404613829a0a3080404e4550a70b970b696d40724042108f4802;
   localparam u1_4 = 256'h148a30808700308ec03ab38e1482b38e407a405a148a108f30803080148c638d;
   localparam u1_5 = 256'h907a118ba74b40461382974b3080308010881088407ada8a907a118b907a4b0b;
   localparam u1_6 = 256'h148087008700308eb0ac3080870030804072103e3582108f3080308035463080;
   localparam u1_7 = 256'h407a4050e06940461382102c30803080445a108230823c8b407c1086407ada8a;
   localparam u1_8 = 256'h148a30808700308f4402308087003080405c4402118b108f30803080405a008d;
   localparam u1_9 = 256'h101c304c87003080b09ce0693080404e4072974b148be069405b4059e462e074;
   localparam u1_A = 256'h1480308e8700308e405a3080e46930801080138b1486878f30803080148a724d;
   localparam u1_B = 256'h198b198b698d4046a74b10873080404e108c148a3080145f8700664d148ae062;
   localparam u1_C = 256'h358630808700308fe0743080108630804050905a1080304f30803080404a3080;
   localparam u1_D = 256'h3c6b3e63407a40464460308a3080404e407a30803d71e462407ada8a30461482;
   localparam u1_E = 256'h666d30808700308f10873080108c3080407a664d148a108f3080308010803080;
   localparam u1_F = 256'h30823082308240463080148a3080404e40721480407a1d7f10803082407ada8a;
   wire [31:0]   indir;
`ifdef verilator
   /* verilator lint_off UNUSED */
   wire [15:0]   sim_a;
   wire [15:0]   sim_b;
   /* verilator lint_on UNUSED */
`endif
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u0_0), .INIT_1(u0_1), .INIT_2(u0_2), .INIT_3(u0_3),
                   .INIT_4(u0_4), .INIT_5(u0_5), .INIT_6(u0_6), .INIT_7(u0_7),
                   .INIT_8(u0_8), .INIT_9(u0_9), .INIT_A(u0_A), .INIT_B(u0_B),
                   .INIT_C(u0_C), .INIT_D(u0_D), .INIT_E(u0_E), .INIT_F(u0_F)
                   ) ucode0
     (
      .RDATA( indir[15:0]         ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u1_0), .INIT_1(u1_1), .INIT_2(u1_2), .INIT_3(u1_3),
                   .INIT_4(u1_4), .INIT_5(u1_5), .INIT_6(u1_6), .INIT_7(u1_7),
                   .INIT_8(u1_8), .INIT_9(u1_9), .INIT_A(u1_A), .INIT_B(u1_B),
                   .INIT_C(u1_C), .INIT_D(u1_D), .INIT_E(u1_E), .INIT_F(u1_F)
                   ) ucode1
     (
      .RDATA( indir[31:16]        ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );

   assign d[0] = indir[0];
   assign d[1] = indir[1];
   assign d[2] = indir[2];
   assign d[3] = indir[3];
   assign d[4] = indir[4];
   assign d[5] = indir[5];
   assign d[6] = indir[6];
   assign d[7] = indir[7];
   assign d[8] = indir[8];
   assign d[9] = indir[9];
   assign d[10] = indir[10];
   assign d[11] = indir[11];
   assign d[12] = indir[12];
   assign d[13] = indir[13];
   assign d[17] = indir[14];
   assign d[19] = indir[15];
   assign d[22] = indir[16];
   assign d[23] = indir[17];
   assign d[24] = indir[18];
   assign d[25] = indir[19];
   assign d[26] = indir[20];
   assign d[27] = indir[21];
   assign d[29] = indir[22];
   assign d[39] = indir[23];
   // replaces = 000100101110000000001001001100000000000000
   SB_LUT4 #(.LUT_INIT(16'h0020)) cmb_d14(.O(d[14]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h5000)) cmb_d15(.O(d[15]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h2000)) cmb_d18(.O(d[18]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h7b7f)) cmb_d21(.O(d[21]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h000c)) cmb_d31(.O(d[31]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0008)) cmb_d32(.O(d[32]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h1a42)) cmb_d33(.O(d[33]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h1002)) cmb_d35(.O(d[35]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h1800)) cmb_d38(.O(d[38]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   // replaces = 110011010000010000000100010000000000000000
   SB_LUT4 #(.LUT_INIT(16'h3ee7)) cmb_d16(.O(d[16]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h7e5e)) cmb_d20(.O(d[20]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h4690)) cmb_d28(.O(d[28]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h2400)) cmb_d34(.O(d[34]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h4004)) cmb_d36(.O(d[36]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h5000)) cmb_d37(.O(d[37]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h08c5)) cmb_d40(.O(d[40]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0800)) cmb_d41(.O(d[41]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   assign d[42] = 1'b0;
   assign d[43] = 1'b0;
   assign d[44] = 1'b0;
   assign d[45] = 1'b0;
   assign d[46] = 1'b0;
   assign d[47] = 1'b0;
wire instr0100,instr1x110100;            bn_l4v #(.I(16'h0010)) leq0100(     .o(instr0100),     .i({minx[3:0]}));    bn_l4v #(.I(16'h8000)) leq1x110100( .o(instr1x110100), .i({minx[7],minx[5:4],instr0100}));    SB_DFFE reg_d18( .Q(d[30]), .C(clk), .E(progress_ucode), .D(instr1x110100));
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019-2020. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * Automatically generated from ../code/ucode.h by midgetv_indirectEBR.c.
 * Do not edit.
 * Optiones for this variant:
 *   No RVC
 *   No MULDIV
 *   minstret for instructions in SRAM and EBR
 */
/* Using LUTSIZE=4. Using 2 EBRs. Initial table has 42 columns
 * Removed:  000000000001000000000000000000000000000000 These are removed from consideration, replaced with hand-crafted Verilog code in the output stage
 * Reserved: 000000000000000000000000000000000000000000 Columns to be represented directly, not part of optimalization
 * Total columns to represent in EBRs: 42
 * 169 distinct lines in remaining untreated columns
 * c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 * 169 169 169 169 169 169 169 169 169 169 169   x 169 169 167 169 168 169 169 168 169 169 168 169 169 169 169 169 166 166 168 169 168 169 168 169 168 169 169 168 168 168  kill col 13  Tbl  40 cols 000000000001000000000000000010000000000000 has 166 unique lines.
 * 166 166 166 166 166 166 166 166 166 166 166   x 166 166 164 166 165 166 166 165 166 166 165 166 166 166 166 166     163 164 166 165 166 165 166 165 166 166 165 165 165  kill col 12  Tbl  39 cols 000000000001000000000000000011000000000000 has 163 unique lines.
 * 163 163 163 163 163 163 163 163 163 163 163   x 163 163 161 163 161 163 163 160 163 163 162 163 163 163 163 163         159 162 162 163 162 163 162 163 163 162 162 162  kill col 11  Tbl  38 cols 000000000001000000000000000011100000000000 has 159 unique lines.
 * 159 159 159 159 159 159 159 159 159 159 159   x 159 159 157 159 157 159 159 156 159 159 157 159 159 159 159 159             158 158 159 158 159 158 159 159 158 158 158  kill col 22  Tbl  37 cols 000000000001000000010000000011100000000000 has 156 unique lines.
 * 156 156 156 156 156 156 156 156 156 156 156   x 156 156 154 156 155 156 156     156 156 154 156 156 156 156 156             155 155 155 155 155 154 155 156 155 155 154  kill col 27  Tbl  36 cols 000000000001001000010000000011100000000000 has 154 unique lines.
 * 154 154 154 154 154 154 154 154 154 154 154   x 154 154     153 153 154 153     154 154 152 154 154 154 154 154             153 153 153 153 153 152 153 154 153 153 152  kill col 19  Tbl  35 cols 000000000001001000010010000011100000000000 has 152 unique lines.
 * 152 152 152 152 152 152 152 152 152 152 152   x 152 152     151 151 152 151     152 152     152 152 152 152 152             151 151 151 151 151 150 151 152 151 151 150  kill col  5  Tbl  34 cols 000000000001001000010010000011100000100000 has 150 unique lines.
 * 150 150 150 150 150 150 150 150 150 150 150   x 150 150     149 149 150 149     150 150     150 150 150 150 150             149 149 149 148 149     149 149 147 146 147  kill col  1  Tbl  33 cols 000000000001001000010010000011100000100010 has 146 unique lines.
 * 146 146 146 146 146 146 146 146 146 146 146   x 146 146     144 145 146 145     146 146     146 146 144 146 146             145 145 145 142 145     143 143 144     143  kill col  7  Tbl  32 cols 000000000001001000010010000011100010100010 has 142 unique lines.
 * 142 142 142 142 142 142 142 142 142 142 142   x 142 141     140 141 140 141     142 142     142 140 139 142 142             141 141 141     141     139 138 138     138  kill col  3  Tbl  31 cols 000000000001001000010010000011100010101010 has 138 unique lines.
 * 138 138 138 138 138 138 138 138 138 138 138   x 138 137     136 135 136 137     138 138     138 135 133 138 137             137 137 137     135     131     130     133  kill col  2  Tbl  30 cols 000000000001001000010010000011100010101110 has 130 unique lines.
 * 130 130 130 130 130 130 130 128 130 130 130   x 130 129     127 125 127 126     130 130     130 124 124 130 129             129 129 129     121     120             122  kill col  4  Tbl  29 cols 000000000001001000010010000011100010111110 has 120 unique lines.
 * 120 120 120 120 120 120 120 117 120 120 120   x 119 118     117 111 114 113     120 120     120 113 114 120 117             119 119 119     105                     108  kill col  6  Tbl  28 cols 000000000001001000010010000011100011111110 has 105 unique lines.
 * 105 105 105 105 105 105 105 103 105 104 104   x 103 103     103  94  98  96     105 105     105  97  98 105 102             104 104 104                              92  kill col  0  Tbl  27 cols 000000000001001000010010000011100011111111 has  92 unique lines.
 *  92  92  92  92  92  92  92  89  92  91  91   x  89  90      88  81  83  82      92  92      92  82  84  92  89              91  91  90                                  kill col 25  Tbl  26 cols 000000000001001010010010000011100011111111 has  81 unique lines.
 *  81  81  81  81  81  81  81  78  80  80  79   x  78  80      78      71  69      81  81      81  71  73  81  77              80  80  79                                  kill col 23  Tbl  25 cols 000000000001001010110010000011100011111111 has  69 unique lines.
 *  68  69  69  69  69  69  69  66  68  68  67   x  65  68      64      61          69  69      69  61  62  69  65              68  68  67                                  kill col 24  Tbl  24 cols 000000000001001011110010000011100011111111 has  61 unique lines.
 *  60  61  59  61  60  61  61  58  60  60  59   x  57  60      57                  61  61      61  55  55  61  58              60  60  59                                  kill col 17  Tbl  23 cols 000000000001001011110010100011100011111111 has  55 unique lines.
 *  54  53  53  55  54  55  55  52  54  54  53   x  51  54      50                  55  55      55      51  55  52              54  54  53                                  kill col 26  Tbl  22 cols 000000000001001111110010100011100011111111 has  50 unique lines.
 *  49  48  48  50  49  50  50  47  49  49  48   x  46  48                          49  50      49      46  50  47              49  49  48                                  kill col 29  Tbl  21 cols 000000000001101111110010100011100011111111 has  46 unique lines.
 *  45  44  38  46  45  46  46  44  45  45  44   x      43                          45  45      45      41  46  42              45  45  44                                  kill col 39  Tbl  20 cols 001000000001101111110010100011100011111111 has  38 unique lines.
 *  37  35      38  37  38  38  36  37  37  36   x      33                          37  36      37      34  38  35              37  37  36                                  kill col 28  Tbl  19 cols 001000000001111111110010100011100011111111 has  33 unique lines.
 *  32  29      33  32  33  33  31  32  32  30   x                                  32  31      32      29  33  31              32  32  31                                  kill col 40  Tbl  18 cols 011000000001111111110010100011100011111111 has  29 unique lines.
 *  27          29  28  28  29  27  27  28  27   x                                  28  27      28      25  29  27              28  28  27                                  kill col 16  Tbl  17 cols 011000000001111111110010110011100011111111 has  25 unique lines.
 *  23          24  24  23  25  23  23  24  23   x                                  23  22      24          25  24              24  24  23                                  kill col 20  Tbl  16 cols 011000000001111111110110110011100011111111 has  22 unique lines.
 *  20          21  21  20  22  20  20  21  21   x                                  21          21          22  21              21  21  20                                  kill col 41  Tbl  15 cols 111000000001111111110110110011100011111111 has  20 unique lines.
 *              19  19  18  20  18  18  19  19   x                                  19          19          20  19              19  19  18                                  kill col 36  Tbl  14 cols 111001000001111111110110110011100011111111 has  18 unique lines.
 *              17  16      18  16  16  17  17   x                                  17          17          18  17              17  17  16                                  kill col 37  Tbl  13 cols 111011000001111111110110110011100011111111 has  16 unique lines.
Possible good candidates for removal, columns : 8 33 34 
 *
 * Round 1: 000100111110000000001001001100011100000000  4 columns for indexes to table representing 13 original columns (uses 16 of 16 lines in indirect table).
 * Direct:  111011000000111111110110110011100011111111 28 columns
 * Success. Use 2 EBRs, 13 LUTs.
 */

module v3_m_2ebr
  (
   input         clk,
   input [7:0]   minx,
   input         progress_ucode,
/* verilator lint_off UNOPTFLAT */
   output [47:0] d
/* verilator lint_on UNOPTFLAT */
   );
   /*
    * inx         next     indirect index 0
    * || ucode    ucode    | direct representation
    * 00 LB_0     LB_1     0 0110000001101011110000000001| LB     Load byte. q = rdadr=RS1+0fs
    * 01 LB_1     LB_2     1 0010000001011111100111010010|        Read until q=mem[rs1+ofs) & ~3u]
    * 02 IJ_0     IJ_1     2 0110100001101111110010111110| IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0
    * 03 _L0x03   StdIncPc 0 00100000000101x10xxx11100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 04 ADDI_0   StdIncPc 0 0000001000010111010011100110| ADDI   Add immediate. rd =RS1+Iimm (or joined)
    * 05 _L0x05   ADDI_0   0 00100000000101x01xxx00000100| AUIPC  q = imm20 (copy x/2)
    * 06 LB_3     LB_4     0 0010000000110111101000000111|        q = ~mem[rs1+ofs]
    * 07 LB_4     LB_5     0 0010000000101111101100001001|        q = (uint8_t) mem[rs1+Iimm]
    * 08 _L0x08   SB_1     0 0000010001110011110001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 09 LB_5     LB_6     0 0010000000101111100010001011|        q = D^0xffffffff^q = D^0x80
    * 0a _L0x0a   SB_1     0 0000010001110011110001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 0b JALR_2   JAL_2    3 0000011000010111001110000110|        Q = (RS1+imn) & 0xfffffffe
    * 0c ADD_0    ADDI_0   0 0010000001110111100100000100| ADD    add     Addition Q = RS1
    * 0d _L0x0d   StdIncPc 0 0000001000010111011011100110| LUI    q = imm20
    * 0e SUB_0    SUB_1    0 00100000011101x10xxx00010000| SUB    Subtraction
    * 0f _L0x0f   StdIncPc 0 0000001000010111011011100110| LUI    q = imm20
    * 10 SUB_1    LB_6     0 0010000001111111100010001011|        Q = ~RS2
    * 11 AND_1    ANDI_1   0 0010000001110111100000011010|        RS1^0xffffffff to Q
    * 12 _L0x12   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 13 condb_2  condb_3  0 0010000001111111100000010100|        ~RS2 in Q
    * 14 condb_3  condb_4  4 0010000000010111110000010101|        Calculate RS1+~RS2+1
    * 15 condb_4  condb_5  5 0000010001100111100100010110|        Branch on condition
    * 16 condb_5  Fetch    6 0100010101101100111011011110|        Branch not taken.
    * 17 condb_5t BrOpFet  3 0100010101101111110001110100|        Branch taken.
    * 18 BEQ      condb_2  0 0000011001110111011000010011| BEQ    Conditional Branch. Offset to Ryy
    * 19 JALR_0   JALR_1   0 0000011001010111010001000001| JALR   yy=RS1+imm
    * 1a ANDI_1   StdIncPc 0 0000001000010111001111100110|        rd = Iimm & RS1
    * 1b _L0x1b   JAL_1    3 0010000000010110111000110010| JAL    J-imm is in q. Branch on alignfault
    * 1c ECAL_BRK ECAL_RET 2 0010000001011110111010100110| ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI
    * 1d ORI_2    StdIncPc 0 0000001000010111011111100110|        rd = Iimm | RS1
    * 1e aFault_1 aFault_2 4 0010000001010101110011010100|        Q = 4
    * 1f IJ_2     IJ_3     0 0000011001010111011010110111|        Read word is to be masked with 2 lsb = 00
    * 20 LH_0     LH_1     2 0100011001101011110001010010| LH     Load hword. Q = rdadr=RS1+Iimm.
    * 21 XORI_1   StdIncPc 0 0000001000010111000011100110|        rd = Iimm ^ RS1
    * 22 _L0x22   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 23 _L0x23   StdIncPc 0 00100000000101x10xxx11100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 24 SLLI_0   SLLI_1   7 0010000001111010x11000110101| SLLI   Shift left immediate.
    * 25 _L0x25   ADDI_0   0 00100000000101x01xxx00000100| AUIPC  q = imm20 (copy x/2)
    * 26 OR_1     OR_2     0 0000010001110111000000100111|        RS1^0xffffffff to jj
    * 27 OR_2     ORI_2    0 0010000000000111110000011101|        Q = rs2
    * 28 _L0x28   SH_1     2 0000010001110011110010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 29 XOR_1    XORI_1   0 0010000001110111100000100001|        Q = RS1^0xFFFFFFFF
    * 2a _L0x2a   SH_1     2 0000010001110011110010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 2b SLTIX_1  SLTIX_2  4 001000000xxxx111010000110000|        RS1 - imm / RS1 - RS2
    * 2c SLL_0    SLL_1    0 00100000011101x0xxxx00111110| SLL    Shift left
    * 2d _L0x2d   StdIncPc 0 0000001000010111011011100110| LUI    q = imm20
    * 2e unx2e             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| 2e: Not in use 
    * 2f _L0x2f   StdIncPc 0 0000001000010111011011100110| LUI    q = imm20
    * 30 SLTIX_2  StdIncPc 8 0000001000010111011011100110|        Registered ALU flag to rd
    * 31 SLTX_1   SLTIX_1  0 0010000001111111100000101011|        ~rs2 to Q
    * 32 JAL_1    JAL_2    0 0000011000010111010010000110|        Target adr to yy
    * 33 JAERR_1  JAERR_2  0 0000011110010110x10010000001|  Err   JAL target adr misaligned, store to mtval
    * 34 JAL_3    Fetch    9 0100010101101110100111011110|        PC+imm/trap entrypt to PC. OpFetch
    * 35 SLLI_1   SLLI_2   7 0000001001011111100100110110|        Register to shift to Q (and TRG for shift 0)
    * 36 SLLI_2   _L0x03   a 0000001001011111110100000011|        Repeat Q = Q+Q until shregcnt == 0
    * 37 ECALL_2  ECALL_3  5 000001101xxxx111000111010111|        mepc = pc, prep store 0 to mtval
    * 38 BNE      condb_2  0 0000011001110111011000010011| BNE    Conditional Branch. Offset to Ryy
    * 39 _L0x39   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 3a SRxI_1   SRxI_2   b 0000001001010111100100111101|        Register to shift to Q
    * 3b _L0x3b   JAL_1    3 0010000000010110111000110010| JAL    J-imm is in q. Branch on alignfault
    * 3c CSRRW_0  CSRRW_1  0 0000011000110111011001001001| CSRRW  Decoded CSR adr in yy
    * 3d SRxI_2   _L0x03   c 0000001001010111100100000011|        Repeat Q >>= 1 until shregcnt == 0
    * 3e SLL_1    SLLI_1   7 0010000001111010x00100110101|        Shiftamount was in low 5 bits of RS2
    * 3f SRx_1    SRxI_1   7 0010000001111010x00100111010|        Shiftamount in low 5 bits of RS2
    * 40 LW_0     LW_1     3 0110000001101111110001010000| LW     Load word. Q=yy=rdadr=RS1+Iimm
    * 41 JALR_1   JALR_2   4 0010000001100111110000001011|        Q=1
    * 42 _L0x42   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 43 _L0x43   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 44 SLTI_0   SLTIX_1  0 0010000001111111101000101011| SLTI   Set less than immediate (signed)
    * 45 WFI_3    WFI_4    4 0010000001010111110001100101|        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105
    * 46 ILL_1    ILL_2    0 0000011011010110x00101000111|        Store PC to mepc
    * 47 ILL_2    ILL_3    0 0000011111010111000110001111|        Store 0 to mtval
    * 48 _L0x48   SW_1     3 1110000001110111110001100110| SW     Store word. Q=wradr=RS1+Simm
    * 49 CSRRW_1  CSRRW_2  4 0010000000010111110001001011|        Construct PC storage adr
    * 4a _L0x4a   SW_1     3 1110000001110111110001100110| SW     Store word. Q=wradr=RS1+Simm
    * 4b CSRRW_2  CSRRW_3  0 0001000111010110100110110001|        Write PC to 0x100 start Prep emulation entrypt
    * 4c SLT_0    SLTX_1   0 00100000011101x10xxx00110001| SLT    Set less than (signed)
    * 4d unx4d             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| 4d: Not in use 
    * 4e eILL0b   ILLe     0 001000000xxxx1x0xxxx11111110| Illegal instruction seen
    * 4f MRET_8   StdIncPc 4 0010000001010111110011100110|        Prep +4
    * 50 LW_1     StdIncPc d 0000001001011111000111100110|        Read until d=mem[(rs1+ofs) & ~3u]
    * 51 LDAF_LW  LDAF_a   0 0000011111010110111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 52 LH_1     LH_2     1 0010000001011111100101010100|        Read until q=mem[(rs1+ofs) & ~3u]
    * 53 LDAF_LH  LDAF_a   0 0000011111010110111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 54 LH_2     LH_3     c 0010000001010111100111101011|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 55 aFaultb  aFault_1 0 0000011111010111011000011110|  err   LH Load access fault. Faulting adr to mtval
    * 56 LH_4     LH_5     0 0010000001000111101101010111|        q = (uint16_t) mem[rs1+Iimm]
    * 57 LH_5     LB_6     0 0010000001000111100010001011|        q = D^0xffffffff^q = D ^ 0x00008000
    * 58 _L0x58   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 59 _L0x59   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 5a SB_1     SB_2     7 0000011001011111100101011101|        Write d to Q and yy (for sh 0). Prep shift
    * 5b _L0x5b   JAL_1    3 0010000000010110111000110010| JAL    J-imm is in q. Branch on alignfault
    * 5c CSRRS_0  CSRRW_1  0 0000011000110111011001001001| CSRRS  Decoded CSR adr in yy
    * 5d SB_2     SB_3     a 0000011001011111110111111011|        Repeat shl until shreg = 0 (0,8,16 or 24 times)
    * 5e LHU_1    LHU_2    1 0010000001011111100101110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 5f LDAF_LHU LDAF_a   0 0000011111010110111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 60 _L0x60   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 61 EBRKWFI2 EBREAK_1 5 0000010000110111001011110111| EBREAK/WFI2 Select EBREAK or WFI
    * 62 _L0x62   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 63 _L0x63   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 64 SLTIU_0  SLTIX_1  0 0010000001111111101000101011| SLTIU  Set less than immediate (unsigned)
    * 65 WFI_4    WFI_5    5 00100000000101x10xxx11101111|        Prepare read PC
    * 66 SW_1     SW_2     0 0000000111110110100111110010|        Write d to a+k until accepted
    * 67 SW_E1SWE SW_E2    0 0000011110010110x11010010011|        Store faulting address alignment to mtval
    * 68 _L0x68   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 69 unx69             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| 69: Not in use 
    * 6a _L0x6a   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 6b SB_4     SB_5     0 1110000101100111100101111010|        Address back to Q. Prepare get item to write
    * 6c SLTU_0   SLTX_1   0 00100000011101x10xxx00110001| SLTU   Set less than (unsigned)
    * 6d unx6d             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| 6d: Not in use 
    * 6e unx6e             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| 6e: Not in use 
    * 6f MRET_6   MRET_7   4 001000000xxxx111110011001111|        ~302 + origImm + 1 for branch decision
    * 70 LHU_2    LHU_3    c 0010000001010111100110111010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 71 aFaultc  aFault_1 0 0000011111010111011000011110|  err   LHU Load access fault. Faulting adr to mtval
    * 72 LBU_3    ANDI_1   0 0010000000110111101000011010|        Invert q. Prepare read mask
    * 73 BAERR_1  BAERR_2  0 0000011111100111000101110110|        Faultadr to mtval. Prepare get offset
    * 74 BrOpFet  Fetch2   e 0010000001011111011011110100| NewOp2 Read until instruction latched
    * 75 BAlignEr BAERR_1  0 00100000000101x0xxxx01110011|  Err   Branch target instruction address misaligned
    * 76 BAERR_2  BAERR_3  0 0010000000010111100001110111|        ~offset to Q. Prep read (origPC+offset)
    * 77 BAERR_3  BAERR_4  4 0000011011010110x10001111101|        origPC to mepc. Prep read 0
    * 78 _L0x78   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 79 _L0x79   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 7a SB_5     SW_2     0 0000000101100110100111110010|        Write d to a+k until accepted
    * 7b _L0x7b   JAL_1    3 0010000000010110111000110010| JAL    J-imm is in q. Branch on alignfault
    * 7c CSRRC_0  CSRRW_1  0 0000011000110111011001001001| CSRRC  Decoded CSR adr in yy
    * 7d BAERR_4  JAL_3    0 0001111101001110x00100110100|        Store 0 to mcause. Prep get trap entry pont
    * 7e NMI_1    NMI_2    0 000001101xxxx111000110010000|        Store pc to mepc.
    * 7f JALRE2   BAERR_4  0 0000011111010110x00101111101|        mtval is target
    * 80 LBU_0    LBU_1    0 0110000001101011110010000101| LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.
    * 81 JAERR_2  BAERR_4  0 0000011011010110x00101111101|        Store PC to mepc
    * 82 _L0x82   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 83 _L0x83   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 84 XORI_0   XORI_1   0 0010000001111111101000100001| XORI   Xor immediate. Q=~Iimm
    * 85 LBU_1    LBU_2    1 0010000001011111100111110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 86 JAL_2    JAL_25   4 0000001000010100x10010011110|        Return address to TRG
    * 87 JALRE1   JALRE2   0 0000011011100110x00101111111|  err   Store pc to mepc
    * 88 _L0x88   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 89 unx89             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| 89: Not in use 
    * 8a _L0x8a   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 8b LB_6     StdIncPc 4 0000001000010111010011100110|        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80
    * 8c XOR_0    XOR_1    0 00100000011111x10xxx00101001| XOR    xor
    * 8d unx8d             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| 8d: Not in use 
    * 8e _LCSRRS_1 ILLe     0 001000000xxxx1x0xxxx11111110| Illegal instruction seen
    * 8f ILL_3    ILL_4    4 0010000001010111110010101001|        Q = 1
    * 90 NMI_2    JAL_3    0 0001111110100111011000110100|        mtval = 0.
    * 91 LDAF_2   LDAF_3   4 0001111100010100x10010010010|        Store 4 to mcause
    * 92 LDAF_3   JAL_3    0 0000011011001110x00100110100|        PC to mepc
    * 93 SW_E2    SW_E3    0 0000011011011111000110010101|        Store address that faulted
    * 94 SW_E4    JAL_3    0 0001111101001110x10100110100|        Store 6 to mcause
    * 95 SW_E3    SW_E4    4 0010000001011101110010010100|        Q = 3
    * 96 SH_1     SH_2     7 0000011001011111100110111011|        Write d to Q and yy (for sh 0). Prep shift
    * 97 SW_E1SWH SW_E2    0 0000011110010110x11010010011|        Store faulting address alignment to mtval
    * 98 BLT      condb_2  0 0000011001110111011000010011| BLT    Conditional Branch. Offset to Ryy
    * 99 _L0x99   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 9a ECALL_6  JAL_3    0 0001111101001100x10000110100|        mcause = 11
    * 9b SH_4     SH_5     0 1110000011100111100110011111|        Address back to Q. Prepare get item to write
    * 9c _L0x9c   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 9d unx9d             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| 9d: Not in use 
    * 9e JAL_25   JAL_3    0 0000010001100110x00100110100|        Instr. adr. to jj in case of access error
    * 9f SH_5     SW_2     0 0000000011100110100111110010|        Write d to a+k until accepted
    * a0 LHU_0    LHU_1    2 0100011001101011110001011110| LHU    Load unsigned hword. Q = rdadr=RS1+Iimm
    * a1 ECALL_4  ECALL_5  4 0010000001010101110010110110|        Q = 4
    * a2 _L0xa2   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * a3 _L0xa3   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * a4 SRxI_0   SRxI_1   7 0010000001111010x11000111010| SRxI   Shift Right immediate (both logic/arith here)
    * a5 MRET_3   MRET_4   4 0010000000110111110010101111|        0x102 + 0xff + 1 = 0x202
    * a6 ECAL_RET ECALL_1  3 0010000001011110111011010000| ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET
    * a7 EBRKWFI1 EBRKWFI2 0 001000000xxxx111110001100001| EBREAK/WFI1 Prepare select EBREAK or WFI
    * a8 _L0xa8   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * a9 ILL_4    JAL_3    4 0001111101001110x10000110100|        Store 2 to mcause
    * aa _L0xaa   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * ab EBREAK_2 ECALL_6  0 0000011011010111000110011010|        pc to mepc
    * ac _L0xac   SRx_1    0 00100000011101x0xxxx00111111| SRx    Shift Right (both SRL and SRA)
    * ad unxad             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| ad: Not in use 
    * ae _L0xae   SRx_1    0 00100000011101x0xxxx00111111| SRx    Shift Right (both SRL and SRA)
    * af MRET_4   MRET_5   4 001000000xxxx111110011000101|        0x202 + 0xff + 1 = 0x302
    * b0 aF_SW_3  LDAF_3   0 0001111100010100x10010010010|        Store 7 to mcause
    * b1 CSRRW_3  CSRRW_4  4 0010000001010101110010110010|        Prep emulation entrypt 0x108, here Q to 0x104
    * b2 CSRRW_4  Fetch    6 0100010001101100110011011110|        IncPC, OpFetch, but force +4
    * b3 unxb3             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| b3: Not in use 
    * b4 eFetch3           4 0000010011111111110000000000|  Fr11  Write minstret. Update I. Q=immediate, use dinx
    * b5 SH_3     SH_4     0 0010000000000111011010011011|        Prepare get back address to use 
    * b6 ECALL_5  ECALL_6  4 0010000001010101110010011010|        Q = 8
    * b7 IJ_3     IJ_4     0 0010000001100101110010111101|        Construct Q = 3
    * b8 BGE      condb_2  0 0000011001110111011000010011| BGE    Conditional Branch. Offset to Ryy
    * b9 _L0xb9   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * ba LHU_3    ANDI_1   0 0010000000111111101000011010|        Invert q. Prepare read mask
    * bb SH_2     SH_3     a 0000011001011111110110110101|        Repeat shl until shreg = 0 (0,8 or 24 times)
    * bc CSRRWI_0 CSRRW_1  0 0000011000110111011001001001| CSRRWI Decoded CSR adr in yy
    * bd IJ_4     Fetch    9 0110000001101110101111011110|        Mask and use as PC
    * be IJ_1     IJ_2     9 0010000001011111100100011111|        Read until q=mem[(rs1+ofs)&~3u]
    * bf IJT_1    IJT_2    9 0010000001011111100111000001|        Exit CSR, enter trap
    * c0 _L0xc0   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * c1 IJT_2    IJT_3    0 0000011001010111011011101001|        Read word is to be masked with ~3u
    * c2 _L0xc2   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * c3 _L0xc3   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * c4 ORI_0    ORI_1    0 0000010001111111001011100001| ORI    Or immediate. jj=~Iimm
    * c5 MRET_5   MRET_6   0 0010000000000111101001101111|        ~302
    * c6 IJT_4    ILL_2    0 0000011011010111101101000111|        Mask and store to mepc and Q for read of instr
    * c7 QINT_1   QINT_2   0 000001101xxxx111000111001011|        Store pc to mepc.
    * c8 _L0xc8   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * c9 MRET_2   MRET_3   0 0010000000110101110010100101|        0xff+3 = 0x102
    * ca _L0xca   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * cb QINT_2   StdIncPc 0 0001111110100111011011100110|        mtval = 0.
    * cc OR_0     OR_1     0 00100000011111x10xxx00100110| OR     or
    * cd unxcd             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| cd: Not in use 
    * ce _LCSRRCI_1 ILLe     0 001000000xxxx1x0xxxx11111110| Illegal instruction seen
    * cf MRET_7   MRET_8   5 00100000001101x10xxx01001111|        Prepare emulation entry point 0x104
    * d0 ECALL_1  ECALL_2  4 0010000000010111110000110111| ECALL  Verify Imm==0x000
    * d1 MRET_1   MRET_2   0 0000010000110111011011001001| MRET   First save Imm, start build constant for check
    * d2 LB_2     LB_3     c 0010000001010111100100000110|        Repeat shr until shreg == 0 (0,8,16,24 times)
    * d3 aFaultd  aFault_1 0 0000011111010111011000011110|  err   LB Load access fault. Faulting adr to mtval
    * d4 aFault_2 LDAF_3   4 0001111100010110x10010010010|        Store 5 to mcause
    * d5 unxd5             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| d5: Not in use
    * d6 eILL0c   ILLe     0 001000000xxxx1x0xxxx11111110| Illegal instruction seen
    * d7 ECALL_3  ECALL_4  0 0000011111010111011010100001|        mtval = 0, now start the chore of 11 to mcause
    * d8 BLTU     condb_2  0 0000011001110111011000010011| BLTU   Conditional Branch. Offset to Ryy
    * d9 _L0xd9   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * da LDAF_a   LDAF_2   0 00100000010101x10xxx10010001|        Extra cycle after error detected write mtval
    * db jFault_1 LDAF_3   4 0000011100000110x10010010010|        Store 1 to mcause
    * dc CSRRSI_0 CSRRW_1  0 0000011000110111011001001001| CSRRSI Decoded CSR adr in yy
    * dd aF_SW_1  aF_SW_2  0 0000011111010111011011100101|  err   SW Store access fault. Faulting adr to mtval
    * de Fetch    Fetch2   e 0000010101011111011011110100|  Fr11  Read and latch instruction
    * df eFetch   Fetch2   e 0000010101011111011011110100|  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]
    * e0 _L0xe0   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * e1 ORI_1    ORI_2    0 0010000000000111100100011101|        Q = RS1
    * e2 _L0xe2   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * e3 _L0xe3   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * e4 ANDI_0   ANDI_1   0 0010000001111111101000011010| ANDI   And immediate. Q=~Iimm
    * e5 aF_SW_2  aF_SW_3  4 0010000001010101110010110000|        Q = 4
    * e6 StdIncPc Fetch    6 0100010001101100110011011110|  Fr11  IncPC, OpFetch
    * e7 aFault   aFault_1 0 0000011111010111011000011110|  err   Load access fault. Faulting adr to mtval
    * e8 _L0xe8   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * e9 IJT_3    IJT_4    0 0010000001100101110011000110|        Construct Q = 3
    * ea _L0xea   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * eb LH_3     LH_4     0 0010000000111111101001010110|        q = ~mem[rs1+ofs]
    * ec AND_0    AND_1    0 00100000011111x10xxx00010001| AND    And 
    * ed unxed             7 xxxxxxxxxxxxxxxxxxxxxxxxxxxx| ed: Not in use
    * ee eILL0a   ILLe     0 001000000xxxx1x0xxxx11111110| Illegal instruction seen
    * ef WFI_5    Fetch    6 0100010101101100110011011110|        IncPC, OpFetch
    * f0 LBU_2    LBU_3    c 0010000001010111100101110010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * f1 aFaulte  aFault_1 0 0000011111010111011000011110|  err   LBU Load access fault. Faulting adr to mtval
    * f2 SW_2     StdIncPc 0 00100000000101x10xxx11100110|        Prepare read PC
    * f3 aF_SW    aF_SW_1  0 001000000xxxx1x01xxx11011101|  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf
    * f4 Fetch2   eFetch3  f 0000010110001111010010110100|  Fr11  Update ttime. Update I. Q=immediate. Use dinx
    * f5 jFault   jFault_1 0 0000011111010111011011011011|  err   Fetch access fault. Faulting adr to mtval
    * f6 WFI_1    WFI_2    4 0010000000000101110011111010| WFI    Chk offset=0x105. Now=0xff. Prep 0xff+4 = 0x103
    * f7 EBREAK_1 EBREAK_2 0 0000011110010111011010101011| EBREAK mepc = pc, store 0 to mtval
    * f8 BGEU     condb_2  0 0000011001110111011000010011| BGEU   Conditional Branch. Offset to Ryy
    * f9 _L0xf9   ILLe     0 001000000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * fa WFI_2    WFI_3    4 0010000001010111110001000101|        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104
    * fb SB_3     SB_4     0 0010000000000111011001101011|        Prepare get back address to use 
    * fc CSRRCI_0 CSRRW_1  0 0000011000110111011001001001| CSRRCI Decoded CSR adr in yy
    * fd NMI_0    NMI_1    0 00100000000101x10xxx01111110| NMI    Get current PC
    * fe ILLe     ILL_1    0 00100000000101x0xxxx01000110| Illegal
    * ff QINT_0   QINT_1   0 00100000000101x10xxx11000111| INT    Get current PC
    */
   localparam u0_0 = 256'h76e6501076e6790473863c5af88b3c5afb097a07480474e650e6fcbef9d2bc01;
   localparam u0_1 = 256'h76b75cd477e6eea66e3273e674417613fc74cede79167c15f81440fe781af88b;
   localparam u0_2 = 256'h76e6000076e6403e74303c9678213c967c1d70274804a63550e640fe70e6bc52;
   localparam u0_3 = 256'ha13aa135790376496e32793d40fe761371d7fd03f936e9de64817486f82b76e6;
   localparam u0_4 = 256'h7ce640fe0000503169b17c667c4b7c66718f61477c65fa2b40fe40fe7c0bfc50;
   localparam u0_5 = 256'h6edaf970fdfb76496e32f95d40fe40fe788b7b57761e79eb6edaf9546edaf1e6;
   localparam u0_6 = 256'h7ccf000000005031797a40fe000040fe669369f250effa2b40fe40fe72f740fe;
   localparam u0_7 = 256'h617d7190e13476496e3269f240fe40fe647d78774073f6f471767a1a761e79ba;
   localparam u0_8 = 256'h7ca940fe0000d02974e640fe000040fe617f449ef9f0fa2140fe40fe617dbc85;
   localparam u0_9 = 256'h69f26134000040fe799fc43440fe76136693f9bbdc94e534f195e13444927634;
   localparam u0_A = 256'h7cc5403f0000403f719a40fee43440fe7c61eed07cafa63a40fe40fe5cb6bc5e;
   localparam u0_B = 256'hf9c1f91febde7649fdb5fa1a40fe76135cbd5c9a769bfc000000ccde5cb24492;
   localparam u0_C = 256'h504f40fe0000d02676e640fe5ca540fe71cb7b477a6ff2e140fe40fe76e940fe;
   localparam u0_D = 256'hf6f4f6f476e576496492509140fe761376a140fe00006492761e790676c97c37;
   localparam u0_E = 256'hccde40fe0000d011fa5640fe5cc640fe761eccde5cb0fa1a40fe40fe791d40fe;
   localparam u0_F = 256'h50c74046507e7649766b7c4540fe761376ab5cfa76dbf4b448dd50e6761e7972;
   localparam u1_0 = 256'h0021020700210207306100470202004702020203020100210201268612050606;
   localparam u1_1 = 256'h0065420500212205320100210065006734566456504642010207020002070207;
   localparam u1_2 = 256'h0021700000210207420020470207204702000047020172070201020000212466;
   localparam u1_3 = 256'h72077207c02500633201b025020000675068a025702594560079006102078021;
   localparam u1_4 = 256'h4205020070000207011d3e0742013e07007d006d420502070200020042063606;
   localparam u1_5 = 256'h007d1205a0650063320170650200020002040204007dc205007d1205007dd025;
   localparam u1_6 = 256'h42007000700002070e160200700002000079001f520102070200020050430200;
   localparam u1_7 = 256'h007d006801f400633201001602000200406d02010201e205007e0203007dc205;
   localparam u1_8 = 256'h42050200700002074021020070000200006e40211205020702000200006d0606;
   localparam u1_9 = 256'h000e0046700002000e0e01f40200006700797065420501f4006d006c41f101fa;
   localparam u1_A = 256'h4200020770000207006d020041f4020002003205420372070200020042052466;
   localparam u1_B = 256'h9205920596060063a065020302000067020642050200404f70006446420501f1;
   localparam u1_C = 256'h520302007000020701fa0200020302000068006d020000470200020000650200;
   localparam u1_D = 256'he055e055007d00634070020502000067007d0200700041f1007dc20500434201;
   localparam u1_E = 256'h64560200700002070203020002060200007d6446420502070200020002000200;
   localparam u1_F = 256'h0201020102010063020042050200006700794200007df05802000201007dc205;
   wire [31:0]   indir;
`ifdef verilator
   /* verilator lint_off UNUSED */
   wire [15:0]   sim_a;
   wire [15:0]   sim_b;
   /* verilator lint_on UNUSED */
`endif
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u0_0), .INIT_1(u0_1), .INIT_2(u0_2), .INIT_3(u0_3),
                   .INIT_4(u0_4), .INIT_5(u0_5), .INIT_6(u0_6), .INIT_7(u0_7),
                   .INIT_8(u0_8), .INIT_9(u0_9), .INIT_A(u0_A), .INIT_B(u0_B),
                   .INIT_C(u0_C), .INIT_D(u0_D), .INIT_E(u0_E), .INIT_F(u0_F)
                   ) ucode0
     (
      .RDATA( indir[15:0]         ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u1_0), .INIT_1(u1_1), .INIT_2(u1_2), .INIT_3(u1_3),
                   .INIT_4(u1_4), .INIT_5(u1_5), .INIT_6(u1_6), .INIT_7(u1_7),
                   .INIT_8(u1_8), .INIT_9(u1_9), .INIT_A(u1_A), .INIT_B(u1_B),
                   .INIT_C(u1_C), .INIT_D(u1_D), .INIT_E(u1_E), .INIT_F(u1_F)
                   ) ucode1
     (
      .RDATA( indir[31:16]        ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );

   assign d[0] = indir[0];
   assign d[1] = indir[1];
   assign d[2] = indir[2];
   assign d[3] = indir[3];
   assign d[4] = indir[4];
   assign d[5] = indir[5];
   assign d[6] = indir[6];
   assign d[7] = indir[7];
   assign d[11] = indir[8];
   assign d[12] = indir[9];
   assign d[13] = indir[10];
   assign d[16] = indir[11];
   assign d[17] = indir[12];
   assign d[19] = indir[13];
   assign d[20] = indir[14];
   assign d[22] = indir[15];
   assign d[23] = indir[16];
   assign d[24] = indir[17];
   assign d[25] = indir[18];
   assign d[26] = indir[19];
   assign d[27] = indir[20];
   assign d[28] = indir[21];
   assign d[29] = indir[22];
   assign d[36] = indir[23];
   assign d[37] = indir[24];
   assign d[39] = indir[25];
   assign d[40] = indir[26];
   assign d[41] = indir[27];
   // replaces = 000100111110000000001001001100011100000000
   SB_LUT4 #(.LUT_INIT(16'h1802)) cmb_d08(.O(d[8]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0150)) cmb_d09(.O(d[9]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0050)) cmb_d10(.O(d[10]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0020)) cmb_d14(.O(d[14]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h4000)) cmb_d15(.O(d[15]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h8000)) cmb_d18(.O(d[18]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'he37f)) cmb_d21(.O(d[21]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h000c)) cmb_d31(.O(d[31]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0008)) cmb_d32(.O(d[32]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h6242)) cmb_d33(.O(d[33]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h1400)) cmb_d34(.O(d[34]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h4002)) cmb_d35(.O(d[35]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h6000)) cmb_d38(.O(d[38]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   assign d[42] = 1'b0;
   assign d[43] = 1'b0;
   assign d[44] = 1'b0;
   assign d[45] = 1'b0;
   assign d[46] = 1'b0;
   assign d[47] = 1'b0;
wire instrxxxx0100,instr1011xxxx,instr10110100;          bn_l4v #(.I(16'h0010)) leq0100(     .o(instrxxxx0100),     .i({minx[3:0]}));  bn_l4v #(.I(16'h0800)) leq1011(     .o(instr1011xxxx),     .i({minx[7:4]}));  bn_l4v #(.I(16'h8888)) leq1x110100( .o(instr10110100), .i({2'b0,instr1011xxxx,instrxxxx0100}));   SB_DFFE reg_d18( .Q(d[30]), .C(clk), .E(progress_ucode), .D(instr10110100));
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019-2020. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * Automatically generated from ../code/ucode.h by midgetv_indirectEBR.c.
 * Do not edit.
 * Optiones for this variant:
 *   No RVC
 *   MULDIV included
 *   minstret not implemented
 */
/* Using LUTSIZE=4. Using 2 EBRs. Initial table has 45 columns
 * Removed:  000000000000001000000000001000000000000000000 These are removed from consideration, replaced with hand-crafted Verilog code in the output stage
 * Reserved: 000000000000000000000000000000000000000000000 Columns to be represented directly, not part of optimalization
 * Total columns to represent in EBRs: 45
 * 210 distinct lines in remaining untreated columns
 * c44 c43 c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 * 210 209 210 210 210 210 210 210 210 210 210 210 210 210   x 210 210 208 210 209 210 209 209 210 210 210   x 210 210 210 210 208 208 208 210 209 210 209 210 209 210 210 209 208 209  kill col 27  Tbl  42 cols 000000000000001001000000001000000000000000000 has 208 unique lines.
 * 208 207 208 208 208 208 208 208 208 208 208 208 208 208   x 208 208     207 207 208 206 207 208 208 208   x 208 208 208 208 206 206 206 208 207 208 207 208 207 208 208 207 206 207  kill col 23  Tbl  41 cols 000000000000001001000100001000000000000000000 has 206 unique lines.
 * 206 205 206 206 206 206 206 206 206 206 206 206 206 206   x 206 206     205 204 206     205 206 206 206   x 206 206 206 206 204 204 204 206 205 206 205 206 205 206 206 205 204 205  kill col 25  Tbl  40 cols 000000000000001001010100001000000000000000000 has 204 unique lines.
 * 204 203 204 204 204 204 204 204 204 204 204 204 204 204   x 204 204     203     204     203 204 204 204   x 204 204 204 204 202 201 202 204 203 204 202 204 203 204 204 203 202 203  kill col 12  Tbl  39 cols 000000000000001001010100001000001000000000000 has 201 unique lines.
 * 201 200 200 201 201 201 201 201 201 201 201 201 201 201   x 201 201     200     201     199 201 201 201   x 201 201 201 201 198     199 201 200 201 199 201 200 201 201 200 199 200  kill col 13  Tbl  38 cols 000000000000001001010100001000011000000000000 has 198 unique lines.
 * 198 197 197 198 198 198 198 198 198 198 198 198 198 198   x 198 198     197     198     196 198 198 198   x 198 198 198 198         195 198 197 198 196 198 197 197 198 197 196 197  kill col 11  Tbl  37 cols 000000000000001001010100001000011100000000000 has 195 unique lines.
 * 195 194 193 195 195 195 195 195 195 195 195 195 195 195   x 195 195     194     195     193 195 195 195   x 195 195 195 195             195 194 195 193 195 193 193 195 194 193 194  kill col 42  Tbl  36 cols 001000000000001001010100001000011100000000000 has 193 unique lines.
 * 193 191     193 193 193 193 193 193 193 193 193 193 193   x 193 193     192     193     191 193 193 192   x 193 193 193 193             193 192 193 191 193 191 191 193 192 191 192  kill col 43  Tbl  35 cols 011000000000001001010100001000011100000000000 has 191 unique lines.
 * 191         191 191 191 191 191 191 191 191 191 191 191   x 191 191     190     191     189 191 191 189   x 191 191 191 191             190 190 191 189 191 189 189 191 190 189 189  kill col 22  Tbl  34 cols 011000000000001001010110001000011100000000000 has 189 unique lines.
 * 189         189 189 189 189 189 189 189 189 189 189 189   x 189 189     188     188         189 189 187   x 189 189 189 189             188 188 188 187 188 186 186 189 188 187 186  kill col  5  Tbl  33 cols 011000000000001001010110001000011100000100000 has 186 unique lines.
 * 186         186 186 186 186 186 186 186 186 186 186 186   x 186 186     185     185         186 186 184   x 185 186 186 186             183 185 185 180 181     183 183 182 180 182  kill col  7  Tbl  32 cols 011000000000001001010110001000011100010100000 has 180 unique lines.
 * 180         180 180 180 180 180 180 180 180 179 180 180   x 180 179     179     175         180 180 178   x 177 180 180 180             178 179 179     175     177 175 172 174 176  kill col  2  Tbl  31 cols 011000000000001001010110001000011100010100100 has 172 unique lines.
 * 172         172 172 172 172 172 172 172 172 171 172 172   x 172 171     170     165         172 172 168   x 168 170 172 172             170 171 170     164     167 164     163 165  kill col  1  Tbl  30 cols 011000000000001001010110001000011100010100110 has 163 unique lines.
 * 161         163 163 163 163 163 163 163 162 161 163 163   x 163 162     158     153         161 163 159   x 156 159 163 163             161 161 160     149     153 148         153  kill col  3  Tbl  29 cols 011000000000001001010110001000011100010101110 has 148 unique lines.
 * 146         148 148 148 148 148 148 148 146 146 148 148   x 147 147     144     138         145 148 142   x 139 141 148 145             146 146 145     127     132             132  kill col  6  Tbl  28 cols 011000000000001001010110001000011100011101110 has 127 unique lines.
 * 124         127 127 127 127 127 127 127 125 125 127 125   x 126 126     123     112         123 127 120   x 118 118 127 123             125 125 122             109             109  kill col  4  Tbl  27 cols 011000000000001001010110001000011100011111110 has 109 unique lines.
 * 105         108 109 109 109 109 109 109 106 108 108 107   x 107 107     105      96         103 109 102   x 101 101 109 104             107 107 104                              91  kill col  0  Tbl  26 cols 011000000000001001010110001000011100011111111 has  91 unique lines.
 *  87          90  91  91  91  91  91  91  87  90  90  89   x  88  90      86      83          85  91  85   x  84  84  91  86              89  89  86                                  kill col 24  Tbl  25 cols 011000000000001001011110001000011100011111111 has  83 unique lines.
 *  78          82  83  82  83  82  83  83  79  82  82  81   x  80  81      78                  77  83  77   x  77  74  82  79              81  81  78                                  kill col 16  Tbl  24 cols 011000000000001001011110001010011100011111111 has  74 unique lines.
 *  70          73  74  73  74  73  74  74  70  73  73  72   x  70  71      68                  67  73  66   x  69      73  70              72  72  69                                  kill col 19  Tbl  23 cols 011000000000001001011110011010011100011111111 has  66 unique lines.
 *  62          65  66  64  66  65  66  66  62  65  65  64   x  61  63      60                  60  65       x  60      65  63              64  64  62                                  kill col 26  Tbl  22 cols 011000000000001001111110011010011100011111111 has  60 unique lines.
 *  56          59  60  58  60  59  60  60  56  59  59  58   x  55  57                          54  59       x  54      59  57              58  58  56                                  kill col 21  Tbl  21 cols 011000000000001001111111011010011100011111111 has  54 unique lines.
 *  51          53  54  52  54  53  54  54  50  53  53  52   x  50  51                              51       x  48      53  51              52  52  51                                  kill col 17  Tbl  20 cols 011000000000001001111111011110011100011111111 has  48 unique lines.
 *  46          47  45  46  48  47  48  48  44  47  47  46   x  43  44                              45       x          47  45              46  46  45                                  kill col 29  Tbl  19 cols 011000000000001101111111011110011100011111111 has  43 unique lines.
 *  41          42  40  36  43  42  43  43  40  42  42  41   x      40                              41       x          42  40              41  41  40                                  kill col 39  Tbl  18 cols 011001000000001101111111011110011100011111111 has  36 unique lines.
 *  34          35  33      36  35  36  36  33  35  35  34   x      30                              34       x          35  34              34  34  33                                  kill col 28  Tbl  17 cols 011001000000001111111111011110011100011111111 has  30 unique lines.
 *  28          29  26      29  29  29  30  28  29  29  27   x                                      28       x          29  29              28  28  28                                  kill col 40  Tbl  16 cols 011011000000001111111111011110011100011111111 has  26 unique lines.
 *  24          24          25  25  24  26  24  24  25  24   x                                      24       x          25  25              24  24  24                                  kill col 44  Tbl  15 cols 111011000000001111111111011110011100011111111 has  24 unique lines.
 *              22          23  23  22  24  22  22  23  22   x                                      22       x          23  23              22  22  22                                  kill col 41  Tbl  14 cols 111111000000001111111111011110011100011111111 has  22 unique lines.
 *                          21  21  20  22  20  20  21  20   x                                      20       x          21  21              20  20  20                                  kill col 36  Tbl  13 cols 111111001000001111111111011110011100011111111 has  20 unique lines.
 *                          19  18      20  18  18  19  18   x                                      18       x          19  19              18  18  18                                  kill col 37  Tbl  12 cols 111111011000001111111111011110011100011111111 has  18 unique lines.
 *                          17          18  16  16  17  16   x                                      16       x          17  17              16  16  16                                  kill col 34  Tbl  11 cols 111111011010001111111111011110011100011111111 has  16 unique lines.
Possible good candidates for removal, columns : 8 9 10 20 31 33 
 *
 * Round 1: 000000100101110000000000100001100011100000000  4 columns for indexes to table representing 11 original columns (uses 16 of 16 lines in indirect table).
 * Total columns to represent in EBRs: 38
 * 209 distinct lines in remaining untreated columns
 * c44 c43 c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 * 209 206 209 209 209 209   x 209 209   x 209   x   x   x   x 209 209 207 209 207 209 208 208 209   x 207   x 209 209   x   x 207 207 207   x   x   x 208 209 208 209 209 208 207 208  kill col 43  Tbl  31 cols 010000100101111000000000101001100011100000000 has 206 unique lines.
 * 206     206 206 206 206   x 206 206   x 206   x   x   x   x 206 206 204 206 204 206 205 205 206   x 204   x 206 206   x   x 204 204 204   x   x   x 205 206 205 206 206 205 204 205  kill col 27  Tbl  30 cols 010000100101111001000000101001100011100000000 has 204 unique lines.
 * 204     204 204 204 204   x 204 204   x 204   x   x   x   x 204 204     203 202 204 202 203 204   x 202   x 204 204   x   x 202 202 202   x   x   x 203 204 203 204 204 203 202 203  kill col 25  Tbl  29 cols 010000100101111001010000101001100011100000000 has 202 unique lines.
 * 202     202 202 202 202   x 202 202   x 202   x   x   x   x 202 202     201     202 199 200 202   x 200   x 202 202   x   x 200 199 200   x   x   x 201 202 201 202 202 201 200 201  kill col 23  Tbl  28 cols 010000100101111001010100101001100011100000000 has 199 unique lines.
 * 199     199 199 199 199   x 199 199   x 199   x   x   x   x 199 199     198     199     197 199   x 197   x 199 199   x   x 197 196 197   x   x   x 197 199 198 199 198 197 197 198  kill col 12  Tbl  27 cols 010000100101111001010100101001101011100000000 has 196 unique lines.
 * 196     194 196 196 196   x 196 196   x 196   x   x   x   x 196 196     195     196     193 196   x 194   x 196 196   x   x 193     194   x   x   x 194 196 195 196 195 194 194 195  kill col 22  Tbl  26 cols 010000100101111001010110101001101011100000000 has 193 unique lines.
 * 193     191 193 193 193   x 193 193   x 193   x   x   x   x 193 193     192     192         193   x 191   x 193 193   x   x 189     191   x   x   x 191 192 191 193 192 191 190 191  kill col 13  Tbl  25 cols 010000100101111001010110101001111011100000000 has 189 unique lines.
 * 189     187 189 189 189   x 189 189   x 189   x   x   x   x 189 189     188     188         189   x 187   x 189 189   x   x         186   x   x   x 185 188 185 188 188 187 186 187  kill col  7  Tbl  24 cols 010000100101111001010110101001111011110000000 has 185 unique lines.
 * 185     182 185 185 185   x 185 185   x 185   x   x   x   x 185 184     184     183         185   x 183   x 184 184   x   x         182   x   x   x     184 180 183 183 181 182 182  kill col  5  Tbl  23 cols 010000100101111001010110101001111011110100000 has 180 unique lines.
 * 180     174 180 180 180   x 180 180   x 180   x   x   x   x 180 179     179     176         180   x 178   x 178 179   x   x         176   x   x   x     177     178 175 173 173 176  kill col  2  Tbl  22 cols 010000100101111001010110101001111011110100100 has 173 unique lines.
 * 173     166 173 173 173   x 173 173   x 173   x   x   x   x 173 172     172     167         173   x 170   x 170 171   x   x         166   x   x   x     165     170 165     164 166  kill col  1  Tbl  21 cols 010000100101111001010110101001111011110100110 has 164 unique lines.
 * 162     157 164 164 164   x 164 164   x 163   x   x   x   x 163 162     162     157         163   x 161   x 161 161   x   x         153   x   x   x     148     155 149         153  kill col  6  Tbl  20 cols 010000100101111001010110101001111011111100110 has 148 unique lines.
 * 146     138 148 147 148   x 148 148   x 147   x   x   x   x 145 145     145     138         146   x 145   x 144 144   x   x         137   x   x   x             132 125         132  kill col  3  Tbl  19 cols 010000100101111001010110101001111011111101110 has 125 unique lines.
 * 122     112 125 123 125   x 125 124   x 123   x   x   x   x 121 122     122     112         123   x 118   x 116 119   x   x         111   x   x   x             103             102  kill col  0  Tbl  18 cols 010000100101111001010110101001111011111101111 has 102 unique lines.
 *  97      89 101 100 102   x 102 101   x 100   x   x   x   x  98  98      96      89          98   x  94   x  93  93   x   x          91   x   x   x              80                  kill col  4  Tbl  17 cols 010000100101111001010110101001111011111111111 has  80 unique lines.
 *  76      68  79  78  80   x  80  79   x  77   x   x   x   x  75  77      74      70          76   x  74   x  73  73   x   x          71   x   x   x                                  kill col 42  Tbl  16 cols 011000100101111001010110101001111011111111111 has  68 unique lines.
 *  65          67  66  68   x  68  67   x  65   x   x   x   x  64  65      62      59          65   x  63   x  60  61   x   x          57   x   x   x                                  kill col 11  Tbl  15 cols 011000100101111001010110101001111111111111111 has  57 unique lines.
 *  54          56  55  57   x  57  56   x  54   x   x   x   x  54  54      51      49          53   x  51   x  46  50   x   x               x   x   x                                  kill col 17  Tbl  14 cols 011000100101111001010110101101111111111111111 has  46 unique lines.
 *  43          45  43  45   x  46  45   x  43   x   x   x   x  41  42      41      40          42   x  38   x      40   x   x               x   x   x                                  kill col 19  Tbl  13 cols 011000100101111001010110111101111111111111111 has  38 unique lines.
 *  35          37  35  37   x  38  37   x  35   x   x   x   x  33  34      33      33          34   x       x      33   x   x               x   x   x                                  kill col 29  Tbl  12 cols 011000100101111101010110111101111111111111111 has  33 unique lines.
 *  30          32  30  29   x  33  32   x  31   x   x   x   x      29      29      28          28   x       x      28   x   x               x   x   x                                  kill col 24  Tbl  11 cols 011000100101111101011110111101111111111111111 has  28 unique lines.
 *  25          27  25  24   x  27  27   x  26   x   x   x   x      23      23                  22   x       x      21   x   x               x   x   x                                  kill col 16  Tbl  10 cols 011000100101111101011110111111111111111111111 has  21 unique lines.
 *  19          20  18  18   x  20  20   x  19   x   x   x   x      17      17                  17   x       x           x   x               x   x   x                                  kill col 28  Tbl   9 cols 011000100101111111011110111111111111111111111 has  17 unique lines.
 *  15          16  15  13   x  16  15   x  15   x   x   x   x              14                  14   x       x           x   x               x   x   x                                  kill col 39  Tbl   8 cols 011001100101111111011110111111111111111111111 has  13 unique lines.
Possible good candidates for removal, columns : 21 26 
 *
 * Round 2: 100110011010000000100001000000000000000000000  4 columns for indexes to table representing  8 original columns (uses 13 of 16 lines in indirect table).
 * Direct:  011001000000000111011110010110011100011111111 24 columns
 * Success. Use 2 EBRs, 19 LUTs.
 */

module v4_m_2ebr
  (
   input         clk,
   input [7:0]   minx,
   input         progress_ucode,
/* verilator lint_off UNOPTFLAT */
   output [47:0] d
/* verilator lint_on UNOPTFLAT */
   );
   /*
    *                      indirect_index 1
    * inx         next     | indirect index 0
    * || ucode    ucode    | | direct representation
    * 00 LB_0     LB_1     0 0 011000110111110000000001| LB     Load byte. q = rdadr=RS1+0fs
    * 01 LB_1     LB_2     1 1 001000101111100111010010|        Read until q=mem[rs1+ofs) & ~3u]
    * 02 IJ_0     IJ_1     2 2 011000110111110010111110| IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0
    * 03 _L0x03   StdIncPc 1 3 0010000010x10xxx11100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 04 ADDI_0   StdIncPc 1 3 010010001011010011100110| ADDI   Add immediate. rd =RS1+Iimm (or joined)
    * 05 _L0x05   ADDI_0   1 3 0010000010x01xxx00000100| AUIPC  q = imm20 (copy x/2)
    * 06 LB_3     LB_4     1 3 001000011011101000000111|        q = ~mem[rs1+ofs]
    * 07 LB_4     LB_5     1 3 001000010111101100001001|        q = (uint8_t) mem[rs1+Iimm]
    * 08 _L0x08   SB_1     1 0 010100111011110001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 09 LB_5     LB_6     1 3 001000010111100010001011|        q = D^0xffffffff^q = D^0x80
    * 0a _L0x0a   SB_1     1 0 010100111011110001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 0b JALR_2   JAL_2    1 4 000110001011001110000110|        Q = (RS1+imn) & 0xfffffffe
    * 0c ADD_0    ADDI_0   1 3 001000111011100100000100| ADD    add     Addition Q = RS1
    * 0d MUL_0    MUL_1    1 3 1010001110x10xxx11100010| MUL    Store rs1 tp rM. Next read rs2. Q clear
    * 0e SUB_0    SUB_1    1 3 0010001110x10xxx00010000| SUB    Subtraction
    * 0f _L0x0f   StdIncPc 1 3 000010001011011011100110| LUI    q = imm20
    * 10 SUB_1    LB_6     1 3 001000111111100010001011|        Q = ~RS2
    * 11 AND_1    ANDI_1   1 3 001000111011100000011010|        RS1^0xffffffff to Q
    * 12 _L0x12   ILLe     1 3 001000xxxxx0xxxx11111110|  Not in use (illegal as entry)
    * 13 condb_2  condb_3  1 3 001000111111100000010100|        ~RS2 in Q
    * 14 condb_3  condb_4  1 5 011000001011110000010101|        Calculate RS1+~RS2+1
    * 15 condb_4  condb_5  1 6 000100110011100100010110|        Branch on condition
    * 16 condb_5  Fetch    0 7 000101110100111011011110|        Branch not taken.
    * 17 condb_5t BrOpFet  0 4 010101110111110001110100|        Branch taken.
    * 18 BEQ      condb_2  1 3 000110111011011000010011| BEQ    Conditional Branch. Offset to Ryy
    * 19 JALR_0   JALR_1   1 3 010110101011010001000001| JALR   yy=RS1+imm
    * 1a ANDI_1   StdIncPc 1 3 000010001011001111100110|        rd = Iimm & RS1
    * 1b _L0x1b   JAL_1    1 4 001000001010111000110010| JAL    J-imm is in q. Branch on alignfault
    * 1c ECAL_BRK ECAL_RET 1 2 001000101110111010100110| ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI
    * 1d ORI_2    StdIncPc 1 3 000010001011011111100110|        rd = Iimm | RS1
    * 1e aFault_1 aFault_2 1 5 111000101001110011010100|        Q = 4
    * 1f IJ_2     IJ_3     1 3 000110101011011010110111|        Read word is to be masked with 2 lsb = 00
    * 20 LH_0     LH_1     0 8 010110110111110001010010| LH     Load hword. Q = rdadr=RS1+Iimm.
    * 21 XORI_1   StdIncPc 1 3 000010001011000011100110|        rd = Iimm ^ RS1
    * 22 MULHU_6  MULHU_7  1 9 001000101011110000111001|        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar
    * 23 _L0x23   StdIncPc 1 3 0010000010x10xxx11100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 24 SLLI_0   SLLI_1   3 0 001000111110x11000110101| SLLI   Shift left immediate.
    * 25 _L0x25   ADDI_0   1 3 0010000010x01xxx00000100| AUIPC  q = imm20 (copy x/2)
    * 26 OR_1     OR_2     1 3 000100111011000000100111|        RS1^0xffffffff to jj
    * 27 OR_2     ORI_2    1 3 011000000011110000011101|        Q = rs2
    * 28 _L0x28   SH_1     1 8 010100111011110010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 29 XOR_1    XORI_1   1 3 001000111011100000100001|        Q = RS1^0xFFFFFFFF
    * 2a _L0x2a   SH_1     1 8 010100111011110010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 2b SLTIX_1  SLTIX_2  1 5 011000xxxx11010000110000|        RS1 - imm / RS1 - RS2
    * 2c SLL_0    SLL_1    1 3 0010001110x0xxxx00111110| SLL    Shift left
    * 2d MULH_0   MULH_1   3 3 001000101011100101101010| MULH   Store rs1 to Q. Prep read 0, shcnt--
    * 2e MULHU_1  MULHU_2  1 3 100100111111011001000010|        rM<=RS2,  Rjj<=Q=0. next read RS1. 
    * 2f _L0x2f   StdIncPc 1 3 000010001011011011100110| LUI    q = imm20
    * 30 SLTIX_2  StdIncPc 1 a 000010001011011011100110|        Registered ALU flag to rd
    * 31 SLTX_1   SLTIX_1  1 3 001000111111100000101011|        ~rs2 to Q
    * 32 JAL_1    JAL_2    1 3 010110001011010010000110|        Target adr to yy
    * 33 JAERR_1  JAERR_2  4 3 010111001010x10010000001|  Err   JAL target adr misaligned, store to mtval
    * 34 JAL_3    Fetch    0 b 000101110110100111011110|        PC+imm/trap entrypt to PC. OpFetch
    * 35 SLLI_1   SLLI_2   3 3 000010101111100100110110|        Register to shift to Q (and TRG for shift 0)
    * 36 SLLI_2   _L0x03   5 3 000010101111110100000011|        Repeat Q = Q+Q until shregcnt == 0
    * 37 ECALL_2  ECALL_3  4 6 000110xxxx11000111010111|        mepc = pc, prep store 0 to mtval
    * 38 BNE      condb_2  1 3 000110111011011000010011| BNE    Conditional Branch. Offset to Ryy
    * 39 MULHU_7  StdIncPc 1 3 100010001011000111100110|        Last shift.
    * 3a SRxI_1   SRxI_2   3 9 000010101011100100111101|        Register to shift to Q
    * 3b _L0x3b   JAL_1    1 4 001000001010111000110010| JAL    J-imm is in q. Branch on alignfault
    * 3c CSRRW_0  CSRRW_1  1 3 000110011011011001001001| CSRRW  Decoded CSR adr in yy
    * 3d SRxI_2   _L0x03   5 9 000010101011100100000011|        Repeat Q >>= 1 until shregcnt == 0
    * 3e SLL_1    SLLI_1   3 0 001000111110x00100110101|        Shiftamount was in low 5 bits of RS2
    * 3f SRx_1    SRxI_1   3 0 001000111110x00100111010|        Shiftamount in low 5 bits of RS2
    * 40 LW_0     LW_1     0 4 011000110111110001010000| LW     Load word. Q=yy=rdadr=RS1+Iimm
    * 41 JALR_1   JALR_2   1 5 011000110011110000001011|        Q=1
    * 42 MULHU_2  MULHU_3  3 9 001000101011110001100000|        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar
    * 43 MULHU_4  MULHU_5  1 3 001000000010100011101010|        Prepare read Rjj.
    * 44 SLTI_0   SLTIX_1  1 3 001000111111101000101011| SLTI   Set less than immediate (signed)
    * 45 WFI_3    WFI_4    1 5 011000101011110001100101|        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105
    * 46 ILL_1    ILL_2    4 3 000110101010x00101000111|        Store PC to mepc
    * 47 ILL_2    ILL_3    4 3 000111101011000110001111|        Store 0 to mtval
    * 48 _L0x48   SW_1     6 4 011000111011110001100110| SW     Store word. Q=wradr=RS1+Simm
    * 49 CSRRW_1  CSRRW_2  1 5 011000001011110001001011|        Construct PC storage adr
    * 4a _L0x4a   SW_1     6 4 011000111011110001100110| SW     Store word. Q=wradr=RS1+Simm
    * 4b CSRRW_2  CSRRW_3  7 3 000001101010100110110001|        Write PC to 0x100 start Prep emulation entrypt
    * 4c SLT_0    SLTX_1   1 3 0010001110x10xxx00110001| SLT    Set less than (signed)
    * 4d MULHSU_0 MULHU_1  3 3 000110111011000100101110| MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--
    * 4e eILL0b   ILLe     1 3 001000xxxxx0xxxx11111110| Illegal instruction seen
    * 4f MRET_8   StdIncPc 1 5 011000101011110011100110|        Prep +4
    * 50 LW_1     StdIncPc 1 c 000010101111000111100110|        Read until d=mem[(rs1+ofs) & ~3u]
    * 51 LDAF_LW  LDAF_a   4 3 000111101010111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 52 LH_1     LH_2     1 1 001000101111100101010100|        Read until q=mem[(rs1+ofs) & ~3u]
    * 53 LDAF_LH  LDAF_a   4 3 000111101010111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 54 LH_2     LH_3     5 9 001000101011100111101011|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 55 aFaultb  aFault_1 4 3 000111101011011000011110|  err   LH Load access fault. Faulting adr to mtval
    * 56 LH_4     LH_5     1 3 001000100011101101010111|        q = (uint16_t) mem[rs1+Iimm]
    * 57 LH_5     LB_6     1 3 001000100011100010001011|        q = D^0xffffffff^q = D ^ 0x00008000
    * 58 DIV_A    DIV_C    1 9 111000101111100101101110|        Transfer rM to rDee
    * 59 DIV_B    DIV_10   1 3 000110111111011010011100|        REM = Q to yy
    * 5a SB_1     SB_2     3 3 000110101111100101011101|        Write d to Q and yy (for sh 0). Prep shift
    * 5b _L0x5b   JAL_1    1 4 001000001010111000110010| JAL    J-imm is in q. Branch on alignfault
    * 5c CSRRS_0  CSRRW_1  1 3 000110011011011001001001| CSRRS  Decoded CSR adr in yy
    * 5d SB_2     SB_3     5 3 000110101111110111111011|        Repeat shl until shreg = 0 (0,8,16 or 24 times)
    * 5e LHU_1    LHU_2    1 1 001000101111100101110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 5f LDAF_LHU LDAF_a   4 3 000111101010111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 60 MULHU_3  MULHU_2  1 3 101000111111100101000010|        Shift Q and rM. Prepare read rs1
    * 61 EBRKWFI2 EBREAK_1 1 6 000100011011001011110111| EBREAK/WFI2 Select EBREAK or WFI
    * 62 DIV_8    DIV_7    3 5 011000101111110011001000|        Conditionally subtract rs2. Update M[0]
    * 63 DIV_9    DIV_A    8 5 011000101111110001011000|        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]
    * 64 SLTIU_0  SLTIX_1  1 3 001000111111101000101011| SLTIU  Set less than immediate (unsigned)
    * 65 WFI_4    WFI_5    1 6 0010000010x10xxx11101111|        Prepare read PC
    * 66 SW_1     SW_2     4 3 000001111010100111110010|        Write d to a+k until accepted
    * 67 SW_E1SWE SW_E2    4 3 000111001010x11010010011|        Store faulting address alignment to mtval
    * 68 DIV_12   StdIncPc 1 3 000010001011000111100110|        RS2 > 0, RS1 >= 0, yy is true result
    * 69 DIV_13   LB_6     1 3 001000101011100010001011|        RS2 > 0, RS1 < 0, change sign yy
    * 6a MULH_1   MULH_2   1 3 000110101011000011111001|        Store ~rs1 to Ryy. Prep construct 1.
    * 6b SB_4     SB_5     6 3 001001110011100101111010|        Address back to Q. Prepare get item to write
    * 6c SLTU_0   SLTX_1   1 3 0010001110x10xxx00110001| SLTU   Set less than (unsigned)
    * 6d MULHU_0  MULHU_1  3 3 000110111011000100101110| MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--
    * 6e DIV_C    DIV_e    1 3 000110111010100110111001|        rM to yy. Q=ffffffff
    * 6f MRET_6   MRET_7   1 5 011000xxxx11110011001111|        ~302 + origImm + 1 for branch decision
    * 70 LHU_2    LHU_3    5 9 001000101011100110111010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 71 aFaultc  aFault_1 4 3 000111101011011000011110|  err   LHU Load access fault. Faulting adr to mtval
    * 72 LBU_3    ANDI_1   1 3 001000011011101000011010|        Invert q. Prepare read mask
    * 73 BAERR_1  BAERR_2  4 3 000111110011000101110110|        Faultadr to mtval. Prepare get offset
    * 74 BrOpFet  Fetch2   1 d 001000101111011011110100| NewOp2 Read until instruction latched
    * 75 BAlignEr BAERR_1  1 3 0010000010x0xxxx01110011|  Err   Branch target instruction address misaligned
    * 76 BAERR_2  BAERR_3  1 3 001000001011100001110111|        ~offset to Q. Prep read (origPC+offset)
    * 77 BAERR_3  BAERR_4  4 5 010110101010x10001111101|        origPC to mepc. Prep read 0
    * 78 DIV_4    DIV_6    1 3 000110000011011010101010|        ~abs(divisor) to yy
    * 79 DIV_5    DIV_3    1 5 111000101011110010101000|        Kluge to let add1 work in DIV instr
    * 7a SB_5     SW_2     1 3 000001110010100111110010|        Write d to a+k until accepted
    * 7b _L0x7b   JAL_1    1 4 001000001010111000110010| JAL    J-imm is in q. Branch on alignfault
    * 7c CSRRC_0  CSRRW_1  1 3 000110011011011001001001| CSRRC  Decoded CSR adr in yy
    * 7d BAERR_4  JAL_3    9 3 000111100110x00100110100|        Store 0 to mcause. Prep get trap entry pont
    * 7e NMI_1    NMI_2    4 3 000110xxxx11000110010000|        Store pc to mepc.
    * 7f JALRE2   BAERR_4  4 3 000111101010x00101111101|        mtval is target
    * 80 LBU_0    LBU_1    0 0 011000110111110010000101| LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.
    * 81 JAERR_2  BAERR_4  4 3 000110101010x00101111101|        Store PC to mepc
    * 82 DIV_1    DIV_3    1 3 000100111011000010101000|        jj=abs(RS1). Next handle divisor
    * 83 DIV_2    DIV_1    1 3 011000101011110010000010|        Dividend negative, make RS1-1
    * 84 XORI_0   XORI_1   1 3 001000111111101000100001| XORI   Xor immediate. Q=~Iimm
    * 85 LBU_1    LBU_2    1 1 001000101111100111110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 86 JAL_2    JAL_25   1 5 110010001000x10010011110|        Return address to TRG
    * 87 JALRE1   JALRE2   4 3 000110110010x00101111111|  err   Store pc to mepc
    * 88 DIV_E    DIV_10   8 3 1010001111x0xxxx10011100|        RS2 != 0. Check signs
    * 89 DIV_F    StdIncPc 1 3 000010001011011011100110|        RS2 == 0, return 0xffffffff
    * 8a DIVU_5   ANDI_1   1 9 1110001011x10xxx00011010|        Transfer rM to rDee
    * 8b LB_6     StdIncPc 1 5 110010001011010011100110|        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80
    * 8c XOR_0    XOR_1    1 3 0010001111x10xxx00101001| XOR    xor
    * 8d DIV_0    DIV_1    a 3 101000101111100110000010| DIV    Branch on sign dividend RS1
    * 8e _LCSRRS_1 ILLe     1 3 001000xxxxx0xxxx11111110| Illegal instruction seen
    * 8f ILL_3    ILL_4    1 5 001000101011110010101001|        Q = 1
    * 90 NMI_2    JAL_3    b 3 000111010011011000110100|        mtval = 0.
    * 91 LDAF_2   LDAF_3   9 5 110111001000x10010010010|        Store 4 to mcause
    * 92 LDAF_3   JAL_3    4 3 000110100110x00100110100|        PC to mepc
    * 93 SW_E2    SW_E3    4 3 000110101111000110010101|        Store address that faulted
    * 94 SW_E4    JAL_3    9 3 000111100110x10100110100|        Store 6 to mcause
    * 95 SW_E3    SW_E4    1 5 111000101101110010010100|        Q = 3
    * 96 SH_1     SH_2     3 3 000110101111100110111011|        Write d to Q and yy (for sh 0). Prep shift
    * 97 SW_E1SWH SW_E2    4 3 000111001010x11010010011|        Store faulting address alignment to mtval
    * 98 BLT      condb_2  1 3 000110111011011000010011| BLT    Conditional Branch. Offset to Ryy
    * 99 _L0x99   ILLe     1 3 001000xxxxx0xxxx11111110|  Not in use (illegal as entry)
    * 9a ECALL_6  JAL_3    9 3 010111100100x10000110100|        mcause = 11
    * 9b SH_4     SH_5     c 3 001000110011100110011111|        Address back to Q. Prepare get item to write
    * 9c DIV_10   DIV_12   8 3 101000110011000101101000|        RS2 > 0. Branch on sign of RS1
    * 9d DIV_11   DIV_14   8 3 101000110011000110100010|        RS2 < 0. Branch on sign of RS1
    * 9e JAL_25   JAL_3    1 3 000100110010x00100110100|        Instr. adr. to jj in case of access error
    * 9f SH_5     SW_2     4 3 000000110010100111110010|        Write d to a+k until accepted
    * a0 LHU_0    LHU_1    0 8 010110110111110001011110| LHU    Load unsigned hword. Q = rdadr=RS1+Iimm
    * a1 ECALL_4  ECALL_5  1 5 111000101001110010110110|        Q = 4
    * a2 DIV_14   LB_6     1 3 001000101011100010001011|        RS2 < 0, RS1 >= 0, change sign yy
    * a3 DIV_15   StdIncPc 1 3 000010001011000111100110|        RS2 < 0, RS1 < 0, yy is true result
    * a4 SRxI_0   SRxI_1   3 0 001000111110x11000111010| SRxI   Shift Right immediate (both logic/arith here)
    * a5 MRET_3   MRET_4   1 5 011000011011110010101111|        0x102 + 0xff + 1 = 0x202
    * a6 ECAL_RET ECALL_1  1 4 001000101110111011010000| ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET
    * a7 EBRKWFI1 EBRKWFI2 1 3 011000xxxx11110001100001| EBREAK/WFI1 Prepare select EBREAK or WFI
    * a8 DIV_3    DIV_4    8 3 101000101011100001111000|        Branch on sign divisor RS2
    * a9 ILL_4    JAL_3    9 5 010111100110x10000110100|        Store 2 to mcause
    * aa DIV_6    DIV_7    1 3 1010001011x10xxx11001000|        Write M. Prepare shift
    * ab EBREAK_2 ECALL_6  4 3 000110101011000110011010|        pc to mepc
    * ac _L0xac   SRx_1    1 3 0010001110x0xxxx00111111| SRx    Shift Right (both SRL and SRA)
    * ad DIVU_0   DIVU_1   3 3 1010001110x10xxx11100000| DIVU   Store rs1 to rM. Q=0. Prepare invert rs2
    * ae _L0xae   SRx_1    1 3 0010001110x0xxxx00111111| SRx    Shift Right (both SRL and SRA)
    * af MRET_4   MRET_5   1 5 011000xxxx11110011000101|        0x202 + 0xff + 1 = 0x302
    * b0 aF_SW_3  LDAF_3   9 3 010111001000x10010010010|        Store 7 to mcause
    * b1 CSRRW_3  CSRRW_4  1 5 111000101001110010110010|        Prep emulation entrypt 0x108, here Q to 0x104
    * b2 CSRRW_4  Fetch    0 7 110100110100110011011110|        IncPC, OpFetch, but force +4
    * b3 unxb3             3 0 00xxxxxxxxxxxxxxxxxxxxxx| b3: Not in use 
    * b4 i0reserv          3 0 00xxxxxxxxxxxxxxxxxxxxxx| Not in use, reserved to allow LASTINCH
    * b5 SH_3     SH_4     1 3 001000000011011010011011|        Prepare get back address to use 
    * b6 ECALL_5  ECALL_6  1 5 111000101001110010011010|        Q = 8
    * b7 IJ_3     IJ_4     1 3 011000110001110010111101|        Construct Q = 3
    * b8 BGE      condb_2  1 3 000110111011011000010011| BGE    Conditional Branch. Offset to Ryy
    * b9 DIV_e    DIV_D    1 5 001000110011100011000000|        Calc carry of RS2+0xFFFFFFFF
    * ba LHU_3    ANDI_1   1 3 001000011111101000011010|        Invert q. Prepare read mask
    * bb SH_2     SH_3     5 3 000110101111110110110101|        Repeat shl until shreg = 0 (0,8 or 24 times)
    * bc CSRRWI_0 CSRRW_1  1 3 000110011011011001001001| CSRRWI Decoded CSR adr in yy
    * bd IJ_4     Fetch    0 b 001000110110101111011110|        Mask and use as PC
    * be IJ_1     IJ_2     1 b 001000101111100100011111|        Read until q=mem[(rs1+ofs)&~3u]
    * bf IJT_1    IJT_2    1 b 001000101111100111000001|        Exit CSR, enter trap
    * c0 DIV_D    DIV_E    1 6 001000111011100110001000|        Is RS2 == 0?
    * c1 IJT_2    IJT_3    1 3 000110101011011011101001|        Read word is to be masked with ~3u
    * c2 DIVU_3   DIVU_2   3 5 011000101111110011001010|        Conditionally subtract rs2. Update M[0]
    * c3 DIVU_4   DIVU_5   8 5 011000101111110010001010|        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]
    * c4 ORI_0    ORI_1    1 3 000100111111001011100001| ORI    Or immediate. jj=~Iimm
    * c5 MRET_5   MRET_6   1 3 001000000011101001101111|        ~302
    * c6 IJT_4    ILL_2    4 3 000110101011101101000111|        Mask and store to mepc and Q for read of instr
    * c7 QINT_1   QINT_2   4 3 000110xxxx11000111001011|        Store pc to mepc.
    * c8 DIV_7    DIV_8    1 e 101000110011110101100010|        Shift (Q,M) left. Prepare unsigned sub
    * c9 MRET_2   MRET_3   1 3 011000011001110010100101|        0xff+3 = 0x102
    * ca DIVU_2   DIVU_3   1 e 101000110011110111000010|        Shift (Q,M) left. Prepare unsigned sub
    * cb QINT_2   StdIncPc b 3 000111010011011011100110|        mtval = 0.
    * cc OR_0     OR_1     1 3 0010001111x10xxx00100110| OR     or
    * cd REM_0    DIV_1    a 3 101000101111100110000010| REM    Branch on sign dividend RS1
    * ce _LCSRRCI_1 ILLe     1 3 001000xxxxx0xxxx11111110| Illegal instruction seen
    * cf MRET_7   MRET_8   1 6 0010000110x10xxx01001111|        Prepare emulation entry point 0x104
    * d0 ECALL_1  ECALL_2  1 5 011000001011110000110111| ECALL  Verify Imm==0x000
    * d1 MRET_1   MRET_2   1 3 000100011011011011001001| MRET   First save Imm, start build constant for check
    * d2 LB_2     LB_3     5 9 001000101011100100000110|        Repeat shr until shreg == 0 (0,8,16,24 times)
    * d3 aFaultd  aFault_1 4 3 000111101011011000011110|  err   LB Load access fault. Faulting adr to mtval
    * d4 aFault_2 LDAF_3   9 5 010111001010x10010010010|        Store 5 to mcause
    * d5 unxd5             3 0 00xxxxxxxxxxxxxxxxxxxxxx| d5: Not in use
    * d6 eILL0c   ILLe     1 3 001000xxxxx0xxxx11111110| Illegal instruction seen
    * d7 ECALL_3  ECALL_4  4 3 000111101011011010100001|        mtval = 0, now start the chore of 11 to mcause
    * d8 BLTU     condb_2  1 3 000110111011011000010011| BLTU   Conditional Branch. Offset to Ryy
    * d9 MULH_3   MULHU_2  1 3 1010001111x10xxx01000010|        rM<=RS2, Q = 0. next read RS1. Join.
    * da LDAF_a   LDAF_2   1 3 0010001010x10xxx10010001|        Extra cycle after error detected write mtval
    * db jFault_1 LDAF_3   1 5 010111000010x10010010010|        Store 1 to mcause
    * dc CSRRSI_0 CSRRW_1  1 3 000110011011011001001001| CSRRSI Decoded CSR adr in yy
    * dd aF_SW_1  aF_SW_2  4 3 000111101011011011100101|  err   SW Store access fault. Faulting adr to mtval
    * de Fetch    Fetch2   1 f 000101001111011011110100|  Fr00  Read and latch instruction
    * df eFetch   Fetch2   1 d 000101101111011011110100|  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]
    * e0 DIVU_1   DIVU_2   1 3 000110101111000011001010|        Store inverted rs2 to yy. Prepare shift
    * e1 ORI_1    ORI_2    1 3 001000000011100100011101|        Q = RS1
    * e2 MUL_1    MUL_2    3 9 001000101011110011101000|        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar
    * e3 MUL_3    ANDI_1   1 9 1110001011x10xxx00011010|        Transfer rM to rDee
    * e4 ANDI_0   ANDI_1   1 3 001000111111101000011010| ANDI   And immediate. Q=~Iimm
    * e5 aF_SW_2  aF_SW_3  1 5 111000101001110010110000|        Q = 4
    * e6 StdIncPc Fetch    0 7 110100110100110011011110|  Fr00  IncPC, OpFetch
    * e7 aFault   aFault_1 4 3 000111101011011000011110|  err   Load access fault. Faulting adr to mtval
    * e8 MUL_2    MUL_1    1 3 101000111011100111100010|        Shift Q and rM. Prepare read rs2
    * e9 IJT_3    IJT_4    1 3 011000110001110011000110|        Construct Q = 3
    * ea MULHU_5  MULHU_6  1 3 001000110011110000100010|        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy
    * eb LH_3     LH_4     1 3 001000011111101001010110|        q = ~mem[rs1+ofs]
    * ec AND_0    AND_1    1 3 0010001111x10xxx00010001| AND    And 
    * ed REMU_0   DIVU_1   3 3 1010001110x10xxx11100000| REMU   Store dividend to rM. Prepare read divisor.Q=0
    * ee eILL0a   ILLe     1 3 001000xxxxx0xxxx11111110| Illegal instruction seen
    * ef WFI_5    Fetch    0 7 110101110100110011011110|        IncPC, OpFetch
    * f0 LBU_2    LBU_3    5 9 001000101011100101110010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * f1 aFaulte  aFault_1 4 3 000111101011011000011110|  err   LBU Load access fault. Faulting adr to mtval
    * f2 SW_2     StdIncPc 1 3 0010000010x10xxx11100110|        Prepare read PC
    * f3 aF_SW    aF_SW_1  1 3 001000xxxxx01xxx11011101|  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf
    * f4 Fetch2            4 3 010101111111110000000000|  Fr00  Update ttime. Update I. Q=immediate. Use dinx
    * f5 jFault   jFault_1 4 3 000111101011011011011011|  err   Fetch access fault. Faulting adr to mtval
    * f6 WFI_1    WFI_2    1 5 111000000001110011111010| WFI    Chk offset=0x105. Now=0xff. Prep 0xff+4 = 0x103
    * f7 EBREAK_1 EBREAK_2 4 3 000111001011011010101011| EBREAK mepc = pc, store 0 to mtval
    * f8 BGEU     condb_2  1 3 000110111011011000010011| BGEU   Conditional Branch. Offset to Ryy
    * f9 MULH_2   MULH_3   1 5 010100111011010011011001|        Store 1 to Rjj. next read rs2, Q=0
    * fa WFI_2    WFI_3    1 5 011000101011110001000101|        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104
    * fb SB_3     SB_4     1 3 001000000011011001101011|        Prepare get back address to use 
    * fc CSRRCI_0 CSRRW_1  1 3 000110011011011001001001| CSRRCI Decoded CSR adr in yy
    * fd NMI_0    NMI_1    1 3 0010000010x10xxx01111110| NMI    Get current PC
    * fe ILLe     ILL_1    1 3 0010000010x0xxxx01000110| Illegal
    * ff QINT_0   QINT_1   1 3 0010000010x10xxx11000111| INT    Get current PC
    */
   localparam u0_0 = 256'hb6e6901090e2b904b386bc5a788bbc5a7b09ba078804b4e690e67cbef9d27c01;
   localparam u0_1 = 256'hb6b79cd4b7e6eea6ae32b3e6b441b6137c744ede3916bc15f81400feb81af88b;
   localparam u0_2 = 256'hb6e6f642b96a803e3430bc96b821bc963c1db0278804e63590e6bc39b0e67c52;
   localparam u0_3 = 256'he13ae135b903b649ae32b93db1e6b61331d7fd03f93669dea481b486f82bb6e6;
   localparam u0_4 = 256'hbce600feb12e9031a9b1bc66bc4bbc66b18fa147bc65fa2b28eabc603c0b7c50;
   localparam u0_5 = 256'haedaf970fdfbb649ae32f95df69cf96e388b3b57b61eb9ebaedaf954aedaf1e6;
   localparam u0_6 = 256'h3ccfa9b9b12e9031397ab0f9b88bb1e6a693a9f290effa2bfc58fcc8b2f7f942;
   localparam u0_7 = 256'ha17d31906134b649ae3229f2bca836aaa47db8778073f6f43176ba1ab61eb9ba;
   localparam u0_8 = 256'hbca900fef982d029b4e6d01ab6e6c09c217f849ef9f0fa21bc82b0a8a17d7c85;
   localparam u0_9 = 256'h29f2213431a23168399f443400feb613a693f9bbdc946534f195613484923634;
   localparam u0_A = 256'h3cc5803f90e0803fb19ad0c86434b8783c61eed0bcafe63ab1e6b88b9cb67c5e;
   localparam u0_B = 256'hf9c1f91f6bdeb649fdb5fa1a38c0b6131cbd9c9a369b000000004cde9cb28492;
   localparam u0_C = 256'h904f00fef982d02636e63dc29ca53d6231cbbb473a6ff2e1fc8afccab6e9b988;
   localparam u0_D = 256'hf6f4f6f4b6e5b64924929091d042b613b6a100fe0000a492b61eb906b6c9bc37;
   localparam u0_E = 256'h4cde00fe90e0d011fa563c221cc6b9e2b61e4cde9cb0fa1ad01abce8391df0ca;
   localparam u0_F = 256'h90c78046907eb649366bbc45b4d9b613b6ab1cfab6dbfc0008dd90e6b61eb972;
   localparam u1_0 = 256'h1308132313a31323141810531321105313211321132013481320226311220063;
   localparam u1_1 = 256'h131a15e21308122214201308135a131b04570717161315601323132013231323;
   localparam u1_2 = 256'h130813933322132315601853132318531360131313203023132019221308085b;
   localparam u1_3 = 256'h30233023590a13191420390a1388131b4618530a330a0b17435c135813231a08;
   localparam u1_4 = 256'h15621320331b13237306646315606463431e431a156213231320392215630463;
   localparam u1_5 = 256'h431e1122531a13191420331a131b19e213221322431e5922431e1122431e1c0a;
   localparam u1_6 = 256'h1560131b331b13236327131a13221308431c43071620132385623562161113a3;
   localparam u1_7 = 256'h431e4318931e13191420130715e21318455a132013201d22431f1321431e5922;
   localparam u1_8 = 256'h15221320a3a2132315c819e2130883a3431b15c81122132313621313431a0063;
   localparam u1_9 = 256'h4303131383a383a3c323935e1320131b431c331a15e2931e431a431a95dcb31d;
   localparam u1_A = 256'h1560132333a31323431a13a2955e83a213601422156130231308132215e2085b;
   localparam u1_B = 256'h1b221b220b231319531a13211523131b136315e213203000300007d315e2935c;
   localparam u1_C = 256'h16211320a3a21323b31d1ea313611ea34318431a1320131385623562131a1623;
   localparam u1_D = 256'h1d161f14431e1319155c132213a3131b431e13203000955c431e592213111560;
   localparam u1_E = 256'h07d7132033a3132313211323136313a3431e07d315e2132319e239221320131a;
   localparam u1_F = 256'h1320132013201319132015621553131b431c15e0431e435713201320431e5922;
   wire [31:0]   indir;
`ifdef verilator
   /* verilator lint_off UNUSED */
   wire [15:0]   sim_a;
   wire [15:0]   sim_b;
   /* verilator lint_on UNUSED */
`endif
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u0_0), .INIT_1(u0_1), .INIT_2(u0_2), .INIT_3(u0_3),
                   .INIT_4(u0_4), .INIT_5(u0_5), .INIT_6(u0_6), .INIT_7(u0_7),
                   .INIT_8(u0_8), .INIT_9(u0_9), .INIT_A(u0_A), .INIT_B(u0_B),
                   .INIT_C(u0_C), .INIT_D(u0_D), .INIT_E(u0_E), .INIT_F(u0_F)
                   ) ucode0
     (
      .RDATA( indir[15:0]         ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u1_0), .INIT_1(u1_1), .INIT_2(u1_2), .INIT_3(u1_3),
                   .INIT_4(u1_4), .INIT_5(u1_5), .INIT_6(u1_6), .INIT_7(u1_7),
                   .INIT_8(u1_8), .INIT_9(u1_9), .INIT_A(u1_A), .INIT_B(u1_B),
                   .INIT_C(u1_C), .INIT_D(u1_D), .INIT_E(u1_E), .INIT_F(u1_F)
                   ) ucode1
     (
      .RDATA( indir[31:16]        ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );

   assign d[0] = indir[0];
   assign d[1] = indir[1];
   assign d[2] = indir[2];
   assign d[3] = indir[3];
   assign d[4] = indir[4];
   assign d[5] = indir[5];
   assign d[6] = indir[6];
   assign d[7] = indir[7];
   assign d[11] = indir[8];
   assign d[12] = indir[9];
   assign d[13] = indir[10];
   assign d[16] = indir[11];
   assign d[17] = indir[12];
   assign d[19] = indir[13];
   assign d[22] = indir[14];
   assign d[23] = indir[15];
   assign d[24] = indir[16];
   assign d[25] = indir[17];
   assign d[27] = indir[18];
   assign d[28] = indir[19];
   assign d[29] = indir[20];
   assign d[39] = indir[21];
   assign d[42] = indir[22];
   assign d[43] = indir[23];
   // replaces = 000000100101110000000000100001100011100000000
   SB_LUT4 #(.LUT_INIT(16'h0202)) cmb_d08(.O(d[8]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h04a0)) cmb_d09(.O(d[9]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h40a0)) cmb_d10(.O(d[10]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0040)) cmb_d14(.O(d[14]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'ha000)) cmb_d15(.O(d[15]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'hfefe)) cmb_d20(.O(d[20]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0114)) cmb_d31(.O(d[31]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0010)) cmb_d32(.O(d[32]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h3882)) cmb_d33(.O(d[33]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h2002)) cmb_d35(.O(d[35]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h3000)) cmb_d38(.O(d[38]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   // replaces = 100110011010000000100001000000000000000000000
   SB_LUT4 #(.LUT_INIT(16'h1bd7)) cmb_d21(.O(d[21]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h1890)) cmb_d26(.O(d[26]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0020)) cmb_d34(.O(d[34]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0a04)) cmb_d36(.O(d[36]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0a80)) cmb_d37(.O(d[37]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h1045)) cmb_d40(.O(d[40]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h1040)) cmb_d41(.O(d[41]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0500)) cmb_d44(.O(d[44]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   assign d[45] = 1'b0;
   assign d[46] = 1'b0;
   assign d[47] = 1'b0;
wire instr0100,instr1x110100;            bn_l4v #(.I(16'h0010)) leq0100(     .o(instr0100),     .i({minx[3:0]}));    bn_l4v #(.I(16'h8000)) leq1x110100( .o(instr1x110100), .i({minx[7],minx[5:4],instr0100}));    SB_DFFE reg_d18( .Q(d[18]), .C(clk), .E(progress_ucode), .D(instr1x110100));    assign d[30] = d[18];
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019-2020. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * Automatically generated from ../code/ucode.h by midgetv_indirectEBR.c.
 * Do not edit.
 * Optiones for this variant:
 *   No RVC
 *   MULDIV included
 *   minstret for instructions in SRAM
 */
/* Using LUTSIZE=4. Using 2 EBRs. Initial table has 45 columns
 * Removed:  000000000000001000000000000000000000000000000 These are removed from consideration, replaced with hand-crafted Verilog code in the output stage
 * Reserved: 000000000000000000000000000000000000000000000 Columns to be represented directly, not part of optimalization
 * Total columns to represent in EBRs: 45
 * 212 distinct lines in remaining untreated columns
 * c44 c43 c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 * 212 211 212 212 212 212 212 212 212 212 212 212 212 212   x 212 212 210 212 211 212 211 211 212 212 212 212 212 212 212 212 210 210 210 212 211 212 211 212 211 212 212 211 210 211  kill col 27  Tbl  43 cols 000000000000001001000000000000000000000000000 has 210 unique lines.
 * 210 209 210 210 210 210 210 210 210 210 210 210 210 210   x 210 210     209 209 210 208 209 210 210 210 210 210 210 210 210 208 208 208 210 209 210 209 210 209 210 210 209 208 209  kill col 23  Tbl  42 cols 000000000000001001000100000000000000000000000 has 208 unique lines.
 * 208 207 208 208 208 208 208 208 208 208 208 208 208 208   x 208 208     207 206 208     207 208 208 208 208 208 208 208 208 206 206 206 208 207 208 207 208 207 208 208 207 206 207  kill col 25  Tbl  41 cols 000000000000001001010100000000000000000000000 has 206 unique lines.
 * 206 205 206 206 206 206 206 206 206 206 206 206 206 206   x 206 206     205     206     205 206 206 206 206 206 206 206 206 204 203 204 206 205 206 204 206 205 206 206 205 204 205  kill col 12  Tbl  40 cols 000000000000001001010100000000001000000000000 has 203 unique lines.
 * 203 202 202 203 203 203 203 203 203 203 203 203 203 203   x 203 203     202     203     201 203 203 203 203 203 203 203 203 200     201 203 202 203 201 203 202 203 203 202 201 202  kill col 13  Tbl  39 cols 000000000000001001010100000000011000000000000 has 200 unique lines.
 * 200 199 199 200 200 200 200 200 200 200 200 200 200 200   x 200 200     199     200     198 200 200 200 200 200 200 200 200         197 200 199 200 198 200 199 199 200 199 198 199  kill col 11  Tbl  38 cols 000000000000001001010100000000011100000000000 has 197 unique lines.
 * 197 196 195 197 197 197 197 197 197 197 197 197 197 197   x 197 197     196     197     195 197 197 197 197 197 197 197 197             197 196 197 195 197 195 195 197 196 195 196  kill col 42  Tbl  37 cols 001000000000001001010100000000011100000000000 has 195 unique lines.
 * 195 193     195 195 195 195 195 195 195 195 195 195 195   x 195 195     194     195     193 195 195 194 195 195 195 195 195             195 194 195 193 195 193 193 195 194 193 194  kill col 43  Tbl  36 cols 011000000000001001010100000000011100000000000 has 193 unique lines.
 * 193         193 193 193 193 193 193 193 193 193 193 193   x 193 193     192     193     191 193 193 191 193 193 193 193 193             192 192 193 191 193 191 191 193 192 191 191  kill col 22  Tbl  35 cols 011000000000001001010110000000011100000000000 has 191 unique lines.
 * 191         191 191 191 191 191 191 191 191 191 191 191   x 191 191     190     190         191 191 189 191 191 191 191 191             190 190 190 189 190 188 188 191 190 189 188  kill col  5  Tbl  34 cols 011000000000001001010110000000011100000100000 has 188 unique lines.
 * 188         188 188 188 188 188 188 188 188 188 188 188   x 188 188     187     187         188 188 186 188 187 188 188 188             185 187 187 182 183     185 185 184 182 184  kill col  7  Tbl  33 cols 011000000000001001010110000000011100010100000 has 182 unique lines.
 * 182         182 182 182 182 182 182 182 182 181 182 182   x 182 181     181     177         182 182 180 182 179 182 182 182             180 181 181     177     179 177 174 176 178  kill col  2  Tbl  32 cols 011000000000001001010110000000011100010100100 has 174 unique lines.
 * 174         174 174 174 174 174 174 174 174 173 174 174   x 174 173     172     167         174 174 170 174 170 172 174 174             172 173 172     166     169 166     165 167  kill col  1  Tbl  31 cols 011000000000001001010110000000011100010100110 has 165 unique lines.
 * 163         165 165 165 165 165 165 165 164 163 165 165   x 165 164     160     155         163 165 161 165 158 161 165 165             163 163 162     151     155 150         155  kill col  3  Tbl  30 cols 011000000000001001010110000000011100010101110 has 150 unique lines.
 * 148         150 150 150 150 150 150 150 148 148 150 150   x 149 149     146     140         147 150 144 150 141 143 150 147             148 148 147     129     134             134  kill col  6  Tbl  29 cols 011000000000001001010110000000011100011101110 has 129 unique lines.
 * 126         129 129 129 129 129 129 129 127 127 129 127   x 128 128     125     114         125 129 122 129 120 120 129 125             127 127 124             111             111  kill col  4  Tbl  28 cols 011000000000001001010110000000011100011111110 has 111 unique lines.
 * 107         110 111 111 111 111 111 111 108 110 110 109   x 109 109     107      98         105 111 104 111 103 103 111 106             109 109 106                              93  kill col  0  Tbl  27 cols 011000000000001001010110000000011100011111111 has  93 unique lines.
 *  89          92  93  93  93  93  93  93  89  92  92  91   x  90  92      88      85          87  93  87  93  86  86  93  88              91  91  88                                  kill col 24  Tbl  26 cols 011000000000001001011110000000011100011111111 has  85 unique lines.
 *  80          84  85  84  85  84  85  85  81  84  84  83   x  82  84      80                  79  85  79  85  79  75  84  81              83  83  80                                  kill col 16  Tbl  25 cols 011000000000001001011110000010011100011111111 has  75 unique lines.
 *  71          74  75  74  75  74  75  75  71  74  74  73   x  71  73      69                  68  74  67  75  70      74  71              73  73  70                                  kill col 19  Tbl  24 cols 011000000000001001011110010010011100011111111 has  67 unique lines.
 *  63          66  67  65  67  66  67  67  63  66  66  65   x  62  65      61                  61  66      67  61      66  64              65  65  63                                  kill col 26  Tbl  23 cols 011000000000001001111110010010011100011111111 has  61 unique lines.
 *  57          60  61  59  61  60  61  61  57  60  60  59   x  56  58                          55  60      60  55      60  58              59  59  57                                  kill col 21  Tbl  22 cols 011000000000001001111111010010011100011111111 has  55 unique lines.
 *  52          54  55  53  55  54  55  55  51  54  54  53   x  51  52                              52      54  49      54  52              53  53  52                                  kill col 17  Tbl  21 cols 011000000000001001111111010110011100011111111 has  49 unique lines.
 *  47          48  46  47  49  48  49  49  45  48  48  47   x  44  45                              46      48          48  46              47  47  46                                  kill col 29  Tbl  20 cols 011000000000001101111111010110011100011111111 has  44 unique lines.
 *  42          43  41  37  44  43  44  44  41  43  43  42   x      41                              42      43          43  41              42  42  41                                  kill col 39  Tbl  19 cols 011001000000001101111111010110011100011111111 has  37 unique lines.
 *  35          36  34      37  36  37  37  34  36  36  35   x      31                              35      36          36  35              35  35  34                                  kill col 28  Tbl  18 cols 011001000000001111111111010110011100011111111 has  31 unique lines.
 *  29          30  27      30  30  30  31  29  30  30  28   x                                      29      30          30  30              29  29  29                                  kill col 40  Tbl  17 cols 011011000000001111111111010110011100011111111 has  27 unique lines.
 *  25          25          26  26  25  27  25  25  26  25   x                                      25      26          26  26              25  25  25                                  kill col 44  Tbl  16 cols 111011000000001111111111010110011100011111111 has  25 unique lines.
 *              23          24  24  23  25  23  23  24  23   x                                      23      24          24  24              23  23  23                                  kill col 41  Tbl  15 cols 111111000000001111111111010110011100011111111 has  23 unique lines.
 *                          22  22  21  23  21  21  22  21   x                                      21      22          22  22              21  21  21                                  kill col 36  Tbl  14 cols 111111001000001111111111010110011100011111111 has  21 unique lines.
 *                          20  19      21  19  19  20  19   x                                      19      20          20  20              19  19  19                                  kill col 37  Tbl  13 cols 111111011000001111111111010110011100011111111 has  19 unique lines.
 *                          18          19  17  17  18  17   x                                      17      18          18  18              17  17  17                                  kill col 34  Tbl  12 cols 111111011010001111111111010110011100011111111 has  17 unique lines.
 *                          16          17      15  16  15   x                                      15      16          16  16              15  15  16                                  kill col 33  Tbl  11 cols 111111011011001111111111010110011100011111111 has  15 unique lines.
Possible good candidates for removal, columns : 8 9 10 20 31 
 *
 * Round 1: 000000100100110000000000101001100011100000000  4 columns for indexes to table representing 11 original columns (uses 15 of 16 lines in indirect table).
 * Total columns to represent in EBRs: 38
 * 211 distinct lines in remaining untreated columns
 * c44 c43 c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 * 211 208 211 211 211 211   x 211 211   x 211 211   x   x   x 211 211 208 211 210 211 210 210 211   x 209   x 211 211   x   x 209 209 209   x   x   x 210 211 210 211 211 210 209 210  kill col 43  Tbl  32 cols 010000100100111000000000101001100011100000000 has 208 unique lines.
 * 208     208 208 208 208   x 208 208   x 208 208   x   x   x 208 208 205 208 207 208 207 207 208   x 206   x 208 208   x   x 206 206 206   x   x   x 207 208 207 208 208 207 206 207  kill col 27  Tbl  31 cols 010000100100111001000000101001100011100000000 has 205 unique lines.
 * 205     205 205 205 205   x 205 205   x 205 205   x   x   x 205 205     204 204 205 203 204 205   x 203   x 205 205   x   x 203 203 203   x   x   x 204 205 204 205 205 204 203 204  kill col 23  Tbl  30 cols 010000100100111001000100101001100011100000000 has 203 unique lines.
 * 203     203 203 203 203   x 203 203   x 203 203   x   x   x 203 203     202 201 203     202 203   x 201   x 203 203   x   x 201 201 201   x   x   x 202 203 202 203 202 202 201 202  kill col 25  Tbl  29 cols 010000100100111001010100101001100011100000000 has 201 unique lines.
 * 201     201 201 201 201   x 201 201   x 201 201   x   x   x 201 201     200     201     200 201   x 199   x 201 201   x   x 199 198 199   x   x   x 199 201 200 201 200 199 199 200  kill col 12  Tbl  28 cols 010000100100111001010100101001101011100000000 has 198 unique lines.
 * 198     196 198 198 198   x 198 198   x 198 198   x   x   x 198 198     197     198     196 198   x 196   x 198 198   x   x 195     196   x   x   x 196 198 197 198 197 196 196 197  kill col 13  Tbl  27 cols 010000100100111001010100101001111011100000000 has 195 unique lines.
 * 195     193 195 195 195   x 195 195   x 195 195   x   x   x 195 195     194     195     192 195   x 193   x 195 195   x   x         192   x   x   x 192 195 193 194 194 193 193 194  kill col 22  Tbl  26 cols 010000100100111001010110101001111011100000000 has 192 unique lines.
 * 192     190 192 192 192   x 192 192   x 192 191   x   x   x 192 192     191     191         192   x 190   x 192 192   x   x         189   x   x   x 188 191 188 191 191 190 190 190  kill col  7  Tbl  25 cols 010000100100111001010110101001111011110000000 has 188 unique lines.
 * 188     185 188 188 188   x 188 188   x 188 187   x   x   x 188 187     187     186         188   x 186   x 187 187   x   x         185   x   x   x     187 183 186 186 184 186 185  kill col  5  Tbl  24 cols 010000100100111001010110101001111011110100000 has 183 unique lines.
 * 183     177 183 183 183   x 183 183   x 183 182   x   x   x 183 182     182     179         183   x 181   x 181 182   x   x         179   x   x   x     180     181 178 176 177 179  kill col  2  Tbl  23 cols 010000100100111001010110101001111011110100100 has 176 unique lines.
 * 176     169 176 176 176   x 176 176   x 176 175   x   x   x 176 175     175     170         176   x 173   x 173 174   x   x         169   x   x   x     168     173 168     168 170  kill col  6  Tbl  22 cols 010000100100111001010110101001111011111100100 has 168 unique lines.
 * 168     159 168 168 168   x 168 168   x 167 167   x   x   x 165 166     167     160         167   x 165   x 165 166   x   x         159   x   x   x             158 156     152 158  kill col  1  Tbl  21 cols 010000100100111001010110101001111011111100110 has 152 unique lines.
 * 150     143 152 151 152   x 152 152   x 151 150   x   x   x 149 149     149     142         150   x 149   x 148 148   x   x         141   x   x   x             137 129         137  kill col  3  Tbl  20 cols 010000100100111001010110101001111011111101110 has 129 unique lines.
 * 126     117 129 127 129   x 129 128   x 127 127   x   x   x 125 126     126     117         127   x 123   x 120 123   x   x         116   x   x   x             107             107  kill col  4  Tbl  19 cols 010000100100111001010110101001111011111111110 has 107 unique lines.
 * 104      96 106 105 107   x 107 106   x 104 105   x   x   x 102 103     102      94         105   x 101   x  99 101   x   x          95   x   x   x                              85  kill col  0  Tbl  18 cols 010000100100111001010110101001111011111111111 has  85 unique lines.
 *  81      73  84  83  85   x  85  84   x  82  81   x   x   x  80  82      79      75          81   x  79   x  78  78   x   x          76   x   x   x                                  kill col 42  Tbl  17 cols 011000100100111001010110101001111011111111111 has  73 unique lines.
 *  70          72  71  73   x  73  72   x  70  69   x   x   x  69  69      66      64          70   x  68   x  65  66   x   x          62   x   x   x                                  kill col 11  Tbl  16 cols 011000100100111001010110101001111111111111111 has  62 unique lines.
 *  59          61  60  62   x  62  61   x  59  58   x   x   x  59  58      55      54          58   x  56   x  53  54   x   x               x   x   x                                  kill col 17  Tbl  15 cols 011000100100111001010110101101111111111111111 has  53 unique lines.
 *  50          52  50  52   x  53  52   x  50  47   x   x   x  48  48      47      47          49   x  45   x      46   x   x               x   x   x                                  kill col 19  Tbl  14 cols 011000100100111001010110111101111111111111111 has  45 unique lines.
 *  42          44  42  44   x  45  44   x  42  39   x   x   x  40  40      39      40          41   x       x      39   x   x               x   x   x                                  kill col 33  Tbl  13 cols 011000100101111001010110111101111111111111111 has  39 unique lines.
 *  36          38  36  38   x  39  38   x  36       x   x   x  34  34      33      34          35   x       x      34   x   x               x   x   x                                  kill col 26  Tbl  12 cols 011000100101111001110110111101111111111111111 has  33 unique lines.
 *  30          32  30  32   x  33  32   x  30       x   x   x  29  29              27          28   x       x      28   x   x               x   x   x                                  kill col 24  Tbl  11 cols 011000100101111001111110111101111111111111111 has  27 unique lines.
 *  24          26  24  25   x  26  26   x  24       x   x   x  23  24                          22   x       x      21   x   x               x   x   x                                  kill col 16  Tbl  10 cols 011000100101111001111110111111111111111111111 has  21 unique lines.
 *  19          20  18  19   x  20  20   x  18       x   x   x  17  17                          16   x       x           x   x               x   x   x                                  kill col 21  Tbl   9 cols 011000100101111001111111111111111111111111111 has  16 unique lines.
 *
 * Round 2: 100111011010000110000000000000000000000000000  4 columns for indexes to table representing  9 original columns (uses 16 of 16 lines in indirect table).
 * Direct:  011000000001000001111111010110011100011111111 24 columns
 * Success. Use 2 EBRs, 20 LUTs.
 */

module v6_m_2ebr
  (
   input         clk,
   input [7:0]   minx,
   input         progress_ucode,
/* verilator lint_off UNOPTFLAT */
   output [47:0] d
/* verilator lint_on UNOPTFLAT */
   );
   /*
    *                      indirect_index 1
    * inx         next     | indirect index 0
    * || ucode    ucode    | | direct representation
    * 00 LB_0     LB_1     0 0 010001101111110000000001| LB     Load byte. q = rdadr=RS1+0fs
    * 01 LB_1     LB_2     1 1 001001011111100111010010|        Read until q=mem[rs1+ofs) & ~3u]
    * 02 IJ_0     IJ_1     2 2 010001101111110010111110| IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0
    * 03 _L0x03   StdIncPc 1 3 0000000101x10xxx11100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 04 ADDI_0   StdIncPc 3 3 010000010111010011100110| ADDI   Add immediate. rd =RS1+Iimm (or joined)
    * 05 _L0x05   ADDI_0   1 3 0000000101x01xxx00000100| AUIPC  q = imm20 (copy x/2)
    * 06 LB_3     LB_4     1 3 000000110111101000000111|        q = ~mem[rs1+ofs]
    * 07 LB_4     LB_5     1 3 000000101111101100001001|        q = (uint8_t) mem[rs1+Iimm]
    * 08 _L0x08   SB_1     4 0 010001110111110001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 09 LB_5     LB_6     1 3 000000101111100010001011|        q = D^0xffffffff^q = D^0x80
    * 0a _L0x0a   SB_1     4 0 010001110111110001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 0b JALR_2   JAL_2    5 4 000000010111001110000110|        Q = (RS1+imn) & 0xfffffffe
    * 0c ADD_0    ADDI_0   1 3 000001110111100100000100| ADD    add     Addition Q = RS1
    * 0d MUL_0    MUL_1    1 3 1000011101x10xxx11100010| MUL    Store rs1 tp rM. Next read rs2. Q clear
    * 0e SUB_0    SUB_1    1 3 0000011101x10xxx00010000| SUB    Subtraction
    * 0f _L0x0f   StdIncPc 3 3 000000010111011011100110| LUI    q = imm20
    * 10 SUB_1    LB_6     1 3 000001111111100010001011|        Q = ~RS2
    * 11 AND_1    ANDI_1   1 3 000001110111100000011010|        RS1^0xffffffff to Q
    * 12 _L0x12   ILLe     1 3 00000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 13 condb_2  condb_3  1 3 000001111111100000010100|        ~RS2 in Q
    * 14 condb_3  condb_4  1 5 010000010111110000010101|        Calculate RS1+~RS2+1
    * 15 condb_4  condb_5  4 6 000001100111100100010110|        Branch on condition
    * 16 condb_5  Fetch    6 5 001101101100111011011110|        Branch not taken.
    * 17 condb_5t BrOpFet  6 4 010101101111110001110100|        Branch taken.
    * 18 BEQ      condb_2  5 3 000001110111011000010011| BEQ    Conditional Branch. Offset to Ryy
    * 19 JALR_0   JALR_1   5 3 010001010111010001000001| JALR   yy=RS1+imm
    * 1a ANDI_1   StdIncPc 3 3 000000010111001111100110|        rd = Iimm & RS1
    * 1b _L0x1b   JAL_1    1 4 000000010110111000110010| JAL    J-imm is in q. Branch on alignfault
    * 1c ECAL_BRK ECAL_RET 1 2 000001011110111010100110| ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI
    * 1d ORI_2    StdIncPc 3 3 000000010111011111100110|        rd = Iimm | RS1
    * 1e aFault_1 aFault_2 1 5 110001010101110011010100|        Q = 4
    * 1f IJ_2     IJ_3     5 3 000001010111011010110111|        Read word is to be masked with 2 lsb = 00
    * 20 LH_0     LH_1     7 7 010001101111110001010010| LH     Load hword. Q = rdadr=RS1+Iimm.
    * 21 XORI_1   StdIncPc 3 3 000000010111000011100110|        rd = Iimm ^ RS1
    * 22 MULHU_6  MULHU_7  1 8 000001010111110000111001|        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar
    * 23 _L0x23   StdIncPc 1 3 0000000101x10xxx11100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 24 SLLI_0   SLLI_1   1 0 000001111010x11000110101| SLLI   Shift left immediate.
    * 25 _L0x25   ADDI_0   1 3 0000000101x01xxx00000100| AUIPC  q = imm20 (copy x/2)
    * 26 OR_1     OR_2     4 3 000001110111000000100111|        RS1^0xffffffff to jj
    * 27 OR_2     ORI_2    1 3 010000000111110000011101|        Q = rs2
    * 28 _L0x28   SH_1     4 7 010001110111110010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 29 XOR_1    XORI_1   1 3 000001110111100000100001|        Q = RS1^0xFFFFFFFF
    * 2a _L0x2a   SH_1     4 7 010001110111110010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 2b SLTIX_1  SLTIX_2  1 5 01000xxxx111010000110000|        RS1 - imm / RS1 - RS2
    * 2c SLL_0    SLL_1    1 3 0000011101x0xxxx00111110| SLL    Shift left
    * 2d MULH_0   MULH_1   1 3 000001010011100101101010| MULH   Store rs1 to Q. Prep read 0, shcnt--
    * 2e MULHU_1  MULHU_2  4 3 100001111111011001000010|        rM<=RS2,  Rjj<=Q=0. next read RS1. 
    * 2f _L0x2f   StdIncPc 3 3 000000010111011011100110| LUI    q = imm20
    * 30 SLTIX_2  StdIncPc 3 9 000000010111011011100110|        Registered ALU flag to rd
    * 31 SLTX_1   SLTIX_1  1 3 000001111111100000101011|        ~rs2 to Q
    * 32 JAL_1    JAL_2    5 3 010000010111010010000110|        Target adr to yy
    * 33 JAERR_1  JAERR_2  5 3 010110010110x10010000001|  Err   JAL target adr misaligned, store to mtval
    * 34 JAL_3    Fetch    6 3 001101101110100111011110|        PC+imm/trap entrypt to PC. OpFetch
    * 35 SLLI_1   SLLI_2   3 3 000001011011100100110110|        Register to shift to Q (and TRG for shift 0)
    * 36 SLLI_2   _L0x03   8 3 000001011011110100000011|        Repeat Q = Q+Q until shregcnt == 0
    * 37 ECALL_2  ECALL_3  5 6 00001xxxx111000111010111|        mepc = pc, prep store 0 to mtval
    * 38 BNE      condb_2  5 3 000001110111011000010011| BNE    Conditional Branch. Offset to Ryy
    * 39 MULHU_7  StdIncPc 3 3 100000010111000111100110|        Last shift.
    * 3a SRxI_1   SRxI_2   3 8 000001010011100100111101|        Register to shift to Q
    * 3b _L0x3b   JAL_1    1 4 000000010110111000110010| JAL    J-imm is in q. Branch on alignfault
    * 3c CSRRW_0  CSRRW_1  5 3 000000110111011001001001| CSRRW  Decoded CSR adr in yy
    * 3d SRxI_2   _L0x03   8 8 000001010011100100000011|        Repeat Q >>= 1 until shregcnt == 0
    * 3e SLL_1    SLLI_1   1 0 000001111010x00100110101|        Shiftamount was in low 5 bits of RS2
    * 3f SRx_1    SRxI_1   1 0 000001111010x00100111010|        Shiftamount in low 5 bits of RS2
    * 40 LW_0     LW_1     0 4 010001101111110001010000| LW     Load word. Q=yy=rdadr=RS1+Iimm
    * 41 JALR_1   JALR_2   1 5 010001100111110000001011|        Q=1
    * 42 MULHU_2  MULHU_3  1 8 000001010011110001100000|        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar
    * 43 MULHU_4  MULHU_5  1 3 000000000110100011101010|        Prepare read Rjj.
    * 44 SLTI_0   SLTIX_1  1 3 000001111111101000101011| SLTI   Set less than immediate (signed)
    * 45 WFI_3    WFI_4    1 5 010001010111110001100101|        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105
    * 46 ILL_1    ILL_2    5 3 000011010110x00101000111|        Store PC to mepc
    * 47 ILL_2    ILL_3    5 3 000111010111000110001111|        Store 0 to mtval
    * 48 _L0x48   SW_1     9 4 010001110111110001100110| SW     Store word. Q=wradr=RS1+Simm
    * 49 CSRRW_1  CSRRW_2  1 5 010000010111110001001011|        Construct PC storage adr
    * 4a _L0x4a   SW_1     9 4 010001110111110001100110| SW     Store word. Q=wradr=RS1+Simm
    * 4b CSRRW_2  CSRRW_3  a 3 000111010110100110110001|        Write PC to 0x100 start Prep emulation entrypt
    * 4c SLT_0    SLTX_1   1 3 0000011101x10xxx00110001| SLT    Set less than (signed)
    * 4d MULHSU_0 MULHU_1  5 3 000001110011000100101110| MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--
    * 4e eILL0b   ILLe     1 3 00000xxxx1x0xxxx11111110| Illegal instruction seen
    * 4f MRET_8   StdIncPc 1 5 010001010111110011100110|        Prep +4
    * 50 LW_1     StdIncPc 3 a 001001011111000111100110|        Read until d=mem[(rs1+ofs) & ~3u]
    * 51 LDAF_LW  LDAF_a   5 3 000111010110111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 52 LH_1     LH_2     1 1 001001011111100101010100|        Read until q=mem[(rs1+ofs) & ~3u]
    * 53 LDAF_LH  LDAF_a   5 3 000111010110111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 54 LH_2     LH_3     b 8 000001010011100111101011|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 55 aFaultb  aFault_1 5 3 000111010111011000011110|  err   LH Load access fault. Faulting adr to mtval
    * 56 LH_4     LH_5     1 3 000001000111101101010111|        q = (uint16_t) mem[rs1+Iimm]
    * 57 LH_5     LB_6     1 3 000001000111100010001011|        q = D^0xffffffff^q = D ^ 0x00008000
    * 58 DIV_A    DIV_C    1 8 110001011111100101101110|        Transfer rM to rDee
    * 59 DIV_B    DIV_10   5 3 000001111111011010011100|        REM = Q to yy
    * 5a SB_1     SB_2     5 3 000001011011100101011101|        Write d to Q and yy (for sh 0). Prep shift
    * 5b _L0x5b   JAL_1    1 4 000000010110111000110010| JAL    J-imm is in q. Branch on alignfault
    * 5c CSRRS_0  CSRRW_1  5 3 000000110111011001001001| CSRRS  Decoded CSR adr in yy
    * 5d SB_2     SB_3     c 3 000001011011110111111011|        Repeat shl until shreg = 0 (0,8,16 or 24 times)
    * 5e LHU_1    LHU_2    1 1 001001011111100101110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 5f LDAF_LHU LDAF_a   5 3 000111010110111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 60 MULHU_3  MULHU_2  1 3 100001111111100101000010|        Shift Q and rM. Prepare read rs1
    * 61 EBRKWFI2 EBREAK_1 4 6 000000110111001011110111| EBREAK/WFI2 Select EBREAK or WFI
    * 62 DIV_8    DIV_7    1 5 010001011011110011001000|        Conditionally subtract rs2. Update M[0]
    * 63 DIV_9    DIV_A    d 5 010001011111110001011000|        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]
    * 64 SLTIU_0  SLTIX_1  1 3 000001111111101000101011| SLTIU  Set less than immediate (unsigned)
    * 65 WFI_4    WFI_5    1 6 0000000101x10xxx11101111|        Prepare read PC
    * 66 SW_1     SW_2     e 3 000111110110100111110010|        Write d to a+k until accepted
    * 67 SW_E1SWE SW_E2    5 3 000110010110x11010010011|        Store faulting address alignment to mtval
    * 68 DIV_12   StdIncPc 3 3 000000010111000111100110|        RS2 > 0, RS1 >= 0, yy is true result
    * 69 DIV_13   LB_6     1 3 000001010111100010001011|        RS2 > 0, RS1 < 0, change sign yy
    * 6a MULH_1   MULH_2   5 3 000001010111000011111001|        Store ~rs1 to Ryy. Prep construct 1.
    * 6b SB_4     SB_5     9 3 000101100111100101111010|        Address back to Q. Prepare get item to write
    * 6c SLTU_0   SLTX_1   1 3 0000011101x10xxx00110001| SLTU   Set less than (unsigned)
    * 6d MULHU_0  MULHU_1  5 3 000001110011000100101110| MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--
    * 6e DIV_C    DIV_e    5 3 000001110110100110111001|        rM to yy. Q=ffffffff
    * 6f MRET_6   MRET_7   1 5 01000xxxx111110011001111|        ~302 + origImm + 1 for branch decision
    * 70 LHU_2    LHU_3    b 8 000001010011100110111010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 71 aFaultc  aFault_1 5 3 000111010111011000011110|  err   LHU Load access fault. Faulting adr to mtval
    * 72 LBU_3    ANDI_1   1 3 000000110111101000011010|        Invert q. Prepare read mask
    * 73 BAERR_1  BAERR_2  5 3 000111100111000101110110|        Faultadr to mtval. Prepare get offset
    * 74 BrOpFet  Fetch2   1 b 001001011111011011110100| NewOp2 Read until instruction latched
    * 75 BAlignEr BAERR_1  1 3 0000000101x0xxxx01110011|  Err   Branch target instruction address misaligned
    * 76 BAERR_2  BAERR_3  1 3 000000010111100001110111|        ~offset to Q. Prep read (origPC+offset)
    * 77 BAERR_3  BAERR_4  5 5 010011010110x10001111101|        origPC to mepc. Prep read 0
    * 78 DIV_4    DIV_6    5 3 000000000111011010101010|        ~abs(divisor) to yy
    * 79 DIV_5    DIV_3    1 5 110001010111110010101000|        Kluge to let add1 work in DIV instr
    * 7a SB_5     SW_2     e 3 000101100110100111110010|        Write d to a+k until accepted
    * 7b _L0x7b   JAL_1    1 4 000000010110111000110010| JAL    J-imm is in q. Branch on alignfault
    * 7c CSRRC_0  CSRRW_1  5 3 000000110111011001001001| CSRRC  Decoded CSR adr in yy
    * 7d BAERR_4  JAL_3    f 3 000101001110x00100110100|        Store 0 to mcause. Prep get trap entry pont
    * 7e NMI_1    NMI_2    5 3 00001xxxx111000110010000|        Store pc to mepc.
    * 7f JALRE2   BAERR_4  5 3 000111010110x00101111101|        mtval is target
    * 80 LBU_0    LBU_1    0 0 010001101111110010000101| LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.
    * 81 JAERR_2  BAERR_4  5 3 000011010110x00101111101|        Store PC to mepc
    * 82 DIV_1    DIV_3    4 3 000001110111000010101000|        jj=abs(RS1). Next handle divisor
    * 83 DIV_2    DIV_1    1 3 010001010111110010000010|        Dividend negative, make RS1-1
    * 84 XORI_0   XORI_1   1 3 000001111111101000100001| XORI   Xor immediate. Q=~Iimm
    * 85 LBU_1    LBU_2    1 1 001001011111100111110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 86 JAL_2    JAL_25   3 5 110000010100x10010011110|        Return address to TRG
    * 87 JALRE1   JALRE2   5 3 000011100110x00101111111|  err   Store pc to mepc
    * 88 DIV_E    DIV_10   d 3 1000011111x0xxxx10011100|        RS2 != 0. Check signs
    * 89 DIV_F    StdIncPc 3 3 000000010111011011100110|        RS2 == 0, return 0xffffffff
    * 8a DIVU_5   ANDI_1   1 8 1100010111x10xxx00011010|        Transfer rM to rDee
    * 8b LB_6     StdIncPc 3 5 110000010111010011100110|        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80
    * 8c XOR_0    XOR_1    1 3 0000011111x10xxx00101001| XOR    xor
    * 8d DIV_0    DIV_1    d 3 100001011011100110000010| DIV    Branch on sign dividend RS1
    * 8e _LCSRRS_1 ILLe     1 3 00000xxxx1x0xxxx11111110| Illegal instruction seen
    * 8f ILL_3    ILL_4    1 5 000001010111110010101001|        Q = 1
    * 90 NMI_2    JAL_3    f 3 000110100111011000110100|        mtval = 0.
    * 91 LDAF_2   LDAF_3   f 5 110100010100x10010010010|        Store 4 to mcause
    * 92 LDAF_3   JAL_3    5 3 000011001110x00100110100|        PC to mepc
    * 93 SW_E2    SW_E3    5 3 000011011111000110010101|        Store address that faulted
    * 94 SW_E4    JAL_3    f 3 000101001110x10100110100|        Store 6 to mcause
    * 95 SW_E3    SW_E4    1 5 110001011101110010010100|        Q = 3
    * 96 SH_1     SH_2     5 3 000001011011100110111011|        Write d to Q and yy (for sh 0). Prep shift
    * 97 SW_E1SWH SW_E2    5 3 000110010110x11010010011|        Store faulting address alignment to mtval
    * 98 BLT      condb_2  5 3 000001110111011000010011| BLT    Conditional Branch. Offset to Ryy
    * 99 _L0x99   ILLe     1 3 00000xxxx1x0xxxx11111110|  Not in use (illegal as entry)
    * 9a ECALL_6  JAL_3    f 3 010101001100x10000110100|        mcause = 11
    * 9b SH_4     SH_5     9 3 000011100111100110011111|        Address back to Q. Prepare get item to write
    * 9c DIV_10   DIV_12   d 3 100001100111000101101000|        RS2 > 0. Branch on sign of RS1
    * 9d DIV_11   DIV_14   d 3 100001100111000110100010|        RS2 < 0. Branch on sign of RS1
    * 9e JAL_25   JAL_3    4 3 000001100110x00100110100|        Instr. adr. to jj in case of access error
    * 9f SH_5     SW_2     e 3 000011100110100111110010|        Write d to a+k until accepted
    * a0 LHU_0    LHU_1    7 7 010001101111110001011110| LHU    Load unsigned hword. Q = rdadr=RS1+Iimm
    * a1 ECALL_4  ECALL_5  1 5 110001010101110010110110|        Q = 4
    * a2 DIV_14   LB_6     1 3 000001010111100010001011|        RS2 < 0, RS1 >= 0, change sign yy
    * a3 DIV_15   StdIncPc 3 3 000000010111000111100110|        RS2 < 0, RS1 < 0, yy is true result
    * a4 SRxI_0   SRxI_1   1 0 000001111010x11000111010| SRxI   Shift Right immediate (both logic/arith here)
    * a5 MRET_3   MRET_4   1 5 010000110111110010101111|        0x102 + 0xff + 1 = 0x202
    * a6 ECAL_RET ECALL_1  1 4 000001011110111011010000| ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET
    * a7 EBRKWFI1 EBRKWFI2 1 3 01000xxxx111110001100001| EBREAK/WFI1 Prepare select EBREAK or WFI
    * a8 DIV_3    DIV_4    d 3 100001010111100001111000|        Branch on sign divisor RS2
    * a9 ILL_4    JAL_3    f 5 010101001110x10000110100|        Store 2 to mcause
    * aa DIV_6    DIV_7    1 3 1000010111x10xxx11001000|        Write M. Prepare shift
    * ab EBREAK_2 ECALL_6  5 3 000011010111000110011010|        pc to mepc
    * ac _L0xac   SRx_1    1 3 0000011101x0xxxx00111111| SRx    Shift Right (both SRL and SRA)
    * ad DIVU_0   DIVU_1   1 3 1000011100x10xxx11100000| DIVU   Store rs1 to rM. Q=0. Prepare invert rs2
    * ae _L0xae   SRx_1    1 3 0000011101x0xxxx00111111| SRx    Shift Right (both SRL and SRA)
    * af MRET_4   MRET_5   1 5 01000xxxx111110011000101|        0x202 + 0xff + 1 = 0x302
    * b0 aF_SW_3  LDAF_3   f 3 010100010100x10010010010|        Store 7 to mcause
    * b1 CSRRW_3  CSRRW_4  1 5 110001010101110010110010|        Prep emulation entrypt 0x108, here Q to 0x104
    * b2 CSRRW_4  Fetch    6 5 111001101100110011011110|        IncPC, OpFetch, but force +4
    * b3 unxb3             e 0 00xxxxxxxxxxxxxxxxxxxxxx| b3: Not in use 
    * b4 eFetch3           4 5 010011111111110000000000|  Fr10  Update minstret, Q=immediate. Use dinx
    * b5 SH_3     SH_4     1 3 000000000111011010011011|        Prepare get back address to use 
    * b6 ECALL_5  ECALL_6  1 5 110001010101110010011010|        Q = 8
    * b7 IJ_3     IJ_4     1 3 010001100101110010111101|        Construct Q = 3
    * b8 BGE      condb_2  5 3 000001110111011000010011| BGE    Conditional Branch. Offset to Ryy
    * b9 DIV_e    DIV_D    1 5 000001100111100011000000|        Calc carry of RS2+0xFFFFFFFF
    * ba LHU_3    ANDI_1   1 3 000000111111101000011010|        Invert q. Prepare read mask
    * bb SH_2     SH_3     c 3 000001011011110110110101|        Repeat shl until shreg = 0 (0,8 or 24 times)
    * bc CSRRWI_0 CSRRW_1  5 3 000000110111011001001001| CSRRWI Decoded CSR adr in yy
    * bd IJ_4     Fetch    0 3 001001101110101111011110|        Mask and use as PC
    * be IJ_1     IJ_2     1 3 001001011111100100011111|        Read until q=mem[(rs1+ofs)&~3u]
    * bf IJT_1    IJT_2    1 3 001001011111100111000001|        Exit CSR, enter trap
    * c0 DIV_D    DIV_E    1 6 000001110111100110001000|        Is RS2 == 0?
    * c1 IJT_2    IJT_3    5 3 000001010111011011101001|        Read word is to be masked with ~3u
    * c2 DIVU_3   DIVU_2   1 5 010001011011110011001010|        Conditionally subtract rs2. Update M[0]
    * c3 DIVU_4   DIVU_5   d 5 010001011111110010001010|        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]
    * c4 ORI_0    ORI_1    4 3 000001111111001011100001| ORI    Or immediate. jj=~Iimm
    * c5 MRET_5   MRET_6   1 3 000000000111101001101111|        ~302
    * c6 IJT_4    ILL_2    5 3 000011010111101101000111|        Mask and store to mepc and Q for read of instr
    * c7 QINT_1   QINT_2   5 3 00001xxxx111000111001011|        Store pc to mepc.
    * c8 DIV_7    DIV_8    1 c 100001100111110101100010|        Shift (Q,M) left. Prepare unsigned sub
    * c9 MRET_2   MRET_3   1 3 010000110101110010100101|        0xff+3 = 0x102
    * ca DIVU_2   DIVU_3   1 c 100001100111110111000010|        Shift (Q,M) left. Prepare unsigned sub
    * cb QINT_2   StdIncPc f 3 000110100111011011100110|        mtval = 0.
    * cc OR_0     OR_1     1 3 0000011111x10xxx00100110| OR     or
    * cd REM_0    DIV_1    d 3 100001011011100110000010| REM    Branch on sign dividend RS1
    * ce _LCSRRCI_1 ILLe     1 3 00000xxxx1x0xxxx11111110| Illegal instruction seen
    * cf MRET_7   MRET_8   1 6 0000001101x10xxx01001111|        Prepare emulation entry point 0x104
    * d0 ECALL_1  ECALL_2  1 5 010000010111110000110111| ECALL  Verify Imm==0x000
    * d1 MRET_1   MRET_2   4 3 000000110111011011001001| MRET   First save Imm, start build constant for check
    * d2 LB_2     LB_3     b 8 000001010011100100000110|        Repeat shr until shreg == 0 (0,8,16,24 times)
    * d3 aFaultd  aFault_1 5 3 000111010111011000011110|  err   LB Load access fault. Faulting adr to mtval
    * d4 aFault_2 LDAF_3   f 5 010100010110x10010010010|        Store 5 to mcause
    * d5 eFetch2  eFetch3  4 d 010110001111010010110100|  Fr10  Update ttime
    * d6 eILL0c   ILLe     1 3 00000xxxx1x0xxxx11111110| Illegal instruction seen
    * d7 ECALL_3  ECALL_4  5 3 000111010111011010100001|        mtval = 0, now start the chore of 11 to mcause
    * d8 BLTU     condb_2  5 3 000001110111011000010011| BLTU   Conditional Branch. Offset to Ryy
    * d9 MULH_3   MULHU_2  1 3 1000011111x10xxx01000010|        rM<=RS2, Q = 0. next read RS1. Join.
    * da LDAF_a   LDAF_2   1 3 0000010101x10xxx10010001|        Extra cycle after error detected write mtval
    * db jFault_1 LDAF_3   5 5 010100000110x10010010010|        Store 1 to mcause
    * dc CSRRSI_0 CSRRW_1  5 3 000000110111011001001001| CSRRSI Decoded CSR adr in yy
    * dd aF_SW_1  aF_SW_2  5 3 000111010111011011100101|  err   SW Store access fault. Faulting adr to mtval
    * de Fetch    Fetch2   4 e 000100011111011011110100|  Fr10  Read and latch instruction
    * df eFetch   eFetch2  4 b 001101011111011011010101|  Fr10  rep Read until d=mem[(rs1+ofs) & ~3u]
    * e0 DIVU_1   DIVU_2   5 3 000001011111000011001010|        Store inverted rs2 to yy. Prepare shift
    * e1 ORI_1    ORI_2    1 3 000000000111100100011101|        Q = RS1
    * e2 MUL_1    MUL_2    1 8 000001010011110011101000|        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar
    * e3 MUL_3    ANDI_1   1 8 1100010111x10xxx00011010|        Transfer rM to rDee
    * e4 ANDI_0   ANDI_1   1 3 000001111111101000011010| ANDI   And immediate. Q=~Iimm
    * e5 aF_SW_2  aF_SW_3  1 5 110001010101110010110000|        Q = 4
    * e6 StdIncPc Fetch    6 5 111001101100110011011110|  Fr10  IncPC, OpFetch
    * e7 aFault   aFault_1 5 3 000111010111011000011110|  err   Load access fault. Faulting adr to mtval
    * e8 MUL_2    MUL_1    1 3 100001110111100111100010|        Shift Q and rM. Prepare read rs2
    * e9 IJT_3    IJT_4    1 3 010001100101110011000110|        Construct Q = 3
    * ea MULHU_5  MULHU_6  1 3 000001100111110000100010|        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy
    * eb LH_3     LH_4     1 3 000000111111101001010110|        q = ~mem[rs1+ofs]
    * ec AND_0    AND_1    1 3 0000011111x10xxx00010001| AND    And 
    * ed REMU_0   DIVU_1   1 3 1000011100x10xxx11100000| REMU   Store dividend to rM. Prepare read divisor.Q=0
    * ee eILL0a   ILLe     1 3 00000xxxx1x0xxxx11111110| Illegal instruction seen
    * ef WFI_5    Fetch    6 5 111101101100110011011110|        IncPC, OpFetch
    * f0 LBU_2    LBU_3    b 8 000001010011100101110010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * f1 aFaulte  aFault_1 5 3 000111010111011000011110|  err   LBU Load access fault. Faulting adr to mtval
    * f2 SW_2     StdIncPc 1 3 0000000101x10xxx11100110|        Prepare read PC
    * f3 aF_SW    aF_SW_1  1 3 00000xxxx1x01xxx11011101|  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf
    * f4 Fetch2            4 d 010111111111110000000000|  Fr10  Update ttime. Update I. Q=immediate. Use dinx
    * f5 jFault   jFault_1 5 3 000111010111011011011011|  err   Fetch access fault. Faulting adr to mtval
    * f6 WFI_1    WFI_2    1 5 110000000101110011111010| WFI    Chk offset=0x105. Now=0xff. Prep 0xff+4 = 0x103
    * f7 EBREAK_1 EBREAK_2 5 3 000110010111011010101011| EBREAK mepc = pc, store 0 to mtval
    * f8 BGEU     condb_2  5 3 000001110111011000010011| BGEU   Conditional Branch. Offset to Ryy
    * f9 MULH_2   MULH_3   4 5 010001110111010011011001|        Store 1 to Rjj. next read rs2, Q=0
    * fa WFI_2    WFI_3    1 5 010001010111110001000101|        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104
    * fb SB_3     SB_4     1 3 000000000111011001101011|        Prepare get back address to use 
    * fc CSRRCI_0 CSRRW_1  5 3 000000110111011001001001| CSRRCI Decoded CSR adr in yy
    * fd NMI_0    NMI_1    1 3 0000000101x10xxx01111110| NMI    Get current PC
    * fe ILLe     ILL_1    1 3 0000000101x0xxxx01000110| Illegal
    * ff QINT_0   QINT_1   1 3 0000000101x10xxx11000111| INT    Get current PC
    */
   localparam u0_0 = 256'h76e6501050e2790473867c5af88b7c5afb097a07480474e650e6fcbef9d2fc01;
   localparam u0_1 = 256'h76b75cd477e6eea66e3273e674417613fc74cede79167c15f81440fe781af88b;
   localparam u0_2 = 256'h76e6f642396a403e74307c9678217c967c1d70274804a63550e67c3970e6fc52;
   localparam u0_3 = 256'ha13aa135390376496e32393d71e6761371d7bd03b936e9de64817486f82b76e6;
   localparam u0_4 = 256'h7ce640fe312e503169b17c667c4b7c66718f61477c65fa2b68ea3c607c0bfc50;
   localparam u0_5 = 256'h6edaf970bdfb76496e32b95df69cf96e788b7b57761e39eb6edaf9546edaf1e6;
   localparam u0_6 = 256'h7ccf69b9312e5031797a70f9788b71e6669369f250effa2bfc58bcc872f7f942;
   localparam u0_7 = 256'h617d7190e13476496e3269f27ca876aa647d78774073f6f471767a1a761e39ba;
   localparam u0_8 = 256'h7ca940feb982d02974e6d01a76e6c09c617f449ef9f0fa217c8270a8617dfc85;
   localparam u0_9 = 256'h69f2613471a27168799fc43440fe76136693b9bbdc94e534f195e13444927634;
   localparam u0_A = 256'h7cc5403f10e0403f719ad0c8e43478787c61eed07cafa63a71e6788b5cb6fc5e;
   localparam u0_B = 256'hf9c1f91febde7649bdb5fa1a78c076135cbd5c9a769bfc000000ccde5cb24492;
   localparam u0_C = 256'h504f40feb982d02676e67dc25ca57d6271cb7b477a6ff2e1fc8abcca76e97988;
   localparam u0_D = 256'hf6d5f6f476e5764964925091d042761376a140fef4b46492761e390676c97c37;
   localparam u0_E = 256'hccde40fe10e0d011fa567c225cc679e2761eccde5cb0fa1ad01a3ce8791df0ca;
   localparam u0_F = 256'h50c74046507e7649766b7c4574d9761376ab5cfa76dbfc0048dd50e6761e3972;
   localparam u1_0 = 256'h3301130713871307540140471302404713021303130133411301224611250046;
   localparam u1_1 = 256'h530515c533011205140133015345530764566536460615411307130013071307;
   localparam u1_2 = 256'h3301438713051307154047471307474713404307130110071301180533017746;
   localparam u1_3 = 256'h1007100788055303140138053381530756088305330563365359534113073901;
   localparam u1_4 = 256'h1545130053071307a31d944715419447531d530d154513071300180515460446;
   localparam u1_5 = 256'h531d1125c305530314015305530718c513041304531db805531d1125531d3a25;
   localparam u1_6 = 256'h154053075307130793165305130533015319e31f16011307d545154546031387;
   localparam u1_7 = 256'h531d5308f31453031401e31615c55300554d130113011b25531e1303531db805;
   localparam u1_8 = 256'h15051300d385130735c118c53301d387530e35c11125130713454307530d0046;
   localparam u1_9 = 256'he30e4306d386d386930ef354130053075319530515c5f314530d530cf5d1f31a;
   localparam u1_A = 256'h1540130713871307530d1385f554d38513401405154310073301130515c57746;
   localparam u1_B = 256'h1325132503265303c305130315065307134615c51300454fe00065e615c5f351;
   localparam u1_C = 256'h16031300d3851307f31a1c8613431c865308530d13004307d545154553051607;
   localparam u1_D = 256'h4b354e11531d53035550130513875307531d13004d58f551531db80543031541;
   localparam u1_E = 256'h65f61300138713071303130613461387531d65e615c5130718c5180513005305;
   localparam u1_F = 256'h13011301130153031300154545475307531915c0531d4d5f13001301531db805;
   wire [31:0]   indir;
`ifdef verilator
   /* verilator lint_off UNUSED */
   wire [15:0]   sim_a;
   wire [15:0]   sim_b;
   /* verilator lint_on UNUSED */
`endif
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u0_0), .INIT_1(u0_1), .INIT_2(u0_2), .INIT_3(u0_3),
                   .INIT_4(u0_4), .INIT_5(u0_5), .INIT_6(u0_6), .INIT_7(u0_7),
                   .INIT_8(u0_8), .INIT_9(u0_9), .INIT_A(u0_A), .INIT_B(u0_B),
                   .INIT_C(u0_C), .INIT_D(u0_D), .INIT_E(u0_E), .INIT_F(u0_F)
                   ) ucode0
     (
      .RDATA( indir[15:0]         ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u1_0), .INIT_1(u1_1), .INIT_2(u1_2), .INIT_3(u1_3),
                   .INIT_4(u1_4), .INIT_5(u1_5), .INIT_6(u1_6), .INIT_7(u1_7),
                   .INIT_8(u1_8), .INIT_9(u1_9), .INIT_A(u1_A), .INIT_B(u1_B),
                   .INIT_C(u1_C), .INIT_D(u1_D), .INIT_E(u1_E), .INIT_F(u1_F)
                   ) ucode1
     (
      .RDATA( indir[31:16]        ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );

   assign d[0] = indir[0];
   assign d[1] = indir[1];
   assign d[2] = indir[2];
   assign d[3] = indir[3];
   assign d[4] = indir[4];
   assign d[5] = indir[5];
   assign d[6] = indir[6];
   assign d[7] = indir[7];
   assign d[11] = indir[8];
   assign d[12] = indir[9];
   assign d[13] = indir[10];
   assign d[16] = indir[11];
   assign d[17] = indir[12];
   assign d[19] = indir[13];
   assign d[21] = indir[14];
   assign d[22] = indir[15];
   assign d[23] = indir[16];
   assign d[24] = indir[17];
   assign d[25] = indir[18];
   assign d[26] = indir[19];
   assign d[27] = indir[20];
   assign d[33] = indir[21];
   assign d[42] = indir[22];
   assign d[43] = indir[23];
   // replaces = 000000100100110000000000101001100011100000000
   SB_LUT4 #(.LUT_INIT(16'h0102)) cmb_d08(.O(d[8]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0220)) cmb_d09(.O(d[9]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h1020)) cmb_d10(.O(d[10]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0040)) cmb_d14(.O(d[14]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h4800)) cmb_d15(.O(d[15]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h2000)) cmb_d18(.O(d[18]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h7f7e)) cmb_d20(.O(d[20]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0094)) cmb_d31(.O(d[31]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0010)) cmb_d32(.O(d[32]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0802)) cmb_d35(.O(d[35]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0c00)) cmb_d38(.O(d[38]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   // replaces = 100111011010000110000000000000000000000000000
   SB_LUT4 #(.LUT_INIT(16'h91a8)) cmb_d28(.O(d[28]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h90f0)) cmb_d29(.O(d[29]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h1900)) cmb_d34(.O(d[34]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h8004)) cmb_d36(.O(d[36]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h8400)) cmb_d37(.O(d[37]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h2a07)) cmb_d39(.O(d[39]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h02c5)) cmb_d40(.O(d[40]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0200)) cmb_d41(.O(d[41]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h2000)) cmb_d44(.O(d[44]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   assign d[45] = 1'b0;
   assign d[46] = 1'b0;
   assign d[47] = 1'b0;
wire instr0100,instr1x110100;            bn_l4v #(.I(16'h0010)) leq0100(     .o(instr0100),     .i({minx[3:0]}));    bn_l4v #(.I(16'h8000)) leq1x110100( .o(instr1x110100), .i({minx[7],minx[5:4],instr0100}));    SB_DFFE reg_d18( .Q(d[30]), .C(clk), .E(progress_ucode), .D(instr1x110100));
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019-2020. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * Automatically generated from ../code/ucode.h by midgetv_indirectEBR.c.
 * Do not edit.
 * Optiones for this variant:
 *   No RVC
 *   MULDIV included
 *   minstret for instructions in SRAM and EBR
 */
/* Using LUTSIZE=4. Using 2 EBRs. Initial table has 45 columns
 * Removed:  000000000000001000000000000000000000000000000 These are removed from consideration, replaced with hand-crafted Verilog code in the output stage
 * Reserved: 000000000000000000000000000000000000000000000 Columns to be represented directly, not part of optimalization
 * Total columns to represent in EBRs: 45
 * 210 distinct lines in remaining untreated columns
 * c44 c43 c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 * 210 209 210 210 210 210 210 210 210 210 210 210 210 210   x 210 210 208 210 209 210 209 209 210 210 210 210 210 210 210 210 208 208 208 210 209 210 209 210 209 210 210 209 208 209  kill col 27  Tbl  43 cols 000000000000001001000000000000000000000000000 has 208 unique lines.
 * 208 207 208 208 208 208 208 208 208 208 208 208 208 208   x 208 208     207 207 208 206 207 208 208 208 208 208 208 208 208 206 206 206 208 207 208 207 208 207 208 208 207 206 207  kill col 23  Tbl  42 cols 000000000000001001000100000000000000000000000 has 206 unique lines.
 * 206 205 206 206 206 206 206 206 206 206 206 206 206 206   x 206 206     205 204 206     205 206 206 206 206 206 206 206 206 204 204 204 206 205 206 205 206 205 206 206 205 204 205  kill col 25  Tbl  41 cols 000000000000001001010100000000000000000000000 has 204 unique lines.
 * 204 203 204 204 204 204 204 204 204 204 204 204 204 204   x 204 204     203     204     203 204 204 204 204 204 204 204 204 202 201 202 204 203 204 202 204 203 204 204 203 202 203  kill col 12  Tbl  40 cols 000000000000001001010100000000001000000000000 has 201 unique lines.
 * 201 200 200 201 201 201 201 201 201 201 201 201 201 201   x 201 201     200     201     199 201 201 201 201 201 201 201 201 198     199 201 200 201 199 201 200 201 201 200 199 200  kill col 13  Tbl  39 cols 000000000000001001010100000000011000000000000 has 198 unique lines.
 * 198 197 197 198 198 198 198 198 198 198 198 198 198 198   x 198 198     197     198     196 198 198 198 198 198 198 198 198         195 198 197 198 196 198 197 197 198 197 196 197  kill col 11  Tbl  38 cols 000000000000001001010100000000011100000000000 has 195 unique lines.
 * 195 194 193 195 195 195 195 195 195 195 195 195 195 195   x 195 195     194     195     193 195 195 195 195 195 195 195 195             195 194 195 193 195 193 193 195 194 193 194  kill col 42  Tbl  37 cols 001000000000001001010100000000011100000000000 has 193 unique lines.
 * 193 191     193 193 193 193 193 193 193 193 193 193 193   x 193 193     192     193     191 193 193 192 193 193 193 193 193             193 192 193 191 193 191 191 193 192 191 192  kill col 43  Tbl  36 cols 011000000000001001010100000000011100000000000 has 191 unique lines.
 * 191         191 191 191 191 191 191 191 191 191 191 191   x 191 191     190     191     189 191 191 189 191 191 191 191 191             190 190 191 189 191 189 189 191 190 189 189  kill col 22  Tbl  35 cols 011000000000001001010110000000011100000000000 has 189 unique lines.
 * 189         189 189 189 189 189 189 189 189 189 189 189   x 189 189     188     188         189 189 187 189 189 189 189 189             188 188 188 187 188 186 186 189 188 187 186  kill col  5  Tbl  34 cols 011000000000001001010110000000011100000100000 has 186 unique lines.
 * 186         186 186 186 186 186 186 186 186 186 186 186   x 186 186     185     185         186 186 184 186 185 186 186 186             183 185 185 180 181     183 183 182 180 182  kill col  7  Tbl  33 cols 011000000000001001010110000000011100010100000 has 180 unique lines.
 * 180         180 180 180 180 180 180 180 180 179 180 180   x 180 179     179     175         180 180 178 180 177 180 180 180             178 179 179     175     177 175 172 174 176  kill col  2  Tbl  32 cols 011000000000001001010110000000011100010100100 has 172 unique lines.
 * 172         172 172 172 172 172 172 172 172 171 172 172   x 172 171     170     165         172 172 168 172 168 170 172 172             170 171 170     164     167 164     163 165  kill col  1  Tbl  31 cols 011000000000001001010110000000011100010100110 has 163 unique lines.
 * 161         163 163 163 163 163 163 163 162 161 163 163   x 163 162     158     153         161 163 159 163 156 159 163 163             161 161 160     149     153 148         153  kill col  3  Tbl  30 cols 011000000000001001010110000000011100010101110 has 148 unique lines.
 * 146         148 148 148 148 148 148 148 146 146 148 148   x 147 147     144     138         145 148 142 148 139 141 148 145             146 146 145     127     132             132  kill col  6  Tbl  29 cols 011000000000001001010110000000011100011101110 has 127 unique lines.
 * 124         127 127 127 127 127 127 127 125 125 127 125   x 126 126     123     112         123 127 120 127 118 118 127 123             125 125 122             109             109  kill col  4  Tbl  28 cols 011000000000001001010110000000011100011111110 has 109 unique lines.
 * 105         108 109 109 109 109 109 109 106 108 108 107   x 107 107     105      96         103 109 102 109 101 101 109 104             107 107 104                              91  kill col  0  Tbl  27 cols 011000000000001001010110000000011100011111111 has  91 unique lines.
 *  87          90  91  91  91  91  91  91  87  90  90  89   x  88  90      86      83          85  91  85  91  84  84  91  86              89  89  86                                  kill col 24  Tbl  26 cols 011000000000001001011110000000011100011111111 has  83 unique lines.
 *  78          82  83  82  83  82  83  83  79  82  82  81   x  80  82      78                  77  83  77  83  77  74  83  79              81  81  78                                  kill col 16  Tbl  25 cols 011000000000001001011110000010011100011111111 has  74 unique lines.
 *  70          73  74  73  74  73  74  74  70  73  73  72   x  70  72      68                  67  73  66  74  69      74  70              72  72  69                                  kill col 19  Tbl  24 cols 011000000000001001011110010010011100011111111 has  66 unique lines.
 *  62          65  66  64  66  65  66  66  62  65  65  64   x  61  64      60                  60  65      66  60      66  63              64  64  62                                  kill col 26  Tbl  23 cols 011000000000001001111110010010011100011111111 has  60 unique lines.
 *  56          59  60  58  60  59  60  60  56  59  59  58   x  55  57                          54  59      59  54      60  57              58  58  56                                  kill col 21  Tbl  22 cols 011000000000001001111111010010011100011111111 has  54 unique lines.
 *  51          53  54  52  54  53  54  54  50  53  53  52   x  50  51                              51      53  48      54  51              52  52  51                                  kill col 17  Tbl  21 cols 011000000000001001111111010110011100011111111 has  48 unique lines.
 *  46          47  45  46  48  47  48  48  44  47  47  46   x  43  44                              45      47          48  45              46  46  45                                  kill col 29  Tbl  20 cols 011000000000001101111111010110011100011111111 has  43 unique lines.
 *  41          42  40  36  43  42  43  43  40  42  42  41   x      40                              41      42          43  40              41  41  40                                  kill col 39  Tbl  19 cols 011001000000001101111111010110011100011111111 has  36 unique lines.
 *  34          35  33      36  35  36  36  33  35  35  34   x      30                              34      35          36  34              34  34  33                                  kill col 28  Tbl  18 cols 011001000000001111111111010110011100011111111 has  30 unique lines.
 *  28          29  26      29  29  29  30  28  29  29  27   x                                      28      29          30  29              28  28  28                                  kill col 40  Tbl  17 cols 011011000000001111111111010110011100011111111 has  26 unique lines.
 *  24          24          25  25  24  26  24  24  25  24   x                                      24      25          26  25              24  24  24                                  kill col 44  Tbl  16 cols 111011000000001111111111010110011100011111111 has  24 unique lines.
 *              22          23  23  22  24  22  22  23  22   x                                      22      23          24  23              22  22  22                                  kill col 41  Tbl  15 cols 111111000000001111111111010110011100011111111 has  22 unique lines.
 *                          21  21  20  22  20  20  21  20   x                                      20      21          22  21              20  20  20                                  kill col 36  Tbl  14 cols 111111001000001111111111010110011100011111111 has  20 unique lines.
 *                          19  18      20  18  18  19  18   x                                      18      19          20  19              18  18  18                                  kill col 37  Tbl  13 cols 111111011000001111111111010110011100011111111 has  18 unique lines.
 *                          17          18  16  16  17  16   x                                      16      17          18  17              16  16  16                                  kill col 34  Tbl  12 cols 111111011010001111111111010110011100011111111 has  16 unique lines.
Possible good candidates for removal, columns : 8 9 10 20 31 33 
 *
 * Round 1: 000000100101110000000000101001100011100000000  4 columns for indexes to table representing 12 original columns (uses 16 of 16 lines in indirect table).
 * Total columns to represent in EBRs: 37
 * 209 distinct lines in remaining untreated columns
 * c44 c43 c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 * 209 206 209 209 209 209   x 209 209   x 209   x   x   x   x 209 209 207 209 208 209 208 208 209   x 207   x 209 209   x   x 207 207 207   x   x   x 208 209 208 209 209 208 207 208  kill col 43  Tbl  31 cols 010000100101111000000000101001100011100000000 has 206 unique lines.
 * 206     206 206 206 206   x 206 206   x 206   x   x   x   x 206 206 204 206 205 206 205 205 206   x 204   x 206 206   x   x 204 204 204   x   x   x 205 206 205 206 206 205 204 205  kill col 27  Tbl  30 cols 010000100101111001000000101001100011100000000 has 204 unique lines.
 * 204     204 204 204 204   x 204 204   x 204   x   x   x   x 204 204     203 203 204 202 203 204   x 202   x 204 204   x   x 202 202 202   x   x   x 203 204 203 204 204 203 202 203  kill col 23  Tbl  29 cols 010000100101111001000100101001100011100000000 has 202 unique lines.
 * 202     202 202 202 202   x 202 202   x 202   x   x   x   x 202 202     201 200 202     201 202   x 200   x 202 202   x   x 200 200 200   x   x   x 201 202 201 202 201 201 200 201  kill col 25  Tbl  28 cols 010000100101111001010100101001100011100000000 has 200 unique lines.
 * 200     200 200 200 200   x 200 200   x 200   x   x   x   x 200 200     199     200     198 200   x 198   x 200 200   x   x 198 197 198   x   x   x 198 200 199 200 199 198 198 199  kill col 12  Tbl  27 cols 010000100101111001010100101001101011100000000 has 197 unique lines.
 * 197     195 197 197 197   x 197 197   x 197   x   x   x   x 197 197     196     197     194 197   x 195   x 197 197   x   x 194     195   x   x   x 195 197 196 197 196 195 195 196  kill col 22  Tbl  26 cols 010000100101111001010110101001101011100000000 has 194 unique lines.
 * 194     192 194 194 194   x 194 194   x 194   x   x   x   x 194 194     193     193         194   x 192   x 194 194   x   x 190     192   x   x   x 192 193 192 194 193 192 191 192  kill col 13  Tbl  25 cols 010000100101111001010110101001111011100000000 has 190 unique lines.
 * 190     188 190 190 190   x 190 190   x 190   x   x   x   x 190 190     189     189         190   x 188   x 190 190   x   x         187   x   x   x 186 189 186 189 189 188 187 188  kill col  7  Tbl  24 cols 010000100101111001010110101001111011110000000 has 186 unique lines.
 * 186     183 186 186 186   x 186 186   x 186   x   x   x   x 186 185     185     184         186   x 184   x 185 185   x   x         183   x   x   x     185 181 184 184 182 183 183  kill col  5  Tbl  23 cols 010000100101111001010110101001111011110100000 has 181 unique lines.
 * 181     175 181 181 181   x 181 181   x 181   x   x   x   x 181 180     180     177         181   x 179   x 179 180   x   x         177   x   x   x     178     179 176 174 174 177  kill col  2  Tbl  22 cols 010000100101111001010110101001111011110100100 has 174 unique lines.
 * 174     167 174 174 174   x 174 174   x 174   x   x   x   x 174 173     173     168         174   x 171   x 171 172   x   x         167   x   x   x     166     171 166     165 167  kill col  1  Tbl  21 cols 010000100101111001010110101001111011110100110 has 165 unique lines.
 * 163     158 165 165 165   x 165 165   x 164   x   x   x   x 164 163     163     158         164   x 162   x 162 162   x   x         154   x   x   x     149     156 150         154  kill col  6  Tbl  20 cols 010000100101111001010110101001111011111100110 has 149 unique lines.
 * 147     139 149 148 149   x 149 149   x 148   x   x   x   x 146 146     146     139         147   x 146   x 145 145   x   x         138   x   x   x             133 126         133  kill col  3  Tbl  19 cols 010000100101111001010110101001111011111101110 has 126 unique lines.
 * 123     113 126 124 126   x 126 125   x 124   x   x   x   x 122 123     123     113         124   x 119   x 117 120   x   x         112   x   x   x             104             103  kill col  0  Tbl  18 cols 010000100101111001010110101001111011111101111 has 103 unique lines.
 *  98      90 102 101 103   x 103 102   x 101   x   x   x   x  99  99      97      90          99   x  95   x  94  94   x   x          92   x   x   x              81                  kill col  4  Tbl  17 cols 010000100101111001010110101001111011111111111 has  81 unique lines.
 *  77      69  80  79  81   x  81  80   x  78   x   x   x   x  76  78      75      71          77   x  75   x  74  74   x   x          72   x   x   x                                  kill col 42  Tbl  16 cols 011000100101111001010110101001111011111111111 has  69 unique lines.
 *  66          68  67  69   x  69  68   x  66   x   x   x   x  65  65      62      60          66   x  64   x  61  62   x   x          58   x   x   x                                  kill col 11  Tbl  15 cols 011000100101111001010110101001111111111111111 has  58 unique lines.
 *  55          57  56  58   x  58  57   x  55   x   x   x   x  55  54      51      50          54   x  52   x  47  51   x   x               x   x   x                                  kill col 17  Tbl  14 cols 011000100101111001010110101101111111111111111 has  47 unique lines.
 *  44          46  44  46   x  47  46   x  44   x   x   x   x  42  42      41      41          43   x  39   x      41   x   x               x   x   x                                  kill col 19  Tbl  13 cols 011000100101111001010110111101111111111111111 has  39 unique lines.
 *  36          38  36  38   x  39  38   x  36   x   x   x   x  34  34      33      34          35   x       x      34   x   x               x   x   x                                  kill col 26  Tbl  12 cols 011000100101111001110110111101111111111111111 has  33 unique lines.
 *  30          32  30  32   x  33  32   x  30   x   x   x   x  29  29              27          28   x       x      28   x   x               x   x   x                                  kill col 24  Tbl  11 cols 011000100101111001111110111101111111111111111 has  27 unique lines.
 *  24          26  24  25   x  26  26   x  24   x   x   x   x  23  24                          22   x       x      21   x   x               x   x   x                                  kill col 16  Tbl  10 cols 011000100101111001111110111111111111111111111 has  21 unique lines.
 *  19          20  18  19   x  20  20   x  18   x   x   x   x  17  17                          16   x       x           x   x               x   x   x                                  kill col 21  Tbl   9 cols 011000100101111001111111111111111111111111111 has  16 unique lines.
 *
 * Round 2: 100111011010000110000000000000000000000000000  4 columns for indexes to table representing  9 original columns (uses 16 of 16 lines in indirect table).
 * Direct:  011000000000000001111111010110011100011111111 23 columns
 * Can even chose 1 more column to be represented directly.
 * Success. Use 2 EBRs, 20 LUTs.
 */

module v7_m_2ebr
  (
   input         clk,
   input [7:0]   minx,
   input         progress_ucode,
/* verilator lint_off UNOPTFLAT */
   output [47:0] d
/* verilator lint_on UNOPTFLAT */
   );
   /*
    *                      indirect_index 1
    * inx         next     | indirect index 0
    * || ucode    ucode    | | direct representation
    * 00 LB_0     LB_1     0 0 010011011111100000000001| LB     Load byte. q = rdadr=RS1+0fs
    * 01 LB_1     LB_2     1 1 000010111111001111010010|        Read until q=mem[rs1+ofs) & ~3u]
    * 02 IJ_0     IJ_1     2 2 010011011111100010111110| IJ     Jump to mem[(rs1+ofs)&~3u]. inCSR=0
    * 03 _L0x03   StdIncPc 1 3 000000101x10xxx011100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 04 ADDI_0   StdIncPc 3 3 010000101110100011100110| ADDI   Add immediate. rd =RS1+Iimm (or joined)
    * 05 _L0x05   ADDI_0   1 3 000000101x01xxx000000100| AUIPC  q = imm20 (copy x/2)
    * 06 LB_3     LB_4     1 3 000001101111010000000111|        q = ~mem[rs1+ofs]
    * 07 LB_4     LB_5     1 3 000001011111011000001001|        q = (uint8_t) mem[rs1+Iimm]
    * 08 _L0x08   SB_1     4 0 010011101111100001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 09 LB_5     LB_6     1 3 000001011111000010001011|        q = D^0xffffffff^q = D^0x80
    * 0a _L0x0a   SB_1     4 0 010011101111100001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 0b JALR_2   JAL_2    5 4 000000101110011010000110|        Q = (RS1+imn) & 0xfffffffe
    * 0c ADD_0    ADDI_0   1 3 000011101111001000000100| ADD    add     Addition Q = RS1
    * 0d MUL_0    MUL_1    1 3 100011101x10xxx011100010| MUL    Store rs1 tp rM. Next read rs2. Q clear
    * 0e SUB_0    SUB_1    1 3 000011101x10xxx000010000| SUB    Subtraction
    * 0f _L0x0f   StdIncPc 3 3 000000101110110011100110| LUI    q = imm20
    * 10 SUB_1    LB_6     1 3 000011111111000010001011|        Q = ~RS2
    * 11 AND_1    ANDI_1   1 3 000011101111000000011010|        RS1^0xffffffff to Q
    * 12 _L0x12   ILLe     1 3 0000xxxx1x0xxxx011111110|  Not in use (illegal as entry)
    * 13 condb_2  condb_3  1 3 000011111111000000010100|        ~RS2 in Q
    * 14 condb_3  condb_4  1 5 010000101111100000010101|        Calculate RS1+~RS2+1
    * 15 condb_4  condb_5  4 6 000011001111001000010110|        Branch on condition
    * 16 condb_5  Fetch    6 7 001011011001110011011110|        Branch not taken.
    * 17 condb_5t BrOpFet  6 4 011011011111100001110100|        Branch taken.
    * 18 BEQ      condb_2  5 3 000011101110110000010011| BEQ    Conditional Branch. Offset to Ryy
    * 19 JALR_0   JALR_1   5 3 010010101110100001000001| JALR   yy=RS1+imm
    * 1a ANDI_1   StdIncPc 3 3 000000101110011011100110|        rd = Iimm & RS1
    * 1b _L0x1b   JAL_1    1 4 000000101101110000110010| JAL    J-imm is in q. Branch on alignfault
    * 1c ECAL_BRK ECAL_RET 1 2 000010111101110010100110| ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI
    * 1d ORI_2    StdIncPc 3 3 000000101110111011100110|        rd = Iimm | RS1
    * 1e aFault_1 aFault_2 1 5 110010101011100011010100|        Q = 4
    * 1f IJ_2     IJ_3     5 3 000010101110110010110111|        Read word is to be masked with 2 lsb = 00
    * 20 LH_0     LH_1     7 8 010011011111100001010010| LH     Load hword. Q = rdadr=RS1+Iimm.
    * 21 XORI_1   StdIncPc 3 3 000000101110000011100110|        rd = Iimm ^ RS1
    * 22 MULHU_6  MULHU_7  1 9 000010101111100100111001|        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar
    * 23 _L0x23   StdIncPc 1 3 000000101x10xxx011100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 24 SLLI_0   SLLI_1   1 0 00001111010x110000110101| SLLI   Shift left immediate.
    * 25 _L0x25   ADDI_0   1 3 000000101x01xxx000000100| AUIPC  q = imm20 (copy x/2)
    * 26 OR_1     OR_2     4 3 000011101110000000100111|        RS1^0xffffffff to jj
    * 27 OR_2     ORI_2    1 3 010000001111100000011101|        Q = rs2
    * 28 _L0x28   SH_1     4 8 010011101111100010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 29 XOR_1    XORI_1   1 3 000011101111000000100001|        Q = RS1^0xFFFFFFFF
    * 2a _L0x2a   SH_1     4 8 010011101111100010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 2b SLTIX_1  SLTIX_2  1 5 0100xxxx1110100000110000|        RS1 - imm / RS1 - RS2
    * 2c SLL_0    SLL_1    1 3 000011101x0xxxx000111110| SLL    Shift left
    * 2d MULH_0   MULH_1   1 3 000010100111001001101010| MULH   Store rs1 to Q. Prep read 0, shcnt--
    * 2e MULHU_1  MULHU_2  4 3 100011111110110001000010|        rM<=RS2,  Rjj<=Q=0. next read RS1. 
    * 2f _L0x2f   StdIncPc 3 3 000000101110110011100110| LUI    q = imm20
    * 30 SLTIX_2  StdIncPc 3 a 000000101110110011100110|        Registered ALU flag to rd
    * 31 SLTX_1   SLTIX_1  1 3 000011111111000000101011|        ~rs2 to Q
    * 32 JAL_1    JAL_2    5 3 010000101110100010000110|        Target adr to yy
    * 33 JAERR_1  JAERR_2  5 3 01110010110x100010000001|  Err   JAL target adr misaligned, store to mtval
    * 34 JAL_3    Fetch    6 b 001011011101001011011110|        PC+imm/trap entrypt to PC. OpFetch
    * 35 SLLI_1   SLLI_2   3 3 000010110111001000110110|        Register to shift to Q (and TRG for shift 0)
    * 36 SLLI_2   _L0x03   8 3 000010110111101000000011|        Repeat Q = Q+Q until shregcnt == 0
    * 37 ECALL_2  ECALL_3  5 6 0001xxxx1110001011010111|        mepc = pc, prep store 0 to mtval
    * 38 BNE      condb_2  5 3 000011101110110000010011| BNE    Conditional Branch. Offset to Ryy
    * 39 MULHU_7  StdIncPc 3 3 100000101110001011100110|        Last shift.
    * 3a SRxI_1   SRxI_2   3 9 000010100111001100111101|        Register to shift to Q
    * 3b _L0x3b   JAL_1    1 4 000000101101110000110010| JAL    J-imm is in q. Branch on alignfault
    * 3c CSRRW_0  CSRRW_1  5 3 000001101110110001001001| CSRRW  Decoded CSR adr in yy
    * 3d SRxI_2   _L0x03   8 9 000010100111001100000011|        Repeat Q >>= 1 until shregcnt == 0
    * 3e SLL_1    SLLI_1   1 0 00001111010x001000110101|        Shiftamount was in low 5 bits of RS2
    * 3f SRx_1    SRxI_1   1 0 00001111010x001000111010|        Shiftamount in low 5 bits of RS2
    * 40 LW_0     LW_1     0 4 010011011111100001010000| LW     Load word. Q=yy=rdadr=RS1+Iimm
    * 41 JALR_1   JALR_2   1 5 010011001111100000001011|        Q=1
    * 42 MULHU_2  MULHU_3  1 9 000010100111100101100000|        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar
    * 43 MULHU_4  MULHU_5  1 3 000000001101000011101010|        Prepare read Rjj.
    * 44 SLTI_0   SLTIX_1  1 3 000011111111010000101011| SLTI   Set less than immediate (signed)
    * 45 WFI_3    WFI_4    1 5 010010101111100001100101|        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105
    * 46 ILL_1    ILL_2    5 3 00011010110x001001000111|        Store PC to mepc
    * 47 ILL_2    ILL_3    5 3 001110101110001010001111|        Store 0 to mtval
    * 48 _L0x48   SW_1     9 4 010011101111100001100110| SW     Store word. Q=wradr=RS1+Simm
    * 49 CSRRW_1  CSRRW_2  1 5 010000101111100001001011|        Construct PC storage adr
    * 4a _L0x4a   SW_1     9 4 010011101111100001100110| SW     Store word. Q=wradr=RS1+Simm
    * 4b CSRRW_2  CSRRW_3  a 3 001110101101001010110001|        Write PC to 0x100 start Prep emulation entrypt
    * 4c SLT_0    SLTX_1   1 3 000011101x10xxx000110001| SLT    Set less than (signed)
    * 4d MULHSU_0 MULHU_1  5 3 000011100110001000101110| MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--
    * 4e eILL0b   ILLe     1 3 0000xxxx1x0xxxx011111110| Illegal instruction seen
    * 4f MRET_8   StdIncPc 1 5 010010101111100011100110|        Prep +4
    * 50 LW_1     StdIncPc 3 c 000010111110001011100110|        Read until d=mem[(rs1+ofs) & ~3u]
    * 51 LDAF_LW  LDAF_a   5 3 001110101101110011011010|  err   LD AlignFault. Faulting adr to mtval
    * 52 LH_1     LH_2     1 1 000010111111001101010100|        Read until q=mem[(rs1+ofs) & ~3u]
    * 53 LDAF_LH  LDAF_a   5 3 001110101101110011011010|  err   LD AlignFault. Faulting adr to mtval
    * 54 LH_2     LH_3     b 9 000010100111001111101011|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 55 aFaultb  aFault_1 5 3 001110101110110000011110|  err   LH Load access fault. Faulting adr to mtval
    * 56 LH_4     LH_5     1 3 000010001111011001010111|        q = (uint16_t) mem[rs1+Iimm]
    * 57 LH_5     LB_6     1 3 000010001111000010001011|        q = D^0xffffffff^q = D ^ 0x00008000
    * 58 DIV_A    DIV_C    1 9 110010111111001101101110|        Transfer rM to rDee
    * 59 DIV_B    DIV_10   5 3 000011111110110010011100|        REM = Q to yy
    * 5a SB_1     SB_2     5 3 000010110111001001011101|        Write d to Q and yy (for sh 0). Prep shift
    * 5b _L0x5b   JAL_1    1 4 000000101101110000110010| JAL    J-imm is in q. Branch on alignfault
    * 5c CSRRS_0  CSRRW_1  5 3 000001101110110001001001| CSRRS  Decoded CSR adr in yy
    * 5d SB_2     SB_3     c 3 000010110111101011111011|        Repeat shl until shreg = 0 (0,8,16 or 24 times)
    * 5e LHU_1    LHU_2    1 1 000010111111001101110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 5f LDAF_LHU LDAF_a   5 3 001110101101110011011010|  err   LD AlignFault. Faulting adr to mtval
    * 60 MULHU_3  MULHU_2  1 3 100011111111001001000010|        Shift Q and rM. Prepare read rs1
    * 61 EBRKWFI2 EBREAK_1 4 6 000001101110010011110111| EBREAK/WFI2 Select EBREAK or WFI
    * 62 DIV_8    DIV_7    1 5 010010110111100011001000|        Conditionally subtract rs2. Update M[0]
    * 63 DIV_9    DIV_A    d 5 010010111111100001011000|        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]
    * 64 SLTIU_0  SLTIX_1  1 3 000011111111010000101011| SLTIU  Set less than immediate (unsigned)
    * 65 WFI_4    WFI_5    1 6 000000101x10xxx011101111|        Prepare read PC
    * 66 SW_1     SW_2     e 3 001111101101001011110010|        Write d to a+k until accepted
    * 67 SW_E1SWE SW_E2    5 3 00110010110x110010010011|        Store faulting address alignment to mtval
    * 68 DIV_12   StdIncPc 3 3 000000101110001011100110|        RS2 > 0, RS1 >= 0, yy is true result
    * 69 DIV_13   LB_6     1 3 000010101111000010001011|        RS2 > 0, RS1 < 0, change sign yy
    * 6a MULH_1   MULH_2   5 3 000010101110000011111001|        Store ~rs1 to Ryy. Prep construct 1.
    * 6b SB_4     SB_5     9 3 001011001111001001111010|        Address back to Q. Prepare get item to write
    * 6c SLTU_0   SLTX_1   1 3 000011101x10xxx000110001| SLTU   Set less than (unsigned)
    * 6d MULHU_0  MULHU_1  5 3 000011100110001000101110| MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--
    * 6e DIV_C    DIV_e    5 3 000011101101001010111001|        rM to yy. Q=ffffffff
    * 6f MRET_6   MRET_7   1 5 0100xxxx1111100011001111|        ~302 + origImm + 1 for branch decision
    * 70 LHU_2    LHU_3    b 9 000010100111001110111010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 71 aFaultc  aFault_1 5 3 001110101110110000011110|  err   LHU Load access fault. Faulting adr to mtval
    * 72 LBU_3    ANDI_1   1 3 000001101111010000011010|        Invert q. Prepare read mask
    * 73 BAERR_1  BAERR_2  5 3 001111001110001001110110|        Faultadr to mtval. Prepare get offset
    * 74 BrOpFet  Fetch2   1 d 000010111110110011110100| NewOp2 Read until instruction latched
    * 75 BAlignEr BAERR_1  1 3 000000101x0xxxx001110011|  Err   Branch target instruction address misaligned
    * 76 BAERR_2  BAERR_3  1 3 000000101111000001110111|        ~offset to Q. Prep read (origPC+offset)
    * 77 BAERR_3  BAERR_4  5 5 01011010110x100001111101|        origPC to mepc. Prep read 0
    * 78 DIV_4    DIV_6    5 3 000000001110110010101010|        ~abs(divisor) to yy
    * 79 DIV_5    DIV_3    1 5 110010101111100010101000|        Kluge to let add1 work in DIV instr
    * 7a SB_5     SW_2     e 3 001011001101001011110010|        Write d to a+k until accepted
    * 7b _L0x7b   JAL_1    1 4 000000101101110000110010| JAL    J-imm is in q. Branch on alignfault
    * 7c CSRRC_0  CSRRW_1  5 3 000001101110110001001001| CSRRC  Decoded CSR adr in yy
    * 7d BAERR_4  JAL_3    f 3 00101001110x001000110100|        Store 0 to mcause. Prep get trap entry pont
    * 7e NMI_1    NMI_2    5 3 0001xxxx1110001010010000|        Store pc to mepc.
    * 7f JALRE2   BAERR_4  5 3 00111010110x001001111101|        mtval is target
    * 80 LBU_0    LBU_1    0 0 010011011111100010000101| LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.
    * 81 JAERR_2  BAERR_4  5 3 00011010110x001001111101|        Store PC to mepc
    * 82 DIV_1    DIV_3    4 3 000011101110000010101000|        jj=abs(RS1). Next handle divisor
    * 83 DIV_2    DIV_1    1 3 010010101111100010000010|        Dividend negative, make RS1-1
    * 84 XORI_0   XORI_1   1 3 000011111111010000100001| XORI   Xor immediate. Q=~Iimm
    * 85 LBU_1    LBU_2    1 1 000010111111001111110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 86 JAL_2    JAL_25   3 5 11000010100x100010011110|        Return address to TRG
    * 87 JALRE1   JALRE2   5 3 00011100110x001001111111|  err   Store pc to mepc
    * 88 DIV_E    DIV_10   d 3 100011111x0xxxx010011100|        RS2 != 0. Check signs
    * 89 DIV_F    StdIncPc 3 3 000000101110110011100110|        RS2 == 0, return 0xffffffff
    * 8a DIVU_5   ANDI_1   1 9 110010111x10xxx100011010|        Transfer rM to rDee
    * 8b LB_6     StdIncPc 3 5 110000101110100011100110|        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80
    * 8c XOR_0    XOR_1    1 3 000011111x10xxx000101001| XOR    xor
    * 8d DIV_0    DIV_1    d 3 100010110111001010000010| DIV    Branch on sign dividend RS1
    * 8e _LCSRRS_1 ILLe     1 3 0000xxxx1x0xxxx011111110| Illegal instruction seen
    * 8f ILL_3    ILL_4    1 5 000010101111100010101001|        Q = 1
    * 90 NMI_2    JAL_3    f 3 001101001110110000110100|        mtval = 0.
    * 91 LDAF_2   LDAF_3   f 5 11100010100x100010010010|        Store 4 to mcause
    * 92 LDAF_3   JAL_3    5 3 00011001110x001000110100|        PC to mepc
    * 93 SW_E2    SW_E3    5 3 000110111110001010010101|        Store address that faulted
    * 94 SW_E4    JAL_3    f 3 00101001110x101000110100|        Store 6 to mcause
    * 95 SW_E3    SW_E4    1 5 110010111011100010010100|        Q = 3
    * 96 SH_1     SH_2     5 3 000010110111001010111011|        Write d to Q and yy (for sh 0). Prep shift
    * 97 SW_E1SWH SW_E2    5 3 00110010110x110010010011|        Store faulting address alignment to mtval
    * 98 BLT      condb_2  5 3 000011101110110000010011| BLT    Conditional Branch. Offset to Ryy
    * 99 _L0x99   ILLe     1 3 0000xxxx1x0xxxx011111110|  Not in use (illegal as entry)
    * 9a ECALL_6  JAL_3    f 3 01101001100x100000110100|        mcause = 11
    * 9b SH_4     SH_5     9 3 000111001111001010011111|        Address back to Q. Prepare get item to write
    * 9c DIV_10   DIV_12   d 3 100011001110001001101000|        RS2 > 0. Branch on sign of RS1
    * 9d DIV_11   DIV_14   d 3 100011001110001010100010|        RS2 < 0. Branch on sign of RS1
    * 9e JAL_25   JAL_3    4 3 00001100110x001000110100|        Instr. adr. to jj in case of access error
    * 9f SH_5     SW_2     e 3 000111001101001011110010|        Write d to a+k until accepted
    * a0 LHU_0    LHU_1    7 8 010011011111100001011110| LHU    Load unsigned hword. Q = rdadr=RS1+Iimm
    * a1 ECALL_4  ECALL_5  1 5 110010101011100010110110|        Q = 4
    * a2 DIV_14   LB_6     1 3 000010101111000010001011|        RS2 < 0, RS1 >= 0, change sign yy
    * a3 DIV_15   StdIncPc 3 3 000000101110001011100110|        RS2 < 0, RS1 < 0, yy is true result
    * a4 SRxI_0   SRxI_1   1 0 00001111010x110000111010| SRxI   Shift Right immediate (both logic/arith here)
    * a5 MRET_3   MRET_4   1 5 010001101111100010101111|        0x102 + 0xff + 1 = 0x202
    * a6 ECAL_RET ECALL_1  1 4 000010111101110011010000| ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET
    * a7 EBRKWFI1 EBRKWFI2 1 3 0100xxxx1111100001100001| EBREAK/WFI1 Prepare select EBREAK or WFI
    * a8 DIV_3    DIV_4    d 3 100010101111000001111000|        Branch on sign divisor RS2
    * a9 ILL_4    JAL_3    f 5 01101001110x100000110100|        Store 2 to mcause
    * aa DIV_6    DIV_7    1 3 100010111x10xxx011001000|        Write M. Prepare shift
    * ab EBREAK_2 ECALL_6  5 3 000110101110001010011010|        pc to mepc
    * ac _L0xac   SRx_1    1 3 000011101x0xxxx000111111| SRx    Shift Right (both SRL and SRA)
    * ad DIVU_0   DIVU_1   1 3 100011100x10xxx011100000| DIVU   Store rs1 to rM. Q=0. Prepare invert rs2
    * ae _L0xae   SRx_1    1 3 000011101x0xxxx000111111| SRx    Shift Right (both SRL and SRA)
    * af MRET_4   MRET_5   1 5 0100xxxx1111100011000101|        0x202 + 0xff + 1 = 0x302
    * b0 aF_SW_3  LDAF_3   f 3 01100010100x100010010010|        Store 7 to mcause
    * b1 CSRRW_3  CSRRW_4  1 5 110010101011100010110010|        Prep emulation entrypt 0x108, here Q to 0x104
    * b2 CSRRW_4  Fetch    6 7 110011011001100011011110|        IncPC, OpFetch, but force +4
    * b3 unxb3             e 0 00xxxxxxxxxxxxxxxxxxxxxx| b3: Not in use 
    * b4 eFetch3           4 5 010111111111100000000000|  Fr11  Write minstret. Update I. Q=immediate, use dinx
    * b5 SH_3     SH_4     1 3 000000001110110010011011|        Prepare get back address to use 
    * b6 ECALL_5  ECALL_6  1 5 110010101011100010011010|        Q = 8
    * b7 IJ_3     IJ_4     1 3 010011001011100010111101|        Construct Q = 3
    * b8 BGE      condb_2  5 3 000011101110110000010011| BGE    Conditional Branch. Offset to Ryy
    * b9 DIV_e    DIV_D    1 5 000011001111000011000000|        Calc carry of RS2+0xFFFFFFFF
    * ba LHU_3    ANDI_1   1 3 000001111111010000011010|        Invert q. Prepare read mask
    * bb SH_2     SH_3     c 3 000010110111101010110101|        Repeat shl until shreg = 0 (0,8 or 24 times)
    * bc CSRRWI_0 CSRRW_1  5 3 000001101110110001001001| CSRRWI Decoded CSR adr in yy
    * bd IJ_4     Fetch    0 b 000011011101011011011110|        Mask and use as PC
    * be IJ_1     IJ_2     1 b 000010111111001000011111|        Read until q=mem[(rs1+ofs)&~3u]
    * bf IJT_1    IJT_2    1 b 000010111111001011000001|        Exit CSR, enter trap
    * c0 DIV_D    DIV_E    1 6 000011101111001010001000|        Is RS2 == 0?
    * c1 IJT_2    IJT_3    5 3 000010101110110011101001|        Read word is to be masked with ~3u
    * c2 DIVU_3   DIVU_2   1 5 010010110111100011001010|        Conditionally subtract rs2. Update M[0]
    * c3 DIVU_4   DIVU_5   d 5 010010111111100010001010|        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]
    * c4 ORI_0    ORI_1    4 3 000011111110010011100001| ORI    Or immediate. jj=~Iimm
    * c5 MRET_5   MRET_6   1 3 000000001111010001101111|        ~302
    * c6 IJT_4    ILL_2    5 3 000110101111011001000111|        Mask and store to mepc and Q for read of instr
    * c7 QINT_1   QINT_2   5 3 0001xxxx1110001011001011|        Store pc to mepc.
    * c8 DIV_7    DIV_8    1 e 100011001111101001100010|        Shift (Q,M) left. Prepare unsigned sub
    * c9 MRET_2   MRET_3   1 3 010001101011100010100101|        0xff+3 = 0x102
    * ca DIVU_2   DIVU_3   1 e 100011001111101011000010|        Shift (Q,M) left. Prepare unsigned sub
    * cb QINT_2   StdIncPc f 3 001101001110110011100110|        mtval = 0.
    * cc OR_0     OR_1     1 3 000011111x10xxx000100110| OR     or
    * cd REM_0    DIV_1    d 3 100010110111001010000010| REM    Branch on sign dividend RS1
    * ce _LCSRRCI_1 ILLe     1 3 0000xxxx1x0xxxx011111110| Illegal instruction seen
    * cf MRET_7   MRET_8   1 6 000001101x10xxx001001111|        Prepare emulation entry point 0x104
    * d0 ECALL_1  ECALL_2  1 5 010000101111100000110111| ECALL  Verify Imm==0x000
    * d1 MRET_1   MRET_2   4 3 000001101110110011001001| MRET   First save Imm, start build constant for check
    * d2 LB_2     LB_3     b 9 000010100111001100000110|        Repeat shr until shreg == 0 (0,8,16,24 times)
    * d3 aFaultd  aFault_1 5 3 001110101110110000011110|  err   LB Load access fault. Faulting adr to mtval
    * d4 aFault_2 LDAF_3   f 5 01100010110x100010010010|        Store 5 to mcause
    * d5 unxd5             e 0 00xxxxxxxxxxxxxxxxxxxxxx| d5: Not in use
    * d6 eILL0c   ILLe     1 3 0000xxxx1x0xxxx011111110| Illegal instruction seen
    * d7 ECALL_3  ECALL_4  5 3 001110101110110010100001|        mtval = 0, now start the chore of 11 to mcause
    * d8 BLTU     condb_2  5 3 000011101110110000010011| BLTU   Conditional Branch. Offset to Ryy
    * d9 MULH_3   MULHU_2  1 3 100011111x10xxx001000010|        rM<=RS2, Q = 0. next read RS1. Join.
    * da LDAF_a   LDAF_2   1 3 000010101x10xxx010010001|        Extra cycle after error detected write mtval
    * db jFault_1 LDAF_3   5 5 01100000110x100010010010|        Store 1 to mcause
    * dc CSRRSI_0 CSRRW_1  5 3 000001101110110001001001| CSRRSI Decoded CSR adr in yy
    * dd aF_SW_1  aF_SW_2  5 3 001110101110110011100101|  err   SW Store access fault. Faulting adr to mtval
    * de Fetch    Fetch2   4 d 001010111110110011110100|  Fr11  Read and latch instruction
    * df eFetch   Fetch2   4 d 001010111110110011110100|  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]
    * e0 DIVU_1   DIVU_2   5 3 000010111110000011001010|        Store inverted rs2 to yy. Prepare shift
    * e1 ORI_1    ORI_2    1 3 000000001111001000011101|        Q = RS1
    * e2 MUL_1    MUL_2    1 9 000010100111100111101000|        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar
    * e3 MUL_3    ANDI_1   1 9 110010111x10xxx100011010|        Transfer rM to rDee
    * e4 ANDI_0   ANDI_1   1 3 000011111111010000011010| ANDI   And immediate. Q=~Iimm
    * e5 aF_SW_2  aF_SW_3  1 5 110010101011100010110000|        Q = 4
    * e6 StdIncPc Fetch    6 7 110011011001100011011110|  Fr11  IncPC, OpFetch
    * e7 aFault   aFault_1 5 3 001110101110110000011110|  err   Load access fault. Faulting adr to mtval
    * e8 MUL_2    MUL_1    1 3 100011101111001011100010|        Shift Q and rM. Prepare read rs2
    * e9 IJT_3    IJT_4    1 3 010011001011100011000110|        Construct Q = 3
    * ea MULHU_5  MULHU_6  1 3 000011001111100000100010|        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy
    * eb LH_3     LH_4     1 3 000001111111010001010110|        q = ~mem[rs1+ofs]
    * ec AND_0    AND_1    1 3 000011111x10xxx000010001| AND    And 
    * ed REMU_0   DIVU_1   1 3 100011100x10xxx011100000| REMU   Store dividend to rM. Prepare read divisor.Q=0
    * ee eILL0a   ILLe     1 3 0000xxxx1x0xxxx011111110| Illegal instruction seen
    * ef WFI_5    Fetch    6 7 111011011001100011011110|        IncPC, OpFetch
    * f0 LBU_2    LBU_3    b 9 000010100111001101110010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * f1 aFaulte  aFault_1 5 3 001110101110110000011110|  err   LBU Load access fault. Faulting adr to mtval
    * f2 SW_2     StdIncPc 1 3 000000101x10xxx011100110|        Prepare read PC
    * f3 aF_SW    aF_SW_1  1 3 0000xxxx1x01xxx011011101|  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf
    * f4 Fetch2   eFetch3  4 f 011100011110100010110100|  Fr11  Update ttime. Update I. Q=immediate. Use dinx
    * f5 jFault   jFault_1 5 3 001110101110110011011011|  err   Fetch access fault. Faulting adr to mtval
    * f6 WFI_1    WFI_2    1 5 110000001011100011111010| WFI    Chk offset=0x105. Now=0xff. Prep 0xff+4 = 0x103
    * f7 EBREAK_1 EBREAK_2 5 3 001100101110110010101011| EBREAK mepc = pc, store 0 to mtval
    * f8 BGEU     condb_2  5 3 000011101110110000010011| BGEU   Conditional Branch. Offset to Ryy
    * f9 MULH_2   MULH_3   4 5 010011101110100011011001|        Store 1 to Rjj. next read rs2, Q=0
    * fa WFI_2    WFI_3    1 5 010010101111100001000101|        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104
    * fb SB_3     SB_4     1 3 000000001110110001101011|        Prepare get back address to use 
    * fc CSRRCI_0 CSRRW_1  5 3 000001101110110001001001| CSRRCI Decoded CSR adr in yy
    * fd NMI_0    NMI_1    1 3 000000101x10xxx001111110| NMI    Get current PC
    * fe ILLe     ILL_1    1 3 000000101x0xxxx001000110| Illegal
    * ff QINT_0   QINT_1   1 3 000000101x10xxx011000111| INT    Get current PC
    */
   localparam u0_0 = 256'hece6a010a0e2f204e686f85af08bf85af609f4079004e8e6a0e6f8bef3d2f801;
   localparam u0_1 = 256'hecb7b8d4eee6dca6dc32e6e6e841ec13f8749cdef216f815f01480fef01af08b;
   localparam u0_2 = 256'hece6ec42726a803ee830f896f021f896f81de02790044c35a0e6f939e0e6f852;
   localparam u0_3 = 256'h423a42357303ec49dc32733de2e6ec13e2d77a037236d2dec881e886f02bece6;
   localparam u0_4 = 256'hf8e680fe622ea031d2b1f866f84bf866e28fc247f865f42bd0ea7960f80bf850;
   localparam u0_5 = 256'hdcdaf3707afbec49dc32725dec9cf36ef08bf657ec1e73ebdcdaf354dcdae2e6;
   localparam u0_6 = 256'hf8cfd2b9622ea031f27ae0f9f08be2e6cc93d2f2a0eff42bf85878c8e4f7f242;
   localparam u0_7 = 256'hc27de290c234ec49dc32d2f2f8a8ecaac87df0778073ecf4e276f41aec1e73ba;
   localparam u0_8 = 256'hf8a980fe7282a029e8e6a11aece6809cc27f889ef3f0f421f882e0a8c27df885;
   localparam u0_9 = 256'hd2f2c234e2a2e268f29f883480feec13cc9372bbb894ca34e295c2348892ec34;
   localparam u0_A = 256'hf8c5803f20e0803fe29aa0c8c834f078f861dcd0f8af4c3ae2e6f08bb8b6f85e;
   localparam u0_B = 256'hf2c1f21fd6deec497ab5f41af0c0ec13b8bdb89aec9bf800000098deb8b28892;
   localparam u0_C = 256'ha04f80fe7282a026ece6fac2b8a5fa62e2cbf647f46fe4e1f88a78caece9f288;
   localparam u0_D = 256'hecf4ecf4ece5ec49c892a091a042ec13eca180fe0000c892ec1e7306ecc9f837;
   localparam u0_E = 256'h98de80fe20e0a011f456f822b8c6f2e2ec1e98deb8b0f41aa11a79e8f21de0ca;
   localparam u0_F = 256'ha0c78046a07eec49ec6bf845e8d9ec13ecabb8faecdbe8b490dda0e6ec1e7372;
   localparam u1_0 = 256'h3302130e138e130e5402404e1305404e13051306130233421302224d110b004d;
   localparam u1_1 = 256'h530a15ca3302120b14023302534a530e646d672d460c1542130f1300130e130f;
   localparam u1_2 = 256'h3302438f130a130e1540484e130e484e1340430e1302100f1302190a3302784d;
   localparam u1_3 = 256'h100f100f890a53061402390a3382530e5610830b330b6b2d53725342130f3a02;
   localparam u1_4 = 256'h154a1300530e130ea33a944e1542944e533a531a154a130f1300190a154c044d;
   localparam u1_5 = 256'h533a110bc30b53061402530b530f19cb13081308533ab90a533a110b533a3c0b;
   localparam u1_6 = 256'h1540530e530e130e932c530a130a33025332e33e1602130fd54b154b4606138f;
   localparam u1_7 = 256'h533a5310f32953061402e32c15ca5300555a130213021d0b533c1306533ab90a;
   localparam u1_8 = 256'h150a1300d38b130f35c219cb3302d38f531c35c2110b130f134a430e531a004d;
   localparam u1_9 = 256'he31c430cd38cd38c931cf3691300530e5332530b15cbf329531b5319f5e2f334;
   localparam u1_A = 256'h1540130e138e130e531a138bf569d38a1340140b1546100f3302130a15ca784d;
   localparam u1_B = 256'h1b0b1b0b0b0d5306c30b1307150c530e134c15ca1300455fe00067cd15caf362;
   localparam u1_C = 256'h16061300d38b130ff3341e8c13461e8c5310531a1300430fd54b154b530a160e;
   localparam u1_D = 256'h4d2b4d2b533a53065560130a138f530e533a1300e000f562533ab90a43061542;
   localparam u1_E = 256'h67ed1300138e130f1307130c134c138e533a67cd15ca130f19cb190a1300530b;
   localparam u1_F = 256'h13021302130253061300154a454e530e533215c0533a4f7113001302533ab90a;
   wire [31:0]   indir;
`ifdef verilator
   /* verilator lint_off UNUSED */
   wire [15:0]   sim_a;
   wire [15:0]   sim_b;
   /* verilator lint_on UNUSED */
`endif
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u0_0), .INIT_1(u0_1), .INIT_2(u0_2), .INIT_3(u0_3),
                   .INIT_4(u0_4), .INIT_5(u0_5), .INIT_6(u0_6), .INIT_7(u0_7),
                   .INIT_8(u0_8), .INIT_9(u0_9), .INIT_A(u0_A), .INIT_B(u0_B),
                   .INIT_C(u0_C), .INIT_D(u0_D), .INIT_E(u0_E), .INIT_F(u0_F)
                   ) ucode0
     (
      .RDATA( indir[15:0]         ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u1_0), .INIT_1(u1_1), .INIT_2(u1_2), .INIT_3(u1_3),
                   .INIT_4(u1_4), .INIT_5(u1_5), .INIT_6(u1_6), .INIT_7(u1_7),
                   .INIT_8(u1_8), .INIT_9(u1_9), .INIT_A(u1_A), .INIT_B(u1_B),
                   .INIT_C(u1_C), .INIT_D(u1_D), .INIT_E(u1_E), .INIT_F(u1_F)
                   ) ucode1
     (
      .RDATA( indir[31:16]        ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );

   assign d[0] = indir[0];
   assign d[1] = indir[1];
   assign d[2] = indir[2];
   assign d[3] = indir[3];
   assign d[4] = indir[4];
   assign d[5] = indir[5];
   assign d[6] = indir[6];
   assign d[7] = indir[7];
   assign d[8] = indir[8];
   assign d[11] = indir[9];
   assign d[12] = indir[10];
   assign d[13] = indir[11];
   assign d[16] = indir[12];
   assign d[17] = indir[13];
   assign d[19] = indir[14];
   assign d[21] = indir[15];
   assign d[22] = indir[16];
   assign d[23] = indir[17];
   assign d[24] = indir[18];
   assign d[25] = indir[19];
   assign d[26] = indir[20];
   assign d[27] = indir[21];
   assign d[42] = indir[22];
   assign d[43] = indir[23];
   // replaces = 000000100101110000000000101001100011000000000
   SB_LUT4 #(.LUT_INIT(16'h04a0)) cmb_d09(.O(d[9]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h40a0)) cmb_d10(.O(d[10]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0040)) cmb_d14(.O(d[14]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h2000)) cmb_d15(.O(d[15]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h8000)) cmb_d18(.O(d[18]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'hfefe)) cmb_d20(.O(d[20]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0114)) cmb_d31(.O(d[31]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0010)) cmb_d32(.O(d[32]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h3882)) cmb_d33(.O(d[33]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h2002)) cmb_d35(.O(d[35]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h3000)) cmb_d38(.O(d[38]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   // replaces = 100111011010000110000000000000000000000000000
   SB_LUT4 #(.LUT_INIT(16'h91a8)) cmb_d28(.O(d[28]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h90f0)) cmb_d29(.O(d[29]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h1900)) cmb_d34(.O(d[34]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h8004)) cmb_d36(.O(d[36]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h8400)) cmb_d37(.O(d[37]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h2a07)) cmb_d39(.O(d[39]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h02c5)) cmb_d40(.O(d[40]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0200)) cmb_d41(.O(d[41]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h2000)) cmb_d44(.O(d[44]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   assign d[45] = 1'b0;
   assign d[46] = 1'b0;
   assign d[47] = 1'b0;
wire instrxxxx0100,instr1011xxxx,instr10110100;          bn_l4v #(.I(16'h0010)) leq0100(     .o(instrxxxx0100),     .i({minx[3:0]}));  bn_l4v #(.I(16'h0800)) leq1011(     .o(instr1011xxxx),     .i({minx[7:4]}));  bn_l4v #(.I(16'h8888)) leq1x110100( .o(instr10110100), .i({2'b0,instr1011xxxx,instrxxxx0100}));   SB_DFFE reg_d18( .Q(d[30]), .C(clk), .E(progress_ucode), .D(instr10110100));
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019-2020. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * Automatically generated from ../code/ucode.h by midgetv_indirectEBR.c.
 * Do not edit.
 * Optiones for this variant:
 *   RVC included
 *   No MULDIV
 *   minstret not implemented
 */
/* Using LUTSIZE=4. Using 2 EBRs. Initial table has 43 columns
 * Removed:  0000000000001000000000001000000000000000000 These are removed from consideration, replaced with hand-crafted Verilog code in the output stage
 * Reserved: 0000000000000000000000000000000000000000000 Columns to be represented directly, not part of optimalization
 * Total columns to represent in EBRs: 43
 * 167 distinct lines in remaining untreated columns
 * c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 * 166 167 167 167 167 167 167 167 167 167 167 167   x 167 167 167 167 166 167 166 166 167 167 165   x 167 167 167 167 165 164 166 167 166 167 166 167 166 167 167 166 166 166  kill col 12  Tbl  40 cols 0000000000001000000000001000001000000000000 has 164 unique lines.
 * 163 164 164 164 164 164 164 164 164 164 164 164   x 164 164 164 164 162 164 163 161 164 164 162   x 164 164 164 164 162     162 163 163 164 163 164 163 164 164 163 163 163  kill col 22  Tbl  39 cols 0000000000001000000010001000001000000000000 has 161 unique lines.
 * 160 161 161 161 161 161 161 161 161 161 161 161   x 161 161 161 161 160 161 160     161 161 159   x 161 161 161 161 159     159 160 160 161 160 160 159 161 161 160 160 159  kill col 19  Tbl  38 cols 0000000000001000000010011000001000000000000 has 159 unique lines.
 * 158 159 159 159 159 159 159 159 159 159 159 159   x 159 159 159 159 158 159 158     159 159       x 159 159 159 159 157     156 158 158 159 158 158 157 159 159 158 158 157  kill col 11  Tbl  37 cols 0000000000001000000010011000001100000000000 has 156 unique lines.
 * 155 156 156 156 156 156 156 156 156 156 156 156   x 156 156 156 156 155 156 155     156 156       x 156 156 156 156 150         155 155 156 155 155 154 155 156 155 155 154  kill col 13  Tbl  36 cols 0000000000001000000010011000011100000000000 has 150 unique lines.
 * 149 150 150 150 150 150 150 150 150 150 150 150   x 150 150 150 150 149 150 149     150 150       x 150 150 150 150             149 149 149 149 149 148 149 150 149 149 148  kill col  5  Tbl  35 cols 0000000000001000000010011000011100000100000 has 148 unique lines.
 * 147 148 148 148 148 148 148 148 148 148 148 148   x 148 148 148 148 147 148 147     148 148       x 148 148 148 148             147 147 147 145 147     147 147 145 145 145  kill col  7  Tbl  34 cols 0000000000001000000010011000011100010100000 has 145 unique lines.
 * 144 145 145 145 145 145 145 145 145 145 145 145   x 145 144 145 145 144 144 144     145 145       x 144 145 145 145             144 144 144     144     144 143 141 140 142  kill col  1  Tbl  33 cols 0000000000001000000010011000011100010100010 has 140 unique lines.
 * 139 140 140 140 140 140 140 140 140 140 140 140   x 140 139 140 140 139 139 139     140 140       x 139 138 140 140             139 139 139     138     139 136 137     137  kill col  3  Tbl  32 cols 0000000000001000000010011000011100010101010 has 136 unique lines.
 * 135 136 136 136 136 136 136 136 136 136 136 136   x 136 135 136 135 134 135 135     136 136       x 135 132 135 136             135 135 135     132     133     129     133  kill col  2  Tbl  31 cols 0000000000001000000010011000011100010101110 has 129 unique lines.
 * 128 129 129 129 129 129 129 129 127 129 129 129   x 129 128 128 128 125 127 124     129 129       x 126 124 128 128             128 128 128     118     119             121  kill col  6  Tbl  30 cols 0000000000001000000010011000011100011101110 has 118 unique lines.
 * 117 118 118 118 118 118 118 118 117 118 118 117   x 118 117 115 117 112 114 113     118 118       x 114 112 117 117             117 117 117             102             106  kill col  4  Tbl  29 cols 0000000000001000000010011000011100011111110 has 102 unique lines.
 * 100 102 102 102 102 102 102 102 100 102 101 101   x 101 100  99 101  95  98  97     102 102       x  96  96 101  99             101 101 101                              87  kill col  0  Tbl  28 cols 0000000000001000000010011000011100011111111 has  87 unique lines.
 *  85  87  87  87  87  87  87  87  84  87  86  86   x  85  85  85  86  81  83  82      87  87       x  81  80  86  83              86  86  85                                  kill col 16  Tbl  27 cols 0000000000001000000010011010011100011111111 has  80 unique lines.
 *  78  80  80  80  80  80  80  80  77  79  79  79   x  78  78  77  79  73  75  74      79  79       x  74      79  76              79  79  78                                  kill col 25  Tbl  26 cols 0000000000001000010010011010011100011111111 has  73 unique lines.
 *  71  73  73  73  73  73  73  73  70  72  72  71   x  70  72  70  71      67  63      71  72       x  66      72  69              72  72  71                                  kill col 23  Tbl  25 cols 0000000000001000010110011010011100011111111 has  63 unique lines.
 *  61  62  63  63  63  63  63  63  60  62  62  61   x  60  62  60  60      58          61  62       x  57      62  59              62  62  61                                  kill col 17  Tbl  24 cols 0000000000001000010110011110011100011111111 has  57 unique lines.
 *  55  56  57  57  57  57  57  57  54  56  56  55   x  53  56  55  55      53          55  56       x          56  53              56  56  55                                  kill col 29  Tbl  23 cols 0000000000001100010110011110011100011111111 has  53 unique lines.
 *  51  52  53  50  53  53  53  53  51  52  52  51   x      52  50  50      48          52  52       x          52  49              52  52  51                                  kill col 24  Tbl  22 cols 0000000000001100011110011110011100011111111 has  48 unique lines.
 *  46  47  47  44  48  47  48  48  46  47  47  46   x      45  44  43                  46  47       x          46  45              47  47  46                                  kill col 26  Tbl  21 cols 0000000000001100111110011110011100011111111 has  43 unique lines.
 *  41  42  42  39  43  42  43  43  41  42  42  41   x      41  39                      41  42       x          41  41              42  42  41                                  kill col 39  Tbl  20 cols 0001000000001100111110011110011100011111111 has  39 unique lines.
 *  37  38  37      39  38  39  39  37  38  38  37   x      34  35                      37  37       x          38  37              38  38  37                                  kill col 28  Tbl  19 cols 0001000000001110111110011110011100011111111 has  34 unique lines.
 *  32  33  31      33  33  33  34  32  33  33  31   x          31                      32  31       x          33  33              33  33  32                                  kill col 40  Tbl  18 cols 0011000000001110111110011110011100011111111 has  31 unique lines.
 *  29  28          30  30  29  31  29  28  30  29   x          27                      29  28       x          30  30              30  30  29                                  kill col 27  Tbl  17 cols 0011000000001111111110011110011100011111111 has  27 unique lines.
 *  25  25          26  26  25  27  25  24  26  25   x                                  25  24       x          26  26              26  26  25                                  kill col 33  Tbl  16 cols 0011000001001111111110011110011100011111111 has  24 unique lines.
 *  23  22          23  23  22  24  22      23  22   x                                  22  21       x          23  23              23  23  22                                  kill col 20  Tbl  15 cols 0011000001001111111110111110011100011111111 has  21 unique lines.
 *  20  19          20  20  19  21  19      20  20   x                                  20           x          20  20              20  20  19                                  kill col 41  Tbl  14 cols 0111000001001111111110111110011100011111111 has  19 unique lines.
 *  18              18  18  17  19  17      18  18   x                                  18           x          18  18              18  18  17                                  kill col 36  Tbl  13 cols 0111001001001111111110111110011100011111111 has  17 unique lines.
 *  16              16  15      17  15      16  16   x                                  16           x          16  16              16  16  15                                  kill col 37  Tbl  12 cols 0111011001001111111110111110011100011111111 has  15 unique lines.
Possible good candidates for removal, columns : 8 14 31 34 
 *
 * Round 1: 1000100110110000000001000001100011100000000  4 columns for indexes to table representing 12 original columns (uses 15 of 16 lines in indirect table).
 * Total columns to represent in EBRs: 35
 * 162 distinct lines in remaining untreated columns
 * c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 *   x 162 162 162   x 162 162   x   x 162   x   x   x 162 162 162 162 161 162 161 161   x 162 159   x 162 162   x   x 160 159 160   x   x   x 161 162 161 162 162 161 161 161  kill col 19  Tbl  28 cols 1000100110111000000001011001100011100000000 has 159 unique lines.
 *   x 159 159 159   x 159 159   x   x 159   x   x   x 159 159 159 159 158 159 158 158   x 159       x 159 159   x   x 157 156 157   x   x   x 158 159 158 159 159 158 158 158  kill col 12  Tbl  27 cols 1000100110111000000001011001101011100000000 has 156 unique lines.
 *   x 156 156 156   x 156 156   x   x 156   x   x   x 156 156 156 156 154 156 155 153   x 156       x 156 156   x   x 154     153   x   x   x 155 156 155 156 156 155 155 155  kill col 22  Tbl  26 cols 1000100110111000000011011001101011100000000 has 153 unique lines.
 *   x 153 153 153   x 153 153   x   x 153   x   x   x 153 153 153 153 152 153 152       x 153       x 153 153   x   x 150     150   x   x   x 152 152 151 153 153 152 152 151  kill col 13  Tbl  25 cols 1000100110111000000011011001111011100000000 has 150 unique lines.
 *   x 150 150 150   x 150 150   x   x 150   x   x   x 150 150 150 150 149 150 149       x 150       x 150 150   x   x         143   x   x   x 149 148 148 150 150 149 149 148  kill col 11  Tbl  24 cols 1000100110111000000011011001111111100000000 has 143 unique lines.
 *   x 143 143 143   x 143 143   x   x 143   x   x   x 143 143 143 143 142 143 142       x 143       x 143 143   x   x               x   x   x 142 141 140 142 142 142 142 141  kill col  5  Tbl  23 cols 1000100110111000000011011001111111100100000 has 140 unique lines.
 *   x 140 140 140   x 140 140   x   x 139   x   x   x 140 140 140 140 139 140 139       x 140       x 140 139   x   x               x   x   x 136 138     139 139 137 137 136  kill col  7  Tbl  22 cols 1000100110111000000011011001111111110100000 has 136 unique lines.
 *   x 136 136 136   x 136 136   x   x 134   x   x   x 136 135 136 136 134 133 135       x 136       x 134 134   x   x               x   x   x     133     134 133 130 131 132  kill col  2  Tbl  21 cols 1000100110111000000011011001111111110100100 has 130 unique lines.
 *   x 130 130 130   x 130 130   x   x 127   x   x   x 130 129 129 130 126 127 126       x 129       x 126 127   x   x               x   x   x     126     128 126     124 125  kill col  1  Tbl  20 cols 1000100110111000000011011001111111110100110 has 124 unique lines.
 *   x 124 124 124   x 124 124   x   x 122   x   x   x 123 123 123 124 120 119 118       x 123       x 120 116   x   x               x   x   x     116     118 112         119  kill col  3  Tbl  19 cols 1000100110111000000011011001111111110101110 has 112 unique lines.
 *   x 112 111 112   x 112 112   x   x 110   x   x   x 111 111 111 111 108 106 105       x 110       x 106 103   x   x               x   x   x     102      99             100  kill col  4  Tbl  18 cols 1000100110111000000011011001111111110111110 has  99 unique lines.
 *   x  99  98  99   x  99  99   x   x  96   x   x   x  98  97  97  97  91  91  89       x  97       x  91  89   x   x               x   x   x      81                      84  kill col  6  Tbl  17 cols 1000100110111000000011011001111111111111110 has  81 unique lines.
 *   x  81  80  81   x  81  80   x   x  79   x   x   x  80  79  78  79  72  73  73       x  79       x  73  69   x   x               x   x   x                              64  kill col  0  Tbl  16 cols 1000100110111000000011011001111111111111111 has  64 unique lines.
 *   x  64  63  64   x  64  63   x   x  62   x   x   x  63  62  62  62  56  56  57       x  62       x  57  54   x   x               x   x   x                                  kill col 16  Tbl  15 cols 1000100110111000000011011011111111111111111 has  54 unique lines.
 *   x  54  53  54   x  54  53   x   x  52   x   x   x  53  52  51  53  45  47  48       x  51       x  47       x   x               x   x   x                                  kill col 25  Tbl  14 cols 1000100110111000010011011011111111111111111 has  45 unique lines.
 *   x  45  44  45   x  45  44   x   x  42   x   x   x  44  43  42  43      40  38       x  42       x  38       x   x               x   x   x                                  kill col 23  Tbl  13 cols 1000100110111000010111011011111111111111111 has  38 unique lines.
 *   x  37  37  38   x  38  37   x   x  35   x   x   x  37  36  33  34      34           x  35       x  32       x   x               x   x   x                                  kill col 17  Tbl  12 cols 1000100110111000010111011111111111111111111 has  32 unique lines.
 *   x  31  30  32   x  32  31   x   x  29   x   x   x  30  30  27  29      29           x  29       x           x   x               x   x   x                                  kill col 27  Tbl  11 cols 1000100110111001010111011111111111111111111 has  27 unique lines.
 *   x  26  25  26   x  27  26   x   x  24   x   x   x  24  25      23      24           x  24       x           x   x               x   x   x                                  kill col 26  Tbl  10 cols 1000100110111001110111011111111111111111111 has  23 unique lines.
 *   x  22  21  22   x  23  22   x   x  20   x   x   x  21  21              19           x  20       x           x   x               x   x   x                                  kill col 24  Tbl   9 cols 1000100110111001111111011111111111111111111 has  19 unique lines.
 *   x  18  16  17   x  18  18   x   x  16   x   x   x  16  17                           x  15       x           x   x               x   x   x                                  kill col 20  Tbl   8 cols 1000100110111001111111111111111111111111111 has  15 unique lines.
 *
 * Round 2: 0111011001000110000000000000000000000000000  4 columns for indexes to table representing  8 original columns (uses 15 of 16 lines in indirect table).
 * Direct:  0000000000000001111110110110011100011111111 21 columns
 * Can even chose 3 more columns to be represented directly.
 * Success. Use 2 EBRs, 17 LUTs.
 */

module v8_m_2ebr
  (
   input         clk,
   input [7:0]   minx,
   input         progress_ucode,
/* verilator lint_off UNOPTFLAT */
   output [47:0] d
/* verilator lint_on UNOPTFLAT */
   );
   /*
    *                      indirect_index 1
    * inx         next     | indirect index 0
    * || ucode    ucode    | | direct representation
    * 00 LB_0     LB_1     0 0 001101011110000000000001| LB     Load byte. q = rdadr=RS1+0fs
    * 01 LB_1     LB_2     1 1 0010111111001xx111010010|        Read until q=mem[rs1+ofs) & ~3u]
    * 02 IJ_0     IJ_1     2 2 001101111110000010111110| IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0
    * 03 _L0x03   StdIncPc 3 0 0000101x10xxxxx011100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 04 ADDI_0   StdIncPc 4 0 000010111010000011100110| ADDI   Add immediate. rd =RS1+Iimm (or joined)
    * 05 _L0x05   ADDI_0   3 0 0000001x01xxxxx000000100| AUIPC  q = imm20+2 or imm20+4  (copy x/2)
    * 06 LB_3     LB_4     3 0 0001101111010xx000000111|        q = ~mem[rs1+ofs]
    * 07 LB_4     LB_5     3 0 0001011111011xx000001001|        q = (uint8_t) mem[rs1+Iimm]
    * 08 _L0x08   SB_1     5 0 001110011110000001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 09 LB_5     LB_6     3 0 0001011111000xx010001011|        q = D^0xffffffff^q = D^0x80
    * 0a _L0x0a   SB_1     5 0 001110011110000001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 0b JALR_2   JALR_3   3 3 000010111110011000110011|        Q=1. Prep legalize target
    * 0c ADD_0    ADDI_0   3 0 0011101111001xx000000100| ADD    add     Addition Q = RS1
    * 0d _L0x0d   StdIncPc 4 0 000010111011000011100110| LUI    q = imm20
    * 0e SUB_0    SUB_1    3 0 0011101x10xxxxx000010000| SUB    Subtraction
    * 0f _L0x0f   StdIncPc 4 0 000010111011000011100110| LUI    q = imm20
    * 10 SUB_1    LB_6     3 0 0011111111000xx010001011|        Q = ~RS2
    * 11 AND_1    ANDI_1   3 0 0011101111000xx000011010|        RS1^0xffffffff to Q
    * 12 straddle Fetchu   6 4 101101100110011001110110|  Fr00u IncPC, OpFetch
    * 13 condb_2  condb_3  3 0 0011111111000xx000010100|        ~RS2 in Q
    * 14 condb_3  condb_4  3 3 001100111110011000010101|        Calculate RS1+~RS2+1
    * 15 condb_4  condb_5  3 5 0000001111001xx000010110|        Branch on condition
    * 16 condb_5  StdIncPc 3 0 0000001x10xxxxx011100110|        Branch not taken.
    * 17 condb_5t condb_6t 7 0 0000001101001xx001111101|        Branch taken. yy=oldPC incase of access error
    * 18 BEQ      condb_2  7 0 001110111011000000010011| BEQ    Conditional Branch. Offset to Ryy
    * 19 JALR_0   JALR_1   5 0 100000110x10000001000001| JALR   (tmp) Prep pc=RS1+imm (target)
    * 1a ANDI_1   StdIncPc 4 0 0000101110011xx011100110|        rd = Iimm & RS1
    * 1b _L0x1b   JAL_1    3 0 0000001x01xxxxx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 1c ECAL_BRK ECAL_RET 3 2 001011110111000010100110| ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI
    * 1d ORI_2    StdIncPc 4 0 000010111011100011100110|        rd = Iimm | RS1
    * 1e aFault_1 aFault_2 3 3 001010101110011011010100|        Q = 4
    * 1f IJ_2     IJ_3     5 0 100000110111000010110111|        Read word is to be masked with lsb = 0
    * 20 LH_0     LH_1     8 2 001101011110000001010010| LH     Load hword. Q = rdadr=RS1+Iimm.
    * 21 XORI_1   StdIncPc 4 0 0000101110000xx011100110|        rd = Iimm ^ RS1
    * 22 _L0x22   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * 23 _L0x23   StdIncPc 3 0 0000101x10xxxxx011100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 24 SLLI_0   SLLI_1   3 6 001111010x11000000110101| SLLI   Shift left immediate.
    * 25 _L0x25   ADDI_0   3 0 0000001x01xxxxx000000100| AUIPC  q = imm20+2 or imm20+4  (copy x/2)
    * 26 OR_1     OR_2     5 0 0011101110000xx000100111|        RS1^0xffffffff to jj
    * 27 OR_2     ORI_2    3 0 000000111110000000011101|        Q = rs2
    * 28 _L0x28   SH_1     5 2 001110011110000010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 29 XOR_1    XORI_1   3 0 0011101111000xx000100001|        Q = RS1^0xFFFFFFFF
    * 2a _L0x2a   SH_1     5 2 001110011110000010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 2b SLTIX_1  SLTIX_2  3 3 00xxxx111010011000110000|        RS1 - imm / RS1 - RS2
    * 2c SLL_0    SLL_1    3 0 0011101x0xxxxxx000111110| SLL    Shift left
    * 2d _L0x2d   StdIncPc 4 0 000010111011000011100110| LUI    q = imm20
    * 2e unx2e             9 6 xxxxxxxxxxxxxxxxxxxxxxxx| 2e: Not in use 
    * 2f _L0x2f   StdIncPc 4 0 000010111011000011100110| LUI    q = imm20
    * 30 SLTIX_2  StdIncPc 4 7 000010111011001011100110|        Registered ALU flag to rd
    * 31 SLTX_1   SLTIX_1  3 0 0011111111000xx000101011|        ~rs2 to Q
    * 32 JAL_1    JAL_2    7 0 0000001101001xx010000110|      Prep Instradr to yy. Refetch instradr
    * 33 JALR_3   JAL_25   5 0 1000001110011xx010011110|        Q = (RS1+imn) & 0xfffffffe
    * 34 JAL_3    Fetch    6 0 1011011101001xx011011110|      Prep fetch next instr.
    * 35 SLLI_1   SLLI_2   4 6 0010111111001xx000110110|        Register to shift to Q (and TRG for shift 0)
    * 36 SLLI_2   _L0x03   4 8 001011111110100000000011|        Repeat Q = Q+Q until shregcnt == 0
    * 37 ECALL_2  ECALL_3  7 5 01xxxx1110001xx011010111|        mepc = pc, prep store 0 to mtval
    * 38 BNE      condb_2  7 0 001110111011000000010011| BNE    Conditional Branch. Offset to Ryy
    * 39 _L0x39   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * 3a SRxI_1   SRxI_2   4 9 0010101111001xx100111101|        Register to shift to Q
    * 3b _L0x3b   JAL_1    3 0 0000001x01xxxxx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 3c CSRRW_0  CSRRW_1  7 0 000110111011000001001001| CSRRW  Decoded CSR adr in yy
    * 3d SRxI_2   _L0x03   4 a 0010101111001xx100000011|        Repeat Q >>= 1 until shregcnt == 0
    * 3e SLL_1    SLLI_1   3 6 001111010x001xx000110101|        Shiftamount was in low 5 bits of RS2
    * 3f SRx_1    SRxI_1   3 6 001111010x001xx000111010|        Shiftamount in low 5 bits of RS2
    * 40 LW_0     LW_1     0 b 001101111110000001010000| LW     Load word. Q=yy=rdadr=RS1+Iimm
    * 41 JALR_1   JALR_2   7 0 0010101110001xx000001011|        yy=jj. Prep get Q=1
    * 42 _L0x42   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * 43 _L0x43   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * 44 SLTI_0   SLTIX_1  3 0 0011111111010xx000101011| SLTI   Set less than immediate (signed)
    * 45 WFI_3    WFI_4    3 3 001010111110011001100101|        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105
    * 46 ILL_1    ILL_2    7 0 011010110x001xx001000111|        Store PC to mepc
    * 47 ILL_2    ILL_3    7 0 1110101110001xx010001111|        Store 0 to mtval
    * 48 _L0x48   SW_1     a b 001110111110000001100110| SW     Store word. Q=wradr=RS1+Simm
    * 49 CSRRW_1  CSRRW_2  3 3 000010111110011001001011|        Construct PC storage adr
    * 4a _L0x4a   SW_1     a b 001110111110000001100110| SW     Store word. Q=wradr=RS1+Simm
    * 4b CSRRW_2  CSRRW_3  b 0 1110101101001xx010110001|        Write PC to 0x100 start Prep emulation entrypt
    * 4c SLT_0    SLTX_1   3 0 0011101x10xxxxx000110001| SLT    Set less than (signed)
    * 4d unx4d             9 6 xxxxxxxxxxxxxxxxxxxxxxxx| 4d: Not in use 
    * 4e eILL0b   ILLe     3 0 00xxxx1x0xxxxxx011111110| Illegal instruction seen
    * 4f MRET_8   MRET_9   3 3 001010101110011001110100|        +4, so now 0x103
    * 50 LW_1     StdIncPc c c 0010111110001xx011100110|        Read until d=mem[(rs1+ofs) & ~3u]
    * 51 LDAF_LW  LDAF_a   7 0 111010110111000011011010|  err   LD AlignFault. Faulting adr to mtval
    * 52 LH_1     LH_2     1 1 0010111111001xx101010100|        Read until q=mem[(rs1+ofs) & ~3u]
    * 53 LDAF_LH  LDAF_a   7 0 111010110111000011011010|  err   LD AlignFault. Faulting adr to mtval
    * 54 LH_2     LH_3     3 a 0010101111001xx111101011|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 55 aFaultb  aFault_1 7 0 111010111011000000011110|  err   LH Load access fault. Faulting adr to mtval
    * 56 LH_4     LH_5     3 0 0010001111011xx001010111|        q = (uint16_t) mem[rs1+Iimm]
    * 57 LH_5     LB_6     3 0 0010001111000xx010001011|        q = D^0xffffffff^q = D ^ 0x00008000
    * 58 _L0x58   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * 59 _L0x59   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * 5a SB_1     SB_2     7 6 0010111111001xx001011101|        Write d to Q and yy (for sh 0). Prep shift
    * 5b _L0x5b   JAL_1    3 0 0000001x01xxxxx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 5c CSRRS_0  CSRRW_1  7 0 000110111011000001001001| CSRRS  Decoded CSR adr in yy
    * 5d SB_2     SB_3     7 8 001011111110100011111011|        Repeat shl until shreg = 0 (0,8,16 or 24 times)
    * 5e LHU_1    LHU_2    1 1 0010111111001xx101110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 5f LDAF_LHU LDAF_a   7 0 111010110111000011011010|  err   LD AlignFault. Faulting adr to mtval
    * 60 _L0x60   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * 61 EBRKWFI2 EBREAK_1 7 5 0001101110010xx011110111| EBREAK/WFI2 Select EBREAK or WFI.
    * 62 _L0x62   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * 63 _L0x63   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * 64 SLTIU_0  SLTIX_1  3 0 0011111111010xx000101011| SLTIU  Set less than immediate (unsigned)
    * 65 WFI_4    WFI_5    3 5 0000001x10xxxxx011101111|        Prepare read PC.
    * 66 SW_1     SW_2     9 0 1111101101001xx011110010|        Write d to a+k until accepted
    * 67 SW_E1SWE SW_E2    7 0 110010110x11000010010011|        Store faulting address alignment to mtval
    * 68 _L0x68   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * 69 unx69             9 6 xxxxxxxxxxxxxxxxxxxxxxxx| 69: Not in use 
    * 6a _L0x6a   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * 6b SB_4     SB_5     a 0 1011001111001xx001111010|        Address back to Q. Prepare get item to write
    * 6c SLTU_0   SLTX_1   3 0 0011101x10xxxxx000110001| SLTU   Set less than (unsigned)
    * 6d unx6d             9 6 xxxxxxxxxxxxxxxxxxxxxxxx| 6d: Not in use 
    * 6e unx6e             9 6 xxxxxxxxxxxxxxxxxxxxxxxx| 6e: Not in use 
    * 6f MRET_6   MRET_7   3 3 00xxxx111110011011001111|        ~302 + origImm + 1 for branch decision
    * 70 LHU_2    LHU_3    3 a 0010101111001xx110111010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 71 aFaultc  aFault_1 7 0 111010111011000000011110|  err   LHU Load access fault. Faulting adr to mtval
    * 72 LBU_3    ANDI_1   3 0 0001101111010xx000011010|        Invert q. Prepare read mask
    * 73 unx73             9 6 xxxxxxxxxxxxxxxxxxxxxxxx| 73: Not in use 
    * 74 MRET_9   Fetch    6 3 101101110110011011011110|        +1, IncPC, OpFetch next
    * 75 IJ_5     Fetch    6 0 1011011101011xx011011110|        Mask and use as PC
    * 76 Fetchu   Fetch2   3 d 000011111011000011110100|  Fr00u Read and latch instruction
    * 77 eFetchu  Fetch2   1 e 001011111011000011110100|  Fr00u rep Read until d=mem[(rs1+ofs) & ~3u]
    * 78 _L0x78   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * 79 _L0x79   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * 7a SB_5     SW_2     9 0 1011001101001xx011110010|        Write d to a+k until accepted
    * 7b _L0x7b   JAL_1    3 0 0000001x01xxxxx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 7c CSRRC_0  CSRRW_1  7 0 000110111011000001001001| CSRRC  Decoded CSR adr in yy
    * 7d condb_6t Fetch    6 0 101101110110000011011110|        Branch taken.
    * 7e NMI_1    NMI_2    7 0 01xxxx1110001xx010010000|        Store pc to mepc.
    * 7f unx7f             9 6 xxxxxxxxxxxxxxxxxxxxxxxx| 7f: Not in use 
    * 80 LBU_0    LBU_1    0 0 001101011110000010000101| LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.
    * 81 unx81             9 6 xxxxxxxxxxxxxxxxxxxxxxxx| 81: Not in use 
    * 82 _L0x82   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * 83 _L0x83   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * 84 XORI_0   XORI_1   3 0 0011111111010xx000100001| XORI   Xor immediate. Q=~Iimm
    * 85 LBU_1    LBU_2    1 1 0010111111001xx111110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 86 JAL_2    JAL_25   5 0 100000111010000010011110|      Prep pc = jj + ofs
    * 87 unx87             9 6 xxxxxxxxxxxxxxxxxxxxxxxx| 87: Not in use 
    * 88 _L0x88   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * 89 unx89             9 6 xxxxxxxxxxxxxxxxxxxxxxxx| 89: Not in use 
    * 8a _L0x8a   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * 8b LB_6     StdIncPc 4 3 000010111010011011100110|        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80
    * 8c XOR_0    XOR_1    3 0 0011111x10xxxxx000101001| XOR    xor
    * 8d unx8d             9 6 xxxxxxxxxxxxxxxxxxxxxxxx| 8d: Not in use 
    * 8e _LCSRRS_1 ILLe     3 0 00xxxx1x0xxxxxx011111110| Illegal instruction seen
    * 8f ILL_3    ILL_4    3 3 001010111110011010101001|        Q = 1
    * 90 NMI_2    JAL_3    d 0 110100111011000000110100|        mtval = 0.
    * 91 LDAF_2   LDAF_3   d 3 100010100x10011010010010|        Store 4 to mcause
    * 92 LDAF_3   JAL_3    7 0 011001110x001xx000110100|        PC to mepc
    * 93 SW_E2    SW_E3    7 0 0110111110001xx010010101|        Store address that faulted
    * 94 SW_E4    JAL_3    d 0 101001110x10100000110100|        Store 6 to mcause
    * 95 SW_E3    SW_E4    3 3 001011101110011010010100|        Q = 3
    * 96 SH_1     SH_2     7 6 0010111111001xx010111011|        Write d to Q and yy (for sh 0). Prep shift
    * 97 SW_E1SWH SW_E2    7 0 110010110x11000010010011|        Store faulting address alignment to mtval
    * 98 BLT      condb_2  7 0 001110111011000000010011| BLT    Conditional Branch. Offset to Ryy
    * 99 _L0x99   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * 9a ECALL_6  JAL_3    d 0 101001100x10000000110100|        mcause = 11
    * 9b SH_4     SH_5     a 0 0111001111001xx010011111|        Address back to Q. Prepare get item to write
    * 9c _L0x9c   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * 9d unx9d             9 6 xxxxxxxxxxxxxxxxxxxxxxxx| 9d: Not in use 
    * 9e JAL_25   JAL_3    4 4 000010101010011000110100|      Prep WTRG = jj+2/4 (return adr)
    * 9f SH_5     SW_2     9 0 0111001101001xx011110010|        Write d to a+k until accepted
    * a0 LHU_0    LHU_1    8 2 001101011110000001011110| LHU    Load unsigned hword. Q = rdadr=RS1+Iimm
    * a1 ECALL_4  ECALL_5  3 3 001010101110011010110110|        Q = 4
    * a2 _L0xa2   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * a3 _L0xa3   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * a4 SRxI_0   SRxI_1   3 6 001111010x11000000111010| SRxI   Shift Right immediate (both logic/arith here)
    * a5 MRET_3   MRET_4   3 3 000110111110011010101111|        0x102 + 0xff + 1 = 0x202
    * a6 ECAL_RET ECALL_1  3 b 001011110111000011010000| ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET
    * a7 EBRKWFI1 EBRKWFI2 3 0 00xxxx111110000001100001| EBREAK/WFI1 Prepare select EBREAK or WFI
    * a8 _L0xa8   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * a9 ILL_4    JAL_3    d 3 101001110x10011000110100|        Store 2 to mcause
    * aa _L0xaa   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * ab EBREAK_2 ECALL_6  7 0 0110101110001xx010011010|        pc to mepc
    * ac _L0xac   SRx_1    3 0 0011101x0xxxxxx000111111| SRx    Shift Right (both SRL and SRA)
    * ad unxad             9 6 xxxxxxxxxxxxxxxxxxxxxxxx| ad: Not in use 
    * ae _L0xae   SRx_1    3 0 0011101x0xxxxxx000111111| SRx    Shift Right (both SRL and SRA)
    * af MRET_4   MRET_5   3 3 00xxxx111110011011000101|        0x202 + 0xff + 1 = 0x302
    * b0 aF_SW_3  LDAF_3   d 0 100010100x10000010010010|        Store 7 to mcause
    * b1 CSRRW_3  CSRRW_4  3 3 001010101110011010110010|        Prep emulation entrypt 0x108, here Q to 0x104
    * b2 CSRRW_4  Fetch    6 3 101101100110011011011110|        IncPC, OpFetch, but force +4
    * b3 unxb3             9 6 xxxxxxxxxxxxxxxxxxxxxxxx| b3: Not in use 
    * b4 ic0reser          9 6 xxxxxxxxxxxxxxxxxxxxxxxx|  Fr00  Not really used, reserved to allow LASTINCH
    * b5 SH_3     SH_4     3 0 000000111011000010011011|        Prepare get back address to use 
    * b6 ECALL_5  ECALL_6  3 3 001010101110011010011010|        Q = 8
    * b7 IJ_3     IJ_4     7 0 0010101110001xx010111101|        Store present PC in case of access error
    * b8 BGE      condb_2  7 0 001110111011000000010011| BGE    Conditional Branch. Offset to Ryy
    * b9 _L0xb9   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * ba LHU_3    ANDI_1   3 0 0001111111010xx000011010|        Invert q. Prepare read mask
    * bb SH_2     SH_3     7 8 001011111110100010110101|        Repeat shl until shreg = 0 (0,8 or 24 times)
    * bc CSRRWI_0 CSRRW_1  7 0 000110111011000001001001| CSRRWI Decoded CSR adr in yy
    * bd IJ_4     IJ_5     3 3 000010111110011001110101|        Construct Q = 1
    * be IJ_1     IJ_2     1 0 0010111111001xx000011111|        Read until q=mem[(rs1+ofs)&~1u]
    * bf IJT_1    IJT_2    1 0 0010111111001xx011000001|        Exit CSR, enter trap
    * c0 _L0xc0   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * c1 IJT_2    IJT_3    7 0 001010111011000011101001|        Read word is to be masked with ~1u
    * c2 _L0xc2   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * c3 _L0xc3   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * c4 ORI_0    ORI_1    5 0 0011111110010xx011100001| ORI    Or immediate. jj=~Iimm
    * c5 MRET_5   MRET_6   3 0 0000001111010xx001101111|        ~302
    * c6 IJT_4    ILL_2    7 0 0110101111011xx001000111|        Mask and store to mepc and Q for read of instr
    * c7 QINT_1   QINT_2   7 0 01xxxx1110001xx011001011|        Store pc to mepc.
    * c8 _L0xc8   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * c9 MRET_2   MRET_3   3 0 000110101110000010100101|        0xff+3 = 0x102
    * ca _L0xca   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * cb QINT_2   StdIncPc d 0 110100111011000011100110|        mtval = 0.
    * cc OR_0     OR_1     3 0 0011111x10xxxxx000100110| OR     or
    * cd unxcd             9 6 xxxxxxxxxxxxxxxxxxxxxxxx| cd: Not in use 
    * ce _LCSRRCI_1 ILLe     3 0 00xxxx1x0xxxxxx011111110| Illegal instruction seen
    * cf MRET_7   MRET_8   3 5 0001101x10xxxxx001001111|        Prepare emulation entry point 0x104
    * d0 ECALL_1  ECALL_2  3 3 000000111110011000110111| ECALL  Verify Imm==0x000
    * d1 MRET_1   MRET_2   5 0 000110111011000011001001| MRET   First save Imm, start build constant for check
    * d2 LB_2     LB_3     3 a 0010101111001xx100000110|        Repeat shr until shreg == 0 (0,8,16,24 times)
    * d3 aFaultd  aFault_1 7 0 111010111011000000011110|  err   LB Load access fault. Faulting adr to mtval
    * d4 aFault_2 LDAF_3   d 3 100010110x10011010010010|        Store 5 to mcause
    * d5 unalignd straddle 3 0 000010111011000000010010|  Fr00u Unaligned pc, prep read high hword
    * d6 eILL0c   ILLe     3 0 00xxxx1x0xxxxxx011111110| Illegal instruction seen
    * d7 ECALL_3  ECALL_4  7 0 111010111011000010100001|        mtval = 0, now start the chore of 11 to mcause
    * d8 BLTU     condb_2  7 0 001110111011000000010011| BLTU   Conditional Branch. Offset to Ryy
    * d9 _L0xd9   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * da LDAF_a   LDAF_2   3 0 0010101x10xxxxx010010001|        Extra cycle after error detected write mtval
    * db jFault_1 LDAF_3   7 3 101100110x10011010010010|        Store 1 to mcause
    * dc CSRRSI_0 CSRRW_1  7 0 000110111011000001001001| CSRRSI Decoded CSR adr in yy
    * dd aF_SW_1  aF_SW_2  7 0 111010111011000011100101|  err   SW Store access fault. Faulting adr to mtval
    * de Fetch    Fetch2   5 d 000011111011000011110100|  Fr00  Read and latch instruction
    * df eFetch   Fetch2   e e 001011111011000011110100|  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]
    * e0 _L0xe0   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * e1 ORI_1    ORI_2    3 0 0000001111001xx000011101|        Q = RS1
    * e2 _L0xe2   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * e3 _L0xe3   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * e4 ANDI_0   ANDI_1   3 0 0011111111010xx000011010| ANDI   And immediate. Q=~Iimm
    * e5 aF_SW_2  aF_SW_3  3 3 001010101110011010110000|        Q = 4
    * e6 StdIncPc Fetch    6 4 101101100110011011011110|  Fr00  IncPC, OpFetch
    * e7 aFault   aFault_1 7 0 111010111011000000011110|  err   Load access fault. Faulting adr to mtval
    * e8 _L0xe8   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * e9 IJT_3    IJT_4    3 3 001100111110011011000110|        Construct Q = 1
    * ea _L0xea   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * eb LH_3     LH_4     3 0 0001111111010xx001010110|        q = ~mem[rs1+ofs]
    * ec AND_0    AND_1    3 0 0011111x10xxxxx000010001| AND    And 
    * ed unxed             9 6 xxxxxxxxxxxxxxxxxxxxxxxx| ed: Not in use
    * ee eILL0a   ILLe     3 0 00xxxx1x0xxxxxx011111110| Illegal instruction seen
    * ef WFI_5    Fetch    6 3 101101100110011011011110|        IncPC, OpFetch
    * f0 LBU_2    LBU_3    3 a 0010101111001xx101110010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * f1 aFaulte  aFault_1 7 0 111010111011000000011110|  err   LBU Load access fault. Faulting adr to mtval
    * f2 SW_2     StdIncPc 3 0 0000101x10xxxxx011100110|        Prepare read PC
    * f3 aF_SW    aF_SW_1  3 0 00xxxx1x01xxxxx011011101|  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf
    * f4 Fetch2   unalignd 5 0 111111111110000011010101|  Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned 
    * f5 jFault   jFault_1 7 0 111010111011000011011011|  err   Fetch access fault. Faulting adr to mtval
    * f6 WFI_1    WFI_2    3 3 001100101110011011111010| WFI    Chk offset=0x105. Now 0xff. Prep 0xff+4 = 0x103
    * f7 EBREAK_1 EBREAK_2 7 0 110000111011000010101011| EBREAK mepc = pc, store 0 to mtval
    * f8 BGEU     condb_2  7 0 001110111011000000010011| BGEU   Conditional Branch. Offset to Ryy
    * f9 _L0xf9   ILLe     3 0 00xxxx1x0xxxxxx011111110|  Not in use (illegal as entry)
    * fa WFI_2    WFI_3    3 3 001010111110011001000101|        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104
    * fb SB_3     SB_4     3 0 000000111011000001101011|        Prepare get back address to use 
    * fc CSRRCI_0 CSRRW_1  7 0 000110111011000001001001| CSRRCI Decoded CSR adr in yy
    * fd NMI_0    NMI_1    3 0 0000101x10xxxxx001111110| NMI    Get current PC
    * fe ILLe     ILL_1    3 0 0000101x0xxxxxx001000110| Illegal
    * ff QINT_0   QINT_1   3 0 0000101x10xxxxx011000111| INT    Get current PC
    */
   localparam u0_0 = 256'hb0e68010b0e6c804e633e05ac08be05ad809d0074004a0e680e6e0bec9d2e001;
   localparam u0_1 = 256'h70b7e6d4b8e670a6403298e62041b013487d80e6c816e615c0146676c01ac08b;
   localparam u0_2 = 256'hb0e60000b0e6003ea630e096c021e096e01d80274004303580e600fe80e6e052;
   localparam u0_3 = 256'h083a0835c903b0494032c93d00feb01388d7e803c83648de989e4886c02bb2e6;
   localparam u0_4 = 256'he67400fe0000803148b1e066e64be066888f0847e665d02b00fe00fe880be050;
   localparam u0_5 = 256'h70dac970e8fbb0494032c85d00fe00fec08bd857b01ec9eb70dac95470da88e6;
   localparam u0_6 = 256'he6cf000000008031c87a00fe000000fe309348f280efd02b00fe00fe90f700fe;
   localparam u0_7 = 256'h0000889060deb049403248f200fe00feb0f4b0f458de66de0000d01ab01ec9ba;
   localparam u0_8 = 256'he6a900fe00008029a6e600fe000000fe0000a09ec9f0d02100fe00fe0000e085;
   localparam u0_9 = 256'h48f2a634000000fec89f203400feb0133093c8bbe6942834889508342692b034;
   localparam u0_A = 256'he6c5003f0000003f889a00fe263400fee06170d0e6af303a00fe00fee6b6e05e;
   localparam u0_B = 256'hc8c1c81fe675b049e8b5d01a00feb01388bde69ab09b0000000066dee6b22092;
   localparam u0_C = 256'h804f00fe00008026b0e600fee0a500fe88cbd847d06f90e100fe00feb0e900fe;
   localparam u0_D = 256'hb0f4b0f4b0e5b0492692809100feb013b0a100feb0122692b01ec906b0c9e637;
   localparam u0_E = 256'h66de00fe00008011d05600fee6c600feb01e66dee6b0d01a00fe00fec81d00fe;
   localparam u0_F = 256'h80c70046807eb049b06be64500feb013b0abe6fab0dbe0d540dd80e6b01ec972;
   localparam u1_0 = 256'h400b303a400b303b330b5039301750393017301b3002400b300a2237112f0035;
   localparam u1_1 = 256'h5083332a400b322f3002400b5083703b7003300235033333303f64b6303b303f;
   localparam u1_2 = 256'h400b9600400b303a33035239303b52393003503b3002363d300a3002400b8235;
   localparam u1_3 = 256'h363d363d4a2b701b3002492b3002703b7543482f462f60b750837003303f470b;
   localparam u1_4 = 256'h332a30029600303ab0ebab3b330bab3b70eb706b332b303f30023002702b0b37;
   localparam u1_5 = 256'h70eb112f782f701b3002762f300230023023302370eb3a2b70eb112f70ebcc2f;
   localparam u1_6 = 256'h330396009600303aa0b330029600300270cb90fb3502303f30023002751b3002;
   localparam u1_7 = 256'h9600704360b7701b300290b3300230021e2f3d0f60b763b79600301b70eb3a2b;
   localparam u1_8 = 256'h332b30029600303e430b30029600300296005083112f303f3002300296000035;
   localparam u1_9 = 256'h9073440a96003002a073d0a63002703b70cb762f332ed0a7706f7067d38ad0d3;
   localparam u1_A = 256'h3303303a9600303a706b3002d3a7300230033b2f331b363d30023002332a8235;
   localparam u1_B = 256'h102f102f330b701b782f301f3002703b702b332a30039600960063b6332ad08a;
   localparam u1_C = 256'h351a30029600303ed0d33002301a30027043706b3003503f30023002702b3002;
   localparam u1_D = 256'hee2f5d0f70eb701b73b3302a3002703b70eb3002300bd38b70eb3a2b501b3303;
   localparam u1_E = 256'h63b630029600303e301f30023333300270eb64b6332a303f3002300230033002;
   localparam u1_F = 256'h300a300a300a701b3003332b3002703b70c3333270eb50ff3002300a70eb3a2b;
   wire [31:0]   indir;
`ifdef verilator
   /* verilator lint_off UNUSED */
   wire [15:0]   sim_a;
   wire [15:0]   sim_b;
   /* verilator lint_on UNUSED */
`endif
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u0_0), .INIT_1(u0_1), .INIT_2(u0_2), .INIT_3(u0_3),
                   .INIT_4(u0_4), .INIT_5(u0_5), .INIT_6(u0_6), .INIT_7(u0_7),
                   .INIT_8(u0_8), .INIT_9(u0_9), .INIT_A(u0_A), .INIT_B(u0_B),
                   .INIT_C(u0_C), .INIT_D(u0_D), .INIT_E(u0_E), .INIT_F(u0_F)
                   ) ucode0
     (
      .RDATA( indir[15:0]         ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u1_0), .INIT_1(u1_1), .INIT_2(u1_2), .INIT_3(u1_3),
                   .INIT_4(u1_4), .INIT_5(u1_5), .INIT_6(u1_6), .INIT_7(u1_7),
                   .INIT_8(u1_8), .INIT_9(u1_9), .INIT_A(u1_A), .INIT_B(u1_B),
                   .INIT_C(u1_C), .INIT_D(u1_D), .INIT_E(u1_E), .INIT_F(u1_F)
                   ) ucode1
     (
      .RDATA( indir[31:16]        ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );

   assign d[0] = indir[0];
   assign d[1] = indir[1];
   assign d[2] = indir[2];
   assign d[3] = indir[3];
   assign d[4] = indir[4];
   assign d[5] = indir[5];
   assign d[6] = indir[6];
   assign d[7] = indir[7];
   assign d[8] = indir[8];
   assign d[9] = indir[9];
   assign d[10] = indir[10];
   assign d[11] = indir[11];
   assign d[12] = indir[12];
   assign d[13] = indir[13];
   assign d[16] = indir[14];
   assign d[17] = indir[15];
   assign d[19] = indir[16];
   assign d[20] = indir[17];
   assign d[22] = indir[18];
   assign d[23] = indir[19];
   assign d[24] = indir[20];
   assign d[25] = indir[21];
   assign d[26] = indir[22];
   assign d[27] = indir[23];
   // replaces = 1000100110110000000001000001100000000000000
   SB_LUT4 #(.LUT_INIT(16'h0020)) cmb_d14(.O(d[14]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h6000)) cmb_d15(.O(d[15]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h78bf)) cmb_d21(.O(d[21]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0804)) cmb_d31(.O(d[31]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0800)) cmb_d32(.O(d[32]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0500)) cmb_d34(.O(d[34]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h4002)) cmb_d35(.O(d[35]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h5000)) cmb_d38(.O(d[38]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0010)) cmb_d42(.O(d[42]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   // replaces = 0111011001000110000000000000000000000000000
   SB_LUT4 #(.LUT_INIT(16'h3190)) cmb_d28(.O(d[28]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h61e0)) cmb_d29(.O(d[29]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h5042)) cmb_d33(.O(d[33]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h2004)) cmb_d36(.O(d[36]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h2800)) cmb_d37(.O(d[37]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h040f)) cmb_d39(.O(d[39]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0545)) cmb_d40(.O(d[40]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0400)) cmb_d41(.O(d[41]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   assign d[43] = 1'b0;
   assign d[44] = 1'b0;
   assign d[45] = 1'b0;
   assign d[46] = 1'b0;
   assign d[47] = 1'b0;
wire instr0100,instr1x110100;        bn_l4v #(.I(16'h0010)) leq0100(     .o(instr0100),     .i({minx[3:0]}));bn_l4v #(.I(16'h8000)) leq1x110100( .o(instr1x110100), .i({minx[7],minx[5:4],instr0100}));SB_DFFE reg_d18( .Q(d[18]), .C(clk), .E(progress_ucode), .D(instr1x110100));assign d[30] = d[18];
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019-2020. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * Automatically generated from ../code/ucode.h by midgetv_indirectEBR.c.
 * Do not edit.
 * Optiones for this variant:
 *   RVC included
 *   No MULDIV
 *   minstret for instructions in SRAM
 */
/* Using LUTSIZE=4. Using 2 EBRs. Initial table has 43 columns
 * Removed:  0000000000000000000000000000000000000000000 These are removed from consideration, replaced with hand-crafted Verilog code in the output stage
 * Reserved: 0000000000000000000000000000000000000000000 Columns to be represented directly, not part of optimalization
 * Total columns to represent in EBRs: 43
 * 169 distinct lines in remaining untreated columns
 * c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 * 168 169 169 169 169 169 169 169 169 169 169 169 169 169 169 169 169 168 169 168 168 169 169 167 169 169 169 169 169 167 166 168 169 168 169 168 169 168 169 169 168 168 168  kill col 12  Tbl  42 cols 0000000000000000000000000000001000000000000 has 166 unique lines.
 * 165 166 166 166 166 166 166 166 166 166 166 166 166 166 166 166 166 164 166 165 163 166 166 164 166 166 166 166 166 164     164 165 165 166 165 166 165 166 166 165 165 165  kill col 22  Tbl  41 cols 0000000000000000000010000000001000000000000 has 163 unique lines.
 * 162 163 163 163 163 163 163 163 163 163 163 163 163 163 163 163 163 162 163 162     163 163 161 163 163 163 163 163 161     161 162 162 163 162 162 161 163 163 162 162 161  kill col 19  Tbl  40 cols 0000000000000000000010010000001000000000000 has 161 unique lines.
 * 160 161 161 161 161 161 161 161 161 161 161 161 161 161 161 161 161 160 161 160     161 161     161 161 161 161 161 159     158 160 160 161 160 160 159 161 161 160 160 159  kill col 11  Tbl  39 cols 0000000000000000000010010000001100000000000 has 158 unique lines.
 * 157 158 158 158 158 158 158 158 158 158 158 158 158 158 158 158 158 157 158 157     158 158     158 158 158 158 158 152         157 157 158 157 157 156 157 158 157 157 156  kill col 13  Tbl  38 cols 0000000000000000000010010000011100000000000 has 152 unique lines.
 * 151 152 152 152 152 152 152 152 152 152 152 152 152 152 152 152 152 151 152 151     152 152     152 152 152 152 152             151 151 151 151 151 150 151 152 151 151 150  kill col  5  Tbl  37 cols 0000000000000000000010010000011100000100000 has 150 unique lines.
 * 149 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150 149 150 149     150 150     150 150 150 150 150             149 149 149 147 149     149 149 147 147 147  kill col  7  Tbl  36 cols 0000000000000000000010010000011100010100000 has 147 unique lines.
 * 146 147 147 147 147 147 147 147 147 147 147 147 147 147 146 147 147 146 146 146     147 147     147 146 147 147 147             146 146 146     146     146 145 142 142 144  kill col  2  Tbl  35 cols 0000000000000000000010010000011100010100100 has 142 unique lines.
 * 141 142 142 142 142 142 142 142 142 142 142 142 142 142 141 141 142 140 141 140     142 142     142 141 140 142 141             141 141 141     140     141 139     138 138  kill col  1  Tbl  34 cols 0000000000000000000010010000011100010100110 has 138 unique lines.
 * 137 138 138 138 138 138 138 138 137 138 138 138 138 138 137 137 138 136 137 136     138 138     138 137 133 138 137             137 137 137     132     134 130         134  kill col  3  Tbl  33 cols 0000000000000000000010010000011100010101110 has 130 unique lines.
 * 129 130 130 130 130 130 130 130 128 130 130 130 130 130 129 129 129 127 128 126     130 130     130 127 125 129 129             129 129 129     119     121             122  kill col  6  Tbl  32 cols 0000000000000000000010010000011100011101110 has 119 unique lines.
 * 118 119 119 119 119 119 119 119 118 119 119 118 119 119 118 116 118 114 116 115     119 119     119 115 113 118 118             118 118 118             104             107  kill col  4  Tbl  31 cols 0000000000000000000010010000011100011111110 has 104 unique lines.
 * 102 104 104 104 104 104 104 104 102 104 103 103 104 103 102 101 103  97 100  99     104 104     104  98  98 103 101             103 103 103                              89  kill col  0  Tbl  30 cols 0000000000000000000010010000011100011111111 has  89 unique lines.
 *  87  89  89  89  89  89  89  89  86  89  88  88  89  87  87  87  88  83  85  84      89  89      89  83  82  88  85              88  88  87                                  kill col 16  Tbl  29 cols 0000000000000000000010010010011100011111111 has  82 unique lines.
 *  80  82  82  82  82  82  82  82  79  81  81  81  82  80  80  79  81  75  77  76      81  81      82  76      81  78              81  81  80                                  kill col 25  Tbl  28 cols 0000000000000000010010010010011100011111111 has  75 unique lines.
 *  73  75  75  75  75  75  75  75  72  74  74  73  75  72  74  72  73      69  65      73  74      75  68      74  71              74  74  73                                  kill col 23  Tbl  27 cols 0000000000000000010110010010011100011111111 has  65 unique lines.
 *  63  64  65  65  65  65  65  65  62  64  64  63  65  62  64  62  62      60          63  64      65  59      64  61              64  64  63                                  kill col 17  Tbl  26 cols 0000000000000000010110010110011100011111111 has  59 unique lines.
 *  57  58  59  59  59  59  59  59  56  58  58  57  59  56  58  57  57      55          57  58      59          58  55              58  58  57                                  kill col 24  Tbl  25 cols 0000000000000000011110010110011100011111111 has  55 unique lines.
 *  53  54  54  54  55  54  55  55  52  54  54  53  54  51  54  52  51                  53  54      55          53  52              54  54  53                                  kill col 29  Tbl  24 cols 0000000000000100011110010110011100011111111 has  51 unique lines.
 *  49  50  50  47  51  50  51  51  49  50  50  49  50      48  47  46                  49  50      50          49  48              50  50  49                                  kill col 26  Tbl  23 cols 0000000000000100111110010110011100011111111 has  46 unique lines.
 *  44  45  45  42  46  45  46  46  44  45  45  44  45      44  42                      44  45      45          44  44              45  45  44                                  kill col 39  Tbl  22 cols 0001000000000100111110010110011100011111111 has  42 unique lines.
 *  40  41  40      42  41  42  42  40  41  41  40  40      37  38                      40  40      41          41  40              41  41  40                                  kill col 28  Tbl  21 cols 0001000000000110111110010110011100011111111 has  37 unique lines.
 *  35  36  34      36  36  36  37  35  36  36  34  35          34                      35  34      36          36  36              36  36  35                                  kill col 40  Tbl  20 cols 0011000000000110111110010110011100011111111 has  34 unique lines.
 *  32  31          33  33  32  34  32  31  33  32  32          30                      32  31      33          33  33              33  33  32                                  kill col 27  Tbl  19 cols 0011000000000111111110010110011100011111111 has  30 unique lines.
 *  28  28          29  29  28  30  28  27  29  28  28                                  28  27      29          29  29              29  29  28                                  kill col 33  Tbl  18 cols 0011000001000111111110010110011100011111111 has  27 unique lines.
 *  26  25          26  26  25  27  25      26  25  25                                  25  24      26          26  26              26  26  25                                  kill col 20  Tbl  17 cols 0011000001000111111110110110011100011111111 has  24 unique lines.
 *  23  22          23  23  22  24  22      23  23  22                                  23          23          23  23              23  23  22                                  kill col 41  Tbl  16 cols 0111000001000111111110110110011100011111111 has  22 unique lines.
 *  21              21  21  20  22  20      21  21  20                                  21          21          21  21              21  21  20                                  kill col 36  Tbl  15 cols 0111001001000111111110110110011100011111111 has  20 unique lines.
 *  19              19  18      20  18      19  19  18                                  19          19          19  19              19  19  18                                  kill col 37  Tbl  14 cols 0111011001000111111110110110011100011111111 has  18 unique lines.
 *  17              17          18  16      17  17  16                                  17          17          17  17              17  17  16                                  kill col 34  Tbl  13 cols 0111011011000111111110110110011100011111111 has  16 unique lines.
Possible good candidates for removal, columns : 8 14 30 31 
 *
 * Round 1: 1000100100111000000001001001100011100000000  4 columns for indexes to table representing 13 original columns (uses 16 of 16 lines in indirect table).
 * Total columns to represent in EBRs: 34
 * 164 distinct lines in remaining untreated columns
 * c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 *   x 164 164 164   x 164 164   x 164 164   x   x   x 164 164 163 164 163 164 163 163   x 164 161   x 164 164   x   x 162 161 162   x   x   x 163 164 163 164 164 163 163 163  kill col 19  Tbl  29 cols 1000100100111000000001011001100011100000000 has 161 unique lines.
 *   x 161 161 161   x 161 161   x 161 161   x   x   x 161 161 160 161 160 161 160 160   x 161       x 161 161   x   x 159 158 159   x   x   x 160 161 160 161 161 160 160 160  kill col 12  Tbl  28 cols 1000100100111000000001011001101011100000000 has 158 unique lines.
 *   x 158 158 158   x 158 158   x 158 158   x   x   x 158 158 157 158 156 158 157 155   x 158       x 158 158   x   x 156     155   x   x   x 157 158 157 158 158 157 157 157  kill col 22  Tbl  27 cols 1000100100111000000011011001101011100000000 has 155 unique lines.
 *   x 155 155 155   x 155 155   x 155 155   x   x   x 155 155 154 155 154 155 154       x 155       x 155 155   x   x 152     152   x   x   x 154 154 153 155 155 154 154 153  kill col 13  Tbl  26 cols 1000100100111000000011011001111011100000000 has 152 unique lines.
 *   x 152 152 152   x 152 152   x 152 152   x   x   x 152 152 151 152 151 152 151       x 152       x 152 152   x   x         145   x   x   x 151 151 150 152 152 151 151 150  kill col 11  Tbl  25 cols 1000100100111000000011011001111111100000000 has 145 unique lines.
 *   x 145 145 145   x 145 145   x 145 145   x   x   x 145 145 144 145 144 145 144       x 145       x 145 145   x   x               x   x   x 144 144 143 144 145 144 144 143  kill col  5  Tbl  24 cols 1000100100111000000011011001111111100100000 has 143 unique lines.
 *   x 143 143 143   x 143 143   x 142 142   x   x   x 143 143 142 143 142 143 142       x 143       x 143 141   x   x               x   x   x 139 142     142 142 139 140 139  kill col  7  Tbl  23 cols 1000100100111000000011011001111111110100000 has 139 unique lines.
 *   x 139 139 139   x 139 139   x 138 138   x   x   x 139 138 138 139 138 136 138       x 139       x 138 136   x   x               x   x   x     138     138 136 132 134 135  kill col  2  Tbl  22 cols 1000100100111000000011011001111111110100100 has 132 unique lines.
 *   x 132 132 132   x 132 132   x 131 130   x   x   x 132 131 130 132 129 129 129       x 131       x 129 129   x   x               x   x   x     130     131 128     128 127  kill col  0  Tbl  21 cols 1000100100111000000011011001111111110100101 has 127 unique lines.
 *   x 127 127 127   x 127 127   x 126 124   x   x   x 127 126 125 127 122 124 123       x 126       x 124 121   x   x               x   x   x     124     121 122     123      kill col 16  Tbl  20 cols 1000100100111000000011011011111111110100101 has 121 unique lines.
 *   x 121 121 121   x 121 121   x 120 118   x   x   x 120 120 119 120 115 118 117       x 120       x 115       x   x               x   x   x     116     113 112     110      kill col  1  Tbl  19 cols 1000100100111000000011011011111111110100111 has 110 unique lines.
 *   x 110 110 110   x 110 110   x 107 107   x   x   x 109 109 107 109 103 106 104       x 109       x 104       x   x               x   x   x     101      99  97              kill col  3  Tbl  18 cols 1000100100111000000011011011111111110101111 has  97 unique lines.
 *   x  97  96  97   x  97  97   x  91  94   x   x   x  96  96  94  94  90  90  91       x  96       x  89       x   x               x   x   x      79      80                  kill col  6  Tbl  17 cols 1000100100111000000011011011111111111101111 has  79 unique lines.
 *   x  79  78  79   x  79  78   x  76  77   x   x   x  78  78  75  76  67  70  71       x  78       x  70       x   x               x   x   x              59                  kill col  4  Tbl  16 cols 1000100100111000000011011011111111111111111 has  59 unique lines.
 *   x  59  58  59   x  59  58   x  56  57   x   x   x  57  56  55  56  50  52  53       x  56       x  52       x   x               x   x   x                                  kill col 25  Tbl  15 cols 1000100100111000010011011011111111111111111 has  50 unique lines.
 *   x  50  49  50   x  50  49   x  47  47   x   x   x  48  47  46  46      45  43       x  47       x  43       x   x               x   x   x                                  kill col 23  Tbl  14 cols 1000100100111000010111011011111111111111111 has  43 unique lines.
 *   x  42  42  43   x  43  42   x  40  40   x   x   x  41  40  37  37      38           x  40       x  37       x   x               x   x   x                                  kill col 27  Tbl  13 cols 1000100100111001010111011011111111111111111 has  37 unique lines.
 *   x  36  36  36   x  37  36   x  34  34   x   x   x  35  33      31      31           x  34       x  31       x   x               x   x   x                                  kill col 26  Tbl  12 cols 1000100100111001110111011011111111111111111 has  31 unique lines.
 *   x  30  30  30   x  31  30   x  28  28   x   x   x  29  28              26           x  28       x  26       x   x               x   x   x                                  kill col 24  Tbl  11 cols 1000100100111001111111011011111111111111111 has  26 unique lines.
 *   x  25  25  24   x  25  25   x  23  23   x   x   x  23  24                           x  22       x  22       x   x               x   x   x                                  kill col 20  Tbl  10 cols 1000100100111001111111111011111111111111111 has  22 unique lines.
 *   x  21  20  21   x  21  21   x  19  19   x   x   x  19  20                           x           x  18       x   x               x   x   x                                  kill col 17  Tbl   9 cols 1000100100111001111111111111111111111111111 has  18 unique lines.
 *   x  17  15  17   x  17  17   x  15  15   x   x   x  15  16                           x           x           x   x               x   x   x                                  kill col 40  Tbl   8 cols 1010100100111001111111111111111111111111111 has  15 unique lines.
Possible good candidates for removal, columns : 29 33 34 
 *
 * Round 2: 0101011011000110000000000000000000000000000  4 columns for indexes to table representing  8 original columns (uses 15 of 16 lines in indirect table).
 * Direct:  0010000000000001111110110110011100011111111 22 columns
 * Can even chose 2 more columns to be represented directly.
 * Success. Use 2 EBRs, 19 LUTs.
 */

module v10_m_2ebr
  (
   input         clk,
   input [7:0]   minx,
   input         progress_ucode,
/* verilator lint_off UNOPTFLAT */
   output [47:0] d
/* verilator lint_on UNOPTFLAT */
   );
   /*
    *                      indirect_index 1
    * inx         next     | indirect index 0
    * || ucode    ucode    | | direct representation
    * 00 LB_0     LB_1     0 0 100110101111000000000001| LB     Load byte. q = rdadr=RS1+0fs
    * 01 LB_1     LB_2     1 1 00010111111001x111010010|        Read until q=mem[rs1+ofs) & ~3u]
    * 02 IJ_0     IJ_1     2 2 100110111111000010111110| IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0
    * 03 _L0x03   StdIncPc 0 0 00000101x10xxxx011100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 04 ADDI_0   StdIncPc 3 0 000001011101000011100110| ADDI   Add immediate. rd =RS1+Iimm (or joined)
    * 05 _L0x05   ADDI_0   0 0 00000001x01xxxx000000100| AUIPC  q = imm20+2 or imm20+4  (copy x/2)
    * 06 LB_3     LB_4     0 0 00001101111010x000000111|        q = ~mem[rs1+ofs]
    * 07 LB_4     LB_5     0 0 00001011111011x000001001|        q = (uint8_t) mem[rs1+Iimm]
    * 08 _L0x08   SB_1     4 0 000111001111000001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 09 LB_5     LB_6     0 0 00001011111000x010001011|        q = D^0xffffffff^q = D^0x80
    * 0a _L0x0a   SB_1     4 0 000111001111000001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 0b JALR_2   JALR_3   0 3 000001011111001000110011|        Q=1. Prep legalize target
    * 0c ADD_0    ADDI_0   0 0 00011101111001x000000100| ADD    add     Addition Q = RS1
    * 0d _L0x0d   StdIncPc 3 0 000001011101100011100110| LUI    q = imm20
    * 0e SUB_0    SUB_1    0 0 00011101x10xxxx000010000| SUB    Subtraction
    * 0f _L0x0f   StdIncPc 3 0 000001011101100011100110| LUI    q = imm20
    * 10 SUB_1    LB_6     0 0 00011111111000x010001011|        Q = ~RS2
    * 11 AND_1    ANDI_1   0 0 00011101111000x000011010|        RS1^0xffffffff to Q
    * 12 straddle Fetchu   5 4 110110110011001001110110|  Fr10u IncPC, OpFetch
    * 13 condb_2  condb_3  0 0 00011111111000x000010100|        ~RS2 in Q
    * 14 condb_3  condb_4  0 3 000110011111001000010101|        Calculate RS1+~RS2+1
    * 15 condb_4  condb_5  0 5 00000001111001x000010110|        Branch on condition
    * 16 condb_5  StdIncPc 0 0 00000001x10xxxx011100110|        Branch not taken.
    * 17 condb_5t condb_6t 6 0 00000001101001x001111101|        Branch taken. yy=oldPC incase of access error
    * 18 BEQ      condb_2  6 0 000111011101100000010011| BEQ    Conditional Branch. Offset to Ryy
    * 19 JALR_0   JALR_1   4 0 0100000110x1000001000001| JALR   (tmp) Prep pc=RS1+imm (target)
    * 1a ANDI_1   StdIncPc 3 0 00000101110011x011100110|        rd = Iimm & RS1
    * 1b _L0x1b   JAL_1    0 0 00000001x01xxxx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 1c ECAL_BRK ECAL_RET 0 2 000101111011100010100110| ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI
    * 1d ORI_2    StdIncPc 3 0 000001011101110011100110|        rd = Iimm | RS1
    * 1e aFault_1 aFault_2 0 3 000101010111001011010100|        Q = 4
    * 1f IJ_2     IJ_3     4 0 010000011011100010110111|        Read word is to be masked with lsb = 0
    * 20 LH_0     LH_1     6 2 100110101111000001010010| LH     Load hword. Q = rdadr=RS1+Iimm.
    * 21 XORI_1   StdIncPc 3 0 00000101110000x011100110|        rd = Iimm ^ RS1
    * 22 _L0x22   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 23 _L0x23   StdIncPc 0 0 00000101x10xxxx011100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 24 SLLI_0   SLLI_1   0 6 0001111010x1100000110101| SLLI   Shift left immediate.
    * 25 _L0x25   ADDI_0   0 0 00000001x01xxxx000000100| AUIPC  q = imm20+2 or imm20+4  (copy x/2)
    * 26 OR_1     OR_2     4 0 00011101110000x000100111|        RS1^0xffffffff to jj
    * 27 OR_2     ORI_2    0 0 000000011111000000011101|        Q = rs2
    * 28 _L0x28   SH_1     4 2 000111001111000010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 29 XOR_1    XORI_1   0 0 00011101111000x000100001|        Q = RS1^0xFFFFFFFF
    * 2a _L0x2a   SH_1     4 2 000111001111000010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 2b SLTIX_1  SLTIX_2  0 3 000xxxx11101001000110000|        RS1 - imm / RS1 - RS2
    * 2c SLL_0    SLL_1    0 0 00011101x0xxxxx000111110| SLL    Shift left
    * 2d _L0x2d   StdIncPc 3 0 000001011101100011100110| LUI    q = imm20
    * 2e unx2e             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 2e: Not in use 
    * 2f _L0x2f   StdIncPc 3 0 000001011101100011100110| LUI    q = imm20
    * 30 SLTIX_2  StdIncPc 3 7 000001011101101011100110|        Registered ALU flag to rd
    * 31 SLTX_1   SLTIX_1  0 0 00011111111000x000101011|        ~rs2 to Q
    * 32 JAL_1    JAL_2    6 0 00000001101001x010000110|      Prep Instradr to yy. Refetch instradr
    * 33 JALR_3   JAL_25   4 0 01000001110011x010011110|        Q = (RS1+imn) & 0xfffffffe
    * 34 JAL_3    Fetch    5 0 11011011101001x011011110|      Prep fetch next instr.
    * 35 SLLI_1   SLLI_2   3 6 00010111111001x000110110|        Register to shift to Q (and TRG for shift 0)
    * 36 SLLI_2   _L0x03   8 6 000101111111010000000011|        Repeat Q = Q+Q until shregcnt == 0
    * 37 ECALL_2  ECALL_3  6 5 001xxxx1110001x011010111|        mepc = pc, prep store 0 to mtval
    * 38 BNE      condb_2  6 0 000111011101100000010011| BNE    Conditional Branch. Offset to Ryy
    * 39 _L0x39   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 3a SRxI_1   SRxI_2   3 8 00010101111001x100111101|        Register to shift to Q
    * 3b _L0x3b   JAL_1    0 0 00000001x01xxxx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 3c CSRRW_0  CSRRW_1  6 0 000011011101100001001001| CSRRW  Decoded CSR adr in yy
    * 3d SRxI_2   _L0x03   8 8 00010101111001x100000011|        Repeat Q >>= 1 until shregcnt == 0
    * 3e SLL_1    SLLI_1   0 6 0001111010x001x000110101|        Shiftamount was in low 5 bits of RS2
    * 3f SRx_1    SRxI_1   0 6 0001111010x001x000111010|        Shiftamount in low 5 bits of RS2
    * 40 LW_0     LW_1     0 9 100110111111000001010000| LW     Load word. Q=yy=rdadr=RS1+Iimm
    * 41 JALR_1   JALR_2   6 0 00010101110001x000001011|        yy=jj. Prep get Q=1
    * 42 _L0x42   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 43 _L0x43   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 44 SLTI_0   SLTIX_1  0 0 00011111111010x000101011| SLTI   Set less than immediate (signed)
    * 45 WFI_3    WFI_4    0 3 000101011111001001100101|        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105
    * 46 ILL_1    ILL_2    6 0 0011010110x001x001000111|        Store PC to mepc
    * 47 ILL_2    ILL_3    6 0 01110101110001x010001111|        Store 0 to mtval
    * 48 _L0x48   SW_1     9 9 100111011111000001100110| SW     Store word. Q=wradr=RS1+Simm
    * 49 CSRRW_1  CSRRW_2  0 3 000000011111001001001011|        Construct PC storage adr
    * 4a _L0x4a   SW_1     9 9 100111011111000001100110| SW     Store word. Q=wradr=RS1+Simm
    * 4b CSRRW_2  CSRRW_3  a 0 01110101101001x010110001|        Write PC to 0x100 start Prep emulation entrypt
    * 4c SLT_0    SLTX_1   0 0 00011101x10xxxx000110001| SLT    Set less than (signed)
    * 4d unx4d             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 4d: Not in use 
    * 4e eILL0b   ILLe     0 0 000xxxx1x0xxxxx011111110| Illegal instruction seen
    * 4f MRET_8   MRET_9   0 3 000101010111001001110100|        +4, so now 0x103
    * 50 LW_1     StdIncPc b a 00010111110001x011100110|        Read until d=mem[(rs1+ofs) & ~3u]
    * 51 LDAF_LW  LDAF_a   6 0 011101011011100011011010|  err   LD AlignFault. Faulting adr to mtval
    * 52 LH_1     LH_2     1 1 00010111111001x101010100|        Read until q=mem[(rs1+ofs) & ~3u]
    * 53 LDAF_LH  LDAF_a   6 0 011101011011100011011010|  err   LD AlignFault. Faulting adr to mtval
    * 54 LH_2     LH_3     c 8 00010101111001x111101011|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 55 aFaultb  aFault_1 6 0 011101011101100000011110|  err   LH Load access fault. Faulting adr to mtval
    * 56 LH_4     LH_5     0 0 00010001111011x001010111|        q = (uint16_t) mem[rs1+Iimm]
    * 57 LH_5     LB_6     0 0 00010001111000x010001011|        q = D^0xffffffff^q = D ^ 0x00008000
    * 58 _L0x58   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 59 _L0x59   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 5a SB_1     SB_2     6 6 00010111111001x001011101|        Write d to Q and yy (for sh 0). Prep shift
    * 5b _L0x5b   JAL_1    0 0 00000001x01xxxx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 5c CSRRS_0  CSRRW_1  6 0 000011011101100001001001| CSRRS  Decoded CSR adr in yy
    * 5d SB_2     SB_3     d 6 000101111111010011111011|        Repeat shl until shreg = 0 (0,8,16 or 24 times)
    * 5e LHU_1    LHU_2    1 1 00010111111001x101110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 5f LDAF_LHU LDAF_a   6 0 011101011011100011011010|  err   LD AlignFault. Faulting adr to mtval
    * 60 _L0x60   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 61 EBRKWFI2 EBREAK_1 6 5 00001101110010x011110111| EBREAK/WFI2 Select EBREAK or WFI.
    * 62 _L0x62   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 63 _L0x63   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 64 SLTIU_0  SLTIX_1  0 0 00011111111010x000101011| SLTIU  Set less than immediate (unsigned)
    * 65 WFI_4    WFI_5    0 5 00000001x10xxxx011101111|        Prepare read PC.
    * 66 SW_1     SW_2     7 0 01111101101001x011110010|        Write d to a+k until accepted
    * 67 SW_E1SWE SW_E2    6 0 0110010110x1100010010011|        Store faulting address alignment to mtval
    * 68 _L0x68   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 69 unx69             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 69: Not in use 
    * 6a _L0x6a   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 6b SB_4     SB_5     9 0 11011001111001x001111010|        Address back to Q. Prepare get item to write
    * 6c SLTU_0   SLTX_1   0 0 00011101x10xxxx000110001| SLTU   Set less than (unsigned)
    * 6d unx6d             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 6d: Not in use 
    * 6e unx6e             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 6e: Not in use 
    * 6f MRET_6   MRET_7   0 3 000xxxx11111001011001111|        ~302 + origImm + 1 for branch decision
    * 70 LHU_2    LHU_3    c 8 00010101111001x110111010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 71 aFaultc  aFault_1 6 0 011101011101100000011110|  err   LHU Load access fault. Faulting adr to mtval
    * 72 LBU_3    ANDI_1   0 0 00001101111010x000011010|        Invert q. Prepare read mask
    * 73 unalignd straddle 0 0 000001011101100000010010|  Fr10u Unaligned pc, prep read high hword
    * 74 MRET_9   Fetch    5 3 110110111011001011011110|        +1, IncPC, OpFetch next
    * 75 IJ_5     Fetch    5 0 11011011101011x011011110|        Mask and use as PC
    * 76 Fetchu   Fetch2   0 b 000001111101100011110100|  Fr10u Read and latch instruction
    * 77 eFetchu  Fetch2   1 c 000101111101100011110100|  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]
    * 78 _L0x78   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 79 _L0x79   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 7a SB_5     SW_2     7 0 01011001101001x011110010|        Write d to a+k until accepted
    * 7b _L0x7b   JAL_1    0 0 00000001x01xxxx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 7c CSRRC_0  CSRRW_1  6 0 000011011101100001001001| CSRRC  Decoded CSR adr in yy
    * 7d condb_6t Fetch    5 0 110110111011000011011110|        Branch taken.
    * 7e NMI_1    NMI_2    6 0 001xxxx1110001x010010000|        Store pc to mepc.
    * 7f unx7f             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 7f: Not in use 
    * 80 LBU_0    LBU_1    0 0 100110101111000010000101| LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.
    * 81 unx81             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 81: Not in use 
    * 82 _L0x82   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 83 _L0x83   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 84 XORI_0   XORI_1   0 0 00011111111010x000100001| XORI   Xor immediate. Q=~Iimm
    * 85 LBU_1    LBU_2    1 1 00010111111001x111110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 86 JAL_2    JAL_25   4 0 010000011101000010011110|      Prep pc = jj + ofs
    * 87 unx87             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 87: Not in use 
    * 88 _L0x88   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 89 unx89             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 89: Not in use 
    * 8a _L0x8a   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 8b LB_6     StdIncPc 3 3 000001011101001011100110|        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80
    * 8c XOR_0    XOR_1    0 0 00011111x10xxxx000101001| XOR    xor
    * 8d unx8d             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 8d: Not in use 
    * 8e _LCSRRS_1 ILLe     0 0 000xxxx1x0xxxxx011111110| Illegal instruction seen
    * 8f ILL_3    ILL_4    0 3 000101011111001010101001|        Q = 1
    * 90 NMI_2    JAL_3    e 0 011010011101100000110100|        mtval = 0.
    * 91 LDAF_2   LDAF_3   e 3 0100010100x1001010010010|        Store 4 to mcause
    * 92 LDAF_3   JAL_3    6 0 0011001110x001x000110100|        PC to mepc
    * 93 SW_E2    SW_E3    6 0 00110111110001x010010101|        Store address that faulted
    * 94 SW_E4    JAL_3    e 0 0101001110x1010000110100|        Store 6 to mcause
    * 95 SW_E3    SW_E4    0 3 000101110111001010010100|        Q = 3
    * 96 SH_1     SH_2     6 6 00010111111001x010111011|        Write d to Q and yy (for sh 0). Prep shift
    * 97 SW_E1SWH SW_E2    6 0 0110010110x1100010010011|        Store faulting address alignment to mtval
    * 98 BLT      condb_2  6 0 000111011101100000010011| BLT    Conditional Branch. Offset to Ryy
    * 99 _L0x99   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 9a ECALL_6  JAL_3    e 0 0101001100x1000000110100|        mcause = 11
    * 9b SH_4     SH_5     9 0 10111001111001x010011111|        Address back to Q. Prepare get item to write
    * 9c _L0x9c   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 9d unx9d             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 9d: Not in use 
    * 9e JAL_25   JAL_3    3 4 000001010101001000110100|      Prep WTRG = jj+2/4 (return adr)
    * 9f SH_5     SW_2     7 0 00111001101001x011110010|        Write d to a+k until accepted
    * a0 LHU_0    LHU_1    6 2 100110101111000001011110| LHU    Load unsigned hword. Q = rdadr=RS1+Iimm
    * a1 ECALL_4  ECALL_5  0 3 000101010111001010110110|        Q = 4
    * a2 _L0xa2   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * a3 _L0xa3   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * a4 SRxI_0   SRxI_1   0 6 0001111010x1100000111010| SRxI   Shift Right immediate (both logic/arith here)
    * a5 MRET_3   MRET_4   0 3 000011011111001010101111|        0x102 + 0xff + 1 = 0x202
    * a6 ECAL_RET ECALL_1  0 9 000101111011100011010000| ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET
    * a7 EBRKWFI1 EBRKWFI2 0 0 000xxxx11111000001100001| EBREAK/WFI1 Prepare select EBREAK or WFI
    * a8 _L0xa8   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * a9 ILL_4    JAL_3    e 3 0101001110x1001000110100|        Store 2 to mcause
    * aa _L0xaa   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * ab EBREAK_2 ECALL_6  6 0 00110101110001x010011010|        pc to mepc
    * ac _L0xac   SRx_1    0 0 00011101x0xxxxx000111111| SRx    Shift Right (both SRL and SRA)
    * ad unxad             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| ad: Not in use 
    * ae _L0xae   SRx_1    0 0 00011101x0xxxxx000111111| SRx    Shift Right (both SRL and SRA)
    * af MRET_4   MRET_5   0 3 000xxxx11111001011000101|        0x202 + 0xff + 1 = 0x302
    * b0 aF_SW_3  LDAF_3   e 0 0100010100x1000010010010|        Store 7 to mcause
    * b1 CSRRW_3  CSRRW_4  0 3 000101010111001010110010|        Prep emulation entrypt 0x108, here Q to 0x104
    * b2 CSRRW_4  Fetch    5 3 110110110011001011011110|        IncPC, OpFetch, but force +4
    * b3 unxb3             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| b3: Not in use 
    * b4 eFetch3  unalignd 4 d 001111111111001001110011|  Fr10  Update minstret, Q=immediate. Use dinx
    * b5 SH_3     SH_4     0 0 000000011101100010011011|        Prepare get back address to use 
    * b6 ECALL_5  ECALL_6  0 3 000101010111001010011010|        Q = 8
    * b7 IJ_3     IJ_4     6 0 00010101110001x010111101|        Store present PC in case of access error
    * b8 BGE      condb_2  6 0 000111011101100000010011| BGE    Conditional Branch. Offset to Ryy
    * b9 _L0xb9   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * ba LHU_3    ANDI_1   0 0 00001111111010x000011010|        Invert q. Prepare read mask
    * bb SH_2     SH_3     d 6 000101111111010010110101|        Repeat shl until shreg = 0 (0,8 or 24 times)
    * bc CSRRWI_0 CSRRW_1  6 0 000011011101100001001001| CSRRWI Decoded CSR adr in yy
    * bd IJ_4     IJ_5     0 3 000001011111001001110101|        Construct Q = 1
    * be IJ_1     IJ_2     1 0 00010111111001x000011111|        Read until q=mem[(rs1+ofs)&~1u]
    * bf IJT_1    IJT_2    1 0 00010111111001x011000001|        Exit CSR, enter trap
    * c0 _L0xc0   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * c1 IJT_2    IJT_3    6 0 000101011101100011101001|        Read word is to be masked with ~1u
    * c2 _L0xc2   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * c3 _L0xc3   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * c4 ORI_0    ORI_1    4 0 00011111110010x011100001| ORI    Or immediate. jj=~Iimm
    * c5 MRET_5   MRET_6   0 0 00000001111010x001101111|        ~302
    * c6 IJT_4    ILL_2    6 0 00110101111011x001000111|        Mask and store to mepc and Q for read of instr
    * c7 QINT_1   QINT_2   6 0 001xxxx1110001x011001011|        Store pc to mepc.
    * c8 _L0xc8   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * c9 MRET_2   MRET_3   0 0 000011010111000010100101|        0xff+3 = 0x102
    * ca _L0xca   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * cb QINT_2   StdIncPc e 0 011010011101100011100110|        mtval = 0.
    * cc OR_0     OR_1     0 0 00011111x10xxxx000100110| OR     or
    * cd unxcd             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| cd: Not in use 
    * ce _LCSRRCI_1 ILLe     0 0 000xxxx1x0xxxxx011111110| Illegal instruction seen
    * cf MRET_7   MRET_8   0 5 00001101x10xxxx001001111|        Prepare emulation entry point 0x104
    * d0 ECALL_1  ECALL_2  0 3 000000011111001000110111| ECALL  Verify Imm==0x000
    * d1 MRET_1   MRET_2   4 0 000011011101100011001001| MRET   First save Imm, start build constant for check
    * d2 LB_2     LB_3     c 8 00010101111001x100000110|        Repeat shr until shreg == 0 (0,8,16,24 times)
    * d3 aFaultd  aFault_1 6 0 011101011101100000011110|  err   LB Load access fault. Faulting adr to mtval
    * d4 aFault_2 LDAF_3   e 3 0100010110x1001010010010|        Store 5 to mcause
    * d5 eFetch2  eFetch3  4 e 011000111101000010110100|  Fr10  Update ttime
    * d6 eILL0c   ILLe     0 0 000xxxx1x0xxxxx011111110| Illegal instruction seen
    * d7 ECALL_3  ECALL_4  6 0 011101011101100010100001|        mtval = 0, now start the chore of 11 to mcause
    * d8 BLTU     condb_2  6 0 000111011101100000010011| BLTU   Conditional Branch. Offset to Ryy
    * d9 _L0xd9   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * da LDAF_a   LDAF_2   0 0 00010101x10xxxx010010001|        Extra cycle after error detected write mtval
    * db jFault_1 LDAF_3   6 3 0101100110x1001010010010|        Store 1 to mcause
    * dc CSRRSI_0 CSRRW_1  6 0 000011011101100001001001| CSRRSI Decoded CSR adr in yy
    * dd aF_SW_1  aF_SW_2  6 0 011101011101100011100101|  err   SW Store access fault. Faulting adr to mtval
    * de Fetch    Fetch2   4 b 000001111101100011110100|  Fr10  Read and latch instruction
    * df eFetch   eFetch2  5 c 000101111101100011010101|  Fr10  rep Read until d=mem[(rs1+ofs) & ~3u]
    * e0 _L0xe0   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * e1 ORI_1    ORI_2    0 0 00000001111001x000011101|        Q = RS1
    * e2 _L0xe2   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * e3 _L0xe3   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * e4 ANDI_0   ANDI_1   0 0 00011111111010x000011010| ANDI   And immediate. Q=~Iimm
    * e5 aF_SW_2  aF_SW_3  0 3 000101010111001010110000|        Q = 4
    * e6 StdIncPc Fetch    5 4 110110110011001011011110|  Fr10  IncPC, OpFetch
    * e7 aFault   aFault_1 6 0 011101011101100000011110|  err   Load access fault. Faulting adr to mtval
    * e8 _L0xe8   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * e9 IJT_3    IJT_4    0 3 000110011111001011000110|        Construct Q = 1
    * ea _L0xea   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * eb LH_3     LH_4     0 0 00001111111010x001010110|        q = ~mem[rs1+ofs]
    * ec AND_0    AND_1    0 0 00011111x10xxxx000010001| AND    And 
    * ed unxed             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| ed: Not in use
    * ee eILL0a   ILLe     0 0 000xxxx1x0xxxxx011111110| Illegal instruction seen
    * ef WFI_5    Fetch    5 3 110110110011001011011110|        IncPC, OpFetch
    * f0 LBU_2    LBU_3    c 8 00010101111001x101110010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * f1 aFaulte  aFault_1 6 0 011101011101100000011110|  err   LBU Load access fault. Faulting adr to mtval
    * f2 SW_2     StdIncPc 0 0 00000101x10xxxx011100110|        Prepare read PC
    * f3 aF_SW    aF_SW_1  0 0 000xxxx1x01xxxx011011101|  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf
    * f4 Fetch2   unalignd 4 f 011111111111000001110011|  Fr10  Update ttime. Update I. Q=immediate. Use dinx
    * f5 jFault   jFault_1 6 0 011101011101100011011011|  err   Fetch access fault. Faulting adr to mtval
    * f6 WFI_1    WFI_2    0 3 000110010111001011111010| WFI    Chk offset=0x105. Now 0xff. Prep 0xff+4 = 0x103
    * f7 EBREAK_1 EBREAK_2 6 0 011000011101100010101011| EBREAK mepc = pc, store 0 to mtval
    * f8 BGEU     condb_2  6 0 000111011101100000010011| BGEU   Conditional Branch. Offset to Ryy
    * f9 _L0xf9   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * fa WFI_2    WFI_3    0 3 000101011111001001000101|        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104
    * fb SB_3     SB_4     0 0 000000011101100001101011|        Prepare get back address to use 
    * fc CSRRCI_0 CSRRW_1  6 0 000011011101100001001001| CSRRCI Decoded CSR adr in yy
    * fd NMI_0    NMI_1    0 0 00000101x10xxxx001111110| NMI    Get current PC
    * fe ILLe     ILL_1    0 0 00000101x0xxxxx001000110| Illegal
    * ff QINT_0   QINT_1   0 0 00000101x10xxxx011000111| INT    Get current PC
    */
   localparam u0_0 = 256'hd8e64010d8e6e404f233f05ae08bf05aec09e8072004d0e640e6f0bee5d2f001;
   localparam u0_1 = 256'hb8b772d4dce6b8a62032cce69041d813a47d40e6e416f215e0143276e01ae08b;
   localparam u0_2 = 256'hd8e60000d8e6003ed230f096e021f096f01dc0272004983540e600fec0e6f052;
   localparam u0_3 = 256'h843a8435e503d8492032e53d00fed813c4d7f403e436a4decc9ea486e02bdae6;
   localparam u0_4 = 256'h727400fe00004031a4b1f066f24bf066c48f8447f265e82b00fe00fec40bf050;
   localparam u0_5 = 256'hb8dae570f4fbd8492032e45d00fe00fee08bec57d81ee5ebb8dae554b8dac4e6;
   localparam u0_6 = 256'hf2cf000000004031e47a00fe000000fe9893a4f240efe82b00fe00fec8f700fe;
   localparam u0_7 = 256'h0000c490b0ded8492032a4f200fe00fed8f4d8f4acdeb2ded812e81ad81ee5ba;
   localparam u0_8 = 256'hf2a900fe00004029d2e600fe000000fe0000d09ee5f0e82100fe00fe0000f085;
   localparam u0_9 = 256'ha4f25234000000fee49f103400fed8139893e4bb72949434c49584341292d834;
   localparam u0_A = 256'hf2c5003f0000003fc49a00fe923400fef061b8d0f2af983a00fe00fe72b6f05e;
   localparam u0_B = 256'he4c1e41ff275d849f4b5e81a00fed813c4bd729ad89bf273000032de72b21092;
   localparam u0_C = 256'h404f00fe00004026d8e600fe70a500fec4cbec47e86fc8e100fe00fed8e900fe;
   localparam u0_D = 256'hd8d5d8f4d8e5d8499292409100fed813d8a100fed0b49292d81ee506d8c9f237;
   localparam u0_E = 256'h32de00fe00004011e85600fef2c600fed81e32de72b0e81a00fe00fee41d00fe;
   localparam u0_F = 256'h40c70046407ed849d86bf24500fed813d8ab72fad8dbf07320dd40e6d81ee572;
   localparam u1_0 = 256'h3005001d3005001d0305401c000b401c000b000d000130050005229b1117009a;
   localparam u1_1 = 256'h4041031530050217000130054041601d6001000105010319001f54db001d001f;
   localparam u1_2 = 256'h300576003005001d0301421c001d421c0001401d0001061e000500013005629a;
   localparam u1_3 = 256'h061e061e8815600d000138150001601d65218617361750db40416001001f3705;
   localparam u1_4 = 256'h031500017600001da075999d0301999d607560350315001f000100016015099b;
   localparam u1_5 = 256'h60751117d617600d0001661700010001001100116075c815607511176075ba17;
   localparam u1_6 = 256'h030176007600001d90d90001760000016065707d0501001f00010001650d0001;
   localparam u1_7 = 256'h7600602150db600d00017059000100011c170b0750db53db0005000d6075c815;
   localparam u1_8 = 256'h031500017600001f3305000176000001760040411117001f000100017600009a;
   localparam u1_9 = 256'h703934057600000190b9e0530001601d606566170317e05360376033e345e069;
   localparam u1_A = 256'h0301001d7600001d60350001e353000100010917030d061e000100010315629a;
   localparam u1_B = 256'h101710170305600dd617000f0001601d6015031500014d3f760053db0315e045;
   localparam u1_C = 256'h050d00017600001fe0690001000d0001602160350001401f0001000160150001;
   localparam u1_D = 256'h5c174b076075600d635900150001601d607500014e63e3456075c815400d0301;
   localparam u1_E = 256'h53db00017600001f000f000103190001607554db0315001f0001000100010001;
   localparam u1_F = 256'h000500050005600d000103150001601d6061031960754f7f000100056075c815;
   wire [31:0]   indir;
`ifdef verilator
   /* verilator lint_off UNUSED */
   wire [15:0]   sim_a;
   wire [15:0]   sim_b;
   /* verilator lint_on UNUSED */
`endif
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u0_0), .INIT_1(u0_1), .INIT_2(u0_2), .INIT_3(u0_3),
                   .INIT_4(u0_4), .INIT_5(u0_5), .INIT_6(u0_6), .INIT_7(u0_7),
                   .INIT_8(u0_8), .INIT_9(u0_9), .INIT_A(u0_A), .INIT_B(u0_B),
                   .INIT_C(u0_C), .INIT_D(u0_D), .INIT_E(u0_E), .INIT_F(u0_F)
                   ) ucode0
     (
      .RDATA( indir[15:0]         ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u1_0), .INIT_1(u1_1), .INIT_2(u1_2), .INIT_3(u1_3),
                   .INIT_4(u1_4), .INIT_5(u1_5), .INIT_6(u1_6), .INIT_7(u1_7),
                   .INIT_8(u1_8), .INIT_9(u1_9), .INIT_A(u1_A), .INIT_B(u1_B),
                   .INIT_C(u1_C), .INIT_D(u1_D), .INIT_E(u1_E), .INIT_F(u1_F)
                   ) ucode1
     (
      .RDATA( indir[31:16]        ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );

   assign d[0] = indir[0];
   assign d[1] = indir[1];
   assign d[2] = indir[2];
   assign d[3] = indir[3];
   assign d[4] = indir[4];
   assign d[5] = indir[5];
   assign d[6] = indir[6];
   assign d[7] = indir[7];
   assign d[8] = indir[8];
   assign d[9] = indir[9];
   assign d[11] = indir[10];
   assign d[12] = indir[11];
   assign d[13] = indir[12];
   assign d[16] = indir[13];
   assign d[17] = indir[14];
   assign d[19] = indir[15];
   assign d[20] = indir[16];
   assign d[22] = indir[17];
   assign d[23] = indir[18];
   assign d[24] = indir[19];
   assign d[25] = indir[20];
   assign d[26] = indir[21];
   assign d[27] = indir[22];
   assign d[40] = indir[23];
   // replaces = 1000100100111000000001001001100010000000000
   SB_LUT4 #(.LUT_INIT(16'h2018)) cmb_d10(.O(d[10]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0020)) cmb_d14(.O(d[14]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h1800)) cmb_d15(.O(d[15]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'hc000)) cmb_d18(.O(d[18]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'hfebf)) cmb_d21(.O(d[21]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'ha000)) cmb_d30(.O(d[30]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0204)) cmb_d31(.O(d[31]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0200)) cmb_d32(.O(d[32]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h1002)) cmb_d35(.O(d[35]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h1400)) cmb_d38(.O(d[38]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0010)) cmb_d42(.O(d[42]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   // replaces = 0101011011000110000000000000000000000000000
   SB_LUT4 #(.LUT_INIT(16'h6948)) cmb_d28(.O(d[28]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h6070)) cmb_d29(.O(d[29]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0822)) cmb_d33(.O(d[33]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h3100)) cmb_d34(.O(d[34]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h4004)) cmb_d36(.O(d[36]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h4400)) cmb_d37(.O(d[37]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h1207)) cmb_d39(.O(d[39]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0200)) cmb_d41(.O(d[41]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   assign d[43] = 1'b0;
   assign d[44] = 1'b0;
   assign d[45] = 1'b0;
   assign d[46] = 1'b0;
   assign d[47] = 1'b0;
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019-2020. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * Automatically generated from ../code/ucode.h by midgetv_indirectEBR.c.
 * Do not edit.
 * Optiones for this variant:
 *   RVC included
 *   No MULDIV
 *   minstret for instructions in SRAM and EBR
 */
/* Using LUTSIZE=4. Using 2 EBRs. Initial table has 43 columns
 * Removed:  0000000000000000000000000000000000000000000 These are removed from consideration, replaced with hand-crafted Verilog code in the output stage
 * Reserved: 0000000000000000000000000000000000000000000 Columns to be represented directly, not part of optimalization
 * Total columns to represent in EBRs: 43
 * 168 distinct lines in remaining untreated columns
 * c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 * 167 168 168 168 168 168 168 168 168 168 168 168 168 168 168 168 168 167 168 167 167 168 168 166 168 168 168 168 168 166 165 167 168 167 168 167 168 167 168 168 167 167 167  kill col 12  Tbl  42 cols 0000000000000000000000000000001000000000000 has 165 unique lines.
 * 164 165 165 165 165 165 165 165 165 165 165 165 165 165 165 165 165 163 165 164 162 165 165 163 165 165 165 165 165 163     163 164 164 165 164 165 164 165 165 164 164 164  kill col 22  Tbl  41 cols 0000000000000000000010000000001000000000000 has 162 unique lines.
 * 161 162 162 162 162 162 162 162 162 162 162 162 162 162 162 162 162 161 162 161     162 162 160 162 162 162 162 162 160     160 161 161 162 161 161 160 162 162 161 161 160  kill col 19  Tbl  40 cols 0000000000000000000010010000001000000000000 has 160 unique lines.
 * 159 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 159 160 159     160 160     160 160 160 160 160 158     157 159 159 160 159 159 158 160 160 159 159 158  kill col 11  Tbl  39 cols 0000000000000000000010010000001100000000000 has 157 unique lines.
 * 156 157 157 157 157 157 157 157 157 157 157 157 157 157 157 157 157 156 157 156     157 157     157 157 157 157 157 151         156 156 157 156 156 155 156 157 156 156 155  kill col 13  Tbl  38 cols 0000000000000000000010010000011100000000000 has 151 unique lines.
 * 150 151 151 151 151 151 151 151 151 151 151 151 151 151 151 151 151 150 151 150     151 151     151 151 151 151 151             150 150 150 150 150 149 150 151 150 150 149  kill col  5  Tbl  37 cols 0000000000000000000010010000011100000100000 has 149 unique lines.
 * 148 149 149 149 149 149 149 149 149 149 149 149 149 149 149 149 149 148 149 148     149 149     149 149 149 149 149             148 148 148 146 148     148 148 146 146 146  kill col  7  Tbl  36 cols 0000000000000000000010010000011100010100000 has 146 unique lines.
 * 145 146 146 146 146 146 146 146 146 146 146 146 146 146 145 146 146 145 145 145     146 146     146 145 146 146 146             145 145 145     145     145 144 141 141 143  kill col  2  Tbl  35 cols 0000000000000000000010010000011100010100100 has 141 unique lines.
 * 140 141 141 141 141 141 141 141 141 141 141 141 141 141 140 140 141 139 140 139     141 141     141 140 139 141 140             140 140 140     139     140 138     137 137  kill col  1  Tbl  34 cols 0000000000000000000010010000011100010100110 has 137 unique lines.
 * 136 137 137 137 137 137 137 137 136 137 137 137 137 137 136 136 137 135 136 135     137 137     137 136 132 137 136             136 136 136     131     133 129         133  kill col  3  Tbl  33 cols 0000000000000000000010010000011100010101110 has 129 unique lines.
 * 128 129 129 129 129 129 129 129 127 129 129 129 129 129 128 128 128 126 127 125     129 129     129 126 124 129 128             128 128 128     118     120             121  kill col  6  Tbl  32 cols 0000000000000000000010010000011100011101110 has 118 unique lines.
 * 117 118 118 118 118 118 118 118 117 118 118 117 118 118 117 115 117 113 115 114     118 118     118 114 112 118 117             117 117 117             103             106  kill col  4  Tbl  31 cols 0000000000000000000010010000011100011111110 has 103 unique lines.
 * 101 103 103 103 103 103 103 103 101 103 102 102 103 102 101 100 102  96  99  98     103 103     103  97  97 102 100             102 102 102                              88  kill col  0  Tbl  30 cols 0000000000000000000010010000011100011111111 has  88 unique lines.
 *  86  88  88  88  88  88  88  88  85  88  87  87  88  86  86  86  87  82  84  83      88  88      88  82  81  87  84              87  87  86                                  kill col 16  Tbl  29 cols 0000000000000000000010010010011100011111111 has  81 unique lines.
 *  79  81  81  81  81  81  81  81  78  80  80  80  81  79  79  78  80  74  76  75      80  80      81  75      80  77              80  80  79                                  kill col 25  Tbl  28 cols 0000000000000000010010010010011100011111111 has  74 unique lines.
 *  72  74  74  74  74  74  74  74  71  73  73  72  74  71  73  71  72      68  64      72  73      74  67      73  70              73  73  72                                  kill col 23  Tbl  27 cols 0000000000000000010110010010011100011111111 has  64 unique lines.
 *  62  63  64  64  64  64  64  64  61  63  63  62  64  61  63  61  61      59          62  63      64  58      63  60              63  63  62                                  kill col 17  Tbl  26 cols 0000000000000000010110010110011100011111111 has  58 unique lines.
 *  56  57  58  58  58  58  58  58  55  57  57  56  58  55  57  56  56      54          56  57      58          57  54              57  57  56                                  kill col 24  Tbl  25 cols 0000000000000000011110010110011100011111111 has  54 unique lines.
 *  52  53  53  53  54  53  54  54  51  53  53  52  53  50  53  51  50                  52  53      54          53  51              53  53  52                                  kill col 29  Tbl  24 cols 0000000000000100011110010110011100011111111 has  50 unique lines.
 *  48  49  49  47  50  49  50  50  48  49  49  48  49      47  46  45                  48  49      49          49  47              49  49  48                                  kill col 26  Tbl  23 cols 0000000000000100111110010110011100011111111 has  45 unique lines.
 *  43  44  44  42  45  44  45  45  43  44  44  43  44      43  41                      43  44      44          44  43              44  44  43                                  kill col 27  Tbl  22 cols 0000000000000101111110010110011100011111111 has  41 unique lines.
 *  39  40  40  38  41  40  41  41  39  40  40  39  40      40                          39  40      40          40  39              40  40  39                                  kill col 39  Tbl  21 cols 0001000000000101111110010110011100011111111 has  38 unique lines.
 *  36  37  35      38  37  38  38  36  37  37  36  36      34                          36  36      37          37  36              37  37  36                                  kill col 28  Tbl  20 cols 0001000000000111111110010110011100011111111 has  34 unique lines.
 *  32  33  30      33  33  33  34  32  33  33  31  32                                  32  31      33          33  33              33  33  32                                  kill col 40  Tbl  19 cols 0011000000000111111110010110011100011111111 has  30 unique lines.
 *  28  28          29  29  28  30  28  27  29  28  28                                  28  27      29          29  29              29  29  28                                  kill col 33  Tbl  18 cols 0011000001000111111110010110011100011111111 has  27 unique lines.
 *  26  25          26  26  25  27  25      26  25  25                                  25  24      26          26  26              26  26  25                                  kill col 20  Tbl  17 cols 0011000001000111111110110110011100011111111 has  24 unique lines.
 *  23  22          23  23  22  24  22      23  23  22                                  23          23          23  23              23  23  22                                  kill col 41  Tbl  16 cols 0111000001000111111110110110011100011111111 has  22 unique lines.
 *  21              21  21  20  22  20      21  21  20                                  21          21          21  21              21  21  20                                  kill col 36  Tbl  15 cols 0111001001000111111110110110011100011111111 has  20 unique lines.
 *  19              19  18      20  18      19  19  18                                  19          19          19  19              19  19  18                                  kill col 37  Tbl  14 cols 0111011001000111111110110110011100011111111 has  18 unique lines.
 *  17              17          18  16      17  17  16                                  17          17          17  17              17  17  16                                  kill col 34  Tbl  13 cols 0111011011000111111110110110011100011111111 has  16 unique lines.
Possible good candidates for removal, columns : 8 14 30 
 *
 * Round 1: 1000100100111000000001001001100011100000000  4 columns for indexes to table representing 13 original columns (uses 16 of 16 lines in indirect table).
 * Total columns to represent in EBRs: 34
 * 163 distinct lines in remaining untreated columns
 * c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 *   x 163 163 163   x 163 163   x 163 163   x   x   x 163 163 163 163 162 163 162 162   x 163 160   x 163 163   x   x 161 160 161   x   x   x 162 163 162 163 163 162 162 162  kill col 19  Tbl  29 cols 1000100100111000000001011001100011100000000 has 160 unique lines.
 *   x 160 160 160   x 160 160   x 160 160   x   x   x 160 160 160 160 159 160 159 159   x 160       x 160 160   x   x 158 157 158   x   x   x 159 160 159 160 160 159 159 159  kill col 12  Tbl  28 cols 1000100100111000000001011001101011100000000 has 157 unique lines.
 *   x 157 157 157   x 157 157   x 157 157   x   x   x 157 157 157 157 155 157 156 154   x 157       x 157 157   x   x 155     154   x   x   x 156 157 156 157 157 156 156 156  kill col 22  Tbl  27 cols 1000100100111000000011011001101011100000000 has 154 unique lines.
 *   x 154 154 154   x 154 154   x 154 154   x   x   x 154 154 154 154 153 154 153       x 154       x 154 154   x   x 151     151   x   x   x 153 153 152 154 154 153 153 152  kill col 13  Tbl  26 cols 1000100100111000000011011001111011100000000 has 151 unique lines.
 *   x 151 151 151   x 151 151   x 151 151   x   x   x 151 151 151 151 150 151 150       x 151       x 151 151   x   x         144   x   x   x 150 150 149 151 151 150 150 149  kill col 11  Tbl  25 cols 1000100100111000000011011001111111100000000 has 144 unique lines.
 *   x 144 144 144   x 144 144   x 144 144   x   x   x 144 144 144 144 143 144 143       x 144       x 144 144   x   x               x   x   x 143 143 142 143 144 143 143 142  kill col  5  Tbl  24 cols 1000100100111000000011011001111111100100000 has 142 unique lines.
 *   x 142 142 142   x 142 142   x 141 141   x   x   x 142 142 142 142 141 142 141       x 142       x 142 140   x   x               x   x   x 138 141     141 141 138 139 138  kill col  7  Tbl  23 cols 1000100100111000000011011001111111110100000 has 138 unique lines.
 *   x 138 138 138   x 138 138   x 137 137   x   x   x 138 137 138 138 137 135 137       x 138       x 137 135   x   x               x   x   x     137     137 135 131 133 134  kill col  2  Tbl  22 cols 1000100100111000000011011001111111110100100 has 131 unique lines.
 *   x 131 131 131   x 131 131   x 130 129   x   x   x 131 130 130 131 128 128 128       x 130       x 128 128   x   x               x   x   x     129     130 127     127 126  kill col  0  Tbl  21 cols 1000100100111000000011011001111111110100101 has 126 unique lines.
 *   x 126 126 126   x 126 126   x 125 123   x   x   x 126 125 125 126 121 123 122       x 125       x 123 120   x   x               x   x   x     123     120 121     122      kill col 16  Tbl  20 cols 1000100100111000000011011011111111110100101 has 120 unique lines.
 *   x 120 120 120   x 120 120   x 119 117   x   x   x 119 119 119 119 114 117 116       x 119       x 114       x   x               x   x   x     115     112 111     109      kill col  1  Tbl  19 cols 1000100100111000000011011011111111110100111 has 109 unique lines.
 *   x 109 109 109   x 109 109   x 106 106   x   x   x 108 108 107 108 102 105 103       x 108       x 103       x   x               x   x   x     100      98  96              kill col  3  Tbl  18 cols 1000100100111000000011011011111111110101111 has  96 unique lines.
 *   x  96  95  96   x  96  96   x  90  93   x   x   x  95  95  94  93  89  89  90       x  95       x  88       x   x               x   x   x      78      79                  kill col  6  Tbl  17 cols 1000100100111000000011011011111111111101111 has  78 unique lines.
 *   x  78  77  78   x  78  77   x  75  76   x   x   x  77  77  75  75  66  69  70       x  77       x  69       x   x               x   x   x              58                  kill col  4  Tbl  16 cols 1000100100111000000011011011111111111111111 has  58 unique lines.
 *   x  58  57  58   x  58  57   x  55  56   x   x   x  56  55  54  55  49  52  52       x  55       x  51       x   x               x   x   x                                  kill col 25  Tbl  15 cols 1000100100111000010011011011111111111111111 has  49 unique lines.
 *   x  49  48  49   x  49  48   x  46  47   x   x   x  47  47  45  45      45  42       x  46       x  42       x   x               x   x   x                                  kill col 23  Tbl  14 cols 1000100100111000010111011011111111111111111 has  42 unique lines.
 *   x  41  41  42   x  42  41   x  39  40   x   x   x  40  40  37  36      38           x  39       x  36       x   x               x   x   x                                  kill col 26  Tbl  13 cols 1000100100111000110111011011111111111111111 has  36 unique lines.
 *   x  35  35  35   x  36  35   x  33  34   x   x   x  34  33  31          31           x  33       x  31       x   x               x   x   x                                  kill col 27  Tbl  12 cols 1000100100111001110111011011111111111111111 has  31 unique lines.
 *   x  30  30  30   x  31  30   x  28  28   x   x   x  29  28              26           x  28       x  26       x   x               x   x   x                                  kill col 24  Tbl  11 cols 1000100100111001111111011011111111111111111 has  26 unique lines.
 *   x  25  25  24   x  25  25   x  23  23   x   x   x  23  24                           x  22       x  22       x   x               x   x   x                                  kill col 20  Tbl  10 cols 1000100100111001111111111011111111111111111 has  22 unique lines.
 *   x  21  20  21   x  21  21   x  19  19   x   x   x  19  20                           x           x  18       x   x               x   x   x                                  kill col 17  Tbl   9 cols 1000100100111001111111111111111111111111111 has  18 unique lines.
 *   x  17  15  17   x  17  17   x  15  15   x   x   x  15  16                           x           x           x   x               x   x   x                                  kill col 40  Tbl   8 cols 1010100100111001111111111111111111111111111 has  15 unique lines.
Possible good candidates for removal, columns : 29 33 34 
 *
 * Round 2: 0101011011000110000000000000000000000000000  4 columns for indexes to table representing  8 original columns (uses 15 of 16 lines in indirect table).
 * Direct:  0010000000000001111110110110011100011111111 22 columns
 * Can even chose 2 more columns to be represented directly.
 * Success. Use 2 EBRs, 19 LUTs.
 */

module v11_m_2ebr
  (
   input         clk,
   input [7:0]   minx,
   input         progress_ucode,
/* verilator lint_off UNOPTFLAT */
   output [47:0] d
/* verilator lint_on UNOPTFLAT */
   );
   /*
    *                      indirect_index 1
    * inx         next     | indirect index 0
    * || ucode    ucode    | | direct representation
    * 00 LB_0     LB_1     0 0 100110101111000000000001| LB     Load byte. q = rdadr=RS1+0fs
    * 01 LB_1     LB_2     1 1 00010111111001x111010010|        Read until q=mem[rs1+ofs) & ~3u]
    * 02 IJ_0     IJ_1     2 2 100110111111000010111110| IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0
    * 03 _L0x03   StdIncPc 0 0 00000101x10xxxx011100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 04 ADDI_0   StdIncPc 3 0 000001011101000011100110| ADDI   Add immediate. rd =RS1+Iimm (or joined)
    * 05 _L0x05   ADDI_0   0 0 00000001x01xxxx000000100| AUIPC  q = imm20+2 or imm20+4  (copy x/2)
    * 06 LB_3     LB_4     0 0 00001101111010x000000111|        q = ~mem[rs1+ofs]
    * 07 LB_4     LB_5     0 0 00001011111011x000001001|        q = (uint8_t) mem[rs1+Iimm]
    * 08 _L0x08   SB_1     4 0 000111001111000001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 09 LB_5     LB_6     0 0 00001011111000x010001011|        q = D^0xffffffff^q = D^0x80
    * 0a _L0x0a   SB_1     4 0 000111001111000001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 0b JALR_2   JALR_3   0 3 000001011111001000110011|        Q=1. Prep legalize target
    * 0c ADD_0    ADDI_0   0 0 00011101111001x000000100| ADD    add     Addition Q = RS1
    * 0d _L0x0d   StdIncPc 3 0 000001011101100011100110| LUI    q = imm20
    * 0e SUB_0    SUB_1    0 0 00011101x10xxxx000010000| SUB    Subtraction
    * 0f _L0x0f   StdIncPc 3 0 000001011101100011100110| LUI    q = imm20
    * 10 SUB_1    LB_6     0 0 00011111111000x010001011|        Q = ~RS2
    * 11 AND_1    ANDI_1   0 0 00011101111000x000011010|        RS1^0xffffffff to Q
    * 12 straddle Fetchu   5 4 110110110011001001110110|  Fr10u IncPC, OpFetch
    * 13 condb_2  condb_3  0 0 00011111111000x000010100|        ~RS2 in Q
    * 14 condb_3  condb_4  0 3 000110011111001000010101|        Calculate RS1+~RS2+1
    * 15 condb_4  condb_5  0 5 00000001111001x000010110|        Branch on condition
    * 16 condb_5  StdIncPc 0 0 00000001x10xxxx011100110|        Branch not taken.
    * 17 condb_5t condb_6t 6 0 00000001101001x001111101|        Branch taken. yy=oldPC incase of access error
    * 18 BEQ      condb_2  6 0 000111011101100000010011| BEQ    Conditional Branch. Offset to Ryy
    * 19 JALR_0   JALR_1   4 0 0100000110x1000001000001| JALR   (tmp) Prep pc=RS1+imm (target)
    * 1a ANDI_1   StdIncPc 3 0 00000101110011x011100110|        rd = Iimm & RS1
    * 1b _L0x1b   JAL_1    0 0 00000001x01xxxx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 1c ECAL_BRK ECAL_RET 0 2 000101111011100010100110| ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI
    * 1d ORI_2    StdIncPc 3 0 000001011101110011100110|        rd = Iimm | RS1
    * 1e aFault_1 aFault_2 0 3 000101010111001011010100|        Q = 4
    * 1f IJ_2     IJ_3     4 0 010000011011100010110111|        Read word is to be masked with lsb = 0
    * 20 LH_0     LH_1     6 2 100110101111000001010010| LH     Load hword. Q = rdadr=RS1+Iimm.
    * 21 XORI_1   StdIncPc 3 0 00000101110000x011100110|        rd = Iimm ^ RS1
    * 22 _L0x22   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 23 _L0x23   StdIncPc 0 0 00000101x10xxxx011100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 24 SLLI_0   SLLI_1   0 6 0001111010x1100000110101| SLLI   Shift left immediate.
    * 25 _L0x25   ADDI_0   0 0 00000001x01xxxx000000100| AUIPC  q = imm20+2 or imm20+4  (copy x/2)
    * 26 OR_1     OR_2     4 0 00011101110000x000100111|        RS1^0xffffffff to jj
    * 27 OR_2     ORI_2    0 0 000000011111000000011101|        Q = rs2
    * 28 _L0x28   SH_1     4 2 000111001111000010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 29 XOR_1    XORI_1   0 0 00011101111000x000100001|        Q = RS1^0xFFFFFFFF
    * 2a _L0x2a   SH_1     4 2 000111001111000010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 2b SLTIX_1  SLTIX_2  0 3 000xxxx11101001000110000|        RS1 - imm / RS1 - RS2
    * 2c SLL_0    SLL_1    0 0 00011101x0xxxxx000111110| SLL    Shift left
    * 2d _L0x2d   StdIncPc 3 0 000001011101100011100110| LUI    q = imm20
    * 2e unx2e             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 2e: Not in use 
    * 2f _L0x2f   StdIncPc 3 0 000001011101100011100110| LUI    q = imm20
    * 30 SLTIX_2  StdIncPc 3 7 000001011101101011100110|        Registered ALU flag to rd
    * 31 SLTX_1   SLTIX_1  0 0 00011111111000x000101011|        ~rs2 to Q
    * 32 JAL_1    JAL_2    6 0 00000001101001x010000110|      Prep Instradr to yy. Refetch instradr
    * 33 JALR_3   JAL_25   4 0 01000001110011x010011110|        Q = (RS1+imn) & 0xfffffffe
    * 34 JAL_3    Fetch    5 0 11011011101001x011011110|      Prep fetch next instr.
    * 35 SLLI_1   SLLI_2   3 6 00010111111001x000110110|        Register to shift to Q (and TRG for shift 0)
    * 36 SLLI_2   _L0x03   8 6 000101111111010000000011|        Repeat Q = Q+Q until shregcnt == 0
    * 37 ECALL_2  ECALL_3  6 5 001xxxx1110001x011010111|        mepc = pc, prep store 0 to mtval
    * 38 BNE      condb_2  6 0 000111011101100000010011| BNE    Conditional Branch. Offset to Ryy
    * 39 _L0x39   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 3a SRxI_1   SRxI_2   3 8 00010101111001x100111101|        Register to shift to Q
    * 3b _L0x3b   JAL_1    0 0 00000001x01xxxx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 3c CSRRW_0  CSRRW_1  6 0 000011011101100001001001| CSRRW  Decoded CSR adr in yy
    * 3d SRxI_2   _L0x03   8 8 00010101111001x100000011|        Repeat Q >>= 1 until shregcnt == 0
    * 3e SLL_1    SLLI_1   0 6 0001111010x001x000110101|        Shiftamount was in low 5 bits of RS2
    * 3f SRx_1    SRxI_1   0 6 0001111010x001x000111010|        Shiftamount in low 5 bits of RS2
    * 40 LW_0     LW_1     0 9 100110111111000001010000| LW     Load word. Q=yy=rdadr=RS1+Iimm
    * 41 JALR_1   JALR_2   6 0 00010101110001x000001011|        yy=jj. Prep get Q=1
    * 42 _L0x42   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 43 _L0x43   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 44 SLTI_0   SLTIX_1  0 0 00011111111010x000101011| SLTI   Set less than immediate (signed)
    * 45 WFI_3    WFI_4    0 3 000101011111001001100101|        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105
    * 46 ILL_1    ILL_2    6 0 0011010110x001x001000111|        Store PC to mepc
    * 47 ILL_2    ILL_3    6 0 01110101110001x010001111|        Store 0 to mtval
    * 48 _L0x48   SW_1     9 9 100111011111000001100110| SW     Store word. Q=wradr=RS1+Simm
    * 49 CSRRW_1  CSRRW_2  0 3 000000011111001001001011|        Construct PC storage adr
    * 4a _L0x4a   SW_1     9 9 100111011111000001100110| SW     Store word. Q=wradr=RS1+Simm
    * 4b CSRRW_2  CSRRW_3  a 0 01110101101001x010110001|        Write PC to 0x100 start Prep emulation entrypt
    * 4c SLT_0    SLTX_1   0 0 00011101x10xxxx000110001| SLT    Set less than (signed)
    * 4d unx4d             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 4d: Not in use 
    * 4e eILL0b   ILLe     0 0 000xxxx1x0xxxxx011111110| Illegal instruction seen
    * 4f MRET_8   MRET_9   0 3 000101010111001001110100|        +4, so now 0x103
    * 50 LW_1     StdIncPc b a 00010111110001x011100110|        Read until d=mem[(rs1+ofs) & ~3u]
    * 51 LDAF_LW  LDAF_a   6 0 011101011011100011011010|  err   LD AlignFault. Faulting adr to mtval
    * 52 LH_1     LH_2     1 1 00010111111001x101010100|        Read until q=mem[(rs1+ofs) & ~3u]
    * 53 LDAF_LH  LDAF_a   6 0 011101011011100011011010|  err   LD AlignFault. Faulting adr to mtval
    * 54 LH_2     LH_3     c 8 00010101111001x111101011|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 55 aFaultb  aFault_1 6 0 011101011101100000011110|  err   LH Load access fault. Faulting adr to mtval
    * 56 LH_4     LH_5     0 0 00010001111011x001010111|        q = (uint16_t) mem[rs1+Iimm]
    * 57 LH_5     LB_6     0 0 00010001111000x010001011|        q = D^0xffffffff^q = D ^ 0x00008000
    * 58 _L0x58   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 59 _L0x59   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 5a SB_1     SB_2     6 6 00010111111001x001011101|        Write d to Q and yy (for sh 0). Prep shift
    * 5b _L0x5b   JAL_1    0 0 00000001x01xxxx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 5c CSRRS_0  CSRRW_1  6 0 000011011101100001001001| CSRRS  Decoded CSR adr in yy
    * 5d SB_2     SB_3     d 6 000101111111010011111011|        Repeat shl until shreg = 0 (0,8,16 or 24 times)
    * 5e LHU_1    LHU_2    1 1 00010111111001x101110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 5f LDAF_LHU LDAF_a   6 0 011101011011100011011010|  err   LD AlignFault. Faulting adr to mtval
    * 60 _L0x60   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 61 EBRKWFI2 EBREAK_1 6 5 00001101110010x011110111| EBREAK/WFI2 Select EBREAK or WFI.
    * 62 _L0x62   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 63 _L0x63   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 64 SLTIU_0  SLTIX_1  0 0 00011111111010x000101011| SLTIU  Set less than immediate (unsigned)
    * 65 WFI_4    WFI_5    0 5 00000001x10xxxx011101111|        Prepare read PC.
    * 66 SW_1     SW_2     7 0 01111101101001x011110010|        Write d to a+k until accepted
    * 67 SW_E1SWE SW_E2    6 0 0110010110x1100010010011|        Store faulting address alignment to mtval
    * 68 _L0x68   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 69 unx69             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 69: Not in use 
    * 6a _L0x6a   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 6b SB_4     SB_5     9 0 11011001111001x001111010|        Address back to Q. Prepare get item to write
    * 6c SLTU_0   SLTX_1   0 0 00011101x10xxxx000110001| SLTU   Set less than (unsigned)
    * 6d unx6d             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 6d: Not in use 
    * 6e unx6e             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 6e: Not in use 
    * 6f MRET_6   MRET_7   0 3 000xxxx11111001011001111|        ~302 + origImm + 1 for branch decision
    * 70 LHU_2    LHU_3    c 8 00010101111001x110111010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 71 aFaultc  aFault_1 6 0 011101011101100000011110|  err   LHU Load access fault. Faulting adr to mtval
    * 72 LBU_3    ANDI_1   0 0 00001101111010x000011010|        Invert q. Prepare read mask
    * 73 unalignd straddle 0 0 000001011101100000010010|  Fr10u Unaligned pc, prep read high hword
    * 74 MRET_9   Fetch    5 3 110110111011001011011110|        +1, IncPC, OpFetch next
    * 75 IJ_5     Fetch    5 0 11011011101011x011011110|        Mask and use as PC
    * 76 Fetchu   Fetch2u  0 b 000001111101100011010101|  Fr10u Read and latch instruction
    * 77 eFetchu  Fetch2u  1 c 000101111101100011010101|  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]
    * 78 _L0x78   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 79 _L0x79   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 7a SB_5     SW_2     7 0 01011001101001x011110010|        Write d to a+k until accepted
    * 7b _L0x7b   JAL_1    0 0 00000001x01xxxx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 7c CSRRC_0  CSRRW_1  6 0 000011011101100001001001| CSRRC  Decoded CSR adr in yy
    * 7d condb_6t Fetch    5 0 110110111011000011011110|        Branch taken.
    * 7e NMI_1    NMI_2    6 0 001xxxx1110001x010010000|        Store pc to mepc.
    * 7f unx7f             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 7f: Not in use 
    * 80 LBU_0    LBU_1    0 0 100110101111000010000101| LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.
    * 81 unx81             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 81: Not in use 
    * 82 _L0x82   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 83 _L0x83   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 84 XORI_0   XORI_1   0 0 00011111111010x000100001| XORI   Xor immediate. Q=~Iimm
    * 85 LBU_1    LBU_2    1 1 00010111111001x111110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 86 JAL_2    JAL_25   4 0 010000011101000010011110|      Prep pc = jj + ofs
    * 87 unx87             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 87: Not in use 
    * 88 _L0x88   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 89 unx89             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 89: Not in use 
    * 8a _L0x8a   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 8b LB_6     StdIncPc 3 3 000001011101001011100110|        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80
    * 8c XOR_0    XOR_1    0 0 00011111x10xxxx000101001| XOR    xor
    * 8d unx8d             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 8d: Not in use 
    * 8e _LCSRRS_1 ILLe     0 0 000xxxx1x0xxxxx011111110| Illegal instruction seen
    * 8f ILL_3    ILL_4    0 3 000101011111001010101001|        Q = 1
    * 90 NMI_2    JAL_3    e 0 011010011101100000110100|        mtval = 0.
    * 91 LDAF_2   LDAF_3   e 3 0100010100x1001010010010|        Store 4 to mcause
    * 92 LDAF_3   JAL_3    6 0 0011001110x001x000110100|        PC to mepc
    * 93 SW_E2    SW_E3    6 0 00110111110001x010010101|        Store address that faulted
    * 94 SW_E4    JAL_3    e 0 0101001110x1010000110100|        Store 6 to mcause
    * 95 SW_E3    SW_E4    0 3 000101110111001010010100|        Q = 3
    * 96 SH_1     SH_2     6 6 00010111111001x010111011|        Write d to Q and yy (for sh 0). Prep shift
    * 97 SW_E1SWH SW_E2    6 0 0110010110x1100010010011|        Store faulting address alignment to mtval
    * 98 BLT      condb_2  6 0 000111011101100000010011| BLT    Conditional Branch. Offset to Ryy
    * 99 _L0x99   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 9a ECALL_6  JAL_3    e 0 0101001100x1000000110100|        mcause = 11
    * 9b SH_4     SH_5     9 0 10111001111001x010011111|        Address back to Q. Prepare get item to write
    * 9c _L0x9c   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * 9d unx9d             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| 9d: Not in use 
    * 9e JAL_25   JAL_3    3 4 000001010101001000110100|      Prep WTRG = jj+2/4 (return adr)
    * 9f SH_5     SW_2     7 0 00111001101001x011110010|        Write d to a+k until accepted
    * a0 LHU_0    LHU_1    6 2 100110101111000001011110| LHU    Load unsigned hword. Q = rdadr=RS1+Iimm
    * a1 ECALL_4  ECALL_5  0 3 000101010111001010110110|        Q = 4
    * a2 _L0xa2   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * a3 _L0xa3   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * a4 SRxI_0   SRxI_1   0 6 0001111010x1100000111010| SRxI   Shift Right immediate (both logic/arith here)
    * a5 MRET_3   MRET_4   0 3 000011011111001010101111|        0x102 + 0xff + 1 = 0x202
    * a6 ECAL_RET ECALL_1  0 9 000101111011100011010000| ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET
    * a7 EBRKWFI1 EBRKWFI2 0 0 000xxxx11111000001100001| EBREAK/WFI1 Prepare select EBREAK or WFI
    * a8 _L0xa8   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * a9 ILL_4    JAL_3    e 3 0101001110x1001000110100|        Store 2 to mcause
    * aa _L0xaa   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * ab EBREAK_2 ECALL_6  6 0 00110101110001x010011010|        pc to mepc
    * ac _L0xac   SRx_1    0 0 00011101x0xxxxx000111111| SRx    Shift Right (both SRL and SRA)
    * ad unxad             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| ad: Not in use 
    * ae _L0xae   SRx_1    0 0 00011101x0xxxxx000111111| SRx    Shift Right (both SRL and SRA)
    * af MRET_4   MRET_5   0 3 000xxxx11111001011000101|        0x202 + 0xff + 1 = 0x302
    * b0 aF_SW_3  LDAF_3   e 0 0100010100x1000010010010|        Store 7 to mcause
    * b1 CSRRW_3  CSRRW_4  0 3 000101010111001010110010|        Prep emulation entrypt 0x108, here Q to 0x104
    * b2 CSRRW_4  Fetch    5 3 110110110011001011011110|        IncPC, OpFetch, but force +4
    * b3 unxb3             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| b3: Not in use 
    * b4 eFetch3  unalignd 4 d 001111111111001001110011|  Fr11  Write minstret. Update I. Q=immediate, use dinx
    * b5 SH_3     SH_4     0 0 000000011101100010011011|        Prepare get back address to use 
    * b6 ECALL_5  ECALL_6  0 3 000101010111001010011010|        Q = 8
    * b7 IJ_3     IJ_4     6 0 00010101110001x010111101|        Store present PC in case of access error
    * b8 BGE      condb_2  6 0 000111011101100000010011| BGE    Conditional Branch. Offset to Ryy
    * b9 _L0xb9   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * ba LHU_3    ANDI_1   0 0 00001111111010x000011010|        Invert q. Prepare read mask
    * bb SH_2     SH_3     d 6 000101111111010010110101|        Repeat shl until shreg = 0 (0,8 or 24 times)
    * bc CSRRWI_0 CSRRW_1  6 0 000011011101100001001001| CSRRWI Decoded CSR adr in yy
    * bd IJ_4     IJ_5     0 3 000001011111001001110101|        Construct Q = 1
    * be IJ_1     IJ_2     1 0 00010111111001x000011111|        Read until q=mem[(rs1+ofs)&~1u]
    * bf IJT_1    IJT_2    1 0 00010111111001x011000001|        Exit CSR, enter trap
    * c0 _L0xc0   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * c1 IJT_2    IJT_3    6 0 000101011101100011101001|        Read word is to be masked with ~1u
    * c2 _L0xc2   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * c3 _L0xc3   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * c4 ORI_0    ORI_1    4 0 00011111110010x011100001| ORI    Or immediate. jj=~Iimm
    * c5 MRET_5   MRET_6   0 0 00000001111010x001101111|        ~302
    * c6 IJT_4    ILL_2    6 0 00110101111011x001000111|        Mask and store to mepc and Q for read of instr
    * c7 QINT_1   QINT_2   6 0 001xxxx1110001x011001011|        Store pc to mepc.
    * c8 _L0xc8   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * c9 MRET_2   MRET_3   0 0 000011010111000010100101|        0xff+3 = 0x102
    * ca _L0xca   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * cb QINT_2   StdIncPc e 0 011010011101100011100110|        mtval = 0.
    * cc OR_0     OR_1     0 0 00011111x10xxxx000100110| OR     or
    * cd unxcd             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| cd: Not in use 
    * ce _LCSRRCI_1 ILLe     0 0 000xxxx1x0xxxxx011111110| Illegal instruction seen
    * cf MRET_7   MRET_8   0 5 00001101x10xxxx001001111|        Prepare emulation entry point 0x104
    * d0 ECALL_1  ECALL_2  0 3 000000011111001000110111| ECALL  Verify Imm==0x000
    * d1 MRET_1   MRET_2   4 0 000011011101100011001001| MRET   First save Imm, start build constant for check
    * d2 LB_2     LB_3     c 8 00010101111001x100000110|        Repeat shr until shreg == 0 (0,8,16,24 times)
    * d3 aFaultd  aFault_1 6 0 011101011101100000011110|  err   LB Load access fault. Faulting adr to mtval
    * d4 aFault_2 LDAF_3   e 3 0100010110x1001010010010|        Store 5 to mcause
    * d5 Fetch2u           4 e 011111111111000000000000|  Fr11  Update ttime. Update I. Q=immediate. Use dinx
    * d6 eILL0c   ILLe     0 0 000xxxx1x0xxxxx011111110| Illegal instruction seen
    * d7 ECALL_3  ECALL_4  6 0 011101011101100010100001|        mtval = 0, now start the chore of 11 to mcause
    * d8 BLTU     condb_2  6 0 000111011101100000010011| BLTU   Conditional Branch. Offset to Ryy
    * d9 _L0xd9   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * da LDAF_a   LDAF_2   0 0 00010101x10xxxx010010001|        Extra cycle after error detected write mtval
    * db jFault_1 LDAF_3   6 3 0101100110x1001010010010|        Store 1 to mcause
    * dc CSRRSI_0 CSRRW_1  6 0 000011011101100001001001| CSRRSI Decoded CSR adr in yy
    * dd aF_SW_1  aF_SW_2  6 0 011101011101100011100101|  err   SW Store access fault. Faulting adr to mtval
    * de Fetch    Fetch2   5 c 000101111101100011110100|  Fr11  Read and latch instruction
    * df eFetch   Fetch2   5 c 000101111101100011110100|  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]
    * e0 _L0xe0   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * e1 ORI_1    ORI_2    0 0 00000001111001x000011101|        Q = RS1
    * e2 _L0xe2   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * e3 _L0xe3   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * e4 ANDI_0   ANDI_1   0 0 00011111111010x000011010| ANDI   And immediate. Q=~Iimm
    * e5 aF_SW_2  aF_SW_3  0 3 000101010111001010110000|        Q = 4
    * e6 StdIncPc Fetch    5 4 110110110011001011011110|  Fr11  IncPC, OpFetch
    * e7 aFault   aFault_1 6 0 011101011101100000011110|  err   Load access fault. Faulting adr to mtval
    * e8 _L0xe8   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * e9 IJT_3    IJT_4    0 3 000110011111001011000110|        Construct Q = 1
    * ea _L0xea   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * eb LH_3     LH_4     0 0 00001111111010x001010110|        q = ~mem[rs1+ofs]
    * ec AND_0    AND_1    0 0 00011111x10xxxx000010001| AND    And 
    * ed unxed             7 6 xxxxxxxxxxxxxxxxxxxxxxxx| ed: Not in use
    * ee eILL0a   ILLe     0 0 000xxxx1x0xxxxx011111110| Illegal instruction seen
    * ef WFI_5    Fetch    5 3 110110110011001011011110|        IncPC, OpFetch
    * f0 LBU_2    LBU_3    c 8 00010101111001x101110010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * f1 aFaulte  aFault_1 6 0 011101011101100000011110|  err   LBU Load access fault. Faulting adr to mtval
    * f2 SW_2     StdIncPc 0 0 00000101x10xxxx011100110|        Prepare read PC
    * f3 aF_SW    aF_SW_1  0 0 000xxxx1x01xxxx011011101|  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf
    * f4 Fetch2   eFetch3  4 f 011000111101000010110100|  Fr11  Update ttime. Update I. Q=immediate. Use dinx
    * f5 jFault   jFault_1 6 0 011101011101100011011011|  err   Fetch access fault. Faulting adr to mtval
    * f6 WFI_1    WFI_2    0 3 000110010111001011111010| WFI    Chk offset=0x105. Now 0xff. Prep 0xff+4 = 0x103
    * f7 EBREAK_1 EBREAK_2 6 0 011000011101100010101011| EBREAK mepc = pc, store 0 to mtval
    * f8 BGEU     condb_2  6 0 000111011101100000010011| BGEU   Conditional Branch. Offset to Ryy
    * f9 _L0xf9   ILLe     0 0 000xxxx1x0xxxxx011111110|  Not in use (illegal as entry)
    * fa WFI_2    WFI_3    0 3 000101011111001001000101|        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104
    * fb SB_3     SB_4     0 0 000000011101100001101011|        Prepare get back address to use 
    * fc CSRRCI_0 CSRRW_1  6 0 000011011101100001001001| CSRRCI Decoded CSR adr in yy
    * fd NMI_0    NMI_1    0 0 00000101x10xxxx001111110| NMI    Get current PC
    * fe ILLe     ILL_1    0 0 00000101x0xxxxx001000110| Illegal
    * ff QINT_0   QINT_1   0 0 00000101x10xxxx011000111| INT    Get current PC
    */
   localparam u0_0 = 256'hd8e64010d8e6e404f233f05ae08bf05aec09e8072004d0e640e6f0bee5d2f001;
   localparam u0_1 = 256'hb8b772d4dce6b8a62032cce69041d813a47d40e6e416f215e0143276e01ae08b;
   localparam u0_2 = 256'hd8e60000d8e6003ed230f096e021f096f01dc0272004983540e600fec0e6f052;
   localparam u0_3 = 256'h843a8435e503d8492032e53d00fed813c4d7f403e436a4decc9ea486e02bdae6;
   localparam u0_4 = 256'h727400fe00004031a4b1f066f24bf066c48f8447f265e82b00fe00fec40bf050;
   localparam u0_5 = 256'hb8dae570f4fbd8492032e45d00fe00fee08bec57d81ee5ebb8dae554b8dac4e6;
   localparam u0_6 = 256'hf2cf000000004031e47a00fe000000fe9893a4f240efe82b00fe00fec8f700fe;
   localparam u0_7 = 256'h0000c490b0ded8492032a4f200fe00fed8d5d8d5acdeb2ded812e81ad81ee5ba;
   localparam u0_8 = 256'hf2a900fe00004029d2e600fe000000fe0000d09ee5f0e82100fe00fe0000f085;
   localparam u0_9 = 256'ha4f25234000000fee49f103400fed8139893e4bb72949434c49584341292d834;
   localparam u0_A = 256'hf2c5003f0000003fc49a00fe923400fef061b8d0f2af983a00fe00fe72b6f05e;
   localparam u0_B = 256'he4c1e41ff275d849f4b5e81a00fed813c4bd729ad89bf273000032de72b21092;
   localparam u0_C = 256'h404f00fe00004026d8e600fe70a500fec4cbec47e86fc8e100fe00fed8e900fe;
   localparam u0_D = 256'hd8f4d8f4d8e5d8499292409100fed813d8a100fef0009292d81ee506d8c9f237;
   localparam u0_E = 256'h32de00fe00004011e85600fef2c600fed81e32de72b0e81a00fe00fee41d00fe;
   localparam u0_F = 256'h40c70046407ed849d86bf24500fed813d8ab72fad8dbd0b420dd40e6d81ee572;
   localparam u1_0 = 256'h3005001d3005001d0305401c000b401c000b000d000130050005229b1117009a;
   localparam u1_1 = 256'h4041031530050217000130054041601d6001000105010319001f54db001d001f;
   localparam u1_2 = 256'h300576003005001d0301421c001d421c0001401d0001061e000500013005629a;
   localparam u1_3 = 256'h061e061e8815600d000138150001601d65218617361750db40416001001f3705;
   localparam u1_4 = 256'h031500017600001da075999d0301999d607560350315001f000100016015099b;
   localparam u1_5 = 256'h60751117d617600d0001661700010001001100116075c815607511176075ba17;
   localparam u1_6 = 256'h030176007600001d90d90001760000016065707d0501001f00010001650d0001;
   localparam u1_7 = 256'h7600602150db600d00017059000100011c170b0750db53db0005000d6075c815;
   localparam u1_8 = 256'h031500017600001f3305000176000001760040411117001f000100017600009a;
   localparam u1_9 = 256'h703934057600000190b9e0530001601d606566170317e05360376033e345e069;
   localparam u1_A = 256'h0301001d7600001d60350001e353000100010917030d061e000100010315629a;
   localparam u1_B = 256'h101710170305600dd617000f0001601d6015031500014d3f760053db0315e045;
   localparam u1_C = 256'h050d00017600001fe0690001000d0001602160350001401f0001000160150001;
   localparam u1_D = 256'h5c175c176075600d635900150001601d607500014e7fe3456075c815400d0301;
   localparam u1_E = 256'h53db00017600001f000f000103190001607554db0315001f0001000100010001;
   localparam u1_F = 256'h000500050005600d000103150001601d6061031960754f63000100056075c815;
   wire [31:0]   indir;
`ifdef verilator
   /* verilator lint_off UNUSED */
   wire [15:0]   sim_a;
   wire [15:0]   sim_b;
   /* verilator lint_on UNUSED */
`endif
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u0_0), .INIT_1(u0_1), .INIT_2(u0_2), .INIT_3(u0_3),
                   .INIT_4(u0_4), .INIT_5(u0_5), .INIT_6(u0_6), .INIT_7(u0_7),
                   .INIT_8(u0_8), .INIT_9(u0_9), .INIT_A(u0_A), .INIT_B(u0_B),
                   .INIT_C(u0_C), .INIT_D(u0_D), .INIT_E(u0_E), .INIT_F(u0_F)
                   ) ucode0
     (
      .RDATA( indir[15:0]         ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u1_0), .INIT_1(u1_1), .INIT_2(u1_2), .INIT_3(u1_3),
                   .INIT_4(u1_4), .INIT_5(u1_5), .INIT_6(u1_6), .INIT_7(u1_7),
                   .INIT_8(u1_8), .INIT_9(u1_9), .INIT_A(u1_A), .INIT_B(u1_B),
                   .INIT_C(u1_C), .INIT_D(u1_D), .INIT_E(u1_E), .INIT_F(u1_F)
                   ) ucode1
     (
      .RDATA( indir[31:16]        ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );

   assign d[0] = indir[0];
   assign d[1] = indir[1];
   assign d[2] = indir[2];
   assign d[3] = indir[3];
   assign d[4] = indir[4];
   assign d[5] = indir[5];
   assign d[6] = indir[6];
   assign d[7] = indir[7];
   assign d[8] = indir[8];
   assign d[9] = indir[9];
   assign d[11] = indir[10];
   assign d[12] = indir[11];
   assign d[13] = indir[12];
   assign d[16] = indir[13];
   assign d[17] = indir[14];
   assign d[19] = indir[15];
   assign d[20] = indir[16];
   assign d[22] = indir[17];
   assign d[23] = indir[18];
   assign d[24] = indir[19];
   assign d[25] = indir[20];
   assign d[26] = indir[21];
   assign d[27] = indir[22];
   assign d[40] = indir[23];
   // replaces = 1000100100111000000001001001100010000000000
   SB_LUT4 #(.LUT_INIT(16'h2018)) cmb_d10(.O(d[10]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0020)) cmb_d14(.O(d[14]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h1800)) cmb_d15(.O(d[15]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'hc000)) cmb_d18(.O(d[18]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'hfebf)) cmb_d21(.O(d[21]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h6000)) cmb_d30(.O(d[30]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0204)) cmb_d31(.O(d[31]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0200)) cmb_d32(.O(d[32]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h1002)) cmb_d35(.O(d[35]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h1400)) cmb_d38(.O(d[38]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0010)) cmb_d42(.O(d[42]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   // replaces = 0101011011000110000000000000000000000000000
   SB_LUT4 #(.LUT_INIT(16'h6948)) cmb_d28(.O(d[28]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h6070)) cmb_d29(.O(d[29]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0822)) cmb_d33(.O(d[33]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h3100)) cmb_d34(.O(d[34]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h4004)) cmb_d36(.O(d[36]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h4400)) cmb_d37(.O(d[37]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h1207)) cmb_d39(.O(d[39]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0200)) cmb_d41(.O(d[41]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   assign d[43] = 1'b0;
   assign d[44] = 1'b0;
   assign d[45] = 1'b0;
   assign d[46] = 1'b0;
   assign d[47] = 1'b0;
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019-2020. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * Automatically generated from ../code/ucode.h by midgetv_indirectEBR.c.
 * Do not edit.
 * Optiones for this variant:
 *   RVC included
 *   MULDIV included
 *   minstret not implemented
 */
/* Using LUTSIZE=4. Using 2 EBRs. Initial table has 46 columns
 * Removed:  0000000000000001000000000001000000000000000000 These are removed from consideration, replaced with hand-crafted Verilog code in the output stage
 * Reserved: 0000000000000000000000000000000000000000000000 Columns to be represented directly, not part of optimalization
 * Total columns to represent in EBRs: 46
 * 208 distinct lines in remaining untreated columns
 * c45 c44 c43 c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 * 207 208 207 208 208 208 208 208 208 208 208 208 208 208 208   x 208 208 208 208 207 208 206 207 208 208 208   x 208 208 208 208 207 205 206 208 207 208 207 208 207 208 208 207 206 207  kill col 12  Tbl  43 cols 0000000000000001000000000001000001000000000000 has 205 unique lines.
 * 204 205 204 204 205 205 205 205 205 205 205 205 205 205 205   x 205 205 205 205 203 205 203 202 205 205 205   x 205 205 205 205 203     203 205 204 205 204 205 204 205 205 204 203 204  kill col 22  Tbl  42 cols 0000000000000001000000010001000001000000000000 has 202 unique lines.
 * 201 202 201 201 202 202 202 202 202 202 202 202 202 202 202   x 202 202 202 202 201 201 200     202 202 202   x 202 202 202 202 200     200 202 201 202 201 201 200 202 202 201 200 200  kill col 23  Tbl  41 cols 0000000000000001000000110001000001000000000000 has 200 unique lines.
 * 199 200 199 199 200 200 200 200 200 200 200 200 200 200 200   x 200 200 199 199 198 199         200 200 200   x 200 200 200 200 198     198 200 199 200 199 199 198 200 200 198 198 198  kill col 25  Tbl  40 cols 0000000000000001000010110001000001000000000000 has 198 unique lines.
 * 197 198 197 197 198 198 198 198 198 198 198 198 198 198 198   x 198 198 197 197     197         198 198 198   x 198 198 198 198 196     196 198 197 198 196 197 196 197 198 196 196 196  kill col 13  Tbl  39 cols 0000000000000001000010110001000011000000000000 has 196 unique lines.
 * 195 196 195 195 196 196 196 196 196 196 196 196 196 196 196   x 196 196 195 195     195         196 196 196   x 196 196 196 196         193 196 195 195 194 195 194 194 196 194 194 194  kill col 11  Tbl  38 cols 0000000000000001000010110001000011100000000000 has 193 unique lines.
 * 192 193 192 189 193 193 193 193 193 193 193 193 193 193 193   x 193 193 192 192     192         193 193 193   x 193 193 193 193             193 192 192 191 192 191 190 193 191 191 191  kill col 42  Tbl  37 cols 0001000000000001000010110001000011100000000000 has 189 unique lines.
 * 188 189 188     189 189 189 189 189 189 189 189 189 189 189   x 189 189 188 188     188         189 189 188   x 189 189 189 189             189 188 188 187 188 187 186 189 187 187 187  kill col  4  Tbl  36 cols 0001000000000001000010110001000011100000010000 has 186 unique lines.
 * 185 186 185     186 186 186 186 186 186 186 186 186 186 186   x 186 186 184 185     185         186 186 185   x 186 185 186 186             186 185 185 184 185 184     185 184 184 184  kill col 27  Tbl  35 cols 0001000000000001001010110001000011100000010000 has 184 unique lines.
 * 183 184 183     184 184 184 184 184 184 184 184 184 184 184   x 184 184     183     183         184 184 183   x 184 183 184 184             184 183 183 182 183 182     183 182 182 182  kill col  7  Tbl  34 cols 0001000000000001001010110001000011100010010000 has 182 unique lines.
 * 181 182 181     182 182 182 182 182 182 182 182 182 182 182   x 182 181     181     180         182 182 181   x 181 180 182 182             180 181 181     181 175     179 177 179 178  kill col  5  Tbl  33 cols 0001000000000001001010110001000011100010110000 has 175 unique lines.
 * 174 175 174     175 175 175 175 175 175 175 175 174 175 175   x 175 174     172     170         175 175 174   x 173 173 175 175             174 174 174     170         165 166 170 167  kill col  3  Tbl  32 cols 0001000000000001001010110001000011100010111000 has 165 unique lines.
 * 164 165 164     165 165 165 165 165 165 165 165 164 165 165   x 165 164     161     158         165 165 163   x 162 163 165 164             164 164 164     157             153 154 154  kill col  2  Tbl  31 cols 0001000000000001001010110001000011100010111100 has 153 unique lines.
 * 152 153 151     153 153 153 153 153 153 153 153 151 153 153   x 152 149     148     144         153 153 149   x 148 148 153 149             152 152 151     140                 134 142  kill col  1  Tbl  30 cols 0001000000000001001010110001000011100010111110 has 134 unique lines.
 * 133 134 131     133 134 134 134 134 134 134 130 132 134 134   x 132 130     130     122         132 134 129   x 128 129 134 129             133 133 131     115                     120  kill col  6  Tbl  29 cols 0001000000000001001010110001000011100011111110 has 115 unique lines.
 * 114 115 110     114 115 115 115 115 115 115 112 114 114 113   x 113 111     111     101         111 115 109   x 109 108 113 109             114 114 111                              99  kill col  0  Tbl  28 cols 0001000000000001001010110001000011100011111111 has  99 unique lines.
 *  98  98  92      98  99  99  99  99  99  99  95  98  98  97   x  96  96      95      88          93  99  94   x  93  92  97  93              98  98  94                                  kill col 24  Tbl  27 cols 0001000000000001001011110001000011100011111111 has  88 unique lines.
 *  87  86  82      87  88  87  88  87  88  88  84  87  87  86   x  84  85      83                  82  88  83   x  82  79  86  84              87  86  82                                  kill col 16  Tbl  26 cols 0001000000000001001011110001010011100011111111 has  79 unique lines.
 *  78  77  73      78  79  78  79  78  79  79  75  78  78  77   x  75  76      73                  72  78  72   x  74      77  75              78  77  73                                  kill col 21  Tbl  25 cols 0001000000000001001011111001010011100011111111 has  72 unique lines.
 *  71  70  66      71  72  71  72  71  72  72  68  71  71  70   x  69  69      66                      70  65   x  67      70  68              71  70  67                                  kill col 19  Tbl  24 cols 0001000000000001001011111011010011100011111111 has  65 unique lines.
 *  63  63  58      64  65  63  65  64  65  65  61  64  64  63   x  62  62      59                      62       x  60      63  62              64  63  61                                  kill col 43  Tbl  23 cols 0011000000000001001011111011010011100011111111 has  58 unique lines.
 *  56  55          57  58  56  58  57  58  58  54  57  57  56   x  55  55      52                      55       x  53      56  55              56  56  55                                  kill col 26  Tbl  22 cols 0011000000000001001111111011010011100011111111 has  52 unique lines.
 *  50  49          51  52  50  52  51  52  52  48  51  51  50   x  49  50                              49       x  47      50  50              50  50  49                                  kill col 17  Tbl  21 cols 0011000000000001001111111011110011100011111111 has  47 unique lines.
 *  45  45          46  45  45  47  46  47  47  43  46  46  45   x  42  44                              44       x          45  45              45  45  44                                  kill col 29  Tbl  20 cols 0011000000000001101111111011110011100011111111 has  42 unique lines.
 *  40  40          41  40  37  42  41  42  42  39  41  41  40   x      40                              40       x          40  40              40  40  39                                  kill col 39  Tbl  19 cols 0011001000000001101111111011110011100011111111 has  37 unique lines.
 *  35  35          36  34      37  36  37  37  34  36  36  35   x      32                              35       x          36  35              35  35  34                                  kill col 28  Tbl  18 cols 0011001000000001111111111011110011100011111111 has  32 unique lines.
 *  30  30          31  28      31  31  31  32  30  31  31  29   x                                      30       x          31  31              30  30  30                                  kill col 40  Tbl  17 cols 0011011000000001111111111011110011100011111111 has  28 unique lines.
 *  26  26          26          27  27  26  28  26  25  27  26   x                                      26       x          27  27              26  26  26                                  kill col 33  Tbl  16 cols 0011011000001001111111111011110011100011111111 has  25 unique lines.
 *  24  23          23          24  24  23  24  23      24  23   x                                      23       x          24  24              23  23  23                                  kill col 44  Tbl  15 cols 0111011000001001111111111011110011100011111111 has  23 unique lines.
 *  22              21          22  22  21  22  21      22  21   x                                      21       x          22  22              21  21  21                                  kill col 41  Tbl  14 cols 0111111000001001111111111011110011100011111111 has  21 unique lines.
 *  20                          20  20  19  20  19      20  19   x                                      19       x          20  20              19  19  19                                  kill col 36  Tbl  13 cols 0111111001001001111111111011110011100011111111 has  19 unique lines.
 *  18                          18  17      18  17      18  17   x                                      17       x          18  18              17  17  17                                  kill col 37  Tbl  12 cols 0111111011001001111111111011110011100011111111 has  17 unique lines.
 *  16                          16          16  15      16  15   x                                      15       x          16  16              15  15  15                                  kill col 34  Tbl  11 cols 0111111011011001111111111011110011100011111111 has  15 unique lines.
Possible good candidates for removal, columns : 8 9 10 20 31 
 *
 * Round 1: 1000000100100110000000000100001100011100000000  4 columns for indexes to table representing 11 original columns (uses 15 of 16 lines in indirect table).
 * Total columns to represent in EBRs: 39
 * 205 distinct lines in remaining untreated columns
 * c45 c44 c43 c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 *   x 205 202 205 205 205 205   x 205 205   x 205 205   x   x   x 205 205 205 205 204 205 203 204 205   x 203   x 205 205   x   x 204 202 203   x   x   x 204 205 204 205 205 204 203 204  kill col 43  Tbl  32 cols 1010000100100111000000000101001100011100000000 has 202 unique lines.
 *   x 202     202 202 202 202   x 202 202   x 202 202   x   x   x 202 202 202 202 201 202 200 201 202   x 199   x 202 202   x   x 201 199 200   x   x   x 201 202 201 202 202 201 200 201  kill col 19  Tbl  31 cols 1010000100100111000000000111001100011100000000 has 199 unique lines.
 *   x 199     199 199 199 199   x 199 199   x 199 199   x   x   x 199 199 199 199 198 199 197 198 199   x       x 199 199   x   x 198 196 197   x   x   x 198 199 198 199 199 198 197 198  kill col 12  Tbl  30 cols 1010000100100111000000000111001101011100000000 has 196 unique lines.
 *   x 196     195 196 196 196   x 196 196   x 196 196   x   x   x 196 196 196 196 194 196 194 193 196   x       x 196 196   x   x 194     194   x   x   x 195 196 195 196 196 195 194 195  kill col 22  Tbl  29 cols 1010000100100111000000010111001101011100000000 has 193 unique lines.
 *   x 193     192 193 193 193   x 193 193   x 193 193   x   x   x 193 193 193 193 192 192 191     193   x       x 193 193   x   x 190     191   x   x   x 192 192 191 193 193 192 191 191  kill col 13  Tbl  28 cols 1010000100100111000000010111001111011100000000 has 190 unique lines.
 *   x 190     189 190 190 190   x 190 190   x 190 190   x   x   x 190 190 190 190 189 189 188     190   x       x 190 190   x   x         187   x   x   x 189 189 188 189 190 189 188 188  kill col 11  Tbl  27 cols 1010000100100111000000010111001111111100000000 has 187 unique lines.
 *   x 187     182 187 187 187   x 187 187   x 187 187   x   x   x 187 187 187 187 186 186 185     187   x       x 187 185   x   x               x   x   x 186 185 185 185 187 186 184 185  kill col 42  Tbl  26 cols 1011000100100111000000010111001111111100000000 has 182 unique lines.
 *   x 182         182 182 182   x 182 182   x 182 182   x   x   x 182 182 182 182 181 181 180     182   x       x 182 180   x   x               x   x   x 181 180 178 180 182 180 179 179  kill col  5  Tbl  25 cols 1011000100100111000000010111001111111100100000 has 178 unique lines.
 *   x 178         178 178 178   x 178 178   x 178 177   x   x   x 178 178 178 178 177 176 174     178   x       x 178 174   x   x               x   x   x 170 176     175 177 173 172 173  kill col  7  Tbl  24 cols 1011000100100111000000010111001111111110100000 has 170 unique lines.
 *   x 170         170 170 170   x 170 170   x 170 169   x   x   x 170 169 170 170 169 165 167     170   x       x 169 165   x   x               x   x   x     168     166 166 162 162 165  kill col  2  Tbl  23 cols 1011000100100111000000010111001111111110100100 has 162 unique lines.
 *   x 162         162 162 162   x 162 162   x 162 160   x   x   x 162 161 161 162 159 157 157     160   x       x 158 157   x   x               x   x   x     157     158 156     155 156  kill col  1  Tbl  22 cols 1011000100100111000000010111001111111110100110 has 155 unique lines.
 *   x 153         155 155 155   x 155 155   x 154 152   x   x   x 154 154 154 155 152 149 148     152   x       x 151 145   x   x               x   x   x     143     145 142         145  kill col  3  Tbl  21 cols 1011000100100111000000010111001111111110101110 has 142 unique lines.
 *   x 139         142 141 142   x 142 142   x 140 139   x   x   x 141 141 141 141 136 133 134     137   x       x 136 131   x   x               x   x   x     122     126             123  kill col  6  Tbl  20 cols 1011000100100111000000010111001111111111101110 has 122 unique lines.
 *   x 118         122 121 122   x 122 121   x 120 118   x   x   x 121 120 119 121 112 112 113     117   x       x 114 110   x   x               x   x   x              98              99  kill col  4  Tbl  19 cols 1011000100100111000000010111001111111111111110 has  98 unique lines.
 *   x  95          98  96  98   x  98  97   x  95  95   x   x   x  96  95  95  95  88  88  90      92   x       x  89  85   x   x               x   x   x                              75  kill col  0  Tbl  18 cols 1011000100100111000000010111001111111111111111 has  75 unique lines.
 *   x  72          75  74  75   x  75  74   x  72  73   x   x   x  73  73  73  73  67  67  68      70   x       x  67  65   x   x               x   x   x                                  kill col 16  Tbl  17 cols 1011000100100111000000010111011111111111111111 has  65 unique lines.
 *   x  61          65  64  65   x  65  64   x  62  64   x   x   x  63  63  62  63  57  56  59      59   x       x  55       x   x               x   x   x                                  kill col 17  Tbl  16 cols 1011000100100111000000010111111111111111111111 has  55 unique lines.
 *   x  51          55  54  55   x  55  54   x  52  54   x   x   x  52  53  53  53  47  46  48      50   x       x           x   x               x   x   x                                  kill col 24  Tbl  15 cols 1011000100100111000001010111111111111111111111 has  46 unique lines.
 *   x  43          46  45  46   x  45  45   x  43  44   x   x   x  42  43  44  44  40      40      43   x       x           x   x               x   x   x                                  kill col 25  Tbl  14 cols 1011000100100111000011010111111111111111111111 has  40 unique lines.
 *   x  37          40  38  40   x  39  39   x  37  37   x   x   x  35  37  37  36          34      36   x       x           x   x               x   x   x                                  kill col 23  Tbl  13 cols 1011000100100111000011110111111111111111111111 has  34 unique lines.
 *   x  32          33  32  33   x  33  33   x  31  31   x   x   x  29  30  29  28                  30   x       x           x   x               x   x   x                                  kill col 26  Tbl  12 cols 1011000100100111000111110111111111111111111111 has  28 unique lines.
 *   x  26          27  26  26   x  27  27   x  25  25   x   x   x  23  24  24                      23   x       x           x   x               x   x   x                                  kill col 29  Tbl  11 cols 1011000100100111100111110111111111111111111111 has  23 unique lines.
 *   x  21          22  21  20   x  22  22   x  21  20   x   x   x      19  20                      19   x       x           x   x               x   x   x                                  kill col 28  Tbl  10 cols 1011000100100111110111110111111111111111111111 has  19 unique lines.
 *   x  17          18  17  14   x  18  17   x  17  17   x   x   x          17                      16   x       x           x   x               x   x   x                                  kill col 39  Tbl   9 cols 1011001100100111110111110111111111111111111111 has  14 unique lines.
Possible good candidates for removal, columns : 21 
 *
 * Round 2: 0100110011011000001000001000000000000000000000  4 columns for indexes to table representing  9 original columns (uses 14 of 16 lines in indirect table).
 * Direct:  0011001000000000110111110010110011100011111111 24 columns
 * Success. Use 2 EBRs, 20 LUTs.
 */

module v12_m_2ebr
  (
   input         clk,
   input [7:0]   minx,
   input         progress_ucode,
/* verilator lint_off UNOPTFLAT */
   output [47:0] d
/* verilator lint_on UNOPTFLAT */
   );
   /*
    *                      indirect_index 1
    * inx         next     | indirect index 0
    * || ucode    ucode    | | direct representation
    * 00 LB_0     LB_1     0 0 011000110111110000000001| LB     Load byte. q = rdadr=RS1+0fs
    * 01 LB_1     LB_2     1 1 001000101111100111010010|        Read until q=mem[rs1+ofs) & ~3u]
    * 02 IJ_0     IJ_1     2 2 011000110111110010111110| IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0
    * 03 _L0x03   StdIncPc 3 3 0010000010x10xxx11100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 04 ADDI_0   StdIncPc 3 3 010010001011010011100110| ADDI   Add immediate. rd =RS1+Iimm (or joined)
    * 05 _L0x05   ADDI_0   3 3 0010000000x01xxx00000100| AUIPC  q = imm20+2 or imm20+4  (copy x/2)
    * 06 LB_3     LB_4     3 3 001000011011101000000111|        q = ~mem[rs1+ofs]
    * 07 LB_4     LB_5     3 3 001000010111101100001001|        q = (uint8_t) mem[rs1+Iimm]
    * 08 _L0x08   SB_1     3 0 010100111011110001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 09 LB_5     LB_6     3 3 001000010111100010001011|        q = D^0xffffffff^q = D^0x80
    * 0a _L0x0a   SB_1     3 0 010100111011110001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 0b JALR_2   JALR_3   3 4 011000001011110000110011|        Q=1. Prep legalize target
    * 0c ADD_0    ADDI_0   3 3 001000111011100100000100| ADD    add     Addition Q = RS1
    * 0d MUL_0    MUL_1    3 3 1010001110x10xxx11100010| MUL    Store rs1 tp rM. Next read rs2. Q clear
    * 0e SUB_0    SUB_1    3 3 0010001110x10xxx00010000| SUB    Subtraction
    * 0f _L0x0f   StdIncPc 3 3 000010001011011011100110| LUI    q = imm20
    * 10 SUB_1    LB_6     3 3 001000111111100010001011|        Q = ~RS2
    * 11 AND_1    ANDI_1   3 3 001000111011100000011010|        RS1^0xffffffff to Q
    * 12 straddle Fetchu   4 5 110100110100110001110110|  Fr10u IncPC, OpFetch
    * 13 condb_2  condb_3  3 3 001000111111100000010100|        ~RS2 in Q
    * 14 condb_3  condb_4  3 4 011000110011110000010101|        Calculate RS1+~RS2+1
    * 15 condb_4  condb_5  3 6 001000000011100100010110|        Branch on condition
    * 16 condb_5  StdIncPc 3 3 0010000000x10xxx11100110|        Branch not taken.
    * 17 condb_5t condb_6t 3 3 000110000010100101111101|        Branch taken. yy=oldPC incase of access error
    * 18 BEQ      condb_2  3 3 000110111011011000010011| BEQ    Conditional Branch. Offset to Ryy
    * 19 JALR_0   JALR_1   5 3 010100000010x10001000001| JALR   (tmp) Prep pc=RS1+imm (target)
    * 1a ANDI_1   StdIncPc 3 3 000010001011001111100110|        rd = Iimm & RS1
    * 1b _L0x1b   JAL_1    3 3 0010000000x01xxx00110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 1c ECAL_BRK ECAL_RET 3 2 001000101110111010100110| ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI
    * 1d ORI_2    StdIncPc 3 3 000010001011011111100110|        rd = Iimm | RS1
    * 1e aFault_1 aFault_2 3 4 111000101001110011010100|        Q = 4
    * 1f IJ_2     IJ_3     5 3 000100000010111010110111|        Read word is to be masked with lsb = 0
    * 20 LH_0     LH_1     0 7 010110110111110001010010| LH     Load hword. Q = rdadr=RS1+Iimm.
    * 21 XORI_1   StdIncPc 3 3 000010001011000011100110|        rd = Iimm ^ RS1
    * 22 MULHU_6  MULHU_7  3 8 001000101011110000111001|        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar
    * 23 _L0x23   StdIncPc 3 3 0010000010x10xxx11100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 24 SLLI_0   SLLI_1   6 0 001000111110x11000110101| SLLI   Shift left immediate.
    * 25 _L0x25   ADDI_0   3 3 0010000000x01xxx00000100| AUIPC  q = imm20+2 or imm20+4  (copy x/2)
    * 26 OR_1     OR_2     3 3 000100111011000000100111|        RS1^0xffffffff to jj
    * 27 OR_2     ORI_2    3 3 011000000011110000011101|        Q = rs2
    * 28 _L0x28   SH_1     3 7 010100111011110010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 29 XOR_1    XORI_1   3 3 001000111011100000100001|        Q = RS1^0xFFFFFFFF
    * 2a _L0x2a   SH_1     3 7 010100111011110010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 2b SLTIX_1  SLTIX_2  3 4 011000xxxx11010000110000|        RS1 - imm / RS1 - RS2
    * 2c SLL_0    SLL_1    3 3 0010001110x0xxxx00111110| SLL    Shift left
    * 2d MULH_0   MULH_1   6 3 001000101011100101101010| MULH   Store rs1 to Q. Prep read 0, shcnt--
    * 2e MULHU_1  MULHU_2  3 3 100100111111011001000010|        rM<=RS2,  Rjj<=Q=0. next read RS1. 
    * 2f _L0x2f   StdIncPc 3 3 000010001011011011100110| LUI    q = imm20
    * 30 SLTIX_2  StdIncPc 3 9 000010001011011011100110|        Registered ALU flag to rd
    * 31 SLTX_1   SLTIX_1  3 3 001000111111100000101011|        ~rs2 to Q
    * 32 JAL_1    JAL_2    3 3 000110000010100110000110|      Prep Instradr to yy. Refetch instradr
    * 33 JALR_3   JAL_25   5 3 000100000011001110011110|        Q = (RS1+imn) & 0xfffffffe
    * 34 JAL_3    Fetch    4 3 000100110110100111011110|      Prep fetch next instr.
    * 35 SLLI_1   SLLI_2   6 3 000010101111100100110110|        Register to shift to Q (and TRG for shift 0)
    * 36 SLLI_2   _L0x03   7 3 000010101111110100000011|        Repeat Q = Q+Q until shregcnt == 0
    * 37 ECALL_2  ECALL_3  3 6 000111xxxx11000111010111|        mepc = pc, prep store 0 to mtval
    * 38 BNE      condb_2  3 3 000110111011011000010011| BNE    Conditional Branch. Offset to Ryy
    * 39 MULHU_7  StdIncPc 3 3 100010001011000111100110|        Last shift.
    * 3a SRxI_1   SRxI_2   6 8 000010101011100100111101|        Register to shift to Q
    * 3b _L0x3b   JAL_1    3 3 0010000000x01xxx00110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 3c CSRRW_0  CSRRW_1  3 3 000110011011011001001001| CSRRW  Decoded CSR adr in yy
    * 3d SRxI_2   _L0x03   7 8 000010101011100100000011|        Repeat Q >>= 1 until shregcnt == 0
    * 3e SLL_1    SLLI_1   6 0 001000111110x00100110101|        Shiftamount was in low 5 bits of RS2
    * 3f SRx_1    SRxI_1   6 0 001000111110x00100111010|        Shiftamount in low 5 bits of RS2
    * 40 LW_0     LW_1     0 a 011000110111110001010000| LW     Load word. Q=yy=rdadr=RS1+Iimm
    * 41 JALR_1   JALR_2   3 3 000110101011000100001011|        yy=jj. Prep get Q=1
    * 42 MULHU_2  MULHU_3  6 8 001000101011110001100000|        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar
    * 43 MULHU_4  MULHU_5  3 3 001000000010100011101010|        Prepare read Rjj.
    * 44 SLTI_0   SLTIX_1  3 3 001000111111101000101011| SLTI   Set less than immediate (signed)
    * 45 WFI_3    WFI_4    3 4 011000101011110001100101|        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105
    * 46 ILL_1    ILL_2    3 3 000111101010x00101000111|        Store PC to mepc
    * 47 ILL_2    ILL_3    5 3 000111101011000110001111|        Store 0 to mtval
    * 48 _L0x48   SW_1     8 a 011000111011110001100110| SW     Store word. Q=wradr=RS1+Simm
    * 49 CSRRW_1  CSRRW_2  3 4 011000000011110001001011|        Construct PC storage adr
    * 4a _L0x4a   SW_1     8 a 011000111011110001100110| SW     Store word. Q=wradr=RS1+Simm
    * 4b CSRRW_2  CSRRW_3  9 3 000001101010100110110001|        Write PC to 0x100 start Prep emulation entrypt
    * 4c SLT_0    SLTX_1   3 3 0010001110x10xxx00110001| SLT    Set less than (signed)
    * 4d MULHSU_0 MULHU_1  6 3 000110111011000100101110| MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--
    * 4e eILL0b   ILLe     3 3 001000xxxxx0xxxx11111110| Illegal instruction seen
    * 4f MRET_8   MRET_9   3 4 111000101001110001110100|        +4, so now 0x103
    * 50 LW_1     StdIncPc 1 b 000010101111000111100110|        Read until d=mem[(rs1+ofs) & ~3u]
    * 51 LDAF_LW  LDAF_a   5 3 000111101010111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 52 LH_1     LH_2     1 1 001000101111100101010100|        Read until q=mem[(rs1+ofs) & ~3u]
    * 53 LDAF_LH  LDAF_a   5 3 000111101010111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 54 LH_2     LH_3     7 8 001000101011100111101011|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 55 aFaultb  aFault_1 5 3 000111101011011000011110|  err   LH Load access fault. Faulting adr to mtval
    * 56 LH_4     LH_5     3 3 001000100011101101010111|        q = (uint16_t) mem[rs1+Iimm]
    * 57 LH_5     LB_6     3 3 001000100011100010001011|        q = D^0xffffffff^q = D ^ 0x00008000
    * 58 DIV_A    DIV_C    3 8 111000101111100101101110|        Transfer rM to rDee
    * 59 DIV_B    DIV_10   3 3 000110111111011010011100|        REM = Q to yy
    * 5a SB_1     SB_2     6 3 000110101111100101011101|        Write d to Q and yy (for sh 0). Prep shift
    * 5b _L0x5b   JAL_1    3 3 0010000000x01xxx00110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 5c CSRRS_0  CSRRW_1  3 3 000110011011011001001001| CSRRS  Decoded CSR adr in yy
    * 5d SB_2     SB_3     7 3 000110101111110111111011|        Repeat shl until shreg = 0 (0,8,16 or 24 times)
    * 5e LHU_1    LHU_2    1 1 001000101111100101110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 5f LDAF_LHU LDAF_a   5 3 000111101010111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 60 MULHU_3  MULHU_2  3 3 101000111111100101000010|        Shift Q and rM. Prepare read rs1
    * 61 EBRKWFI2 EBREAK_1 3 6 000110011011001011110111| EBREAK/WFI2 Select EBREAK or WFI.
    * 62 DIV_8    DIV_7    6 4 011000101111110011001000|        Conditionally subtract rs2. Update M[0]
    * 63 DIV_9    DIV_A    a 4 011000101111110001011000|        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]
    * 64 SLTIU_0  SLTIX_1  3 3 001000111111101000101011| SLTIU  Set less than immediate (unsigned)
    * 65 WFI_4    WFI_5    3 6 0010000000x10xxx11101111|        Prepare read PC.
    * 66 SW_1     SW_2     5 3 000001111010100111110010|        Write d to a+k until accepted
    * 67 SW_E1SWE SW_E2    5 3 000111001010x11010010011|        Store faulting address alignment to mtval
    * 68 DIV_12   StdIncPc 3 3 000010001011000111100110|        RS2 > 0, RS1 >= 0, yy is true result
    * 69 DIV_13   LB_6     3 3 001000101011100010001011|        RS2 > 0, RS1 < 0, change sign yy
    * 6a MULH_1   MULH_2   3 3 000110101011000011111001|        Store ~rs1 to Ryy. Prep construct 1.
    * 6b SB_4     SB_5     b 3 001000110011100101111010|        Address back to Q. Prepare get item to write
    * 6c SLTU_0   SLTX_1   3 3 0010001110x10xxx00110001| SLTU   Set less than (unsigned)
    * 6d MULHU_0  MULHU_1  6 3 000110111011000100101110| MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--
    * 6e DIV_C    DIV_e    3 3 000110111010100110111001|        rM to yy. Q=ffffffff
    * 6f MRET_6   MRET_7   3 4 011000xxxx11110011001111|        ~302 + origImm + 1 for branch decision
    * 70 LHU_2    LHU_3    7 8 001000101011100110111010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 71 aFaultc  aFault_1 5 3 000111101011011000011110|  err   LHU Load access fault. Faulting adr to mtval
    * 72 LBU_3    ANDI_1   3 3 001000011011101000011010|        Invert q. Prepare read mask
    * 73 unx73             6 0 00xxxxxxxxxxxxxxxxxxxxxx| 73: Not in use 
    * 74 MRET_9   Fetch    4 4 010100110110110011011110|        +1, IncPC, OpFetch next
    * 75 IJ_5     Fetch    4 3 000100110110101111011110|        Mask and use as PC
    * 76 Fetchu   Fetch2   3 c 001000001111011011110100|  Fr00u Read and latch instruction
    * 77 eFetchu  Fetch2   1 d 001000101111011011110100|  Fr00u rep Read until d=mem[(rs1+ofs) & ~3u]
    * 78 DIV_4    DIV_6    3 3 000110000011011010101010|        ~abs(divisor) to yy
    * 79 DIV_5    DIV_3    3 4 111000101011110010101000|        Kluge to let add1 work in DIV instr
    * 7a SB_5     SW_2     5 3 000000110010100111110010|        Write d to a+k until accepted
    * 7b _L0x7b   JAL_1    3 3 0010000000x01xxx00110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 7c CSRRC_0  CSRRW_1  3 3 000110011011011001001001| CSRRC  Decoded CSR adr in yy
    * 7d condb_6t Fetch    4 3 010100110110110011011110|        Branch taken.
    * 7e NMI_1    NMI_2    3 3 000111xxxx11000110010000|        Store pc to mepc.
    * 7f unx7f             6 0 00xxxxxxxxxxxxxxxxxxxxxx| 7f: Not in use 
    * 80 LBU_0    LBU_1    0 0 011000110111110010000101| LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.
    * 81 unx81             6 0 00xxxxxxxxxxxxxxxxxxxxxx| 81: Not in use 
    * 82 DIV_1    DIV_3    3 3 000100111011000010101000|        jj=abs(RS1). Next handle divisor
    * 83 DIV_2    DIV_1    3 3 011000101011110010000010|        Dividend negative, make RS1-1
    * 84 XORI_0   XORI_1   3 3 001000111111101000100001| XORI   Xor immediate. Q=~Iimm
    * 85 LBU_1    LBU_2    1 1 001000101111100111110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 86 JAL_2    JAL_25   5 3 010100000011010010011110|      Prep pc = jj + ofs
    * 87 unx87             6 0 00xxxxxxxxxxxxxxxxxxxxxx| 87: Not in use 
    * 88 DIV_E    DIV_10   a 3 1010001111x0xxxx10011100|        RS2 != 0. Check signs
    * 89 DIV_F    StdIncPc 3 3 000010001011011011100110|        RS2 == 0, return 0xffffffff
    * 8a DIVU_5   ANDI_1   3 8 1110001011x10xxx00011010|        Transfer rM to rDee
    * 8b LB_6     StdIncPc 3 4 110010001011010011100110|        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80
    * 8c XOR_0    XOR_1    3 3 0010001111x10xxx00101001| XOR    xor
    * 8d DIV_0    DIV_1    c 3 101000101111100110000010| DIV    Branch on sign dividend RS1
    * 8e _LCSRRS_1 ILLe     3 3 001000xxxxx0xxxx11111110| Illegal instruction seen
    * 8f ILL_3    ILL_4    3 4 001000101011110010101001|        Q = 1
    * 90 NMI_2    JAL_3    d 3 000111010011011000110100|        mtval = 0.
    * 91 LDAF_2   LDAF_3   d 4 110110001000x10010010010|        Store 4 to mcause
    * 92 LDAF_3   JAL_3    3 3 000111100110x00100110100|        PC to mepc
    * 93 SW_E2    SW_E3    3 3 000111101111000110010101|        Store address that faulted
    * 94 SW_E4    JAL_3    d 3 000110100110x10100110100|        Store 6 to mcause
    * 95 SW_E3    SW_E4    3 4 111000101101110010010100|        Q = 3
    * 96 SH_1     SH_2     6 3 000110101111100110111011|        Write d to Q and yy (for sh 0). Prep shift
    * 97 SW_E1SWH SW_E2    5 3 000111001010x11010010011|        Store faulting address alignment to mtval
    * 98 BLT      condb_2  3 3 000110111011011000010011| BLT    Conditional Branch. Offset to Ryy
    * 99 _L0x99   ILLe     3 3 001000xxxxx0xxxx11111110|  Not in use (illegal as entry)
    * 9a ECALL_6  JAL_3    d 3 010110100100x10000110100|        mcause = 11
    * 9b SH_4     SH_5     8 3 001001110011100110011111|        Address back to Q. Prepare get item to write
    * 9c DIV_10   DIV_12   a 3 101000110011000101101000|        RS2 > 0. Branch on sign of RS1
    * 9d DIV_11   DIV_14   a 3 101000110011000110100010|        RS2 < 0. Branch on sign of RS1
    * 9e JAL_25   JAL_3    3 5 110010001001010000110100|      Prep WTRG = jj+2/4 (return adr)
    * 9f SH_5     SW_2     3 3 000001110010100111110010|        Write d to a+k until accepted
    * a0 LHU_0    LHU_1    0 7 010110110111110001011110| LHU    Load unsigned hword. Q = rdadr=RS1+Iimm
    * a1 ECALL_4  ECALL_5  3 4 111000101001110010110110|        Q = 4
    * a2 DIV_14   LB_6     3 3 001000101011100010001011|        RS2 < 0, RS1 >= 0, change sign yy
    * a3 DIV_15   StdIncPc 3 3 000010001011000111100110|        RS2 < 0, RS1 < 0, yy is true result
    * a4 SRxI_0   SRxI_1   6 0 001000111110x11000111010| SRxI   Shift Right immediate (both logic/arith here)
    * a5 MRET_3   MRET_4   3 4 011000011011110010101111|        0x102 + 0xff + 1 = 0x202
    * a6 ECAL_RET ECALL_1  3 a 001000101110111011010000| ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET
    * a7 EBRKWFI1 EBRKWFI2 3 3 011000xxxx11110001100001| EBREAK/WFI1 Prepare select EBREAK or WFI
    * a8 DIV_3    DIV_4    a 3 101000101011100001111000|        Branch on sign divisor RS2
    * a9 ILL_4    JAL_3    d 4 010110100110x10000110100|        Store 2 to mcause
    * aa DIV_6    DIV_7    3 3 1010001011x10xxx11001000|        Write M. Prepare shift
    * ab EBREAK_2 ECALL_6  3 3 000111101011000110011010|        pc to mepc
    * ac _L0xac   SRx_1    3 3 0010001110x0xxxx00111111| SRx    Shift Right (both SRL and SRA)
    * ad DIVU_0   DIVU_1   6 3 1010001110x10xxx11100000| DIVU   Store rs1 to rM. Q=0. Prepare invert rs2
    * ae _L0xae   SRx_1    3 3 0010001110x0xxxx00111111| SRx    Shift Right (both SRL and SRA)
    * af MRET_4   MRET_5   3 4 011000xxxx11110011000101|        0x202 + 0xff + 1 = 0x302
    * b0 aF_SW_3  LDAF_3   d 3 010110001000x10010010010|        Store 7 to mcause
    * b1 CSRRW_3  CSRRW_4  3 4 111000101001110010110010|        Prep emulation entrypt 0x108, here Q to 0x104
    * b2 CSRRW_4  Fetch    4 4 110100110100110011011110|        IncPC, OpFetch, but force +4
    * b3 unxb3             6 0 00xxxxxxxxxxxxxxxxxxxxxx| b3: Not in use 
    * b4 ic0reser          6 0 00xxxxxxxxxxxxxxxxxxxxxx|  Fr00  Not really used, reserved to allow LASTINCH
    * b5 SH_3     SH_4     3 3 001000000011011010011011|        Prepare get back address to use 
    * b6 ECALL_5  ECALL_6  3 4 111000101001110010011010|        Q = 8
    * b7 IJ_3     IJ_4     3 3 000110101011000110111101|        Store present PC in case of access error
    * b8 BGE      condb_2  3 3 000110111011011000010011| BGE    Conditional Branch. Offset to Ryy
    * b9 DIV_e    DIV_D    3 4 001000110011100011000000|        Calc carry of RS2+0xFFFFFFFF
    * ba LHU_3    ANDI_1   3 3 001000011111101000011010|        Invert q. Prepare read mask
    * bb SH_2     SH_3     7 3 000110101111110110110101|        Repeat shl until shreg = 0 (0,8 or 24 times)
    * bc CSRRWI_0 CSRRW_1  3 3 000110011011011001001001| CSRRWI Decoded CSR adr in yy
    * bd IJ_4     IJ_5     3 4 011000001011110001110101|        Construct Q = 1
    * be IJ_1     IJ_2     1 3 001000101111100100011111|        Read until q=mem[(rs1+ofs)&~1u]
    * bf IJT_1    IJT_2    1 3 001000101111100111000001|        Exit CSR, enter trap
    * c0 DIV_D    DIV_E    3 6 001000111011100110001000|        Is RS2 == 0?
    * c1 IJT_2    IJT_3    3 3 000110101011011011101001|        Read word is to be masked with ~1u
    * c2 DIVU_3   DIVU_2   6 4 011000101111110011001010|        Conditionally subtract rs2. Update M[0]
    * c3 DIVU_4   DIVU_5   a 4 011000101111110010001010|        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]
    * c4 ORI_0    ORI_1    3 3 000100111111001011100001| ORI    Or immediate. jj=~Iimm
    * c5 MRET_5   MRET_6   3 3 001000000011101001101111|        ~302
    * c6 IJT_4    ILL_2    3 3 000111101011101101000111|        Mask and store to mepc and Q for read of instr
    * c7 QINT_1   QINT_2   3 3 000111xxxx11000111001011|        Store pc to mepc.
    * c8 DIV_7    DIV_8    3 e 101000110011110101100010|        Shift (Q,M) left. Prepare unsigned sub
    * c9 MRET_2   MRET_3   3 3 011000011001110010100101|        0xff+3 = 0x102
    * ca DIVU_2   DIVU_3   3 e 101000110011110111000010|        Shift (Q,M) left. Prepare unsigned sub
    * cb QINT_2   StdIncPc d 3 000111010011011011100110|        mtval = 0.
    * cc OR_0     OR_1     3 3 0010001111x10xxx00100110| OR     or
    * cd REM_0    DIV_1    c 3 101000101111100110000010| REM    Branch on sign dividend RS1
    * ce _LCSRRCI_1 ILLe     3 3 001000xxxxx0xxxx11111110| Illegal instruction seen
    * cf MRET_7   MRET_8   3 6 0010000110x10xxx01001111|        Prepare emulation entry point 0x104
    * d0 ECALL_1  ECALL_2  3 4 011000000011110000110111| ECALL  Verify Imm==0x000
    * d1 MRET_1   MRET_2   3 3 000100011011011011001001| MRET   First save Imm, start build constant for check
    * d2 LB_2     LB_3     7 8 001000101011100100000110|        Repeat shr until shreg == 0 (0,8,16,24 times)
    * d3 aFaultd  aFault_1 5 3 000111101011011000011110|  err   LB Load access fault. Faulting adr to mtval
    * d4 aFault_2 LDAF_3   d 4 010110001010x10010010010|        Store 5 to mcause
    * d5 unalignd straddle 3 3 001000001011011000010010|  Fr00u Unaligned pc, prep read high hword
    * d6 eILL0c   ILLe     3 3 001000xxxxx0xxxx11111110| Illegal instruction seen
    * d7 ECALL_3  ECALL_4  5 3 000111101011011010100001|        mtval = 0, now start the chore of 11 to mcause
    * d8 BLTU     condb_2  3 3 000110111011011000010011| BLTU   Conditional Branch. Offset to Ryy
    * d9 MULH_3   MULHU_2  3 3 1010001111x10xxx01000010|        rM<=RS2, Q = 0. next read RS1. Join.
    * da LDAF_a   LDAF_2   3 3 0010001010x10xxx10010001|        Extra cycle after error detected write mtval
    * db jFault_1 LDAF_3   5 4 010110110010x10010010010|        Store 1 to mcause
    * dc CSRRSI_0 CSRRW_1  3 3 000110011011011001001001| CSRRSI Decoded CSR adr in yy
    * dd aF_SW_1  aF_SW_2  5 3 000111101011011011100101|  err   SW Store access fault. Faulting adr to mtval
    * de Fetch    Fetch2   3 c 000100001111011011110100|  Fr00  Read and latch instruction
    * df eFetch   Fetch2   1 d 000100101111011011110100|  Fr00  rep Read until d=mem[(rs1+ofs) & ~3u]
    * e0 DIVU_1   DIVU_2   3 3 000110101111000011001010|        Store inverted rs2 to yy. Prepare shift
    * e1 ORI_1    ORI_2    3 3 001000000011100100011101|        Q = RS1
    * e2 MUL_1    MUL_2    6 8 001000101011110011101000|        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar
    * e3 MUL_3    ANDI_1   3 8 1110001011x10xxx00011010|        Transfer rM to rDee
    * e4 ANDI_0   ANDI_1   3 3 001000111111101000011010| ANDI   And immediate. Q=~Iimm
    * e5 aF_SW_2  aF_SW_3  3 4 111000101001110010110000|        Q = 4
    * e6 StdIncPc Fetch    4 5 110100110100110011011110|  Fr00  IncPC, OpFetch
    * e7 aFault   aFault_1 5 3 000111101011011000011110|  err   Load access fault. Faulting adr to mtval
    * e8 MUL_2    MUL_1    3 3 101000111011100111100010|        Shift Q and rM. Prepare read rs2
    * e9 IJT_3    IJT_4    3 4 011000110011110011000110|        Construct Q = 1
    * ea MULHU_5  MULHU_6  3 3 001000110011110000100010|        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy
    * eb LH_3     LH_4     3 3 001000011111101001010110|        q = ~mem[rs1+ofs]
    * ec AND_0    AND_1    3 3 0010001111x10xxx00010001| AND    And 
    * ed REMU_0   DIVU_1   6 3 1010001110x10xxx11100000| REMU   Store dividend to rM. Prepare read divisor.Q=0
    * ee eILL0a   ILLe     3 3 001000xxxxx0xxxx11111110| Illegal instruction seen
    * ef WFI_5    Fetch    4 4 110100110100110011011110|        IncPC, OpFetch
    * f0 LBU_2    LBU_3    7 8 001000101011100101110010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * f1 aFaulte  aFault_1 5 3 000111101011011000011110|  err   LBU Load access fault. Faulting adr to mtval
    * f2 SW_2     StdIncPc 3 3 0010000010x10xxx11100110|        Prepare read PC
    * f3 aF_SW    aF_SW_1  3 3 001000xxxxx01xxx11011101|  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf
    * f4 Fetch2   unalignd 5 3 010101111111110011010101|  Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned 
    * f5 jFault   jFault_1 5 3 000111101011011011011011|  err   Fetch access fault. Faulting adr to mtval
    * f6 WFI_1    WFI_2    3 4 111000110001110011111010| WFI    Chk offset=0x105. Now 0xff. Prep 0xff+4 = 0x103
    * f7 EBREAK_1 EBREAK_2 5 3 000111000011011010101011| EBREAK mepc = pc, store 0 to mtval
    * f8 BGEU     condb_2  3 3 000110111011011000010011| BGEU   Conditional Branch. Offset to Ryy
    * f9 MULH_2   MULH_3   3 4 010100111011010011011001|        Store 1 to Rjj. next read rs2, Q=0
    * fa WFI_2    WFI_3    3 4 011000101011110001000101|        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104
    * fb SB_3     SB_4     3 3 001000000011011001101011|        Prepare get back address to use 
    * fc CSRRCI_0 CSRRW_1  3 3 000110011011011001001001| CSRRCI Decoded CSR adr in yy
    * fd NMI_0    NMI_1    3 3 0010000010x10xxx01111110| NMI    Get current PC
    * fe ILLe     ILL_1    3 3 0010000010x0xxxx01000110| Illegal
    * ff QINT_0   QINT_1   3 3 0010000010x10xxx11000111| INT    Get current PC
    */
   localparam u0_0 = 256'hb6e6901090e2b904bc33bc5a788bbc5a7b09ba070804b4e690e67cbef9d27c01;
   localparam u0_1 = 256'h2eb79cd4b7e6eea60832b3e62441b613297d10e639163c15f8144c76b81af88b;
   localparam u0_2 = 256'hb6e6f642b96a803e3430bc96b821bc963c1db0270804e63590e6bc39b0e67c52;
   localparam u0_3 = 256'he13ae135b903b6490832b93db1e6b61331d7fd03f93669de339e2986f82bb6e6;
   localparam u0_4 = 256'h9c7400feb12e9031a9b1bc663c4bbc66b18fa147bc65fa2b28eabc60b10b7c50;
   localparam u0_5 = 256'haedaf970fdfbb6490832f95df69cf96e388b3b57b61eb9ebaedaf954aedaf1e6;
   localparam u0_6 = 256'h3ccfa9b9b12e9031397ab0f9b88bb1e6a693a9f210effa2bfc58fcc8b2f7f942;
   localparam u0_7 = 256'h000031906cdeb649083229f2bca836aaf6f4f6f46bde6cde0000ba1ab61eb9ba;
   localparam u0_8 = 256'hbca900fef982d029b4e6d01ab6e6c09c0000349ef9f0fa21bc82b0a800007c85;
   localparam u0_9 = 256'h29f2943431a23168399f443400feb613a693f9bbdc946534f195613484923634;
   localparam u0_A = 256'h3cc5803f90e0803fb19ad0c86434b8783c61eed0bcafe63ab1e6b88b9cb67c5e;
   localparam u0_B = 256'hf9c1f91fbc75b649fdb5fa1a38c0b613b1bd9c9a369b000000004cde9cb28492;
   localparam u0_C = 256'h904f00fef982d02636e63dc29ca53d6231cbbb473a6ff2e1fc8afccab6e9b988;
   localparam u0_D = 256'hf6f4f6f4b6e5b64924929091d042b613b6a100feb612a492b61eb906b6c93c37;
   localparam u0_E = 256'h4cde00fe90e0d011fa563c223cc6b9e2b61e4cde9cb0fa1ad01abce8391df0ca;
   localparam u0_F = 256'h90c78046907eb649366bbc45b4d9b61336ab1cfab6dbfcd508dd90e6b61eb972;
   localparam u1_0 = 256'h3308332333a33323346030533321305333213321332033483320226311220063;
   localparam u1_1 = 256'h531034e233083222332033085350331b3318332036203463332345d333233323;
   localparam u1_2 = 256'h330833936322332334603753332337533360331333206023332038223308075b;
   localparam u1_3 = 256'h60236023780a33193320680a3388331b361c730a630a43135310331833233908;
   localparam u1_4 = 256'h34e23320631b332393068a6334608a63531e331e3462332333206822331a0a63;
   localparam u1_5 = 256'h531e1122731a33193320631a331b38e233223322531e7822531e1122531e1b0a;
   localparam u1_6 = 256'h3460331b631b3323b323331a33223308531c530736203323a4626462361933a3;
   localparam u1_7 = 256'h6000331c435333193320530334e233181d223c204313445360003321531e7822;
   localparam u1_8 = 256'h34223320c3a2332334c838e23308a3a360005350112233233362331360000063;
   localparam u1_9 = 256'h330735c8a3a3a3a38327d35a3320331b531c631a34e2d31a331e331ed4d8d31d;
   localparam u1_A = 256'h3460332363a33323331e33a2d45aa3a233603a22346160233308332234e2075b;
   localparam u1_B = 256'h1322132234603319731a33213423331b331a34e233206000600044d334e2d358;
   localparam u1_C = 256'h36213320c3a23323d31d3ea333613ea3331c331e33203313a4626462331a3623;
   localparam u1_D = 256'h1d123c10531e3319545b332233a3331b531e33203320d458531e782233113460;
   localparam u1_E = 256'h44d3332063a3332333213323346333a3531e45d334e2332338e268223320331a;
   localparam u1_F = 256'h3320332033203319332034623453331b531c34e3531e535733203320531e7822;
   wire [31:0]   indir;
`ifdef verilator
   /* verilator lint_off UNUSED */
   wire [15:0]   sim_a;
   wire [15:0]   sim_b;
   /* verilator lint_on UNUSED */
`endif
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u0_0), .INIT_1(u0_1), .INIT_2(u0_2), .INIT_3(u0_3),
                   .INIT_4(u0_4), .INIT_5(u0_5), .INIT_6(u0_6), .INIT_7(u0_7),
                   .INIT_8(u0_8), .INIT_9(u0_9), .INIT_A(u0_A), .INIT_B(u0_B),
                   .INIT_C(u0_C), .INIT_D(u0_D), .INIT_E(u0_E), .INIT_F(u0_F)
                   ) ucode0
     (
      .RDATA( indir[15:0]         ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u1_0), .INIT_1(u1_1), .INIT_2(u1_2), .INIT_3(u1_3),
                   .INIT_4(u1_4), .INIT_5(u1_5), .INIT_6(u1_6), .INIT_7(u1_7),
                   .INIT_8(u1_8), .INIT_9(u1_9), .INIT_A(u1_A), .INIT_B(u1_B),
                   .INIT_C(u1_C), .INIT_D(u1_D), .INIT_E(u1_E), .INIT_F(u1_F)
                   ) ucode1
     (
      .RDATA( indir[31:16]        ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );

   assign d[0] = indir[0];
   assign d[1] = indir[1];
   assign d[2] = indir[2];
   assign d[3] = indir[3];
   assign d[4] = indir[4];
   assign d[5] = indir[5];
   assign d[6] = indir[6];
   assign d[7] = indir[7];
   assign d[11] = indir[8];
   assign d[12] = indir[9];
   assign d[13] = indir[10];
   assign d[16] = indir[11];
   assign d[17] = indir[12];
   assign d[19] = indir[13];
   assign d[22] = indir[14];
   assign d[23] = indir[15];
   assign d[24] = indir[16];
   assign d[25] = indir[17];
   assign d[26] = indir[18];
   assign d[28] = indir[19];
   assign d[29] = indir[20];
   assign d[39] = indir[21];
   assign d[42] = indir[22];
   assign d[43] = indir[23];
   // replaces = 1000000100100110000000000100001100011100000000
   SB_LUT4 #(.LUT_INIT(16'h0102)) cmb_d08(.O(d[8]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0230)) cmb_d09(.O(d[9]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h4030)) cmb_d10(.O(d[10]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0040)) cmb_d14(.O(d[14]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h3000)) cmb_d15(.O(d[15]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h7f7e)) cmb_d20(.O(d[20]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0484)) cmb_d31(.O(d[31]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0400)) cmb_d32(.O(d[32]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h2002)) cmb_d35(.O(d[35]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h2800)) cmb_d38(.O(d[38]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0020)) cmb_d45(.O(d[45]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   // replaces = 0100110011011000001000001000000000000000000000
   SB_LUT4 #(.LUT_INIT(16'h2f3f)) cmb_d21(.O(d[21]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h2a30)) cmb_d27(.O(d[27]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0012)) cmb_d33(.O(d[33]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0080)) cmb_d34(.O(d[34]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h2004)) cmb_d36(.O(d[36]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h2200)) cmb_d37(.O(d[37]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0915)) cmb_d40(.O(d[40]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0900)) cmb_d41(.O(d[41]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h1400)) cmb_d44(.O(d[44]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   assign d[46] = 1'b0;
   assign d[47] = 1'b0;
wire instr0100,instr1x110100;        bn_l4v #(.I(16'h0010)) leq0100(     .o(instr0100),     .i({minx[3:0]}));bn_l4v #(.I(16'h8000)) leq1x110100( .o(instr1x110100), .i({minx[7],minx[5:4],instr0100}));SB_DFFE reg_d18( .Q(d[18]), .C(clk), .E(progress_ucode), .D(instr1x110100));assign d[30] = d[18];
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019-2020. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * Automatically generated from ../code/ucode.h by midgetv_indirectEBR.c.
 * Do not edit.
 * Optiones for this variant:
 *   RVC included
 *   MULDIV included
 *   minstret for instructions in SRAM
 */
/* Using LUTSIZE=4. Using 2 EBRs. Initial table has 46 columns
 * Removed:  0000000000000000000000000000000000000000000000 These are removed from consideration, replaced with hand-crafted Verilog code in the output stage
 * Reserved: 0000000000000000000000000000000000000000000000 Columns to be represented directly, not part of optimalization
 * Total columns to represent in EBRs: 46
 * 210 distinct lines in remaining untreated columns
 * c45 c44 c43 c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 * 209 210 209 210 210 210 210 210 210 210 210 210 210 210 210 210 210 210 210 210 209 210 208 209 210 210 210 210 210 210 210 210 209 207 208 210 209 210 209 210 209 210 210 209 208 209  kill col 12  Tbl  45 cols 0000000000000000000000000000000001000000000000 has 207 unique lines.
 * 206 207 206 206 207 207 207 207 207 207 207 207 207 207 207 207 207 207 207 207 205 207 205 204 207 207 207 207 207 207 207 207 205     205 207 206 207 206 207 206 207 207 206 205 206  kill col 22  Tbl  44 cols 0000000000000000000000010000000001000000000000 has 204 unique lines.
 * 203 204 203 203 204 204 204 204 204 204 204 204 204 204 204 204 204 204 204 204 203 203 202     204 204 204 204 204 204 204 204 202     202 204 203 204 203 203 202 204 204 203 202 202  kill col 23  Tbl  43 cols 0000000000000000000000110000000001000000000000 has 202 unique lines.
 * 201 202 201 201 202 202 202 202 202 202 202 202 202 202 202 202 202 202 201 201 200 201         202 202 202 202 202 202 202 202 200     200 202 201 202 201 201 200 202 202 200 200 200  kill col 25  Tbl  42 cols 0000000000000000000010110000000001000000000000 has 200 unique lines.
 * 199 200 199 199 200 200 200 200 200 200 200 200 200 200 200 200 200 200 199 199     199         200 200 200 200 200 200 200 200 198     198 200 199 200 198 199 198 199 200 198 198 198  kill col 13  Tbl  41 cols 0000000000000000000010110000000011000000000000 has 198 unique lines.
 * 197 198 197 197 198 198 198 198 198 198 198 198 198 198 198 198 198 198 197 197     197         198 198 198 198 198 198 198 198         195 198 197 197 196 197 196 196 198 196 196 196  kill col 11  Tbl  40 cols 0000000000000000000010110000000011100000000000 has 195 unique lines.
 * 194 195 194 191 195 195 195 195 195 195 195 195 195 195 195 195 195 195 194 194     194         195 195 195 195 195 195 195 195             195 194 194 193 194 193 192 195 193 193 193  kill col 42  Tbl  39 cols 0001000000000000000010110000000011100000000000 has 191 unique lines.
 * 190 191 190     191 191 191 191 191 191 191 191 191 191 191 191 191 191 190 190     190         191 191 190 191 191 191 191 191             191 190 190 189 190 189 188 191 189 189 189  kill col  4  Tbl  38 cols 0001000000000000000010110000000011100000010000 has 188 unique lines.
 * 187 188 187     188 188 188 188 188 188 188 188 188 188 188 188 188 188 186 187     187         188 188 187 188 188 187 188 188             188 187 187 186 187 186     187 186 186 186  kill col 27  Tbl  37 cols 0001000000000000001010110000000011100000010000 has 186 unique lines.
 * 185 186 185     186 186 186 186 186 186 186 186 186 186 186 186 186 186     185     185         186 186 185 186 186 185 186 186             186 185 185 184 185 184     185 184 184 184  kill col  7  Tbl  36 cols 0001000000000000001010110000000011100010010000 has 184 unique lines.
 * 183 184 183     184 184 184 184 184 184 184 184 184 184 184 184 184 183     183     182         184 184 183 184 183 182 184 184             182 183 183     183 177     181 179 181 180  kill col  5  Tbl  35 cols 0001000000000000001010110000000011100010110000 has 177 unique lines.
 * 176 177 176     177 177 177 177 177 177 177 177 176 177 177 177 177 176     174     172         177 177 176 177 175 175 177 177             176 176 176     172         167 168 172 169  kill col  3  Tbl  34 cols 0001000000000000001010110000000011100010111000 has 167 unique lines.
 * 166 167 166     167 167 167 167 167 167 167 167 166 167 167 167 167 166     163     160         167 167 165 167 164 165 167 166             166 166 166     159             155 156 156  kill col  2  Tbl  33 cols 0001000000000000001010110000000011100010111100 has 155 unique lines.
 * 154 155 153     155 155 155 155 155 155 155 155 153 155 155 155 154 151     150     146         155 155 151 155 150 150 155 151             154 154 153     142                 136 144  kill col  1  Tbl  32 cols 0001000000000000001010110000000011100010111110 has 136 unique lines.
 * 135 136 133     135 136 136 136 136 136 136 132 134 136 136 136 134 132     132     124         134 136 131 136 130 131 136 131             135 135 133     117                     122  kill col  6  Tbl  31 cols 0001000000000000001010110000000011100011111110 has 117 unique lines.
 * 116 117 112     116 117 117 117 117 117 117 114 116 116 115 117 115 113     113     103         113 117 111 117 111 110 115 111             116 116 113                             101  kill col  0  Tbl  30 cols 0001000000000000001010110000000011100011111111 has 101 unique lines.
 * 100 100  94     100 101 101 101 101 101 101  97 100 100  99 101  98  98      97      90          95 101  96 101  95  94  99  95             100 100  96                                  kill col 24  Tbl  29 cols 0001000000000000001011110000000011100011111111 has  90 unique lines.
 *  89  88  84      89  90  89  90  89  90  90  86  89  89  88  90  86  88      85                  84  90  85  90  84  81  88  86              89  88  84                                  kill col 16  Tbl  28 cols 0001000000000000001011110000010011100011111111 has  81 unique lines.
 *  80  79  75      80  81  80  81  80  81  81  77  80  80  79  80  77  79      76                  74  80  74  81  76      79  77              80  79  75                                  kill col 21  Tbl  27 cols 0001000000000000001011111000010011100011111111 has  74 unique lines.
 *  73  72  68      73  74  73  74  73  74  74  70  73  73  72  73  71  72      69                      72  67  74  69      72  70              73  72  69                                  kill col 19  Tbl  26 cols 0001000000000000001011111010010011100011111111 has  67 unique lines.
 *  65  65  60      66  67  65  67  66  67  67  63  66  66  65  66  64  65      62                      64      67  62      65  64              66  65  63                                  kill col 43  Tbl  25 cols 0011000000000000001011111010010011100011111111 has  60 unique lines.
 *  58  57          59  60  58  60  59  60  60  56  59  59  58  59  57  58      55                      57      60  55      58  57              58  58  57                                  kill col 26  Tbl  24 cols 0011000000000000001111111010010011100011111111 has  55 unique lines.
 *  53  52          54  55  53  55  54  55  55  51  54  54  53  53  52  53                              52      54  50      53  53              53  53  52                                  kill col 17  Tbl  23 cols 0011000000000000001111111010110011100011111111 has  50 unique lines.
 *  48  48          49  48  48  50  49  50  50  46  49  49  48  48  45  47                              47      49          48  48              48  48  47                                  kill col 29  Tbl  22 cols 0011000000000000101111111010110011100011111111 has  45 unique lines.
 *  43  43          44  43  40  45  44  45  45  42  44  44  43  43      43                              43      44          43  43              43  43  42                                  kill col 39  Tbl  21 cols 0011001000000000101111111010110011100011111111 has  40 unique lines.
 *  38  38          39  37      40  39  40  40  37  39  39  38  38      35                              38      39          39  38              38  38  37                                  kill col 28  Tbl  20 cols 0011001000000000111111111010110011100011111111 has  35 unique lines.
 *  33  33          34  31      34  34  34  35  33  34  34  32  33                                      33      34          34  34              33  33  33                                  kill col 40  Tbl  19 cols 0011011000000000111111111010110011100011111111 has  31 unique lines.
 *  29  29          29          30  30  29  31  29  28  30  29  29                                      29      30          30  30              29  29  29                                  kill col 33  Tbl  18 cols 0011011000001000111111111010110011100011111111 has  28 unique lines.
 *  27  26          26          27  27  26  27  26      27  26  26                                      26      27          27  27              26  26  26                                  kill col 44  Tbl  17 cols 0111011000001000111111111010110011100011111111 has  26 unique lines.
 *  25              24          25  25  24  25  24      25  24  24                                      24      25          25  25              24  24  24                                  kill col 41  Tbl  16 cols 0111111000001000111111111010110011100011111111 has  24 unique lines.
 *  23                          23  23  22  23  22      23  22  22                                      22      23          23  23              22  22  22                                  kill col 36  Tbl  15 cols 0111111001001000111111111010110011100011111111 has  22 unique lines.
 *  21                          21  20      21  20      21  20  20                                      20      21          21  21              20  20  20                                  kill col 37  Tbl  14 cols 0111111011001000111111111010110011100011111111 has  20 unique lines.
 *  19                          19          19  18      19  18  18                                      18      19          19  19              18  18  18                                  kill col 34  Tbl  13 cols 0111111011011000111111111010110011100011111111 has  18 unique lines.
 *  17                          17          17          17  16  16                                      16      17          17  17              16  16  17                                  kill col 31  Tbl  12 cols 0111111011011010111111111010110011100011111111 has  16 unique lines.
Possible good candidates for removal, columns : 8 9 10 20 30 
 *
 * Round 1: 1000000100100101000000000101001100011100000000  4 columns for indexes to table representing 12 original columns (uses 16 of 16 lines in indirect table).
 * Total columns to represent in EBRs: 38
 * 207 distinct lines in remaining untreated columns
 * c45 c44 c43 c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 *   x 207 204 207 207 207 207   x 207 207   x 207 207   x 207   x 207 207 206 207 206 207 205 206 207   x 205   x 207 207   x   x 206 204 205   x   x   x 206 207 206 207 207 206 205 206  kill col 43  Tbl  33 cols 1010000100100101000000000101001100011100000000 has 204 unique lines.
 *   x 204     204 204 204 204   x 204 204   x 204 204   x 204   x 204 204 203 204 203 204 202 203 204   x 201   x 204 204   x   x 203 201 202   x   x   x 203 204 203 204 204 203 202 203  kill col 19  Tbl  32 cols 1010000100100101000000000111001100011100000000 has 201 unique lines.
 *   x 201     201 201 201 201   x 201 201   x 201 201   x 201   x 201 201 200 201 200 201 199 200 201   x       x 201 201   x   x 200 198 199   x   x   x 200 201 200 201 201 200 199 200  kill col 12  Tbl  31 cols 1010000100100101000000000111001101011100000000 has 198 unique lines.
 *   x 198     197 198 198 198   x 198 198   x 198 198   x 198   x 198 198 197 198 196 198 196 195 198   x       x 198 198   x   x 196     196   x   x   x 197 198 197 198 198 197 196 197  kill col 22  Tbl  30 cols 1010000100100101000000010111001101011100000000 has 195 unique lines.
 *   x 195     194 195 195 195   x 195 195   x 195 195   x 195   x 195 195 194 195 194 194 193     195   x       x 195 195   x   x 192     193   x   x   x 194 194 193 195 195 194 193 193  kill col 13  Tbl  29 cols 1010000100100101000000010111001111011100000000 has 192 unique lines.
 *   x 192     191 192 192 192   x 192 192   x 192 192   x 192   x 192 192 191 192 191 191 190     192   x       x 192 192   x   x         189   x   x   x 191 191 190 191 192 191 190 190  kill col 11  Tbl  28 cols 1010000100100101000000010111001111111100000000 has 189 unique lines.
 *   x 189     184 189 189 189   x 189 189   x 189 189   x 189   x 189 189 188 189 188 188 187     189   x       x 189 187   x   x               x   x   x 188 187 187 187 189 188 186 187  kill col 42  Tbl  27 cols 1011000100100101000000010111001111111100000000 has 184 unique lines.
 *   x 184         184 184 184   x 184 184   x 184 184   x 184   x 184 184 183 184 183 183 182     184   x       x 184 182   x   x               x   x   x 183 182 180 182 184 182 181 181  kill col  5  Tbl  26 cols 1011000100100101000000010111001111111100100000 has 180 unique lines.
 *   x 180         180 180 180   x 180 180   x 180 179   x 180   x 180 180 179 180 179 178 176     180   x       x 180 176   x   x               x   x   x 172 178     177 179 175 174 175  kill col  7  Tbl  25 cols 1011000100100101000000010111001111111110100000 has 172 unique lines.
 *   x 172         172 172 172   x 172 172   x 172 171   x 172   x 172 171 171 172 171 167 169     172   x       x 171 167   x   x               x   x   x     170     168 168 164 164 167  kill col  2  Tbl  24 cols 1011000100100101000000010111001111111110100100 has 164 unique lines.
 *   x 164         164 164 164   x 164 164   x 164 162   x 164   x 164 163 162 164 161 159 159     162   x       x 162 159   x   x               x   x   x     159     160 158     157 158  kill col  1  Tbl  23 cols 1011000100100101000000010111001111111110100110 has 157 unique lines.
 *   x 155         157 157 157   x 157 157   x 156 154   x 157   x 156 156 155 157 154 151 150     154   x       x 155 147   x   x               x   x   x     145     147 144         147  kill col  3  Tbl  22 cols 1011000100100101000000010111001111111110101110 has 144 unique lines.
 *   x 141         144 144 144   x 144 144   x 142 141   x 144   x 143 143 142 142 138 135 136     139   x       x 140 133   x   x               x   x   x     125     128             125  kill col  6  Tbl  21 cols 1011000100100101000000010111001111111111101110 has 125 unique lines.
 *   x 121         125 125 125   x 125 124   x 123 121   x 124   x 124 123 121 123 115 115 116     120   x       x 119 113   x   x               x   x   x             101             102  kill col  4  Tbl  20 cols 1011000100100101000000010111001111111111111110 has 101 unique lines.
 *   x  98         101 100 101   x 101 100   x  98  98   x 100   x  99  98  97  97  91  91  93      95   x       x  93  88   x   x               x   x   x                              79  kill col  0  Tbl  19 cols 1011000100100101000000010111001111111111111111 has  79 unique lines.
 *   x  76          79  78  79   x  79  78   x  76  77   x  77   x  77  76  76  75  71  71  72      74   x       x  72  69   x   x               x   x   x                                  kill col 16  Tbl  18 cols 1011000100100101000000010111011111111111111111 has  69 unique lines.
 *   x  65          69  68  69   x  69  68   x  66  68   x  67   x  67  66  65  65  62  61  63      63   x       x  60       x   x               x   x   x                                  kill col 17  Tbl  17 cols 1011000100100101000000010111111111111111111111 has  60 unique lines.
 *   x  56          60  59  60   x  60  59   x  57  59   x  57   x  57  57  57  56  52  51  53      55   x       x           x   x               x   x   x                                  kill col 24  Tbl  16 cols 1011000100100101000001010111111111111111111111 has  51 unique lines.
 *   x  48          51  50  51   x  50  50   x  48  49   x  48   x  47  46  48  47  45      45      48   x       x           x   x               x   x   x                                  kill col 25  Tbl  15 cols 1011000100100101000011010111111111111111111111 has  45 unique lines.
 *   x  42          45  44  45   x  44  44   x  42  42   x  42   x  40  40  41  39          38      41   x       x           x   x               x   x   x                                  kill col 23  Tbl  14 cols 1011000100100101000011110111111111111111111111 has  38 unique lines.
 *   x  36          37  36  37   x  37  37   x  35  35   x  35   x  32  33  33  32                  34   x       x           x   x               x   x   x                                  kill col 29  Tbl  13 cols 1011000100100101100011110111111111111111111111 has  32 unique lines.
 *   x  30          31  30  28   x  31  31   x  30  29   x  29   x      26  28  27                  28   x       x           x   x               x   x   x                                  kill col 28  Tbl  12 cols 1011000100100101110011110111111111111111111111 has  26 unique lines.
 *   x  24          25  23  20   x  25  24   x  24  24   x  23   x          24  23                  23   x       x           x   x               x   x   x                                  kill col 39  Tbl  11 cols 1011001100100101110011110111111111111111111111 has  20 unique lines.
 *   x  18          19  18       x  19  18   x  19  19   x  18   x          18  17                  18   x       x           x   x               x   x   x                                  kill col 26  Tbl  10 cols 1011001100100101110111110111111111111111111111 has  17 unique lines.
 *   x  15          15  15       x  16  15   x  16  16   x  14   x          15                      15   x       x           x   x               x   x   x                                  kill col 31  Tbl   9 cols 1011001100100111110111110111111111111111111111 has  14 unique lines.
 *
 * Round 2: 0100110011011000001000001000000000000000000000  4 columns for indexes to table representing  9 original columns (uses 14 of 16 lines in indirect table).
 * Total columns to represent in EBRs: 33
 * 206 distinct lines in remaining untreated columns
 * c45 c44 c43 c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 *   x   x 203 206   x   x 206   x   x   x   x   x   x   x 206   x 206 206   x 205 204 206 203 205   x   x 204   x 206 206   x   x 205 203 204   x   x   x 205 205 205 206 206 205 203 205  kill col 43  Tbl  24 cols 1110110111111101001000001101001100011100000000 has 203 unique lines.
 *   x   x     203   x   x 203   x   x   x   x   x   x   x 203   x 203 203   x 202 201 203 200 202   x   x 200   x 203 203   x   x 202 200 201   x   x   x 202 202 202 203 203 202 200 202  kill col 23  Tbl  23 cols 1110110111111101001000101101001100011100000000 has 200 unique lines.
 *   x   x     200   x   x 200   x   x   x   x   x   x   x 200   x 200 200   x 199 197 200     199   x   x 197   x 200 200   x   x 199 197 198   x   x   x 199 199 199 200 200 198 197 199  kill col 25  Tbl  22 cols 1110110111111101001010101101001100011100000000 has 197 unique lines.
 *   x   x     197   x   x 197   x   x   x   x   x   x   x 197   x 197 197   x 196     196     195   x   x 194   x 197 197   x   x 196 193 195   x   x   x 195 196 196 195 197 194 194 196  kill col 12  Tbl  21 cols 1110110111111101001010101101001101011100000000 has 193 unique lines.
 *   x   x     192   x   x 193   x   x   x   x   x   x   x 193   x 193 193   x 192     192     190   x   x 190   x 193 193   x   x 191     191   x   x   x 191 192 192 191 193 190 190 192  kill col 22  Tbl  20 cols 1110110111111101001010111101001101011100000000 has 190 unique lines.
 *   x   x     189   x   x 190   x   x   x   x   x   x   x 190   x 190 190   x 189     188           x   x 187   x 190 190   x   x 187     188   x   x   x 188 188 188 188 189 187 185 188  kill col  1  Tbl  19 cols 1110110111111101001010111101001101011100000010 has 185 unique lines.
 *   x   x     184   x   x 185   x   x   x   x   x   x   x 185   x 185 185   x 184     182           x   x 182   x 185 185   x   x 182     183   x   x   x 183 179 180 183 180 182     182  kill col  6  Tbl  18 cols 1110110111111101001010111101001101011101000010 has 179 unique lines.
 *   x   x     177   x   x 179   x   x   x   x   x   x   x 179   x 179 179   x 177     174           x   x 176   x 179 177   x   x 175     176   x   x   x 176     174 174 172 173     172  kill col  3  Tbl  17 cols 1110110111111101001010111101001101011101001010 has 172 unique lines.
 *   x   x     169   x   x 172   x   x   x   x   x   x   x 172   x 172 172   x 170     162           x   x 168   x 171 170   x   x 167     166   x   x   x 166     160 162     161     160  kill col  5  Tbl  16 cols 1110110111111101001010111101001101011101101010 has 160 unique lines.
 *   x   x     154   x   x 160   x   x   x   x   x   x   x 160   x 159 160   x 156     144           x   x 156   x 158 156   x   x 151     152   x   x   x 148         149     145     144  kill col 24  Tbl  15 cols 1110110111111101001011111101001101011101101010 has 144 unique lines.
 *   x   x     137   x   x 144   x   x   x   x   x   x   x 143   x 143 141   x 140                   x   x 140   x 137 140   x   x 134     134   x   x   x 128         132     127     126  kill col  0  Tbl  14 cols 1110110111111101001011111101001101011101101011 has 126 unique lines.
 *   x   x     117   x   x 126   x   x   x   x   x   x   x 124   x 125 121   x 121                   x   x 121   x 119 118   x   x 114     116   x   x   x 109         106     104          kill col  2  Tbl  13 cols 1110110111111101001011111101001101011101101111 has 104 unique lines.
 *   x   x      95   x   x 103   x   x   x   x   x   x   x 102   x 100  98   x  96                   x   x  99   x  96  94   x   x  91      96   x   x   x  80          82                  kill col  7  Tbl  12 cols 1110110111111101001011111101001101011111101111 has  80 unique lines.
 *   x   x      72   x   x  79   x   x   x   x   x   x   x  77   x  75  74   x  72                   x   x  75   x  71  67   x   x  70      73   x   x   x              60                  kill col  4  Tbl  11 cols 1110110111111101001011111101001101011111111111 has  60 unique lines.
 *   x   x      53   x   x  59   x   x   x   x   x   x   x  58   x  54  54   x  53                   x   x  55   x  51  48   x   x  52      54   x   x   x                                  kill col 16  Tbl  10 cols 1110110111111101001011111101011101011111111111 has  48 unique lines.
 *   x   x      42   x   x  46   x   x   x   x   x   x   x  45   x  43  41   x  42                   x   x  42   x  37       x   x  38      40   x   x   x                                  kill col 17  Tbl   9 cols 1110110111111101001011111101111101011111111111 has  37 unique lines.
 *   x   x      30   x   x  34   x   x   x   x   x   x   x  33   x  30  30   x  32                   x   x  32   x           x   x  29      30   x   x   x                                  kill col 13  Tbl   8 cols 1110110111111101001011111101111111011111111111 has  29 unique lines.
 *   x   x      22   x   x  26   x   x   x   x   x   x   x  25   x  24  23   x  24                   x   x  24   x           x   x          23   x   x   x                                  kill col 42  Tbl   7 cols 1111110111111101001011111101111111011111111111 has  22 unique lines.
 *   x   x           x   x  19   x   x   x   x   x   x   x  19   x  17  15   x  17                   x   x  18   x           x   x          17   x   x   x                                  kill col 28  Tbl   6 cols 1111110111111101011011111101111111011111111111 has  15 unique lines.
Possible good candidates for removal, columns : 19 
 *
 * Round 3: 0000001000000010100100000010000000100000000000  4 columns for indexes to table representing  6 original columns (uses 15 of 16 lines in indirect table).
 * Direct:  0011000000000000010011110000110011000011111111 19 columns
 * Can even chose 1 more column to be represented directly.
 * Success. Use 2 EBRs, 26 LUTs.
 */

module v14_m_2ebr
  (
   input         clk,
   input [7:0]   minx,
   input         progress_ucode,
/* verilator lint_off UNOPTFLAT */
   output [47:0] d
/* verilator lint_on UNOPTFLAT */
   );
   /*
    *                      indirect_index 2
    *                      | indirect_index 1
    * inx         next     | | indirect index 0
    * || ucode    ucode    | | | direct representation
    * 00 LB_0     LB_1     0 0 0 01011011110000000001| LB     Load byte. q = rdadr=RS1+0fs
    * 01 LB_1     LB_2     1 1 1 00010111100111010010|        Read until q=mem[rs1+ofs) & ~3u]
    * 02 IJ_0     IJ_1     2 2 2 01011011110010111110| IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0
    * 03 _L0x03   StdIncPc 3 3 2 000001010xx011100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 04 ADDI_0   StdIncPc 4 3 2 01100101010011100110| ADDI   Add immediate. rd =RS1+Iimm (or joined)
    * 05 _L0x05   ADDI_0   3 3 2 000000001xx000000100| AUIPC  q = imm20+2 or imm20+4  (copy x/2)
    * 06 LB_3     LB_4     0 3 2 00001101101000000111|        q = ~mem[rs1+ofs]
    * 07 LB_4     LB_5     1 3 2 00001011101000001001|        q = (uint8_t) mem[rs1+Iimm]
    * 08 _L0x08   SB_1     5 3 0 01011101110001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 09 LB_5     LB_6     0 3 2 00001011100010001011|        q = D^0xffffffff^q = D^0x80
    * 0a _L0x0a   SB_1     5 3 0 01011101110001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 0b JALR_2   JALR_3   0 3 3 01000101110000110011|        Q=1. Prep legalize target
    * 0c ADD_0    ADDI_0   1 3 2 00011101100000000100| ADD    add     Addition Q = RS1
    * 0d MUL_0    MUL_1    3 3 2 100111010xx011100010| MUL    Store rs1 tp rM. Next read rs2. Q clear
    * 0e SUB_0    SUB_1    3 3 2 000111010xx000010000| SUB    Subtraction
    * 0f _L0x0f   StdIncPc 4 3 2 00100101011011100110| LUI    q = imm20
    * 10 SUB_1    LB_6     0 3 2 00011111100010001011|        Q = ~RS2
    * 11 AND_1    ANDI_1   0 3 2 00011101100000011010|        RS1^0xffffffff to Q
    * 12 straddle Fetchu   6 4 4 11011010110001110110|  Fr10u IncPC, OpFetch
    * 13 condb_2  condb_3  0 3 2 00011111100000010100|        ~RS2 in Q
    * 14 condb_3  condb_4  0 3 3 01011001110000010101|        Calculate RS1+~RS2+1
    * 15 condb_4  condb_5  1 3 5 00000001100000010110|        Branch on condition
    * 16 condb_5  StdIncPc 3 3 2 000000010xx011100110|        Branch not taken.
    * 17 condb_5t condb_6t 7 3 2 00100000100001111101|        Branch taken. yy=oldPC incase of access error
    * 18 BEQ      condb_2  5 3 2 00111101011000010011| BEQ    Conditional Branch. Offset to Ryy
    * 19 JALR_0   JALR_1   5 5 2 01000000x10001000001| JALR   (tmp) Prep pc=RS1+imm (target)
    * 1a ANDI_1   StdIncPc 8 3 2 00100101001011100110|        rd = Iimm & RS1
    * 1b _L0x1b   JAL_1    3 3 2 000000001xx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 1c ECAL_BRK ECAL_RET 2 3 2 00010110111010100110| ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI
    * 1d ORI_2    StdIncPc 8 3 2 00100101011011100110|        rd = Iimm | RS1
    * 1e aFault_1 aFault_2 3 3 3 11010101110011010100|        Q = 4
    * 1f IJ_2     IJ_3     5 5 2 00000000111010110111|        Read word is to be masked with lsb = 0
    * 20 LH_0     LH_1     9 0 0 01111011110001010010| LH     Load hword. Q = rdadr=RS1+Iimm.
    * 21 XORI_1   StdIncPc 4 3 2 00100101000011100110|        rd = Iimm ^ RS1
    * 22 MULHU_6  MULHU_7  0 3 6 00010101110100111001|        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar
    * 23 _L0x23   StdIncPc 3 3 2 000001010xx011100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 24 SLLI_0   SLLI_1   0 6 0 00011110x11000110101| SLLI   Shift left immediate.
    * 25 _L0x25   ADDI_0   3 3 2 000000001xx000000100| AUIPC  q = imm20+2 or imm20+4  (copy x/2)
    * 26 OR_1     OR_2     5 3 2 00011101000000100111|        RS1^0xffffffff to jj
    * 27 OR_2     ORI_2    0 3 2 01000001110000011101|        Q = rs2
    * 28 _L0x28   SH_1     9 3 0 01011101110010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 29 XOR_1    XORI_1   0 3 2 00011101100000100001|        Q = RS1^0xFFFFFFFF
    * 2a _L0x2a   SH_1     9 3 0 01011101110010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 2b SLTIX_1  SLTIX_2  0 3 3 010xxxx1010000110000|        RS1 - imm / RS1 - RS2
    * 2c SLL_0    SLL_1    3 3 2 00011100xxx000111110| SLL    Shift left
    * 2d MULH_0   MULH_1   1 6 2 00010101100001101010| MULH   Store rs1 to Q. Prep read 0, shcnt--
    * 2e MULHU_1  MULHU_2  5 3 2 10011111011001000010|        rM<=RS2,  Rjj<=Q=0. next read RS1. 
    * 2f _L0x2f   StdIncPc 4 3 2 00100101011011100110| LUI    q = imm20
    * 30 SLTIX_2  StdIncPc 4 3 7 00100101011011100110|        Registered ALU flag to rd
    * 31 SLTX_1   SLTIX_1  0 3 2 00011111100000101011|        ~rs2 to Q
    * 32 JAL_1    JAL_2    7 3 2 00100000100010000110|      Prep Instradr to yy. Refetch instradr
    * 33 JALR_3   JAL_25   7 5 2 00000001001010011110|        Q = (RS1+imn) & 0xfffffffe
    * 34 JAL_3    Fetch    7 4 2 00011010100011011110|      Prep fetch next instr.
    * 35 SLLI_1   SLLI_2   8 6 2 00110111100000110110|        Register to shift to Q (and TRG for shift 0)
    * 36 SLLI_2   _L0x03   8 7 2 00110111110000000011|        Repeat Q = Q+Q until shregcnt == 0
    * 37 ECALL_2  ECALL_3  a 3 5 001xxxx1000011010111|        mepc = pc, prep store 0 to mtval
    * 38 BNE      condb_2  5 3 2 00111101011000010011| BNE    Conditional Branch. Offset to Ryy
    * 39 MULHU_7  StdIncPc 8 3 2 10100101000011100110|        Last shift.
    * 3a SRxI_1   SRxI_2   8 6 6 00110101100100111101|        Register to shift to Q
    * 3b _L0x3b   JAL_1    3 3 2 000000001xx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 3c CSRRW_0  CSRRW_1  5 3 2 00101101011001001001| CSRRW  Decoded CSR adr in yy
    * 3d SRxI_2   _L0x03   8 7 6 00110101100100000011|        Repeat Q >>= 1 until shregcnt == 0
    * 3e SLL_1    SLLI_1   1 6 0 00011110x00000110101|        Shiftamount was in low 5 bits of RS2
    * 3f SRx_1    SRxI_1   1 6 0 00011110x00000111010|        Shiftamount in low 5 bits of RS2
    * 40 LW_0     LW_1     2 0 8 01011011110001010000| LW     Load word. Q=yy=rdadr=RS1+Iimm
    * 41 JALR_1   JALR_2   7 3 2 00110101000000001011|        yy=jj. Prep get Q=1
    * 42 MULHU_2  MULHU_3  0 6 6 00010101110101100000|        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar
    * 43 MULHU_4  MULHU_5  0 3 2 00000000100011101010|        Prepare read Rjj.
    * 44 SLTI_0   SLTIX_1  0 3 2 00011111101000101011| SLTI   Set less than immediate (signed)
    * 45 WFI_3    WFI_4    0 3 3 01010101110001100101|        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105
    * 46 ILL_1    ILL_2    a 3 2 00110100x00001000111|        Store PC to mepc
    * 47 ILL_2    ILL_3    a 5 2 00110101000010001111|        Store 0 to mtval
    * 48 _L0x48   SW_1     2 8 8 01011101110001100110| SW     Store word. Q=wradr=RS1+Simm
    * 49 CSRRW_1  CSRRW_2  0 3 3 01000001110001001011|        Construct PC storage adr
    * 4a _L0x4a   SW_1     2 8 8 01011101110001100110| SW     Store word. Q=wradr=RS1+Simm
    * 4b CSRRW_2  CSRRW_3  b 9 2 00010100100010110001|        Write PC to 0x100 start Prep emulation entrypt
    * 4c SLT_0    SLTX_1   3 3 2 000111010xx000110001| SLT    Set less than (signed)
    * 4d MULHSU_0 MULHU_1  7 6 2 00111101000000101110| MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--
    * 4e eILL0b   ILLe     3 3 2 000xxxx0xxx011111110| Illegal instruction seen
    * 4f MRET_8   MRET_9   3 3 3 11010101110001110100|        +4, so now 0x103
    * 50 LW_1     StdIncPc 8 1 9 00110111000011100110|        Read until d=mem[(rs1+ofs) & ~3u]
    * 51 LDAF_LW  LDAF_a   c 5 2 00110100111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 52 LH_1     LH_2     1 1 1 00010111100101010100|        Read until q=mem[(rs1+ofs) & ~3u]
    * 53 LDAF_LH  LDAF_a   c 5 2 00110100111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 54 LH_2     LH_3     1 7 6 00010101100111101011|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 55 aFaultb  aFault_1 c 5 2 00110101011000011110|  err   LH Load access fault. Faulting adr to mtval
    * 56 LH_4     LH_5     1 3 2 00010001101001010111|        q = (uint16_t) mem[rs1+Iimm]
    * 57 LH_5     LB_6     0 3 2 00010001100010001011|        q = D^0xffffffff^q = D ^ 0x00008000
    * 58 DIV_A    DIV_C    1 3 6 11010111100101101110|        Transfer rM to rDee
    * 59 DIV_B    DIV_10   5 3 2 00111111011010011100|        REM = Q to yy
    * 5a SB_1     SB_2     7 6 2 00110111100001011101|        Write d to Q and yy (for sh 0). Prep shift
    * 5b _L0x5b   JAL_1    3 3 2 000000001xx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 5c CSRRS_0  CSRRW_1  5 3 2 00101101011001001001| CSRRS  Decoded CSR adr in yy
    * 5d SB_2     SB_3     7 7 2 00110111110011111011|        Repeat shl until shreg = 0 (0,8,16 or 24 times)
    * 5e LHU_1    LHU_2    1 1 1 00010111100101110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 5f LDAF_LHU LDAF_a   c 5 2 00110100111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 60 MULHU_3  MULHU_2  1 3 2 10011111100001000010|        Shift Q and rM. Prepare read rs1
    * 61 EBRKWFI2 EBREAK_1 5 3 5 00101101001011110111| EBREAK/WFI2 Select EBREAK or WFI.
    * 62 DIV_8    DIV_7    0 6 3 01010111110011001000|        Conditionally subtract rs2. Update M[0]
    * 63 DIV_9    DIV_A    0 a 3 01010111110001011000|        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]
    * 64 SLTIU_0  SLTIX_1  0 3 2 00011111101000101011| SLTIU  Set less than immediate (unsigned)
    * 65 WFI_4    WFI_5    3 3 5 000000010xx011101111|        Prepare read PC.
    * 66 SW_1     SW_2     b 5 2 00011100100011110010|        Write d to a+k until accepted
    * 67 SW_E1SWE SW_E2    c 5 2 00100100x11010010011|        Store faulting address alignment to mtval
    * 68 DIV_12   StdIncPc 8 3 2 00100101000011100110|        RS2 > 0, RS1 >= 0, yy is true result
    * 69 DIV_13   LB_6     0 3 2 00010101100010001011|        RS2 > 0, RS1 < 0, change sign yy
    * 6a MULH_1   MULH_2   5 3 2 00110101000011111001|        Store ~rs1 to Ryy. Prep construct 1.
    * 6b SB_4     SB_5     1 b 2 00011001100001111010|        Address back to Q. Prepare get item to write
    * 6c SLTU_0   SLTX_1   3 3 2 000111010xx000110001| SLTU   Set less than (unsigned)
    * 6d MULHU_0  MULHU_1  7 6 2 00111101000000101110| MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--
    * 6e DIV_C    DIV_e    7 3 2 00111100100010111001|        rM to yy. Q=ffffffff
    * 6f MRET_6   MRET_7   0 3 3 010xxxx1110011001111|        ~302 + origImm + 1 for branch decision
    * 70 LHU_2    LHU_3    1 7 6 00010101100110111010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 71 aFaultc  aFault_1 c 5 2 00110101011000011110|  err   LHU Load access fault. Faulting adr to mtval
    * 72 LBU_3    ANDI_1   0 3 2 00001101101000011010|        Invert q. Prepare read mask
    * 73 unalignd straddle 0 3 2 00000101011000010010|  Fr10u Unaligned pc, prep read high hword
    * 74 MRET_9   Fetch    5 4 3 01011010110011011110|        +1, IncPC, OpFetch next
    * 75 IJ_5     Fetch    7 4 2 00011010101011011110|        Mask and use as PC
    * 76 Fetchu   Fetch2   0 3 a 00000111011011110100|  Fr10u Read and latch instruction
    * 77 eFetchu  Fetch2   0 1 b 00010111011011110100|  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]
    * 78 DIV_4    DIV_6    5 3 2 00100001011010101010|        ~abs(divisor) to yy
    * 79 DIV_5    DIV_3    0 3 3 11010101110010101000|        Kluge to let add1 work in DIV instr
    * 7a SB_5     SW_2     8 5 2 00011000100011110010|        Write d to a+k until accepted
    * 7b _L0x7b   JAL_1    3 3 2 000000001xx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 7c CSRRC_0  CSRRW_1  5 3 2 00101101011001001001| CSRRC  Decoded CSR adr in yy
    * 7d condb_6t Fetch    5 4 2 01011010110011011110|        Branch taken.
    * 7e NMI_1    NMI_2    a 3 2 001xxxx1000010010000|        Store pc to mepc.
    * 7f unx7f             d 6 0 00xxxxxxxxxxxxxxxxxx| 7f: Not in use 
    * 80 LBU_0    LBU_1    0 0 0 01011011110010000101| LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.
    * 81 unx81             d 6 0 00xxxxxxxxxxxxxxxxxx| 81: Not in use 
    * 82 DIV_1    DIV_3    5 3 2 00011101000010101000|        jj=abs(RS1). Next handle divisor
    * 83 DIV_2    DIV_1    0 3 2 01010101110010000010|        Dividend negative, make RS1-1
    * 84 XORI_0   XORI_1   0 3 2 00011111101000100001| XORI   Xor immediate. Q=~Iimm
    * 85 LBU_1    LBU_2    1 1 1 00010111100111110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 86 JAL_2    JAL_25   5 5 2 01000001010010011110|      Prep pc = jj + ofs
    * 87 unx87             d 6 0 00xxxxxxxxxxxxxxxxxx| 87: Not in use 
    * 88 DIV_E    DIV_10   3 a 2 10011110xxx010011100|        RS2 != 0. Check signs
    * 89 DIV_F    StdIncPc 4 3 2 00100101011011100110|        RS2 == 0, return 0xffffffff
    * 8a DIVU_5   ANDI_1   3 3 6 110101110xx100011010|        Transfer rM to rDee
    * 8b LB_6     StdIncPc 4 3 3 11100101010011100110|        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80
    * 8c XOR_0    XOR_1    3 3 2 000111110xx000101001| XOR    xor
    * 8d DIV_0    DIV_1    1 c 2 10010111100010000010| DIV    Branch on sign dividend RS1
    * 8e _LCSRRS_1 ILLe     3 3 2 000xxxx0xxx011111110| Illegal instruction seen
    * 8f ILL_3    ILL_4    0 3 3 00010101110010101001|        Q = 1
    * 90 NMI_2    JAL_3    c d 2 00101001011000110100|        mtval = 0.
    * 91 LDAF_2   LDAF_3   6 d 3 11100100x10010010010|        Store 4 to mcause
    * 92 LDAF_3   JAL_3    a 3 2 00110010x00000110100|        PC to mepc
    * 93 SW_E2    SW_E3    a 3 2 00110111000010010101|        Store address that faulted
    * 94 SW_E4    JAL_3    7 d 2 00110010x10000110100|        Store 6 to mcause
    * 95 SW_E3    SW_E4    3 3 3 11010111110010010100|        Q = 3
    * 96 SH_1     SH_2     7 6 2 00110111100010111011|        Write d to Q and yy (for sh 0). Prep shift
    * 97 SW_E1SWH SW_E2    c 5 2 00100100x11010010011|        Store faulting address alignment to mtval
    * 98 BLT      condb_2  5 3 2 00111101011000010011| BLT    Conditional Branch. Offset to Ryy
    * 99 _L0x99   ILLe     3 3 2 000xxxx0xxx011111110|  Not in use (illegal as entry)
    * 9a ECALL_6  JAL_3    6 d 2 01110010x10000110100|        mcause = 11
    * 9b SH_4     SH_5     e 8 2 00011001100010011111|        Address back to Q. Prepare get item to write
    * 9c DIV_10   DIV_12   1 a 2 10011001000001101000|        RS2 > 0. Branch on sign of RS1
    * 9d DIV_11   DIV_14   1 a 2 10011001000010100010|        RS2 < 0. Branch on sign of RS1
    * 9e JAL_25   JAL_3    d 3 4 11100101010000110100|      Prep WTRG = jj+2/4 (return adr)
    * 9f SH_5     SW_2     b 3 2 00011000100011110010|        Write d to a+k until accepted
    * a0 LHU_0    LHU_1    9 0 0 01111011110001011110| LHU    Load unsigned hword. Q = rdadr=RS1+Iimm
    * a1 ECALL_4  ECALL_5  3 3 3 11010101110010110110|        Q = 4
    * a2 DIV_14   LB_6     0 3 2 00010101100010001011|        RS2 < 0, RS1 >= 0, change sign yy
    * a3 DIV_15   StdIncPc 8 3 2 00100101000011100110|        RS2 < 0, RS1 < 0, yy is true result
    * a4 SRxI_0   SRxI_1   0 6 0 00011110x11000111010| SRxI   Shift Right immediate (both logic/arith here)
    * a5 MRET_3   MRET_4   0 3 3 01001101110010101111|        0x102 + 0xff + 1 = 0x202
    * a6 ECAL_RET ECALL_1  2 3 8 00010110111011010000| ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET
    * a7 EBRKWFI1 EBRKWFI2 0 3 2 010xxxx1110001100001| EBREAK/WFI1 Prepare select EBREAK or WFI
    * a8 DIV_3    DIV_4    0 a 2 10010101100001111000|        Branch on sign divisor RS2
    * a9 ILL_4    JAL_3    5 d 3 01110010x10000110100|        Store 2 to mcause
    * aa DIV_6    DIV_7    3 3 2 100101110xx011001000|        Write M. Prepare shift
    * ab EBREAK_2 ECALL_6  a 3 2 00110101000010011010|        pc to mepc
    * ac _L0xac   SRx_1    3 3 2 00011100xxx000111111| SRx    Shift Right (both SRL and SRA)
    * ad DIVU_0   DIVU_1   3 6 2 100111010xx011100000| DIVU   Store rs1 to rM. Q=0. Prepare invert rs2
    * ae _L0xae   SRx_1    3 3 2 00011100xxx000111111| SRx    Shift Right (both SRL and SRA)
    * af MRET_4   MRET_5   0 3 3 010xxxx1110011000101|        0x202 + 0xff + 1 = 0x302
    * b0 aF_SW_3  LDAF_3   6 d 2 01100100x10010010010|        Store 7 to mcause
    * b1 CSRRW_3  CSRRW_4  3 3 3 11010101110010110010|        Prep emulation entrypt 0x108, here Q to 0x104
    * b2 CSRRW_4  Fetch    6 4 3 11011010110011011110|        IncPC, OpFetch, but force +4
    * b3 unxb3             d 6 0 00xxxxxxxxxxxxxxxxxx| b3: Not in use 
    * b4 eFetch3  unalignd c 3 c 01011111110001110011|  Fr10  Update minstret, Q=immediate. Use dinx
    * b5 SH_3     SH_4     0 3 2 00000001011010011011|        Prepare get back address to use 
    * b6 ECALL_5  ECALL_6  3 3 3 11010101110010011010|        Q = 8
    * b7 IJ_3     IJ_4     7 3 2 00110101000010111101|        Store present PC in case of access error
    * b8 BGE      condb_2  5 3 2 00111101011000010011| BGE    Conditional Branch. Offset to Ryy
    * b9 DIV_e    DIV_D    0 3 3 00011001100011000000|        Calc carry of RS2+0xFFFFFFFF
    * ba LHU_3    ANDI_1   0 3 2 00001111101000011010|        Invert q. Prepare read mask
    * bb SH_2     SH_3     7 7 2 00110111110010110101|        Repeat shl until shreg = 0 (0,8 or 24 times)
    * bc CSRRWI_0 CSRRW_1  5 3 2 00101101011001001001| CSRRWI Decoded CSR adr in yy
    * bd IJ_4     IJ_5     0 3 3 01000101110001110101|        Construct Q = 1
    * be IJ_1     IJ_2     1 1 2 00010111100000011111|        Read until q=mem[(rs1+ofs)&~1u]
    * bf IJT_1    IJT_2    1 1 2 00010111100011000001|        Exit CSR, enter trap
    * c0 DIV_D    DIV_E    1 3 5 00011101100010001000|        Is RS2 == 0?
    * c1 IJT_2    IJT_3    5 3 2 00110101011011101001|        Read word is to be masked with ~1u
    * c2 DIVU_3   DIVU_2   0 6 3 01010111110011001010|        Conditionally subtract rs2. Update M[0]
    * c3 DIVU_4   DIVU_5   0 a 3 01010111110010001010|        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]
    * c4 ORI_0    ORI_1    5 3 2 00011111001011100001| ORI    Or immediate. jj=~Iimm
    * c5 MRET_5   MRET_6   0 3 2 00000001101001101111|        ~302
    * c6 IJT_4    ILL_2    a 3 2 00110101101001000111|        Mask and store to mepc and Q for read of instr
    * c7 QINT_1   QINT_2   a 3 2 001xxxx1000011001011|        Store pc to mepc.
    * c8 DIV_7    DIV_8    1 3 d 10011001110001100010|        Shift (Q,M) left. Prepare unsigned sub
    * c9 MRET_2   MRET_3   3 3 2 01001101110010100101|        0xff+3 = 0x102
    * ca DIVU_2   DIVU_3   1 3 d 10011001110011000010|        Shift (Q,M) left. Prepare unsigned sub
    * cb QINT_2   StdIncPc c d 2 00101001011011100110|        mtval = 0.
    * cc OR_0     OR_1     3 3 2 000111110xx000100110| OR     or
    * cd REM_0    DIV_1    1 c 2 10010111100010000010| REM    Branch on sign dividend RS1
    * ce _LCSRRCI_1 ILLe     3 3 2 000xxxx0xxx011111110| Illegal instruction seen
    * cf MRET_7   MRET_8   3 3 5 000011010xx001001111|        Prepare emulation entry point 0x104
    * d0 ECALL_1  ECALL_2  0 3 3 01000001110000110111| ECALL  Verify Imm==0x000
    * d1 MRET_1   MRET_2   5 3 2 00001101011011001001| MRET   First save Imm, start build constant for check
    * d2 LB_2     LB_3     1 7 6 00010101100100000110|        Repeat shr until shreg == 0 (0,8,16,24 times)
    * d3 aFaultd  aFault_1 c 5 2 00110101011000011110|  err   LB Load access fault. Faulting adr to mtval
    * d4 aFault_2 LDAF_3   5 d 3 01100100x10010010010|        Store 5 to mcause
    * d5 eFetch2  eFetch3  c 5 e 01000011010010110100|  Fr10  Update ttime
    * d6 eILL0c   ILLe     3 3 2 000xxxx0xxx011111110| Illegal instruction seen
    * d7 ECALL_3  ECALL_4  c 5 2 00110101011010100001|        mtval = 0, now start the chore of 11 to mcause
    * d8 BLTU     condb_2  5 3 2 00111101011000010011| BLTU   Conditional Branch. Offset to Ryy
    * d9 MULH_3   MULHU_2  3 3 2 100111110xx001000010|        rM<=RS2, Q = 0. next read RS1. Join.
    * da LDAF_a   LDAF_2   3 3 2 000101010xx010010001|        Extra cycle after error detected write mtval
    * db jFault_1 LDAF_3   5 5 3 01111000x10010010010|        Store 1 to mcause
    * dc CSRRSI_0 CSRRW_1  5 3 2 00101101011001001001| CSRRSI Decoded CSR adr in yy
    * dd aF_SW_1  aF_SW_2  c 5 2 00110101011011100101|  err   SW Store access fault. Faulting adr to mtval
    * de Fetch    Fetch2   5 3 a 00000111011011110100|  Fr10  Read and latch instruction
    * df eFetch   eFetch2  5 1 b 00010111011011010101|  Fr10  rep Read until d=mem[(rs1+ofs) & ~3u]
    * e0 DIVU_1   DIVU_2   5 3 2 00110111000011001010|        Store inverted rs2 to yy. Prepare shift
    * e1 ORI_1    ORI_2    1 3 2 00000001100000011101|        Q = RS1
    * e2 MUL_1    MUL_2    0 6 6 00010101110111101000|        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar
    * e3 MUL_3    ANDI_1   3 3 6 110101110xx100011010|        Transfer rM to rDee
    * e4 ANDI_0   ANDI_1   0 3 2 00011111101000011010| ANDI   And immediate. Q=~Iimm
    * e5 aF_SW_2  aF_SW_3  3 3 3 11010101110010110000|        Q = 4
    * e6 StdIncPc Fetch    6 4 4 11011010110011011110|  Fr10  IncPC, OpFetch
    * e7 aFault   aFault_1 c 5 2 00110101011000011110|  err   Load access fault. Faulting adr to mtval
    * e8 MUL_2    MUL_1    1 3 2 10011101100011100010|        Shift Q and rM. Prepare read rs2
    * e9 IJT_3    IJT_4    0 3 3 01011001110011000110|        Construct Q = 1
    * ea MULHU_5  MULHU_6  0 3 2 00011001110000100010|        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy
    * eb LH_3     LH_4     0 3 2 00001111101001010110|        q = ~mem[rs1+ofs]
    * ec AND_0    AND_1    3 3 2 000111110xx000010001| AND    And 
    * ed REMU_0   DIVU_1   3 6 2 100111010xx011100000| REMU   Store dividend to rM. Prepare read divisor.Q=0
    * ee eILL0a   ILLe     3 3 2 000xxxx0xxx011111110| Illegal instruction seen
    * ef WFI_5    Fetch    6 4 3 11011010110011011110|        IncPC, OpFetch
    * f0 LBU_2    LBU_3    1 7 6 00010101100101110010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * f1 aFaulte  aFault_1 c 5 2 00110101011000011110|  err   LBU Load access fault. Faulting adr to mtval
    * f2 SW_2     StdIncPc 3 3 2 000001010xx011100110|        Prepare read PC
    * f3 aF_SW    aF_SW_1  3 3 2 000xxxx01xx011011101|  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf
    * f4 Fetch2   unalignd c 5 f 01011111110001110011|  Fr10  Update ttime. Update I. Q=immediate. Use dinx
    * f5 jFault   jFault_1 c 5 2 00110101011011011011|  err   Fetch access fault. Faulting adr to mtval
    * f6 WFI_1    WFI_2    3 3 3 11011001110011111010| WFI    Chk offset=0x105. Now 0xff. Prep 0xff+4 = 0x103
    * f7 EBREAK_1 EBREAK_2 c 5 2 00100001011010101011| EBREAK mepc = pc, store 0 to mtval
    * f8 BGEU     condb_2  5 3 2 00111101011000010011| BGEU   Conditional Branch. Offset to Ryy
    * f9 MULH_2   MULH_3   5 3 3 01011101010011011001|        Store 1 to Rjj. next read rs2, Q=0
    * fa WFI_2    WFI_3    0 3 3 01010101110001000101|        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104
    * fb SB_3     SB_4     0 3 2 00000001011001101011|        Prepare get back address to use 
    * fc CSRRCI_0 CSRRW_1  5 3 2 00101101011001001001| CSRRCI Decoded CSR adr in yy
    * fd NMI_0    NMI_1    3 3 2 000001010xx001111110| NMI    Get current PC
    * fe ILLe     ILL_1    3 3 2 00000100xxx001000110| Illegal
    * ff QINT_0   QINT_1   3 3 2 000001010xx011000111| INT    Get current PC
    */
   localparam u0_0 = 256'h56e6d010d0e2d8045c33dc5ab88bdc5aba09da07080454e650e6bcbe79d2bc01;
   localparam u0_1 = 256'h0eb75cd456e66ea6083252e60441d613087d10e618169c15f814ac76d81af88b;
   localparam u0_2 = 256'h56e6f642586ac03e1430dc96d821dc961c1dd0270804e63550e65d3950e6bc52;
   localparam u0_3 = 256'he03ae0355903d6490832593d50e6d61310d77c037836a8de129e0886f82b56e6;
   localparam u0_4 = 256'h5c7400fed02ed03148b1dc661c4bdc66508f40475c65fa2b08ea5d60500bbc50;
   localparam u0_5 = 256'h4eda79707cfbd6490832785df69c796e188b1a57561e59eb4eda79544eda70e6;
   localparam u0_6 = 256'h1ccfc8b9d02ed031987a50f9588b50e64693c8f210effa2b7c587cc8d2f7f842;
   localparam u0_7 = 256'h00001090acded649083288f25ca816aa76f476f4aadeacde5612da1a561e59ba;
   localparam u0_8 = 256'h5ca900fe7882f02954e6711a56e6e09c0000149e79f0fa215c82d0a80000bc85;
   localparam u0_9 = 256'h88f2543490a29068989f243400fed613469378bb7c9424347095203444929634;
   localparam u0_A = 256'h1cc5c03fd0e0c03f509a70c8243458781c616ed0dcafe63a50e6588b5cb6bc5e;
   localparam u0_B = 256'h78c1781f5c75d6497cb5fa1a98c0d61350bd5c9a169bfc730000acde5cb24492;
   localparam u0_C = 256'hd04f00fe7882f02696e69cc2dca59c6210cb5a471a6ff2e17c8a7cca56e9d888;
   localparam u0_D = 256'h76d576f456e5d64984925091f042d61356a100fe34b44492561e5906d6c91c37;
   localparam u0_E = 256'hacde00fed0e0f011fa569c229cc6d8e2561eacde5cb0fa1a711a5de8181d70ca;
   localparam u0_F = 256'h50c74046507ed649166b5c45d4d9d61316ab9cfa56dbfc7308dd50e6561e5972;
   localparam u1_0 = 256'h4322332133291321033453050320530513200320332043263320222511110005;
   localparam u1_1 = 256'h5520333d83222321332083225524532373223320135003350321644d03210321;
   localparam u1_2 = 256'h4322532916213321033493050321930503245321332006013320036143229007;
   localparam u1_3 = 256'h160116018763532233208663832a5323a3528723862374217520732203214372;
   localparam u1_4 = 256'h333d332076233321b921288503342885a523a323033503210320066173232085;
   localparam u1_5 = 256'hc523111177235322332076235323136d03211321c5231761c5231111c5238193;
   localparam u1_6 = 256'h03347323762333211b21532303218322c522b521335003210a35063553521329;
   localparam u1_7 = 256'hd600a3225425532233208521033d532201b103a07421543503200320c5231761;
   localparam u1_8 = 256'h033133201c293321433e336d43223a29d60055241111032103255321d6000005;
   localparam u1_9 = 256'hb321d34e1a291a29e8216d2733205323c5227623333d7d23a323a3236d3ecd22;
   localparam u1_A = 256'h0334332136293321a32333295d370a29032423810334060183220321333d9007;
   localparam u1_B = 256'h112111210334532277230320033153237323333d0320c3c5d600643d333d6d26;
   localparam u1_C = 256'h335033201c293321cd2213d9332413d9a322a323032053210a35063553231351;
   localparam u1_D = 256'h51b153a0c52353225537332133295323c5233320c5e45d36c523176153200334;
   localparam u1_E = 256'h643d3320362933210320032103351329c523644d333d0321336d066113205323;
   localparam u1_F = 256'h33203320332053220320033553355323c522333dc523c5f533203320c5231761;
   wire [31:0]   indir;
`ifdef verilator
   /* verilator lint_off UNUSED */
   wire [15:0]   sim_a;
   wire [15:0]   sim_b;
   /* verilator lint_on UNUSED */
`endif
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u0_0), .INIT_1(u0_1), .INIT_2(u0_2), .INIT_3(u0_3),
                   .INIT_4(u0_4), .INIT_5(u0_5), .INIT_6(u0_6), .INIT_7(u0_7),
                   .INIT_8(u0_8), .INIT_9(u0_9), .INIT_A(u0_A), .INIT_B(u0_B),
                   .INIT_C(u0_C), .INIT_D(u0_D), .INIT_E(u0_E), .INIT_F(u0_F)
                   ) ucode0
     (
      .RDATA( indir[15:0]         ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u1_0), .INIT_1(u1_1), .INIT_2(u1_2), .INIT_3(u1_3),
                   .INIT_4(u1_4), .INIT_5(u1_5), .INIT_6(u1_6), .INIT_7(u1_7),
                   .INIT_8(u1_8), .INIT_9(u1_9), .INIT_A(u1_A), .INIT_B(u1_B),
                   .INIT_C(u1_C), .INIT_D(u1_D), .INIT_E(u1_E), .INIT_F(u1_F)
                   ) ucode1
     (
      .RDATA( indir[31:16]        ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );

   assign d[0] = indir[0];
   assign d[1] = indir[1];
   assign d[2] = indir[2];
   assign d[3] = indir[3];
   assign d[4] = indir[4];
   assign d[5] = indir[5];
   assign d[6] = indir[6];
   assign d[7] = indir[7];
   assign d[8] = indir[8];
   assign d[12] = indir[9];
   assign d[13] = indir[10];
   assign d[16] = indir[11];
   assign d[17] = indir[12];
   assign d[22] = indir[13];
   assign d[23] = indir[14];
   assign d[24] = indir[15];
   assign d[25] = indir[16];
   assign d[28] = indir[17];
   assign d[42] = indir[18];
   assign d[43] = indir[19];
   // replaces = 1000000100100101000000000101001100011000000000
   SB_LUT4 #(.LUT_INIT(16'h1098)) cmb_d09(.O(d[9]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'h3018)) cmb_d10(.O(d[10]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'h0020)) cmb_d14(.O(d[14]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'h0c00)) cmb_d15(.O(d[15]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'hc000)) cmb_d18(.O(d[18]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'hfffe)) cmb_d20(.O(d[20]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'h9000)) cmb_d30(.O(d[30]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'h0100)) cmb_d32(.O(d[32]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'h0802)) cmb_d35(.O(d[35]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'h0a00)) cmb_d38(.O(d[38]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'h0010)) cmb_d45(.O(d[45]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   // replaces = 0100110011011000001000001000000000000000000000
   SB_LUT4 #(.LUT_INIT(16'h2f3f)) cmb_d21(.O(d[21]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h2a30)) cmb_d27(.O(d[27]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0012)) cmb_d33(.O(d[33]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0080)) cmb_d34(.O(d[34]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h2004)) cmb_d36(.O(d[36]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h2200)) cmb_d37(.O(d[37]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0915)) cmb_d40(.O(d[40]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0900)) cmb_d41(.O(d[41]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h1400)) cmb_d44(.O(d[44]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   // replaces = 0000001000000010100100000010000000100000000000
   SB_LUT4 #(.LUT_INIT(16'h4d82)) cmb_d11(.O(d[11]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h5fb7)) cmb_d19(.O(d[19]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h5c00)) cmb_d26(.O(d[26]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h16e0)) cmb_d29(.O(d[29]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0204)) cmb_d31(.O(d[31]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h400f)) cmb_d39(.O(d[39]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   assign d[46] = 1'b0;
   assign d[47] = 1'b0;
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019-2020. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * Automatically generated from ../code/ucode.h by midgetv_indirectEBR.c.
 * Do not edit.
 * Optiones for this variant:
 *   RVC included
 *   MULDIV included
 *   minstret for instructions in SRAM and EBR
 */
/* Using LUTSIZE=4. Using 2 EBRs. Initial table has 46 columns
 * Removed:  0000000000000000000000000000000000000000000000 These are removed from consideration, replaced with hand-crafted Verilog code in the output stage
 * Reserved: 0000000000000000000000000000000000000000000000 Columns to be represented directly, not part of optimalization
 * Total columns to represent in EBRs: 46
 * 209 distinct lines in remaining untreated columns
 * c45 c44 c43 c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 * 208 209 208 209 209 209 209 209 209 209 209 209 209 209 209 209 209 209 209 209 208 209 207 208 209 209 209 209 209 209 209 209 208 206 207 209 208 209 208 209 208 209 209 208 207 208  kill col 12  Tbl  45 cols 0000000000000000000000000000000001000000000000 has 206 unique lines.
 * 205 206 205 205 206 206 206 206 206 206 206 206 206 206 206 206 206 206 206 206 204 206 204 203 206 206 206 206 206 206 206 206 204     204 206 205 206 205 206 205 206 206 205 204 205  kill col 22  Tbl  44 cols 0000000000000000000000010000000001000000000000 has 203 unique lines.
 * 202 203 202 202 203 203 203 203 203 203 203 203 203 203 203 203 203 203 203 203 202 202 201     203 203 203 203 203 203 203 203 201     201 203 202 203 202 202 201 203 203 202 201 201  kill col 23  Tbl  43 cols 0000000000000000000000110000000001000000000000 has 201 unique lines.
 * 200 201 200 200 201 201 201 201 201 201 201 201 201 201 201 201 201 201 200 200 199 200         201 201 201 201 201 201 201 201 199     199 201 200 201 200 200 199 201 201 199 199 199  kill col 25  Tbl  42 cols 0000000000000000000010110000000001000000000000 has 199 unique lines.
 * 198 199 198 198 199 199 199 199 199 199 199 199 199 199 199 199 199 199 198 198     198         199 199 199 199 199 199 199 199 197     197 199 198 199 197 198 197 198 199 197 197 197  kill col 13  Tbl  41 cols 0000000000000000000010110000000011000000000000 has 197 unique lines.
 * 196 197 196 196 197 197 197 197 197 197 197 197 197 197 197 197 197 197 196 196     196         197 197 197 197 197 197 197 197         194 197 196 196 195 196 195 195 197 195 195 195  kill col 11  Tbl  40 cols 0000000000000000000010110000000011100000000000 has 194 unique lines.
 * 193 194 193 190 194 194 194 194 194 194 194 194 194 194 194 194 194 194 193 193     193         194 194 194 194 194 194 194 194             194 193 193 192 193 192 191 194 192 192 192  kill col 42  Tbl  39 cols 0001000000000000000010110000000011100000000000 has 190 unique lines.
 * 189 190 189     190 190 190 190 190 190 190 190 190 190 190 190 190 190 189 189     189         190 190 189 190 190 190 190 190             190 189 189 188 189 188 187 190 188 188 188  kill col  4  Tbl  38 cols 0001000000000000000010110000000011100000010000 has 187 unique lines.
 * 186 187 186     187 187 187 187 187 187 187 187 187 187 187 187 187 187 185 186     186         187 187 186 187 187 186 187 187             187 186 186 185 186 185     186 185 185 185  kill col 27  Tbl  37 cols 0001000000000000001010110000000011100000010000 has 185 unique lines.
 * 184 185 184     185 185 185 185 185 185 185 185 185 185 185 185 185 185     184     184         185 185 184 185 185 184 185 185             185 184 184 183 184 183     184 183 183 183  kill col  7  Tbl  36 cols 0001000000000000001010110000000011100010010000 has 183 unique lines.
 * 182 183 182     183 183 183 183 183 183 183 183 183 183 183 183 183 182     182     181         183 183 182 183 182 181 183 183             181 182 182     182 176     180 178 180 179  kill col  5  Tbl  35 cols 0001000000000000001010110000000011100010110000 has 176 unique lines.
 * 175 176 175     176 176 176 176 176 176 176 176 175 176 176 176 176 175     173     171         176 176 175 176 174 174 176 176             175 175 175     171         166 167 171 168  kill col  3  Tbl  34 cols 0001000000000000001010110000000011100010111000 has 166 unique lines.
 * 165 166 165     166 166 166 166 166 166 166 166 165 166 166 166 166 165     162     159         166 166 164 166 163 164 166 165             165 165 165     158             154 155 155  kill col  2  Tbl  33 cols 0001000000000000001010110000000011100010111100 has 154 unique lines.
 * 153 154 152     154 154 154 154 154 154 154 154 152 154 154 154 153 150     149     145         154 154 150 154 149 149 154 150             153 153 152     141                 135 143  kill col  1  Tbl  32 cols 0001000000000000001010110000000011100010111110 has 135 unique lines.
 * 134 135 132     134 135 135 135 135 135 135 131 133 135 135 135 133 131     131     123         133 135 130 135 129 130 134 130             134 134 132     116                     121  kill col  6  Tbl  31 cols 0001000000000000001010110000000011100011111110 has 116 unique lines.
 * 115 116 111     115 116 116 116 116 116 116 113 115 115 114 116 114 112     112     102         112 116 110 116 110 109 115 110             115 115 112                             100  kill col  0  Tbl  30 cols 0001000000000000001010110000000011100011111111 has 100 unique lines.
 *  99  99  93      99 100 100 100 100 100 100  96  99  99  98 100  97  97      96      89          94 100  95 100  94  93  99  94              99  99  95                                  kill col 24  Tbl  29 cols 0001000000000000001011110000000011100011111111 has  89 unique lines.
 *  88  87  83      88  89  88  89  88  89  89  85  88  88  87  89  85  87      84                  83  89  84  89  83  80  88  85              88  87  83                                  kill col 16  Tbl  28 cols 0001000000000000001011110000010011100011111111 has  80 unique lines.
 *  79  78  74      79  80  79  80  79  80  80  76  79  79  78  79  76  78      75                  73  79  73  80  75      79  76              79  78  74                                  kill col 21  Tbl  27 cols 0001000000000000001011111000010011100011111111 has  73 unique lines.
 *  72  71  67      72  73  72  73  72  73  73  69  72  72  71  72  70  71      68                      71  66  73  68      72  69              72  71  68                                  kill col 19  Tbl  26 cols 0001000000000000001011111010010011100011111111 has  66 unique lines.
 *  64  64  59      65  66  64  66  65  66  66  62  65  65  64  65  63  64      61                      63      66  61      65  63              65  64  62                                  kill col 43  Tbl  25 cols 0011000000000000001011111010010011100011111111 has  59 unique lines.
 *  57  56          58  59  57  59  58  59  59  55  58  58  57  58  56  57      54                      56      59  54      58  56              57  57  56                                  kill col 26  Tbl  24 cols 0011000000000000001111111010010011100011111111 has  54 unique lines.
 *  52  51          53  54  52  54  53  54  54  50  53  53  52  52  51  52                              51      53  49      53  52              52  52  51                                  kill col 17  Tbl  23 cols 0011000000000000001111111010110011100011111111 has  49 unique lines.
 *  47  47          48  47  47  49  48  49  49  45  48  48  47  47  44  46                              46      48          48  47              47  47  46                                  kill col 29  Tbl  22 cols 0011000000000000101111111010110011100011111111 has  44 unique lines.
 *  42  42          43  42  40  44  43  44  44  41  43  43  42  42      42                              42      43          43  42              42  42  41                                  kill col 39  Tbl  21 cols 0011001000000000101111111010110011100011111111 has  40 unique lines.
 *  38  38          39  37      40  39  40  40  37  39  39  38  38      35                              38      39          39  38              38  38  37                                  kill col 28  Tbl  20 cols 0011001000000000111111111010110011100011111111 has  35 unique lines.
 *  33  33          34  31      34  34  34  35  33  34  34  32  33                                      33      34          34  34              33  33  33                                  kill col 40  Tbl  19 cols 0011011000000000111111111010110011100011111111 has  31 unique lines.
 *  29  29          29          30  30  29  31  29  28  30  29  29                                      29      30          30  30              29  29  29                                  kill col 33  Tbl  18 cols 0011011000001000111111111010110011100011111111 has  28 unique lines.
 *  27  26          26          27  27  26  27  26      27  26  26                                      26      27          27  27              26  26  26                                  kill col 44  Tbl  17 cols 0111011000001000111111111010110011100011111111 has  26 unique lines.
 *  25              24          25  25  24  25  24      25  24  24                                      24      25          25  25              24  24  24                                  kill col 41  Tbl  16 cols 0111111000001000111111111010110011100011111111 has  24 unique lines.
 *  23                          23  23  22  23  22      23  22  22                                      22      23          23  23              22  22  22                                  kill col 36  Tbl  15 cols 0111111001001000111111111010110011100011111111 has  22 unique lines.
 *  21                          21  20      21  20      21  20  20                                      20      21          21  21              20  20  20                                  kill col 37  Tbl  14 cols 0111111011001000111111111010110011100011111111 has  20 unique lines.
 *  19                          19          19  18      19  18  18                                      18      19          19  19              18  18  18                                  kill col 34  Tbl  13 cols 0111111011011000111111111010110011100011111111 has  18 unique lines.
 *  17                          17          17          17  16  16                                      16      17          17  17              16  16  17                                  kill col 31  Tbl  12 cols 0111111011011010111111111010110011100011111111 has  16 unique lines.
Possible good candidates for removal, columns : 8 9 10 20 30 
 *
 * Round 1: 1000000100100101000000000101001100011100000000  4 columns for indexes to table representing 12 original columns (uses 16 of 16 lines in indirect table).
 * Total columns to represent in EBRs: 38
 * 206 distinct lines in remaining untreated columns
 * c45 c44 c43 c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 *   x 206 203 206 206 206 206   x 206 206   x 206 206   x 206   x 206 206 206 206 205 206 204 205 206   x 204   x 206 206   x   x 205 203 204   x   x   x 205 206 205 206 206 205 204 205  kill col 43  Tbl  33 cols 1010000100100101000000000101001100011100000000 has 203 unique lines.
 *   x 203     203 203 203 203   x 203 203   x 203 203   x 203   x 203 203 203 203 202 203 201 202 203   x 200   x 203 203   x   x 202 200 201   x   x   x 202 203 202 203 203 202 201 202  kill col 19  Tbl  32 cols 1010000100100101000000000111001100011100000000 has 200 unique lines.
 *   x 200     200 200 200 200   x 200 200   x 200 200   x 200   x 200 200 200 200 199 200 198 199 200   x       x 200 200   x   x 199 197 198   x   x   x 199 200 199 200 200 199 198 199  kill col 12  Tbl  31 cols 1010000100100101000000000111001101011100000000 has 197 unique lines.
 *   x 197     196 197 197 197   x 197 197   x 197 197   x 197   x 197 197 197 197 195 197 195 194 197   x       x 197 197   x   x 195     195   x   x   x 196 197 196 197 197 196 195 196  kill col 22  Tbl  30 cols 1010000100100101000000010111001101011100000000 has 194 unique lines.
 *   x 194     193 194 194 194   x 194 194   x 194 194   x 194   x 194 194 194 194 193 193 192     194   x       x 194 194   x   x 191     192   x   x   x 193 193 192 194 194 193 192 192  kill col 13  Tbl  29 cols 1010000100100101000000010111001111011100000000 has 191 unique lines.
 *   x 191     190 191 191 191   x 191 191   x 191 191   x 191   x 191 191 191 191 190 190 189     191   x       x 191 191   x   x         188   x   x   x 190 190 189 190 191 190 189 189  kill col 11  Tbl  28 cols 1010000100100101000000010111001111111100000000 has 188 unique lines.
 *   x 188     183 188 188 188   x 188 188   x 188 188   x 188   x 188 188 188 188 187 187 186     188   x       x 188 186   x   x               x   x   x 187 186 186 186 188 187 185 186  kill col 42  Tbl  27 cols 1011000100100101000000010111001111111100000000 has 183 unique lines.
 *   x 183         183 183 183   x 183 183   x 183 183   x 183   x 183 183 183 183 182 182 181     183   x       x 183 181   x   x               x   x   x 182 181 179 181 183 181 180 180  kill col  5  Tbl  26 cols 1011000100100101000000010111001111111100100000 has 179 unique lines.
 *   x 179         179 179 179   x 179 179   x 179 178   x 179   x 179 179 179 179 178 177 175     179   x       x 179 175   x   x               x   x   x 171 177     176 178 174 173 174  kill col  7  Tbl  25 cols 1011000100100101000000010111001111111110100000 has 171 unique lines.
 *   x 171         171 171 171   x 171 171   x 171 170   x 171   x 171 170 171 171 170 166 168     171   x       x 170 166   x   x               x   x   x     169     167 167 163 163 166  kill col  2  Tbl  24 cols 1011000100100101000000010111001111111110100100 has 163 unique lines.
 *   x 163         163 163 163   x 163 163   x 163 161   x 163   x 163 162 162 163 160 158 158     161   x       x 161 158   x   x               x   x   x     158     159 157     156 157  kill col  1  Tbl  23 cols 1011000100100101000000010111001111111110100110 has 156 unique lines.
 *   x 154         156 156 156   x 156 156   x 155 153   x 156   x 155 155 155 156 153 150 149     153   x       x 154 146   x   x               x   x   x     145     146 144         146  kill col  3  Tbl  22 cols 1011000100100101000000010111001111111110101110 has 144 unique lines.
 *   x 141         144 144 144   x 144 144   x 142 141   x 144   x 143 143 143 142 138 135 136     139   x       x 140 133   x   x               x   x   x     125     127             124  kill col  0  Tbl  21 cols 1011000100100101000000010111001111111110101111 has 124 unique lines.
 *   x 121         124 123 124   x 124 124   x 121 121   x 124   x 123 123 123 121 115 113 115     120   x       x 120 112   x   x               x   x   x     101     104                  kill col  6  Tbl  20 cols 1011000100100101000000010111001111111111101111 has 101 unique lines.
 *   x  97         101 100 101   x 101 100   x  99  98   x 100   x 100  99  99  97  90  91  93      97   x       x  96  90   x   x               x   x   x              78                  kill col  4  Tbl  19 cols 1011000100100101000000010111001111111111111111 has  78 unique lines.
 *   x  75          78  77  78   x  78  77   x  75  76   x  76   x  76  75  75  74  70  71  71      73   x       x  71  68   x   x               x   x   x                                  kill col 16  Tbl  18 cols 1011000100100101000000010111011111111111111111 has  68 unique lines.
 *   x  64          68  67  68   x  68  67   x  65  67   x  66   x  66  65  64  64  61  61  62      62   x       x  59       x   x               x   x   x                                  kill col 17  Tbl  17 cols 1011000100100101000000010111111111111111111111 has  59 unique lines.
 *   x  55          59  58  59   x  59  58   x  56  58   x  56   x  56  56  56  55  51  51  52      54   x       x           x   x               x   x   x                                  kill col 25  Tbl  16 cols 1011000100100101000010010111111111111111111111 has  51 unique lines.
 *   x  47          51  50  51   x  51  50   x  48  49   x  48   x  47  49  48  47      45  44      45   x       x           x   x               x   x   x                                  kill col 23  Tbl  15 cols 1011000100100101000010110111111111111111111111 has  44 unique lines.
 *   x  41          43  43  43   x  44  43   x  41  42   x  41   x  39  41  40  40      38          38   x       x           x   x               x   x   x                                  kill col 24  Tbl  14 cols 1011000100100101000011110111111111111111111111 has  38 unique lines.
 *   x  36          37  36  37   x  37  37   x  35  35   x  35   x  32  33  33  32                  34   x       x           x   x               x   x   x                                  kill col 29  Tbl  13 cols 1011000100100101100011110111111111111111111111 has  32 unique lines.
 *   x  30          31  30  28   x  31  31   x  30  29   x  29   x      26  28  27                  28   x       x           x   x               x   x   x                                  kill col 28  Tbl  12 cols 1011000100100101110011110111111111111111111111 has  26 unique lines.
 *   x  24          25  23  20   x  25  24   x  24  24   x  23   x          24  23                  23   x       x           x   x               x   x   x                                  kill col 39  Tbl  11 cols 1011001100100101110011110111111111111111111111 has  20 unique lines.
 *   x  18          19  18       x  19  18   x  19  19   x  18   x          18  17                  18   x       x           x   x               x   x   x                                  kill col 26  Tbl  10 cols 1011001100100101110111110111111111111111111111 has  17 unique lines.
 *   x  15          15  15       x  16  15   x  16  16   x  14   x          15                      15   x       x           x   x               x   x   x                                  kill col 31  Tbl   9 cols 1011001100100111110111110111111111111111111111 has  14 unique lines.
Possible good candidates for removal, columns : 21 
 *
 * Round 2: 0100110011011000001000001000000000000000000000  4 columns for indexes to table representing  9 original columns (uses 14 of 16 lines in indirect table).
 * Total columns to represent in EBRs: 33
 * 206 distinct lines in remaining untreated columns
 * c45 c44 c43 c42 c41 c40 c39 c38 c37 c36 c35 c34 c33 c32 c31 c30 c29 c28 c27 c26 c25 c24 c23 c22 c21 c20 c19 c18 c17 c16 c15 c14 c13 c12 c11 c10  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 
 *   x   x 203 206   x   x 206   x   x   x   x   x   x   x 206   x 206 206   x 205 204 206 203 205   x   x 204   x 206 206   x   x 205 203 204   x   x   x 205 205 205 206 206 205 203 205  kill col 43  Tbl  24 cols 1110110111111101001000001101001100011100000000 has 203 unique lines.
 *   x   x     203   x   x 203   x   x   x   x   x   x   x 203   x 203 203   x 202 201 203 200 202   x   x 200   x 203 203   x   x 202 200 201   x   x   x 202 202 202 203 203 202 200 202  kill col 23  Tbl  23 cols 1110110111111101001000101101001100011100000000 has 200 unique lines.
 *   x   x     200   x   x 200   x   x   x   x   x   x   x 200   x 200 200   x 199 197 200     199   x   x 197   x 200 200   x   x 199 197 198   x   x   x 199 199 199 200 200 198 197 199  kill col 25  Tbl  22 cols 1110110111111101001010101101001100011100000000 has 197 unique lines.
 *   x   x     197   x   x 197   x   x   x   x   x   x   x 197   x 197 197   x 196     196     195   x   x 194   x 197 197   x   x 196 193 195   x   x   x 195 196 196 195 197 194 194 196  kill col 12  Tbl  21 cols 1110110111111101001010101101001101011100000000 has 193 unique lines.
 *   x   x     192   x   x 193   x   x   x   x   x   x   x 193   x 193 193   x 192     192     190   x   x 190   x 193 193   x   x 191     191   x   x   x 191 192 192 191 193 190 190 192  kill col 22  Tbl  20 cols 1110110111111101001010111101001101011100000000 has 190 unique lines.
 *   x   x     189   x   x 190   x   x   x   x   x   x   x 190   x 190 190   x 189     188           x   x 187   x 190 190   x   x 187     188   x   x   x 188 188 188 188 189 187 185 188  kill col  1  Tbl  19 cols 1110110111111101001010111101001101011100000010 has 185 unique lines.
 *   x   x     184   x   x 185   x   x   x   x   x   x   x 185   x 185 185   x 184     182           x   x 182   x 185 185   x   x 182     183   x   x   x 183 179 180 183 180 182     182  kill col  6  Tbl  18 cols 1110110111111101001010111101001101011101000010 has 179 unique lines.
 *   x   x     177   x   x 179   x   x   x   x   x   x   x 179   x 179 179   x 177     174           x   x 176   x 179 177   x   x 175     176   x   x   x 176     174 174 172 173     172  kill col  3  Tbl  17 cols 1110110111111101001010111101001101011101001010 has 172 unique lines.
 *   x   x     169   x   x 172   x   x   x   x   x   x   x 172   x 172 172   x 170     162           x   x 168   x 171 170   x   x 167     166   x   x   x 166     160 162     160     160  kill col  5  Tbl  16 cols 1110110111111101001010111101001101011101101010 has 160 unique lines.
 *   x   x     154   x   x 160   x   x   x   x   x   x   x 160   x 159 160   x 156     144           x   x 156   x 158 156   x   x 151     152   x   x   x 148         149     144     145  kill col 24  Tbl  15 cols 1110110111111101001011111101001101011101101010 has 144 unique lines.
 *   x   x     137   x   x 144   x   x   x   x   x   x   x 143   x 143 141   x 140                   x   x 140   x 137 140   x   x 134     134   x   x   x 128         132     126     127  kill col  2  Tbl  14 cols 1110110111111101001011111101001101011101101110 has 126 unique lines.
 *   x   x     118   x   x 125   x   x   x   x   x   x   x 125   x 122 123   x 121                   x   x 121   x 118 120   x   x 116     117   x   x   x 105         110             105  kill col  7  Tbl  13 cols 1110110111111101001011111101001101011111101110 has 105 unique lines.
 *   x   x      97   x   x 104   x   x   x   x   x   x   x 102   x 100 100   x  96                   x   x 100   x  94  95   x   x  94      97   x   x   x              84              81  kill col  0  Tbl  12 cols 1110110111111101001011111101001101011111101111 has  81 unique lines.
 *   x   x      73   x   x  80   x   x   x   x   x   x   x  78   x  76  75   x  73                   x   x  76   x  72  68   x   x  71      74   x   x   x              60                  kill col  4  Tbl  11 cols 1110110111111101001011111101001101011111111111 has  60 unique lines.
 *   x   x      53   x   x  59   x   x   x   x   x   x   x  58   x  54  54   x  53                   x   x  55   x  51  48   x   x  52      54   x   x   x                                  kill col 16  Tbl  10 cols 1110110111111101001011111101011101011111111111 has  48 unique lines.
 *   x   x      42   x   x  46   x   x   x   x   x   x   x  45   x  43  41   x  42                   x   x  42   x  37       x   x  38      40   x   x   x                                  kill col 17  Tbl   9 cols 1110110111111101001011111101111101011111111111 has  37 unique lines.
 *   x   x      30   x   x  34   x   x   x   x   x   x   x  33   x  30  30   x  32                   x   x  32   x           x   x  29      30   x   x   x                                  kill col 13  Tbl   8 cols 1110110111111101001011111101111111011111111111 has  29 unique lines.
 *   x   x      22   x   x  26   x   x   x   x   x   x   x  25   x  24  23   x  24                   x   x  24   x           x   x          23   x   x   x                                  kill col 42  Tbl   7 cols 1111110111111101001011111101111111011111111111 has  22 unique lines.
 *   x   x           x   x  19   x   x   x   x   x   x   x  19   x  17  15   x  17                   x   x  18   x           x   x          17   x   x   x                                  kill col 28  Tbl   6 cols 1111110111111101011011111101111111011111111111 has  15 unique lines.
Possible good candidates for removal, columns : 19 
 *
 * Round 3: 0000001000000010100100000010000000100000000000  4 columns for indexes to table representing  6 original columns (uses 15 of 16 lines in indirect table).
 * Direct:  0011000000000000010011110000110011000011111111 19 columns
 * Can even chose 1 more column to be represented directly.
 * Success. Use 2 EBRs, 26 LUTs.
 */

module v15_m_2ebr
  (
   input         clk,
   input [7:0]   minx,
   input         progress_ucode,
/* verilator lint_off UNOPTFLAT */
   output [47:0] d
/* verilator lint_on UNOPTFLAT */
   );
   /*
    *                      indirect_index 2
    *                      | indirect_index 1
    * inx         next     | | indirect index 0
    * || ucode    ucode    | | | direct representation
    * 00 LB_0     LB_1     0 0 0 01011011110000000001| LB     Load byte. q = rdadr=RS1+0fs
    * 01 LB_1     LB_2     1 1 1 00010111100111010010|        Read until q=mem[rs1+ofs) & ~3u]
    * 02 IJ_0     IJ_1     2 2 2 01011011110010111110| IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0
    * 03 _L0x03   StdIncPc 3 3 2 000001010xx011100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 04 ADDI_0   StdIncPc 4 3 2 01100101010011100110| ADDI   Add immediate. rd =RS1+Iimm (or joined)
    * 05 _L0x05   ADDI_0   3 3 2 000000001xx000000100| AUIPC  q = imm20+2 or imm20+4  (copy x/2)
    * 06 LB_3     LB_4     0 3 2 00001101101000000111|        q = ~mem[rs1+ofs]
    * 07 LB_4     LB_5     1 3 2 00001011101000001001|        q = (uint8_t) mem[rs1+Iimm]
    * 08 _L0x08   SB_1     5 3 0 01011101110001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 09 LB_5     LB_6     0 3 2 00001011100010001011|        q = D^0xffffffff^q = D^0x80
    * 0a _L0x0a   SB_1     5 3 0 01011101110001011010| SB     Store byte. wjj=wradr=RS1+Simm
    * 0b JALR_2   JALR_3   0 3 3 01000101110000110011|        Q=1. Prep legalize target
    * 0c ADD_0    ADDI_0   1 3 2 00011101100000000100| ADD    add     Addition Q = RS1
    * 0d MUL_0    MUL_1    3 3 2 100111010xx011100010| MUL    Store rs1 tp rM. Next read rs2. Q clear
    * 0e SUB_0    SUB_1    3 3 2 000111010xx000010000| SUB    Subtraction
    * 0f _L0x0f   StdIncPc 4 3 2 00100101011011100110| LUI    q = imm20
    * 10 SUB_1    LB_6     0 3 2 00011111100010001011|        Q = ~RS2
    * 11 AND_1    ANDI_1   0 3 2 00011101100000011010|        RS1^0xffffffff to Q
    * 12 straddle Fetchu   6 4 4 11011010110001110110|  Fr10u IncPC, OpFetch
    * 13 condb_2  condb_3  0 3 2 00011111100000010100|        ~RS2 in Q
    * 14 condb_3  condb_4  0 3 3 01011001110000010101|        Calculate RS1+~RS2+1
    * 15 condb_4  condb_5  1 3 5 00000001100000010110|        Branch on condition
    * 16 condb_5  StdIncPc 3 3 2 000000010xx011100110|        Branch not taken.
    * 17 condb_5t condb_6t 7 3 2 00100000100001111101|        Branch taken. yy=oldPC incase of access error
    * 18 BEQ      condb_2  5 3 2 00111101011000010011| BEQ    Conditional Branch. Offset to Ryy
    * 19 JALR_0   JALR_1   5 5 2 01000000x10001000001| JALR   (tmp) Prep pc=RS1+imm (target)
    * 1a ANDI_1   StdIncPc 8 3 2 00100101001011100110|        rd = Iimm & RS1
    * 1b _L0x1b   JAL_1    3 3 2 000000001xx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 1c ECAL_BRK ECAL_RET 2 3 2 00010110111010100110| ECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI
    * 1d ORI_2    StdIncPc 8 3 2 00100101011011100110|        rd = Iimm | RS1
    * 1e aFault_1 aFault_2 3 3 3 11010101110011010100|        Q = 4
    * 1f IJ_2     IJ_3     5 5 2 00000000111010110111|        Read word is to be masked with lsb = 0
    * 20 LH_0     LH_1     9 0 0 01111011110001010010| LH     Load hword. Q = rdadr=RS1+Iimm.
    * 21 XORI_1   StdIncPc 4 3 2 00100101000011100110|        rd = Iimm ^ RS1
    * 22 MULHU_6  MULHU_7  0 3 6 00010101110100111001|        Q <= rM[0] ? Q+Ryy : Q. Prepare last shr/sar
    * 23 _L0x23   StdIncPc 3 3 2 000001010xx011100110| FENCE  Prepare read PC (FENCE/FENCE.I)
    * 24 SLLI_0   SLLI_1   0 6 0 00011110x11000110101| SLLI   Shift left immediate.
    * 25 _L0x25   ADDI_0   3 3 2 000000001xx000000100| AUIPC  q = imm20+2 or imm20+4  (copy x/2)
    * 26 OR_1     OR_2     5 3 2 00011101000000100111|        RS1^0xffffffff to jj
    * 27 OR_2     ORI_2    0 3 2 01000001110000011101|        Q = rs2
    * 28 _L0x28   SH_1     9 3 0 01011101110010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 29 XOR_1    XORI_1   0 3 2 00011101100000100001|        Q = RS1^0xFFFFFFFF
    * 2a _L0x2a   SH_1     9 3 0 01011101110010010110| SH     Store halfword. jjw=wradr=RS1+Simm
    * 2b SLTIX_1  SLTIX_2  0 3 3 010xxxx1010000110000|        RS1 - imm / RS1 - RS2
    * 2c SLL_0    SLL_1    3 3 2 00011100xxx000111110| SLL    Shift left
    * 2d MULH_0   MULH_1   1 6 2 00010101100001101010| MULH   Store rs1 to Q. Prep read 0, shcnt--
    * 2e MULHU_1  MULHU_2  5 3 2 10011111011001000010|        rM<=RS2,  Rjj<=Q=0. next read RS1. 
    * 2f _L0x2f   StdIncPc 4 3 2 00100101011011100110| LUI    q = imm20
    * 30 SLTIX_2  StdIncPc 4 3 7 00100101011011100110|        Registered ALU flag to rd
    * 31 SLTX_1   SLTIX_1  0 3 2 00011111100000101011|        ~rs2 to Q
    * 32 JAL_1    JAL_2    7 3 2 00100000100010000110|      Prep Instradr to yy. Refetch instradr
    * 33 JALR_3   JAL_25   7 5 2 00000001001010011110|        Q = (RS1+imn) & 0xfffffffe
    * 34 JAL_3    Fetch    7 4 2 00011010100011011110|      Prep fetch next instr.
    * 35 SLLI_1   SLLI_2   8 6 2 00110111100000110110|        Register to shift to Q (and TRG for shift 0)
    * 36 SLLI_2   _L0x03   8 7 2 00110111110000000011|        Repeat Q = Q+Q until shregcnt == 0
    * 37 ECALL_2  ECALL_3  a 3 5 001xxxx1000011010111|        mepc = pc, prep store 0 to mtval
    * 38 BNE      condb_2  5 3 2 00111101011000010011| BNE    Conditional Branch. Offset to Ryy
    * 39 MULHU_7  StdIncPc 8 3 2 10100101000011100110|        Last shift.
    * 3a SRxI_1   SRxI_2   8 6 6 00110101100100111101|        Register to shift to Q
    * 3b _L0x3b   JAL_1    3 3 2 000000001xx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 3c CSRRW_0  CSRRW_1  5 3 2 00101101011001001001| CSRRW  Decoded CSR adr in yy
    * 3d SRxI_2   _L0x03   8 7 6 00110101100100000011|        Repeat Q >>= 1 until shregcnt == 0
    * 3e SLL_1    SLLI_1   1 6 0 00011110x00000110101|        Shiftamount was in low 5 bits of RS2
    * 3f SRx_1    SRxI_1   1 6 0 00011110x00000111010|        Shiftamount in low 5 bits of RS2
    * 40 LW_0     LW_1     2 0 8 01011011110001010000| LW     Load word. Q=yy=rdadr=RS1+Iimm
    * 41 JALR_1   JALR_2   7 3 2 00110101000000001011|        yy=jj. Prep get Q=1
    * 42 MULHU_2  MULHU_3  0 6 6 00010101110101100000|        Q <= rM[0] ? Q+rs1 : Q. Prepare shr/sar
    * 43 MULHU_4  MULHU_5  0 3 2 00000000100011101010|        Prepare read Rjj.
    * 44 SLTI_0   SLTIX_1  0 3 2 00011111101000101011| SLTI   Set less than immediate (signed)
    * 45 WFI_3    WFI_4    0 3 3 01010101110001100101|        Chk ofs. Now 0x104. Prep +1, so ~ofs+0x105
    * 46 ILL_1    ILL_2    a 3 2 00110100x00001000111|        Store PC to mepc
    * 47 ILL_2    ILL_3    a 5 2 00110101000010001111|        Store 0 to mtval
    * 48 _L0x48   SW_1     2 8 8 01011101110001100110| SW     Store word. Q=wradr=RS1+Simm
    * 49 CSRRW_1  CSRRW_2  0 3 3 01000001110001001011|        Construct PC storage adr
    * 4a _L0x4a   SW_1     2 8 8 01011101110001100110| SW     Store word. Q=wradr=RS1+Simm
    * 4b CSRRW_2  CSRRW_3  b 9 2 00010100100010110001|        Write PC to 0x100 start Prep emulation entrypt
    * 4c SLT_0    SLTX_1   3 3 2 000111010xx000110001| SLT    Set less than (signed)
    * 4d MULHSU_0 MULHU_1  7 6 2 00111101000000101110| MULHSU Signed rs1 to Ryy, nxt rd rs2. Q=0, shcnt--
    * 4e eILL0b   ILLe     3 3 2 000xxxx0xxx011111110| Illegal instruction seen
    * 4f MRET_8   MRET_9   3 3 3 11010101110001110100|        +4, so now 0x103
    * 50 LW_1     StdIncPc 8 1 9 00110111000011100110|        Read until d=mem[(rs1+ofs) & ~3u]
    * 51 LDAF_LW  LDAF_a   c 5 2 00110100111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 52 LH_1     LH_2     1 1 1 00010111100101010100|        Read until q=mem[(rs1+ofs) & ~3u]
    * 53 LDAF_LH  LDAF_a   c 5 2 00110100111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 54 LH_2     LH_3     1 7 6 00010101100111101011|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 55 aFaultb  aFault_1 c 5 2 00110101011000011110|  err   LH Load access fault. Faulting adr to mtval
    * 56 LH_4     LH_5     1 3 2 00010001101001010111|        q = (uint16_t) mem[rs1+Iimm]
    * 57 LH_5     LB_6     0 3 2 00010001100010001011|        q = D^0xffffffff^q = D ^ 0x00008000
    * 58 DIV_A    DIV_C    1 3 6 11010111100101101110|        Transfer rM to rDee
    * 59 DIV_B    DIV_10   5 3 2 00111111011010011100|        REM = Q to yy
    * 5a SB_1     SB_2     7 6 2 00110111100001011101|        Write d to Q and yy (for sh 0). Prep shift
    * 5b _L0x5b   JAL_1    3 3 2 000000001xx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 5c CSRRS_0  CSRRW_1  5 3 2 00101101011001001001| CSRRS  Decoded CSR adr in yy
    * 5d SB_2     SB_3     7 7 2 00110111110011111011|        Repeat shl until shreg = 0 (0,8,16 or 24 times)
    * 5e LHU_1    LHU_2    1 1 1 00010111100101110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 5f LDAF_LHU LDAF_a   c 5 2 00110100111011011010|  err   LD AlignFault. Faulting adr to mtval
    * 60 MULHU_3  MULHU_2  1 3 2 10011111100001000010|        Shift Q and rM. Prepare read rs1
    * 61 EBRKWFI2 EBREAK_1 5 3 5 00101101001011110111| EBREAK/WFI2 Select EBREAK or WFI.
    * 62 DIV_8    DIV_7    0 6 3 01010111110011001000|        Conditionally subtract rs2. Update M[0]
    * 63 DIV_9    DIV_A    0 a 3 01010111110001011000|        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]
    * 64 SLTIU_0  SLTIX_1  0 3 2 00011111101000101011| SLTIU  Set less than immediate (unsigned)
    * 65 WFI_4    WFI_5    3 3 5 000000010xx011101111|        Prepare read PC.
    * 66 SW_1     SW_2     b 5 2 00011100100011110010|        Write d to a+k until accepted
    * 67 SW_E1SWE SW_E2    c 5 2 00100100x11010010011|        Store faulting address alignment to mtval
    * 68 DIV_12   StdIncPc 8 3 2 00100101000011100110|        RS2 > 0, RS1 >= 0, yy is true result
    * 69 DIV_13   LB_6     0 3 2 00010101100010001011|        RS2 > 0, RS1 < 0, change sign yy
    * 6a MULH_1   MULH_2   5 3 2 00110101000011111001|        Store ~rs1 to Ryy. Prep construct 1.
    * 6b SB_4     SB_5     1 b 2 00011001100001111010|        Address back to Q. Prepare get item to write
    * 6c SLTU_0   SLTX_1   3 3 2 000111010xx000110001| SLTU   Set less than (unsigned)
    * 6d MULHU_0  MULHU_1  7 6 2 00111101000000101110| MULHU  Store rs1 to Ryy. Next read rs2. Q=0, shcnt--
    * 6e DIV_C    DIV_e    7 3 2 00111100100010111001|        rM to yy. Q=ffffffff
    * 6f MRET_6   MRET_7   0 3 3 010xxxx1110011001111|        ~302 + origImm + 1 for branch decision
    * 70 LHU_2    LHU_3    1 7 6 00010101100110111010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * 71 aFaultc  aFault_1 c 5 2 00110101011000011110|  err   LHU Load access fault. Faulting adr to mtval
    * 72 LBU_3    ANDI_1   0 3 2 00001101101000011010|        Invert q. Prepare read mask
    * 73 unalignd straddle 0 3 2 00000101011000010010|  Fr10u Unaligned pc, prep read high hword
    * 74 MRET_9   Fetch    5 4 3 01011010110011011110|        +1, IncPC, OpFetch next
    * 75 IJ_5     Fetch    7 4 2 00011010101011011110|        Mask and use as PC
    * 76 Fetchu   Fetch2u  0 3 a 00000111011011010101|  Fr10u Read and latch instruction
    * 77 eFetchu  Fetch2u  0 1 b 00010111011011010101|  Fr10u rep Read until d=mem[(rs1+ofs) & ~3u]
    * 78 DIV_4    DIV_6    5 3 2 00100001011010101010|        ~abs(divisor) to yy
    * 79 DIV_5    DIV_3    0 3 3 11010101110010101000|        Kluge to let add1 work in DIV instr
    * 7a SB_5     SW_2     8 5 2 00011000100011110010|        Write d to a+k until accepted
    * 7b _L0x7b   JAL_1    3 3 2 000000001xx000110010| JAL. J-imm is in q. Prep get isntradr from jj
    * 7c CSRRC_0  CSRRW_1  5 3 2 00101101011001001001| CSRRC  Decoded CSR adr in yy
    * 7d condb_6t Fetch    5 4 2 01011010110011011110|        Branch taken.
    * 7e NMI_1    NMI_2    a 3 2 001xxxx1000010010000|        Store pc to mepc.
    * 7f unx7f             d 6 0 00xxxxxxxxxxxxxxxxxx| 7f: Not in use 
    * 80 LBU_0    LBU_1    0 0 0 01011011110010000101| LBU    Load unsigned byte. Q = rdadr=RS1+Iimm.
    * 81 unx81             d 6 0 00xxxxxxxxxxxxxxxxxx| 81: Not in use 
    * 82 DIV_1    DIV_3    5 3 2 00011101000010101000|        jj=abs(RS1). Next handle divisor
    * 83 DIV_2    DIV_1    0 3 2 01010101110010000010|        Dividend negative, make RS1-1
    * 84 XORI_0   XORI_1   0 3 2 00011111101000100001| XORI   Xor immediate. Q=~Iimm
    * 85 LBU_1    LBU_2    1 1 1 00010111100111110000|        Read until q=mem[(rs1+ofs) & ~3u]
    * 86 JAL_2    JAL_25   5 5 2 01000001010010011110|      Prep pc = jj + ofs
    * 87 unx87             d 6 0 00xxxxxxxxxxxxxxxxxx| 87: Not in use 
    * 88 DIV_E    DIV_10   3 a 2 10011110xxx010011100|        RS2 != 0. Check signs
    * 89 DIV_F    StdIncPc 4 3 2 00100101011011100110|        RS2 == 0, return 0xffffffff
    * 8a DIVU_5   ANDI_1   3 3 6 110101110xx100011010|        Transfer rM to rDee
    * 8b LB_6     StdIncPc 4 3 3 11100101010011100110|        WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80
    * 8c XOR_0    XOR_1    3 3 2 000111110xx000101001| XOR    xor
    * 8d DIV_0    DIV_1    1 c 2 10010111100010000010| DIV    Branch on sign dividend RS1
    * 8e _LCSRRS_1 ILLe     3 3 2 000xxxx0xxx011111110| Illegal instruction seen
    * 8f ILL_3    ILL_4    0 3 3 00010101110010101001|        Q = 1
    * 90 NMI_2    JAL_3    c d 2 00101001011000110100|        mtval = 0.
    * 91 LDAF_2   LDAF_3   6 d 3 11100100x10010010010|        Store 4 to mcause
    * 92 LDAF_3   JAL_3    a 3 2 00110010x00000110100|        PC to mepc
    * 93 SW_E2    SW_E3    a 3 2 00110111000010010101|        Store address that faulted
    * 94 SW_E4    JAL_3    7 d 2 00110010x10000110100|        Store 6 to mcause
    * 95 SW_E3    SW_E4    3 3 3 11010111110010010100|        Q = 3
    * 96 SH_1     SH_2     7 6 2 00110111100010111011|        Write d to Q and yy (for sh 0). Prep shift
    * 97 SW_E1SWH SW_E2    c 5 2 00100100x11010010011|        Store faulting address alignment to mtval
    * 98 BLT      condb_2  5 3 2 00111101011000010011| BLT    Conditional Branch. Offset to Ryy
    * 99 _L0x99   ILLe     3 3 2 000xxxx0xxx011111110|  Not in use (illegal as entry)
    * 9a ECALL_6  JAL_3    6 d 2 01110010x10000110100|        mcause = 11
    * 9b SH_4     SH_5     e 8 2 00011001100010011111|        Address back to Q. Prepare get item to write
    * 9c DIV_10   DIV_12   1 a 2 10011001000001101000|        RS2 > 0. Branch on sign of RS1
    * 9d DIV_11   DIV_14   1 a 2 10011001000010100010|        RS2 < 0. Branch on sign of RS1
    * 9e JAL_25   JAL_3    d 3 4 11100101010000110100|      Prep WTRG = jj+2/4 (return adr)
    * 9f SH_5     SW_2     b 3 2 00011000100011110010|        Write d to a+k until accepted
    * a0 LHU_0    LHU_1    9 0 0 01111011110001011110| LHU    Load unsigned hword. Q = rdadr=RS1+Iimm
    * a1 ECALL_4  ECALL_5  3 3 3 11010101110010110110|        Q = 4
    * a2 DIV_14   LB_6     0 3 2 00010101100010001011|        RS2 < 0, RS1 >= 0, change sign yy
    * a3 DIV_15   StdIncPc 8 3 2 00100101000011100110|        RS2 < 0, RS1 < 0, yy is true result
    * a4 SRxI_0   SRxI_1   0 6 0 00011110x11000111010| SRxI   Shift Right immediate (both logic/arith here)
    * a5 MRET_3   MRET_4   0 3 3 01001101110010101111|        0x102 + 0xff + 1 = 0x202
    * a6 ECAL_RET ECALL_1  2 3 8 00010110111011010000| ECALL/(U/S/M)RET Select ECALL or (U/S/M)RET
    * a7 EBRKWFI1 EBRKWFI2 0 3 2 010xxxx1110001100001| EBREAK/WFI1 Prepare select EBREAK or WFI
    * a8 DIV_3    DIV_4    0 a 2 10010101100001111000|        Branch on sign divisor RS2
    * a9 ILL_4    JAL_3    5 d 3 01110010x10000110100|        Store 2 to mcause
    * aa DIV_6    DIV_7    3 3 2 100101110xx011001000|        Write M. Prepare shift
    * ab EBREAK_2 ECALL_6  a 3 2 00110101000010011010|        pc to mepc
    * ac _L0xac   SRx_1    3 3 2 00011100xxx000111111| SRx    Shift Right (both SRL and SRA)
    * ad DIVU_0   DIVU_1   3 6 2 100111010xx011100000| DIVU   Store rs1 to rM. Q=0. Prepare invert rs2
    * ae _L0xae   SRx_1    3 3 2 00011100xxx000111111| SRx    Shift Right (both SRL and SRA)
    * af MRET_4   MRET_5   0 3 3 010xxxx1110011000101|        0x202 + 0xff + 1 = 0x302
    * b0 aF_SW_3  LDAF_3   6 d 2 01100100x10010010010|        Store 7 to mcause
    * b1 CSRRW_3  CSRRW_4  3 3 3 11010101110010110010|        Prep emulation entrypt 0x108, here Q to 0x104
    * b2 CSRRW_4  Fetch    6 4 3 11011010110011011110|        IncPC, OpFetch, but force +4
    * b3 unxb3             d 6 0 00xxxxxxxxxxxxxxxxxx| b3: Not in use 
    * b4 eFetch3  unalignd c 3 c 01011111110001110011|  Fr11  Write minstret. Update I. Q=immediate, use dinx
    * b5 SH_3     SH_4     0 3 2 00000001011010011011|        Prepare get back address to use 
    * b6 ECALL_5  ECALL_6  3 3 3 11010101110010011010|        Q = 8
    * b7 IJ_3     IJ_4     7 3 2 00110101000010111101|        Store present PC in case of access error
    * b8 BGE      condb_2  5 3 2 00111101011000010011| BGE    Conditional Branch. Offset to Ryy
    * b9 DIV_e    DIV_D    0 3 3 00011001100011000000|        Calc carry of RS2+0xFFFFFFFF
    * ba LHU_3    ANDI_1   0 3 2 00001111101000011010|        Invert q. Prepare read mask
    * bb SH_2     SH_3     7 7 2 00110111110010110101|        Repeat shl until shreg = 0 (0,8 or 24 times)
    * bc CSRRWI_0 CSRRW_1  5 3 2 00101101011001001001| CSRRWI Decoded CSR adr in yy
    * bd IJ_4     IJ_5     0 3 3 01000101110001110101|        Construct Q = 1
    * be IJ_1     IJ_2     1 1 2 00010111100000011111|        Read until q=mem[(rs1+ofs)&~1u]
    * bf IJT_1    IJT_2    1 1 2 00010111100011000001|        Exit CSR, enter trap
    * c0 DIV_D    DIV_E    1 3 5 00011101100010001000|        Is RS2 == 0?
    * c1 IJT_2    IJT_3    5 3 2 00110101011011101001|        Read word is to be masked with ~1u
    * c2 DIVU_3   DIVU_2   0 6 3 01010111110011001010|        Conditionally subtract rs2. Update M[0]
    * c3 DIVU_4   DIVU_5   0 a 3 01010111110010001010|        Last Cond. -rs2. Upd M[0]. Branch on INSTR[13]
    * c4 ORI_0    ORI_1    5 3 2 00011111001011100001| ORI    Or immediate. jj=~Iimm
    * c5 MRET_5   MRET_6   0 3 2 00000001101001101111|        ~302
    * c6 IJT_4    ILL_2    a 3 2 00110101101001000111|        Mask and store to mepc and Q for read of instr
    * c7 QINT_1   QINT_2   a 3 2 001xxxx1000011001011|        Store pc to mepc.
    * c8 DIV_7    DIV_8    1 3 d 10011001110001100010|        Shift (Q,M) left. Prepare unsigned sub
    * c9 MRET_2   MRET_3   3 3 2 01001101110010100101|        0xff+3 = 0x102
    * ca DIVU_2   DIVU_3   1 3 d 10011001110011000010|        Shift (Q,M) left. Prepare unsigned sub
    * cb QINT_2   StdIncPc c d 2 00101001011011100110|        mtval = 0.
    * cc OR_0     OR_1     3 3 2 000111110xx000100110| OR     or
    * cd REM_0    DIV_1    1 c 2 10010111100010000010| REM    Branch on sign dividend RS1
    * ce _LCSRRCI_1 ILLe     3 3 2 000xxxx0xxx011111110| Illegal instruction seen
    * cf MRET_7   MRET_8   3 3 5 000011010xx001001111|        Prepare emulation entry point 0x104
    * d0 ECALL_1  ECALL_2  0 3 3 01000001110000110111| ECALL  Verify Imm==0x000
    * d1 MRET_1   MRET_2   5 3 2 00001101011011001001| MRET   First save Imm, start build constant for check
    * d2 LB_2     LB_3     1 7 6 00010101100100000110|        Repeat shr until shreg == 0 (0,8,16,24 times)
    * d3 aFaultd  aFault_1 c 5 2 00110101011000011110|  err   LB Load access fault. Faulting adr to mtval
    * d4 aFault_2 LDAF_3   5 d 3 01100100x10010010010|        Store 5 to mcause
    * d5 Fetch2u           c 5 e 01011111110000000000|  Fr11  Update ttime. Update I. Q=immediate. Use dinx
    * d6 eILL0c   ILLe     3 3 2 000xxxx0xxx011111110| Illegal instruction seen
    * d7 ECALL_3  ECALL_4  c 5 2 00110101011010100001|        mtval = 0, now start the chore of 11 to mcause
    * d8 BLTU     condb_2  5 3 2 00111101011000010011| BLTU   Conditional Branch. Offset to Ryy
    * d9 MULH_3   MULHU_2  3 3 2 100111110xx001000010|        rM<=RS2, Q = 0. next read RS1. Join.
    * da LDAF_a   LDAF_2   3 3 2 000101010xx010010001|        Extra cycle after error detected write mtval
    * db jFault_1 LDAF_3   5 5 3 01111000x10010010010|        Store 1 to mcause
    * dc CSRRSI_0 CSRRW_1  5 3 2 00101101011001001001| CSRRSI Decoded CSR adr in yy
    * dd aF_SW_1  aF_SW_2  c 5 2 00110101011011100101|  err   SW Store access fault. Faulting adr to mtval
    * de Fetch    Fetch2   5 1 b 00010111011011110100|  Fr11  Read and latch instruction
    * df eFetch   Fetch2   5 1 b 00010111011011110100|  Fr11  rep Read until d=mem[(rs1+ofs) & ~3u]
    * e0 DIVU_1   DIVU_2   5 3 2 00110111000011001010|        Store inverted rs2 to yy. Prepare shift
    * e1 ORI_1    ORI_2    1 3 2 00000001100000011101|        Q = RS1
    * e2 MUL_1    MUL_2    0 6 6 00010101110111101000|        Q <= rM[0] ? Q+rs2 : Q. Prepare shr/sar
    * e3 MUL_3    ANDI_1   3 3 6 110101110xx100011010|        Transfer rM to rDee
    * e4 ANDI_0   ANDI_1   0 3 2 00011111101000011010| ANDI   And immediate. Q=~Iimm
    * e5 aF_SW_2  aF_SW_3  3 3 3 11010101110010110000|        Q = 4
    * e6 StdIncPc Fetch    6 4 4 11011010110011011110|  Fr11  IncPC, OpFetch
    * e7 aFault   aFault_1 c 5 2 00110101011000011110|  err   Load access fault. Faulting adr to mtval
    * e8 MUL_2    MUL_1    1 3 2 10011101100011100010|        Shift Q and rM. Prepare read rs2
    * e9 IJT_3    IJT_4    0 3 3 01011001110011000110|        Construct Q = 1
    * ea MULHU_5  MULHU_6  0 3 2 00011001110000100010|        Q <= rM[0] ? Q+Rjj : Q. Prepare read Ryy
    * eb LH_3     LH_4     0 3 2 00001111101001010110|        q = ~mem[rs1+ofs]
    * ec AND_0    AND_1    3 3 2 000111110xx000010001| AND    And 
    * ed REMU_0   DIVU_1   3 6 2 100111010xx011100000| REMU   Store dividend to rM. Prepare read divisor.Q=0
    * ee eILL0a   ILLe     3 3 2 000xxxx0xxx011111110| Illegal instruction seen
    * ef WFI_5    Fetch    6 4 3 11011010110011011110|        IncPC, OpFetch
    * f0 LBU_2    LBU_3    1 7 6 00010101100101110010|        Repeat shr until shreg = 0 (0, 8 or 16 times)
    * f1 aFaulte  aFault_1 c 5 2 00110101011000011110|  err   LBU Load access fault. Faulting adr to mtval
    * f2 SW_2     StdIncPc 3 3 2 000001010xx011100110|        Prepare read PC
    * f3 aF_SW    aF_SW_1  3 3 2 000xxxx01xx011011101|  err   SW/SH/SB access fault. Rest to set SEL_O=4'hf
    * f4 Fetch2   eFetch3  c 5 f 01000011010010110100|  Fr11  Update ttime. Update I. Q=immediate. Use dinx
    * f5 jFault   jFault_1 c 5 2 00110101011011011011|  err   Fetch access fault. Faulting adr to mtval
    * f6 WFI_1    WFI_2    3 3 3 11011001110011111010| WFI    Chk offset=0x105. Now 0xff. Prep 0xff+4 = 0x103
    * f7 EBREAK_1 EBREAK_2 c 5 2 00100001011010101011| EBREAK mepc = pc, store 0 to mtval
    * f8 BGEU     condb_2  5 3 2 00111101011000010011| BGEU   Conditional Branch. Offset to Ryy
    * f9 MULH_2   MULH_3   5 3 3 01011101010011011001|        Store 1 to Rjj. next read rs2, Q=0
    * fa WFI_2    WFI_3    0 3 3 01010101110001000101|        Chk ofs. Now 0x103. Prep +1+~ofs, so ~ofs+0x104
    * fb SB_3     SB_4     0 3 2 00000001011001101011|        Prepare get back address to use 
    * fc CSRRCI_0 CSRRW_1  5 3 2 00101101011001001001| CSRRCI Decoded CSR adr in yy
    * fd NMI_0    NMI_1    3 3 2 000001010xx001111110| NMI    Get current PC
    * fe ILLe     ILL_1    3 3 2 00000100xxx001000110| Illegal
    * ff QINT_0   QINT_1   3 3 2 000001010xx011000111| INT    Get current PC
    */
   localparam u0_0 = 256'h56e6d010d0e2d8045c33dc5ab88bdc5aba09da07080454e650e6bcbe79d2bc01;
   localparam u0_1 = 256'h0eb75cd456e66ea6083252e60441d613087d10e618169c15f814ac76d81af88b;
   localparam u0_2 = 256'h56e6f642586ac03e1430dc96d821dc961c1dd0270804e63550e65d3950e6bc52;
   localparam u0_3 = 256'he03ae0355903d6490832593d50e6d61310d77c037836a8de129e0886f82b56e6;
   localparam u0_4 = 256'h5c7400fed02ed03148b1dc661c4bdc66508f40475c65fa2b08ea5d60500bbc50;
   localparam u0_5 = 256'h4eda79707cfbd6490832785df69c796e188b1a57561e59eb4eda79544eda70e6;
   localparam u0_6 = 256'h1ccfc8b9d02ed031987a50f9588b50e64693c8f210effa2b7c587cc8d2f7f842;
   localparam u0_7 = 256'h00001090acded649083288f25ca816aa76d576d5aadeacde5612da1a561e59ba;
   localparam u0_8 = 256'h5ca900fe7882f02954e6711a56e6e09c0000149e79f0fa215c82d0a80000bc85;
   localparam u0_9 = 256'h88f2543490a29068989f243400fed613469378bb7c9424347095203444929634;
   localparam u0_A = 256'h1cc5c03fd0e0c03f509a70c8243458781c616ed0dcafe63a50e6588b5cb6bc5e;
   localparam u0_B = 256'h78c1781f5c75d6497cb5fa1a98c0d61350bd5c9a169bfc730000acde5cb24492;
   localparam u0_C = 256'hd04f00fe7882f02696e69cc2dca59c6210cb5a471a6ff2e17c8a7cca56e9d888;
   localparam u0_D = 256'h76f476f456e5d64984925091f042d61356a100fefc004492561e5906d6c91c37;
   localparam u0_E = 256'hacde00fed0e0f011fa569c229cc6d8e2561eacde5cb0fa1a711a5de8181d70ca;
   localparam u0_F = 256'h50c74046507ed649166b5c45d4d9d61316ab9cfa56db34b408dd50e6561e5972;
   localparam u1_0 = 256'h4322332133291321033453050320530513200320332043263320222511110005;
   localparam u1_1 = 256'h5520333d83222321332083225524532373223320135003350321644d03210321;
   localparam u1_2 = 256'h4322532916213321033493050321930503245321332006013320036143229007;
   localparam u1_3 = 256'h160116018763532233208663832a5323a3528723862374217520732203214372;
   localparam u1_4 = 256'h333d332076233321b921288503342885a523a323033503210320066173232085;
   localparam u1_5 = 256'hc523111177235322332076235323136d03211321c5231761c5231111c5238193;
   localparam u1_6 = 256'h03347323762333211b21532303218322c522b521335003210a35063553521329;
   localparam u1_7 = 256'hd600a3225425532233208521033d532201b103a07421543503200320c5231761;
   localparam u1_8 = 256'h033133201c293321433e336d43223a29d60055241111032103255321d6000005;
   localparam u1_9 = 256'hb321d34e1a291a29e8216d2733205323c5227623333d7d23a323a3236d3ecd22;
   localparam u1_A = 256'h0334332136293321a32333295d370a29032423810334060183220321333d9007;
   localparam u1_B = 256'h112111210334532277230320033153237323333d0320c3c5d600643d333d6d26;
   localparam u1_C = 256'h335033201c293321cd2213d9332413d9a322a323032053210a35063553231351;
   localparam u1_D = 256'h51b151b1c52353225537332133295323c5233320c5e55d36c523176153200334;
   localparam u1_E = 256'h643d3320362933210320032103351329c523644d333d0321336d066113205323;
   localparam u1_F = 256'h33203320332053220320033553355323c522333dc523c5f433203320c5231761;
   wire [31:0]   indir;
`ifdef verilator
   /* verilator lint_off UNUSED */
   wire [15:0]   sim_a;
   wire [15:0]   sim_b;
   /* verilator lint_on UNUSED */
`endif
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u0_0), .INIT_1(u0_1), .INIT_2(u0_2), .INIT_3(u0_3),
                   .INIT_4(u0_4), .INIT_5(u0_5), .INIT_6(u0_6), .INIT_7(u0_7),
                   .INIT_8(u0_8), .INIT_9(u0_9), .INIT_A(u0_A), .INIT_B(u0_B),
                   .INIT_C(u0_C), .INIT_D(u0_D), .INIT_E(u0_E), .INIT_F(u0_F)
                   ) ucode0
     (
      .RDATA( indir[15:0]         ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );
   
   SB_RAM40_4K # ( .READ_MODE(0), .WRITE_MODE(0),
                   .INIT_0(u1_0), .INIT_1(u1_1), .INIT_2(u1_2), .INIT_3(u1_3),
                   .INIT_4(u1_4), .INIT_5(u1_5), .INIT_6(u1_6), .INIT_7(u1_7),
                   .INIT_8(u1_8), .INIT_9(u1_9), .INIT_A(u1_A), .INIT_B(u1_B),
                   .INIT_C(u1_C), .INIT_D(u1_D), .INIT_E(u1_E), .INIT_F(u1_F)
                   ) ucode1
     (
      .RDATA( indir[31:16]        ),
      .RADDR( {3'h0,minx}         ),
      .RCLK(  clk                 ),
      .RCLKE( 1'b1                ),
      .RE(    progress_ucode      ),
      .WADDR( 11'h0               ),
      .WCLK(  1'b0                ),
      .WCLKE( 1'b0                ),
      .WDATA( 16'h0               ),
      .WE(    1'b0                ),
      .MASK(  16'h0               )
      );

   assign d[0] = indir[0];
   assign d[1] = indir[1];
   assign d[2] = indir[2];
   assign d[3] = indir[3];
   assign d[4] = indir[4];
   assign d[5] = indir[5];
   assign d[6] = indir[6];
   assign d[7] = indir[7];
   assign d[8] = indir[8];
   assign d[12] = indir[9];
   assign d[13] = indir[10];
   assign d[16] = indir[11];
   assign d[17] = indir[12];
   assign d[22] = indir[13];
   assign d[23] = indir[14];
   assign d[24] = indir[15];
   assign d[25] = indir[16];
   assign d[28] = indir[17];
   assign d[42] = indir[18];
   assign d[43] = indir[19];
   // replaces = 1000000100100101000000000101001100011000000000
   SB_LUT4 #(.LUT_INIT(16'h1098)) cmb_d09(.O(d[9]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'h3018)) cmb_d10(.O(d[10]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'h0020)) cmb_d14(.O(d[14]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'h0c00)) cmb_d15(.O(d[15]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'hc000)) cmb_d18(.O(d[18]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'hfffe)) cmb_d20(.O(d[20]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'h5000)) cmb_d30(.O(d[30]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'h0100)) cmb_d32(.O(d[32]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'h0802)) cmb_d35(.O(d[35]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'h0a00)) cmb_d38(.O(d[38]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   SB_LUT4 #(.LUT_INIT(16'h0010)) cmb_d45(.O(d[45]),.I3(indir[23]),.I2(indir[22]),.I1(indir[21]),.I0(indir[20]));
   // replaces = 0100110011011000001000001000000000000000000000
   SB_LUT4 #(.LUT_INIT(16'h2f3f)) cmb_d21(.O(d[21]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h2a30)) cmb_d27(.O(d[27]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0012)) cmb_d33(.O(d[33]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0080)) cmb_d34(.O(d[34]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h2004)) cmb_d36(.O(d[36]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h2200)) cmb_d37(.O(d[37]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0915)) cmb_d40(.O(d[40]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h0900)) cmb_d41(.O(d[41]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   SB_LUT4 #(.LUT_INIT(16'h1400)) cmb_d44(.O(d[44]),.I3(indir[27]),.I2(indir[26]),.I1(indir[25]),.I0(indir[24]));
   // replaces = 0000001000000010100100000010000000100000000000
   SB_LUT4 #(.LUT_INIT(16'h4d82)) cmb_d11(.O(d[11]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h5fb7)) cmb_d19(.O(d[19]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h5c00)) cmb_d26(.O(d[26]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h16e0)) cmb_d29(.O(d[29]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h0204)) cmb_d31(.O(d[31]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   SB_LUT4 #(.LUT_INIT(16'h400f)) cmb_d39(.O(d[39]),.I3(indir[31]),.I2(indir[30]),.I1(indir[29]),.I0(indir[28]));
   assign d[46] = 1'b0;
   assign d[47] = 1'b0;
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * Instruction decode is preformed in this module. 
 * Experiments with a lowlevel version did not give any gain in size.
 * However:
 *  - There is a lut or two to pinch by better analysis of startup
 *    conditions.
 *  - If we do not use a lazy decoding, the test of rd == 0  and
 *    rs1 == 0 can be multiplexed with the zero-detector just before
 *    the holding register ADR_O[31:0]. This will save a few luts.
 * 
 * All in all there is little to gain by manipulating this module,
 * that also will need to be flexible if we are to implement 
 * standard extension -M and/or -C.
 * 
 * 
 * Microcode program counter
 * 
 * usedinx_or_RST_I_notcorerunning ---------+
 *                                ____      |
 * dinx[7:2] --------------------| or |     |
 * illegal_or_qualint_or_RST_I --|____|----|1\
 *                                         |  |--- minx[7:2]
 * rinx[7:2] ------------------------------|0/
 * 
 * usedinx_or_RST_I_notcorerunning ---------+
 *                       ____               |
 * dinx[1] -------------| or |   ___        |
 * illegal_or_qualint_--|____|--| & |------|1\
 * RST_I-----------------------o|___|      |  |--- minx[1]
 * rinx[1] --------------------------------|0/
 * 
 * usedinx_or_RST_I_notcorerunning ---------+
 *                                          |
 * illegal_or_qualint_or_RST_I --+          |
 * qualint_or_RST_I ------------|1\         |
 *                              |  |-------|1\
 * dinx[0] ---------------------|0/        |  |--- minx[0]
 *                                       +-|0/
 * maybranch -----------+                |
 * takebranch ---------|1\   ____        |
 *                     |  |-|    |-------+
 * rinx[0] ------------|0/  | or |
 * buserror-----------------|____|
 * 
 * When power-on, dinx is used, so a "lb x0,0(x0)" is executed.
 * 
 * Parameter:
 * LAZY_DECODE    0 : Full decode of the riscv instruction. Any unknown instruction leads to a trap
 *                1 : Decode of most riscv instructions. No decode in some minor code spaces
 *                2 : Near minimal decode of riscv instructions. Not recommended
 */
module m_ucodepc
  # ( parameter LAZY_DECODE = 0, MULDIV = 1, RVC = 0 )
  (
   input        corerunning, //         Control startup
   input [7:0]  rinx, //                From ucode
   input        sa28,sa29,sa30,sa37, // From ucode
   input        sa32,sa15, //           == 2'b10 triggers ucode jmp to alternate operand fetch from SRAM
   input        qualint, //             Qualified interrupt
   input        is_brcond, //           Branch condition
   input [31:0] INSTR, //               Instruction to decode at OpCode fetch
   input [31:0] B, //                   B[1:0] to find alignment errors. B[31] to distinguish EBR/SRAM
   input [31:0] DAT_O, //               DAT_O[31] to find sign of variable
   input        RST_I, //               NMI
   input        buserror, //            Accessing empty region if high
   input        ceM, //                 Uses shift-loop or loads or clears bidirectional shift register
   input        rlastshift, //          Together with ceM, last shift in shift-loop
   input        potentialMODbranch, //  Distinguish between DIV[U] and MOD[U]. Together with ceM, branch on sign DAT_O[31]
/* verilator lint_off UNUSED */
   input        pc1, //           For RVC
   input        was_rvc_instr,
/* verilator lint_on UNUSED */
   output [7:0] minx, //                Microcode PC
   output       ucodepc_killwarnings
   );
   wire [7:0]   dinx;
   wire         usedinx, maybranch, takebranch;
   wire         Adr0Mustbe0;
   wire         Adr1Mustbe0;
   wire         use_brcond  = sa37;
   /* verilator lint_off UNUSED */
   wire         illegal;
   wire         RVC_or_aligned;
   /* verilator lint_on UNUSED */

   /*AUTOWIRE*/                
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   wire                 m_illegalop_killwarning;// From inst_illegalop of m_illegalop.v
   // End of automatics
`ifdef verilator
   function [1:0] get_branchvariables;
      // verilator public
      get_branchvariables = {is_brcond,use_brcond};
   endfunction
   function [0:0] get_usedinx;
      // verilator public
      get_usedinx = usedinx;
   endfunction
   function [5:0] get_ucodepcinfo;
      // verilator public
      get_ucodepcinfo = {buserror,usedinx,qualint,illegal,maybranch,takebranch};
   endfunction
   function [7:0] get_dinx;
      // verilator public
      get_dinx = dinx;
   endfunction
`endif

   generate
      if ( RVC == 0 ) begin
         assign usedinx     = sa28;
         assign Adr0Mustbe0 = sa29;
         assign Adr1Mustbe0 = sa30;
         assign RVC_or_aligned = 1'b0; // Prevent warning in Synplify Pro
      end else begin
         assign RVC_or_aligned = ~pc1 | was_rvc_instr; 
         assign usedinx     = sa28 & RVC_or_aligned;
         assign Adr0Mustbe0 = sa29 & RVC_or_aligned;
         assign Adr1Mustbe0 = sa30 & RVC_or_aligned;         
      end
   endgenerate

   assign maybranch = Adr0Mustbe0 | Adr1Mustbe0 | use_brcond | (sa32 & ~sa15) | ceM;

   /* Slight mangling of INSTRUCTION to an index. The following bits are used:
    * 30,14,13,12,6,5,4,3,2, or in case MUL/DIV is included:
    * 30,25,14,13,12,6,5,4,3,2
    */
   generate
      if ( MULDIV ) begin
         assign dinx[0] = (INSTR[6:4] == 3'b011 & INSTR[2] == 1'b0) ? INSTR[25] : INSTR[2];
      end else begin
         assign dinx[0] = INSTR[2];
      end
   endgenerate
   //wire is_lui = INSTR[6:2] == 5'b01101; Simplified because main_illegal covers 
   wire is_lui = INSTR[5:4] == 2'b11 & INSTR[2] == 1'b1;

   assign dinx[1] = is_lui ? 1'b1 : ((~INSTR[6]&INSTR[5])&INSTR[30]) | ((~(~INSTR[6]&INSTR[5]))&INSTR[3]);
   assign dinx[2] = INSTR[4];
   assign dinx[3] = INSTR[5];
   assign dinx[4] = INSTR[6];

   
   /* assign dinx[7:5] = INSTR[14:12]; Need some more space, so index sligthly more elaborate */
   assign dinx[5] = INSTR[12]; // is_lui ? 1 : INSTR[12];
   /* Candidates to compress:
    * INSTR[6:0]
    * 6543210
    *   xxx
    * 0110111 lui
    * 0010111 auipc
    * 1101111jal
    */
   assign dinx[7]   = INSTR[14] & (INSTR[4:2] != 3'b101) & (INSTR[5:2] != 4'b1011);
   assign dinx[6]   = INSTR[13] & (INSTR[4:2] != 3'b101);

   m_illegalop #(.LAZY_DECODE(LAZY_DECODE), .MULDIV(MULDIV))
   inst_illegalop
     (/*AUTOINST*/
      // Outputs
      .illegal                          (illegal),
      .m_illegalop_killwarning          (m_illegalop_killwarning),
      // Inputs
      .INSTR                            (INSTR[31:0]),
      .corerunning                      (corerunning));
   
   
   
   /* takebranch. Microcode must diverge when we have an alignment error,
    * a taken branch, or an opcode fetch when we read from SRAM, or the
    * last shift in a MUL/DIV shift loop.
    *                     _              ____
    * Adr0Mustbe0 -------|&|------------|    |--- takebranch
    * B[0] --------------|_|  +---------| or |
    *                     _   | +-------|    |
    * Adr1Mustbe0 -------|&|--+ | +-----|    |
    * B[1] --------------|_|    | | +---|____|
    *                     _     | | |
    * use_brcond --------|&|----+ | |
    * is_brcond ---------|_|      | |
    *                     _       | |
    * read_instr --------|&|------+ |
    * B[31] -------------|_|        |
    *                     _         |
    * ceM ---------------|&|--------+
    *               __  +|_|
    * rlastshift --|or|-+
    * isDIVbr  ----|__|
    * 
    * #define CH13 (( OI << 34) | sr_h) // ceM==0 clrM==1 conditional hlod, and branch on INSTR[15]. Last inch?
    */
   wire             qualint_or_RST_I = qualint | RST_I;
   wire             illegal_or_qualint = (illegal | qualint);
   wire             illegal_or_qualint_or_RST_I = (illegal | qualint | RST_I);
   assign takebranch = 
                       (Adr0Mustbe0 & B[0]) |
                       (Adr1Mustbe0 & B[1]) |                
                       (use_brcond & is_brcond) |
                       (sa32 & ~sa15 & B[31] ) |
                       (ceM & rlastshift );                       
   wire             usedinx_or_RST_I_notcorerunning = usedinx | RST_I | ~corerunning;

   assign minx[7:2] = (usedinx_or_RST_I_notcorerunning ? (dinx[7:2] | {6{illegal_or_qualint_or_RST_I}}) : rinx[7:2]);
   assign minx[1]   = (usedinx_or_RST_I_notcorerunning ? ( (dinx[1] | illegal_or_qualint) & ~RST_I) : rinx[1]);
   wire mostofminx0 = (buserror | (usedinx_or_RST_I_notcorerunning ? (illegal_or_qualint_or_RST_I ? qualint_or_RST_I : dinx[0]) : (maybranch ? takebranch : rinx[0])));   
   wire doMODbranch_or_signbranch = potentialMODbranch & ( (INSTR[13] & ~ceM) | (DAT_O[31] & ceM) );
   assign minx[0]   = mostofminx0 | doMODbranch_or_signbranch;

   assign ucodepc_killwarnings = INSTR[31] | &INSTR[29:15] | &INSTR[11:7] | &B | INSTR[1] | &DAT_O[31:0] | m_illegalop_killwarning;
   
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * ----------------------------------------------------------------------------ehdr
 * This module is actually several smallish modules in one.
 */
module m_progressctrl
  #( parameter HIGHLEVEL = 0, SRAMADRWIDTH = 0, MULDIV  = 1,
     NO_CYCLECNT = 0, MTIMETAP = 0, MTIMETAP_LOWLIM = 32, DISREGARD_WB4_3_55 = 0, RVC = 0) 
   (
    input        clk, //            System clock
    input        corerunning, //    Avoid writing of registers when we are not running
    input        RST_I, //          Non-maskable interrupt
    input        ACK_I, //          Acknowledge from I/O device.
    input        sram_ack, //       Acknowledge from SRAM (if SRAMADRWIDTH != 0)
    input        sa15, //           Part of enable for Q
    input        sa27,sa26, //      Controls EBR write address mux
    input        sa25,sa24, //      Controls EBR write address mux
    input        sa32, //           read input
    input        sa41, //           Latch SEL_O
    input        sa33, //           Repeat shr until shreg == 0
    input        sa42, //           Possibly activate STB_O, sram_stb
    input        sa43, //           Possibly activate WE_O
    input        sa14, //           Needed to deactivate WE_O
    input        sa30, //           Special case, strobe for "SW" must respect word alignment
    input        lastshift, //      To halt progress of microcode etc
    input        rlastshift, //     To halt progress of microcode etc
    input [31:0] B, //              Do we access SRAM or I/O? Also used when RVC included
    input        buserror, //       When we have bus error we must have forward progress in ucode
    /* verilator lint_off UNUSED */
    input        sysregack, //      Acknowledge from system registers (if MTIMETAP >= MTIMETAP_LOWLIM)
    input        sa12, //           Capturing the instruction
    input [17:0] Di, //             To find out if an instruction is RVC
    input        alu_carryout, //   For DIV
    input        clrM, //           For DIV
    input        ceM, //            For DIV
    input        isDIVREM, //
    input        lastshiftoverride,// Update Q even if lastshift is true in MULx instructions
    input        sa20, //           For RVC need to decode Wpc
    input        sa21, //
    input        sa22, //
    input        sa23, //

    //     
    /* verilator lint_on UNUSED */
    
    output [3:0] SEL_O, //          Byte selects for SRAM and outputs
    output [3:0] bmask, //          SEL_O is unfortunately also needed in an active low version for EBR
                                   
    output       iwe, //            Write of EBR
    output       ctrlreg_we, //     Write control registers in EBR space.   
    output       WE_O, //           Write to Output or SRAM   
    output       STB_O, //          Operation on I/O
    output       sram_stb, //       Operation on SRAM
    output       enaQ, //           Sample output from ALU
    output       progress_ucode, // Continue execution of microcode
    output       qACK, //           Qualified acknowledge, usually (ACK_I | sysregack)
    output       next_STB_O, //     Output for debugging
    output       next_sram_stb, //  Output for debugging
    output       cond_holdq, //     During divide.

    output       pcinc_by_2, //      True only when updating PC after a RVC instruction or in an unaligned 32-bit instruction
    output       pc1, //             Mirror of pc[1] used when RVC instructions implemented
    output       was_rvc_instr, //   To correctly chose ucodepc
    output       luh, //             Load upper halfword of instruction
    
    output       m_progressctrl_killwarnings // Dummy
   );

   // To investigate implementation sizes           HIGH LOW     LOW better by
   localparam sel_o_HIGHLEVEL  = HIGHLEVEL | 0; //  369  365     4  
   localparam stb_HIGHLEVEL    = HIGHLEVEL | 1; //  
   localparam we_HIGHLEVEL     = HIGHLEVEL | 1; //  229  230     -1 Note, if ACK_I = STB_O, Lattice simplifies, this give no good estimate on size
   //                                                               I still don't understand where synthesis can save a LUT.
//Work on enaQ_HIGHLEVEL == 0   
   localparam enaQ_HIGHLEVEL   = HIGHLEVEL | 1; //  363  361     2   when SRAMADRWIDTH != 0 NO_CYCLECNT = 0
   //                                               227  228     0   when SRAMADRWIDTH == 0 NO_CYCLECNT = 0
   //                                                    
   localparam iwe_HIGHLEVEL    = HIGHLEVEL | 0; //  361  361     0
   localparam qACK_HIGHLEVEL   = HIGHLEVEL | 0; //  229  229     0  when DISREGARD_WB4_3_55 == 1. 
   //                                           //  231  231     0  when DISREGARD_WB4_3_55 == 0. 
   localparam RVC_HIGHLEVEL    = HIGHLEVEL | 0;
   
   /* during write to registers in output devices, 
    * writes to SRAM,  EBR, we need byte selects. 
    * Non-maskable interrupt clears registers.
    */
   generate
      if ( sel_o_HIGHLEVEL ) begin

         wire [5:0]    what_sel_o = {sa27,sa26,sa25,sa24,B[1:0]};
         reg [3:0]     aSEL_O; // combinatorical
         reg [3:0]     rSEL_O;
         reg [3:0]     rbmask;
         always @(*) begin
            case ( what_sel_o )
              6'b0001_00 : aSEL_O = 4'b0011;
              6'b0001_10 : aSEL_O = 4'b1100;
              6'b0010_00 : aSEL_O = 4'b0001;
              6'b0010_01 : aSEL_O = 4'b0010;
              6'b0010_10 : aSEL_O = 4'b0100;
              6'b0010_11 : aSEL_O = 4'b1000;
              default :    aSEL_O = 4'b1111;
            endcase
         end   
         always @(posedge clk)
           if ( RST_I ) begin
              rSEL_O <= 4'h0;
              rbmask <= 4'hf;        
           end else if ( sa41 ) begin
              rSEL_O <= aSEL_O;
              rbmask <= ~aSEL_O;
           end
         assign SEL_O = rSEL_O;
         assign bmask = rbmask;

      end else begin : blka
         wire [3:0] cmb_asel,cmb_bsel;
         wire       usedefault,en;
         
         SB_LUT4 #(.LUT_INIT(16'hfff9)) l_usedefault( .O(usedefault), .I3(sa27), .I2(sa26), .I1(sa25), .I0(sa24));
         SB_LUT4 #(.LUT_INIT(16'h004e)) l_cmb_bsel0( .O(cmb_bsel[0]), .I3(usedefault), .I2(sa24), .I1(B[1]), .I0(B[0]));
         SB_LUT4 #(.LUT_INIT(16'h004d)) l_cmb_bsel1( .O(cmb_bsel[1]), .I3(usedefault), .I2(sa24), .I1(B[1]), .I0(B[0]));
         SB_LUT4 #(.LUT_INIT(16'h001b)) l_cmb_bsel2( .O(cmb_bsel[2]), .I3(usedefault), .I2(sa24), .I1(B[1]), .I0(B[0]));
         SB_LUT4 #(.LUT_INIT(16'h0017)) l_cmb_bsel3( .O(cmb_bsel[3]), .I3(usedefault), .I2(sa24), .I1(B[1]), .I0(B[0]));
         SB_LUT4 #(.LUT_INIT(16'h0F0F)) l_cmb_asel0( .O(cmb_asel[0]), .I3(1'b0), .I2(cmb_bsel[0]), .I1(1'b0), .I0(1'b0));
         SB_LUT4 #(.LUT_INIT(16'h0F0F)) l_cmb_asel1( .O(cmb_asel[1]), .I3(1'b0), .I2(cmb_bsel[1]), .I1(1'b0), .I0(1'b0));
         SB_LUT4 #(.LUT_INIT(16'h0F0F)) l_cmb_asel2( .O(cmb_asel[2]), .I3(1'b0), .I2(cmb_bsel[2]), .I1(1'b0), .I0(1'b0));
         SB_LUT4 #(.LUT_INIT(16'h0F0F)) l_cmb_asel3( .O(cmb_asel[3]), .I3(1'b0), .I2(cmb_bsel[3]), .I1(1'b0), .I0(1'b0));

         SB_LUT4 #(.LUT_INIT(16'heeee)) l_en( .O(en), .I3(1'b0), .I2(1'b0), .I1(RST_I), .I0(sa41) );
         SB_DFFESS r_bsel0( .Q(bmask[0]), .C(clk), .E(en), .S(RST_I), .D(cmb_bsel[0]));
         SB_DFFESS r_bsel1( .Q(bmask[1]), .C(clk), .E(en), .S(RST_I), .D(cmb_bsel[1]));
         SB_DFFESS r_bsel2( .Q(bmask[2]), .C(clk), .E(en), .S(RST_I), .D(cmb_bsel[2]));
         SB_DFFESS r_bsel3( .Q(bmask[3]), .C(clk), .E(en), .S(RST_I), .D(cmb_bsel[3]));
         SB_DFFESR r_asel0( .Q(SEL_O[0]), .C(clk), .E(en), .R(RST_I), .D(cmb_asel[0]));
         SB_DFFESR r_asel1( .Q(SEL_O[1]), .C(clk), .E(en), .R(RST_I), .D(cmb_asel[1]));
         SB_DFFESR r_asel2( .Q(SEL_O[2]), .C(clk), .E(en), .R(RST_I), .D(cmb_asel[2]));
         SB_DFFESR r_asel3( .Q(SEL_O[3]), .C(clk), .E(en), .R(RST_I),. D(cmb_asel[3]));

      end
   endgenerate

   wire             badalignment;
   generate
      if ( stb_HIGHLEVEL == 0 || we_HIGHLEVEL == 0 ) begin
         SB_LUT4 #(.LUT_INIT(16'he0ff)) l_badalignment( .O(badalignment), .I3(corerunning), .I2(sa30), .I1(B[1]), .I0(B[0]));
      end else begin
         assign badalignment = ~corerunning | (sa30 & (B[1] | B[0])); // 
      end
   endgenerate
   
   wire clrregs;
   generate      
      if ( stb_HIGHLEVEL ) begin
            
         /* Strobes and acks
          * If sa42 and B[31:28] == 2'b01, STB_O is set next cycle.
          * It remains set until we get ACK_I or sysregack
          * Similarly for sram_stb.
          * 
          * A special case for "SW". If the address is not word aligned, we
          * will not give a strobe. (There is no such special case for "SH",
          * because the decission to give strobe is done some ucode cycles
          * after the address is checked).
          * 
          * Non-maskable interrupt clears registers.
          */
         reg rSTB_O;
         reg rsram_stb;
         assign next_STB_O    = (sa42 & ~B[31] & B[30] & ~badalignment) | (rSTB_O    & ~qACK );
         assign next_sram_stb = (sa42 &  B[31]         & ~badalignment) | (rsram_stb & ~sram_ack);
         always @(posedge clk) 
           if ( RST_I | buserror ) begin
              rSTB_O <= 1'b0;
              rsram_stb <= 1'b0;
           end else begin
              rSTB_O    <= next_STB_O;
              rsram_stb <= next_sram_stb;
           end
         assign STB_O = rSTB_O;
         assign sram_stb = rsram_stb;
         assign clrregs = 0; // Keep Verilator happy
      end else begin
         
         wire help1;
//         assign help1 = sa42 & ~B[31] & B[30] & ~badalignment;
//         assign h0 = sa42 &  B[31] & ~badalignment
//         assign clrregs = RST_I | buserror;
//         assign next_STB_O = help1 | (STB_O & ~qACK);
//         next_sram_stb = ~clrregs & (h2 | (sram_stb & ~sram_ack) 

         if ( NO_CYCLECNT == 0 )  begin
            SB_LUT4 #(.LUT_INIT(16'h0400)) l_help1(.O(help1), .I3(sa42), .I2(B[31]), .I1(B[30]), .I0(badalignment)); 
            SB_LUT4 #(.LUT_INIT(16'hf4f4)) l_next_STB_O( .O(next_STB_O), .I3(1'b0), .I2(help1), .I1(STB_O), .I0(qACK)); 
            SB_LUT4 #(.LUT_INIT(16'heeee)) l_clrregs(.O(clrregs), .I3(1'b0), .I2(1'b0), .I1(RST_I), .I0(buserror));
            SB_DFFSR r_STB_O(    .Q(STB_O),    .C(clk), .R(clrregs), .D(next_STB_O));
         end else begin
            //assign next_STB_O    = (sa42 & ~B[31] & B[30] & ~badalignment) | (rSTB_O & ~qACK ) & ~RST_I;
            SB_LUT4 #(.LUT_INIT(16'h0400)) l_help1(.O(help1), .I3(sa42), .I2(B[31]), .I1(B[30]), .I0(badalignment));
            SB_LUT4 #(.LUT_INIT(16'h00f4)) l_next_STB_O(.O(next_STB_O), .I3(RST_I), .I2(help1), .I1(STB_O), .I0(qACK));
            SB_DFF r_STB_O( .Q(STB_O), .C(clk), .D(next_STB_O));
            assign clrregs = RST_I;
         end
         if ( SRAMADRWIDTH == 0 ) begin
            assign next_sram_stb = 1'b0;
            assign sram_stb = 1'b0;
         end else begin
            wire h2;
            SB_LUT4 #(.LUT_INIT(16'h4040)) l_h2(.O(h2), .I3(1'b0), .I2(sa42), .I1(B[31]), .I0(badalignment)); 
            SB_LUT4 #(.LUT_INIT(16'hf4f4)) l_next_sram_stb( .O(next_sram_stb), .I3(1'b0), .I2(h2), .I1(sram_stb), .I0(sram_ack)); 
            SB_DFFSR r_sram_stb( .Q(sram_stb), .C(clk), .R(clrregs), .D(next_sram_stb));
         end
         
      end
   endgenerate
   
   generate
      if ( we_HIGHLEVEL ) begin

         /* Write enable is set when we do a write to either SRAM or I/O, cleared when ADR_O is cleared.
          * ctrlreg_we is set when we write to address 0x2xxxxxxx.
          * 
          * A special case for "SW". If the address is not word aligned, we
          * do not give WE_O. See above for STB_O.
          * 
          * Non-maskable interrupt clears registers
          */
         reg rWE_O,rctrlreg_we;
         wire next_WE_O = (B[31] | B[30]) & ~badalignment;
         wire next_ctrlreg_we = (B[31:28] == 4'b0010) & ~badalignment;
         always @(posedge clk)
           if ( (~sa14 | RST_I | buserror) ) begin
              rWE_O       <= 1'b0;
              rctrlreg_we <= 1'b0;
           end else if ( sa43 & ~buserror ) begin
              rWE_O       <= next_WE_O;
              rctrlreg_we <= next_ctrlreg_we;
           end
         assign WE_O = rWE_O;
         assign ctrlreg_we = rctrlreg_we;         

      end else begin

         wire next_WE_O,next_ctrlreg_we;
         wire clearweregs,updateweregs,ioregion;
//         assign ioregion = B[31:28] == 4'b0010;
//         assign clearweregs = (~sa14 | RST_I | buserror);
//         assign next_WE_O       = ~clearweregs & ((B[31] | B[30])       & ~badalignment);
//         assign next_ctrlreg_we = ~clearweregs & ( ioregion & ~badalignment);
//         assign updateweregs = (sa43 & ~buserror) | clearweregs;
         SB_LUT4 #(.LUT_INIT(16'h0004)) l_ioregion(.O(ioregion), .I3(B[31]), .I2(B[30]), .I1(B[29]), .I0(B[28]));
//         SB_LUT4 #(.LUT_INIT(16'hfefe)) l_clearweregs(.O(clearweregs), .I3(1'b0), .I2(sa14), .I1(RST_I), .I0(buserror)); 
         SB_LUT4 #(.LUT_INIT(16'h7f7f)) l_clearweregs(.O(clearweregs), .I3(1'b0), .I2(sa14), .I1(RST_I), .I0(buserror)); 
         SB_LUT4 #(.LUT_INIT(16'h000e)) l_next_WE_O(.O(next_WE_O), .I3(clearweregs), .I2(badalignment), .I1(B[31]), .I0(B[30]));

         SB_LUT4 #(.LUT_INIT(16'hf4f4)) I_updateweregs( .O(updateweregs), .I3(1'b0), .I2(clearweregs), .I1(sa43), .I0(buserror));
         SB_DFFE r_WE_O(       .Q(WE_O),       .C(clk), .E(updateweregs), .D(next_WE_O) );

         if ( MTIMETAP < MTIMETAP_LOWLIM ) begin
            assign ctrlreg_we = 1'b0;
         end else begin
            SB_LUT4 #(.LUT_INIT(16'h0202)) I_next_ctrlreg_we(.O(next_ctrlreg_we), .I3(1'b0), .I2(clearweregs), .I1(badalignment), .I0(ioregion));
            SB_DFFE r_ctrlreg_we( .Q(ctrlreg_we), .C(clk), .E(updateweregs), .D(next_ctrlreg_we) );
         end

      end
   endgenerate
      
   
   /* Register ADR_O holds the address when we read and write.
    * When an ack is seen it is sampled with the data.
    * When we ask for a shift of 0, it is held.
    * 
    * sa32
    * |sa15  Codes in ucode.h
    * 00     Qzh,Qhld,Qx
    * 01     Qu,Qshr,Qz,Qzh,Qudec,Qx
    * 10     Qextra
    * 11     Qs.Qcndz
    */
   generate
      if ( SRAMADRWIDTH != 0 ) begin
         if ( enaQ_HIGHLEVEL ) begin
            if ( MULDIV == 0 ) begin
               assign cond_holdq = 0;
               assign enaQ = (sa15 | sa32) & ~lastshift & ~(STB_O | sram_stb);
            end else begin
               wire mod_lastshift = lastshift & ~lastshiftoverride;
               assign cond_holdq = ~alu_carryout & clrM & ~ceM & isDIVREM;
               assign enaQ = ((sa15 | sa32) & ~mod_lastshift & ~(STB_O | sram_stb)) & ~cond_holdq;
            end
            assign progress_ucode = ((~sa33 | lastshift | rlastshift) & ~(STB_O | sram_stb)) | buserror;
         end else begin
            wire h3,hcy;
//            assign h1 = ~sa33 | lastshift | rlastshift;
//            assign progress_ucode = (h1 & ~(STB_O | sram_stb)) | buserror;
//            assign hcy = STB_O | sram_stb;
//            assign enaQ = (sa15 | sa32) & ~lastshift & ~hcy;
//se next line SB_LUT4 #(.LUT_INIT(16'hdfdf)) l_h3(.O(h3), .I3(1'b0), .I2(sa33), .I1(lastshift), .I0(r_issh0_not));
            SB_LUT4 #(.LUT_INIT(16'hefef)) l_h3(.O(h3), .I3(1'b0), .I2(sa33), .I1(lastshift), .I0(rlastshift));
            SB_LUT4 #(.LUT_INIT(16'hff02)) l_progress_ucode(.O(progress_ucode), .I3(buserror), .I2(STB_O), .I1(sram_stb), .I0(h3));
            SB_CARRY l_hcy(.CO(hcy), .CI(1'b1), .I1(STB_O), .I0(sram_stb));
            SB_LUT4 #(.LUT_INIT(16'h000e)) l_enaQ(.O(enaQ), .I3(hcy), .I2(lastshift), .I1(sa15), .I0(sa32));
         end
      end else begin
         if ( enaQ_HIGHLEVEL ) begin
            if ( MULDIV == 0 ) begin
               assign cond_holdq = 0;
               assign enaQ = (sa15 | sa32) & ~lastshift & ~STB_O;
            end else begin
               wire mod_lastshift = lastshift & ~lastshiftoverride;
               assign cond_holdq = ~alu_carryout & clrM & ~ceM & isDIVREM;
               assign enaQ = ((sa15 | sa32) & ~mod_lastshift & ~STB_O) & ~cond_holdq;
            end
            assign progress_ucode = ((~sa33 | lastshift | rlastshift) & ~STB_O) | buserror;
         end else begin
//            assign enaQ            = (sa15 | sa32) & ~lastshift   & ~STB_O;
//            assign progress_ucode = ((~sa33 | lastshift | rlastshift) & ~STB_O) | buserror;
            wire g1;
            
            SB_LUT4 #(.LUT_INIT(16'h000e)) l_enaQ(.O(enaQ), .I3(STB_O), .I2(lastshift), .I1(sa15), .I0(sa32)); //correct
//            SB_LUT4 #(.LUT_INIT(16'h000e)) l_enaQ(.O(enaQ), .I3(STB_O), .I2(lastshift), .I1(sa15), .I0(alu_carryout)); // test

//see next line            SB_LUT4 #(.LUT_INIT(16'h00f7)) l_g1(.O(g1), .I3(STB_O), .I2(lastshift), .I1(sa33), .I0(r_issh0_not));
            SB_LUT4 #(.LUT_INIT(16'h00fb)) l_g1(.O(g1), .I3(STB_O), .I2(lastshift), .I1(sa33), .I0(rlastshift)); 
            SB_LUT4 #(.LUT_INIT(16'heeee)) I_progress_ucode(.O(progress_ucode), .I3(1'b0), .I2(1'b0), .I1(buserror), .I0(g1));
         end
      end
   endgenerate

   generate
      if ( iwe_HIGHLEVEL ) begin
         /* Internal write enable to EBR, mostly active, but not active when:
          *     sa41 == 1         Wnn, Wbp, Whp, Sets up SEL_O
          *     WE_O              We write to SRAM or I/O
          *     rlastshift == 1   Shift right, but inhibit because we want shift 0 
          * 
          * To avoid a potential write the very first active cycle, we qualify write with corerunning.
          * Work. Check if this is really needed.
          */
         wire avoid_iwe = sa41 | WE_O | rlastshift;
         assign iwe = ~avoid_iwe & corerunning;
      end else begin
//see next line            SB_LUT4 #(.LUT_INIT(16'h0200)) l_iwe(.O(iwe), .I3(corerunning), .I2(sa41), .I1(WE_O), .I0(r_issh0_not));
         SB_LUT4 #(.LUT_INIT(16'h0100)) l_iwe(.O(iwe), .I3(corerunning), .I2(sa41), .I1(WE_O), .I0(rlastshift));         
      end
   endgenerate

   generate
      if ( DISREGARD_WB4_3_55 ) begin
         if ( qACK_HIGHLEVEL ) begin
            assign qACK =  (ACK_I | sysregack);
         end else begin
            if ( MTIMETAP < MTIMETAP_LOWLIM ) begin
               assign qACK = ACK_I;
            end else begin
               SB_LUT4 #(.LUT_INIT(16'heeee)) l_iwe(.O(qACK), .I3(1'b0), .I2(1'b0), .I1(ACK_I), .I0(sysregack));
            end
         end
      end else begin

         /* If we ever see an ACK_I without STB_O, the input device is malfunctioning.
          * There is one situation where this legaly can occur according to Whisbone B.4:
          * 
          * PERMISSION 3.35
          * Under certain circumstances SLAVE interfaces MAY be designed to hold [ACK_O] in the
          * asserted state. This situation occurs on point-to-point interfaces where there is a single
          * SLAVE on the interface, and that SLAVE always operates without wait states.
          * RULE 3.55
          * MASTER interfaces MUST be designed to operate normally when the SLAVE interface
          * holds [ACK_I] in the asserted state.      
          * 
          * There is not much I can do if the input data structure is faulty (ACK_I wrong).
          * But I can at least assume we are in the situation as stated in rule 3.55. 
          * If I observe ACK_I without STB_O, I disregard ACK_I, and uses STB_O instead.
          * In an attempt to get midgetv to work with a faulty input device, if we later
          * see ACK_I low, we go back to normal operation. State machine:
          * 
          *         sysregack
          *         | ACK_I
          *         | | STB_O
          * State   | | |   Next state qACK
          * NORMAL  0 0 0   NORMAL     0
          *         0 0 1   NORMAL     0
          *         0 1 0   R355       0
          *         0 1 1   NORMAL     1
          *         1 0 0   NORMAL     1
          *         1 0 1   NORMAL     1
          *         1 1 0   R355       1
          *         1 1 1   NORMAL     1  <- What should I do here? An input device gives ACK on an address reserved for status registers.
          * R355    0 0 0   NORMAL     0
          *         0 0 1   NORMAL     1
          *         0 1 0   R355       0
          *         0 1 1   R355       1
          *         1 0 0   NORMAL     1
          *         1 0 1   NORMAL     1
          *         1 1 0   R355       1
          *         1 1 1   R355       1
          */
         if ( qACK_HIGHLEVEL ) begin

            reg AckM;
            reg nextAckM;
            reg rqACK;
            always @(*) begin
               case ({AckM,sysregack,ACK_I,STB_O})
                 4'b0000 : {nextAckM, rqACK} = 2'b00;
                 4'b0001 : {nextAckM, rqACK} = 2'b00;
                 4'b0010 : {nextAckM, rqACK} = 2'b10;
                 4'b0011 : {nextAckM, rqACK} = 2'b01;
                 4'b0100 : {nextAckM, rqACK} = 2'b01;
                 4'b0101 : {nextAckM, rqACK} = 2'b01;
                 4'b0110 : {nextAckM, rqACK} = 2'b11;
                 4'b0111 : {nextAckM, rqACK} = 2'b01;
                 4'b1000 : {nextAckM, rqACK} = 2'b00;
                 4'b1001 : {nextAckM, rqACK} = 2'b01;
                 4'b1010 : {nextAckM, rqACK} = 2'b10;
                 4'b1011 : {nextAckM, rqACK} = 2'b11;
                 4'b1100 : {nextAckM, rqACK} = 2'b01;
                 4'b1101 : {nextAckM, rqACK} = 2'b01;
                 4'b1110 : {nextAckM, rqACK} = 2'b11;
                 4'b1111 : {nextAckM, rqACK} = 2'b11;
               endcase
            end
            always @(posedge clk)
              AckM <= nextAckM;
            assign qACK = rqACK;

         end else begin

            wire nextAckM,AckM;
            SB_LUT4 #(.LUT_INIT(16'hfaf8)) l_qACK(    .O(qACK),     .I3(AckM), .I2(sysregack), .I1(ACK_I), .I0(STB_O));
            SB_LUT4 #(.LUT_INIT(16'hc4c4)) l_nextAckM(.O(nextAckM), .I3(1'b0), .I2(AckM),      .I1(ACK_I), .I0(STB_O));
            SB_DFF AckM_r(.Q(AckM), .C(clk), .D(nextAckM));

         end
      end
   endgenerate

   generate
      if ( RVC == 0 ) begin

         /* No code for this case */
         assign pcinc_by_2 = 1'b0;
         assign pc1 = 1'b0;
         assign was_rvc_instr = 1'b0;
         assign luh = 1'b0;
      end else begin

         if ( RVC_HIGHLEVEL ) begin
            
            wire potential_rvc_instr = pc1 ? Di[17:16] != 3 : Di[1:0] != 3;
            /* To correctly decode the RVC (and unaligned 32-bit wide instructions) we need access to pc[1] in
             * a cycle where it is not normally available. It is mirrored to pc1.
             */
            reg  reg_pc1;
            always @(posedge clk) begin
               if ( {sa27,sa26,sa25,sa24} == 4'b1010 ) begin// Wpc
                  reg_pc1 <= B[1];
               end
            end
            assign pc1 = reg_pc1;
            
            /* When RVC instructions are implemented, PC must be incremented by 2 rather than 4 when a
             * RVC instruction was seen. An RVC instruction is seen when the two lsb != 3 and the instruction
             * is latched (sa12==1).
             * PC will also be incremented with 2 when we have an unaligned 32-bit instruction. Because
             * an unaligned 32-bit instruction is followed by either a 16-bit instruction, or yet another
             * unaligned 32-bit instruction, we have was_rvc_instr <= potential_rvc_instr | luh, hece
             * was_rvc_instr is a misnomer.
             */
            reg reg_was_rvc_instr;
            always @(posedge clk)
              if (sa12 & progress_ucode)
                reg_was_rvc_instr <= potential_rvc_instr | luh;
            assign was_rvc_instr = reg_was_rvc_instr;
            assign pcinc_by_2 = was_rvc_instr | pc1;
            
            /* When pc is incremented from ...10 to ...00, and we did not see a rvc instruction,
             * we need to load the upper half word of an unaligned 32-bit instruction
             */
            reg reg_luh;
            always @(posedge clk)
              if (sa12 & progress_ucode)
                reg_luh <= pc1 & ~potential_rvc_instr;
            assign luh = reg_luh;

         end else begin
            /*
             *
             *           ___                           ___              
             *  sa24 ---|I0 |              pc1 -------|I0 | cmb_pc1  __          
             *  sa25 ---|I1 |-- upd_pc1    B[1] ------|I1 |---------|  |-- pc1
             *  sa26 ---|I2 |              upd_pc1 ---|I2 |         >__|
             *  sa27 ---|I3_|                      ---|I3_|             
             *                     
             *                        ___
             * Di[0] ----------------|I0 |
             * Di[1] ----------------|I1 |----------- potential_rvc_instr
             * pc1 ------------------|I2 |
             *                   +---|I3_|
             *                  /y\   ___
             * pc1 -------------(((--|I0 |
             *          Di[16] -((+--|I1 |----------- pcinc_by_2
             *          Di[17] -+(---|I2 |
             * was_rvc_instr ----(---|I3_|
             *                   0
             *                        ___
             * potential_rvc_instr --|I0 |
             * luh  -----------------|I1 | lwas_rvc_instr __         
             * was_rvc_instr --------|I2 |---------------|  |-- was_rvc_instr
             * sa12 -----------------|I3_|               >  |        
             * progress_ucode ---------------------------E__|        
             *
             *                        ___
             * potential_rvc_instr --|I0 |
             * pc1  -----------------|I1 | lluh           __         
             * luh ------------------|I2 |---------------|  |-- luh  
             * sa12 -----------------|I3_|               >  |        
             * progress_ucode ---------------------------E__|        
             */
            wire lwas_rvc_instr,lluh;
            wire Di17and16,upd_pc1,cmb_pc1;
            wire potential_rvc_instr;
            
            bn_l4v #(.I(16'h0400)) lupd_pc1(.o(upd_pc1),.i({sa27,sa26,sa25,sa24}));
            bn_l4v #(.I(16'hcaca)) lcmb_pc1(.o(cmb_pc1),.i({1'b0,upd_pc1,B[1],pc1}));
            SB_DFF regpc1( .Q(pc1), .C(clk), .D(cmb_pc1));

            bn_lcy4v_b #(.I(16'hffaa)) lpcinc_by_2(.o(pcinc_by_2),.co(Di17and16), .ci(1'b0), .i({was_rvc_instr,Di[17:16],pc1}));
            bn_l4v #(.I(16'h07f7)) lpotential_rvc_instr(.o(potential_rvc_instr),.i({Di17and16,pc1,Di[1:0]}));

            bn_l4v #(.I(16'heef0)) llwas_rvc_instr(.o(lwas_rvc_instr),.i({sa12,was_rvc_instr,luh,potential_rvc_instr}));
            SB_DFFE regwas_rvc_instr( .Q(was_rvc_instr),.C(clk),.E(progress_ucode),.D(lwas_rvc_instr));
            
            bn_l4v #(.I(16'h44f0)) llluh(.o(lluh),.i({sa12,luh,pc1,potential_rvc_instr}));
            SB_DFFE regluh( .Q(luh),.C(clk),.E(progress_ucode),.D(lluh));
            
         end
      end
   endgenerate

   
`ifdef verilator   
   function [6:0] get_dbg_stb_ack;
      // verilator public
      get_dbg_stb_ack = {progress_ucode, enaQ, WE_O, 1'b00, 1'b0, 1'b0, 1'b0 };
   endfunction
   function [0:0] get_was_rvc_instr;
      // verilator public
      get_was_rvc_instr = was_rvc_instr;
   endfunction
`endif
 
   assign m_progressctrl_killwarnings = &B[31:2] | sram_ack | clrregs | isDIVREM | clrM | ceM | alu_carryout | &Di[17:0];
endmodule


/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019-2020. Copyright B. Nossum.
 * For licence, see LICENCE
 * ----------------------------------------------------------------------------ehdr
 *
 * For multiply and divide.
 * Fun fact. Lattice do highlevel synthesis in 35 LUTs, while Synplify uses 95.
 * 
 *           +-------------+
 * M[i+1] ---|--|0\        |          rA[i]
 *           |  |  |-|1\   |           ____
 * M[i-1] ---|--|1/  |  |--|--- cmbM -|D  Q|- M[i]
 * DAT_O  ---|---+---|0/   |    clk  ->    |
 * loadMn ---|--------+    |    ceM  -E    |
 *           +-------------+    clrM -R____|
 * 
 *                      Possible enhancement
 *           |          Carry chain usable to do a zero find,
 *          /y\  ___    for instance if ADR_O > 0x00000FFF,
 * M[i-1] --(((-|I0 |   or similar, this indicates adr in 
 * M[i+1] --+((-|I1 |   EBR range
 * loadMn ---(+-|I2 |
 * DAT_O[i] -(--|I3_|
 *           |
 *           :
 *           0
 *
 * The lsb is special.
 */
module m_shlr
  # ( parameter 
`ifdef verilator      
      ALUWIDTH = 8,
`else
      ALUWIDTH = 32,
`endif
      MULDIV = 1,
      HIGHLEVEL = 1
      )
   (
    /* verilator lint_off UNUSED */
    input                 clk,
    input                 loadMn, //    Initiating
    input                 ceM, //       Need to hold register certain cycles
    input                 clrM, //      Register must be clared to allow DAT_I to midgetv. Also used to determine lsb during unsigned subtraction in DIV
    input                 cmb_rF2, //   Used to determine lsb during unsigned subtraction in DIV    
    input                 ADR_O0, //    During MULx we shift right. This is msb
    input [ALUWIDTH-1:0]  DAT_O, //     To initiate shift register
    /* verilator lint_on UNUSED */
    output [ALUWIDTH-1:0] MULDIVREG  // Eventually holds low 32 bits of MULT or quotient of DIV
    );
   
   generate
      if ( HIGHLEVEL ) begin
         if ( MULDIV == 0 ) begin
            assign MULDIVREG = 0;
         end else begin
            reg [ALUWIDTH-1:0]  rM;
            wire [ALUWIDTH-2:0] cmbMmost,shlMmost,shrMmost;
            wire                shlM0,shrM0,shift_realcmbMlsb,add_realcmbMlsb,realcmbMlsb,ceMlsb,cmbMlsb;
            
            assign shlMmost = rM[ALUWIDTH-2:0];
            assign shrMmost = {ADR_O0,rM[ALUWIDTH-1:2]};
            assign cmbMmost = loadMn ? (DAT_O[ALUWIDTH-1:1]&shlMmost) | (~DAT_O[ALUWIDTH-1:1]&shrMmost) : DAT_O[ALUWIDTH-1:1];
            
            assign shlM0 = 1'b0;
            assign shrM0 = MULDIVREG[1];
            assign shift_realcmbMlsb = loadMn ? (DAT_O[0] & shlM0) | (~DAT_O[0] & shrM0) : DAT_O[0];
            assign add_realcmbMlsb = ~cmb_rF2;
            assign realcmbMlsb = (clrM & add_realcmbMlsb) | (~clrM & shift_realcmbMlsb);
            assign ceMlsb  =  ceM | clrM;
            assign cmbMlsb = ceMlsb ? realcmbMlsb : rM[0];
            
            always @(posedge clk)
              if ( ceM ) 
                rM[ALUWIDTH-1:1] <= clrM ? 31'h0 : cmbMmost;
            
            always @(posedge clk)
              rM[0] <= cmbMlsb;
            
            assign MULDIVREG = rM;
         end
      end
   endgenerate
   
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2020-2019. Copyright B. Nossum.
 * For licence, see LICENCE
 * ----------------------------------------------------------------------------ehdr
  
 Midgetv ignores all hints, and reserved instructions execute something. All
 floating point instructions are illegal. 
 
 Translation from rv32c instruction to rv32i instruction. Here we name:
     rd and rs1/rd as D4 D3 D2 D1 D0
     rs1 as S4 S3 S2 S1 S0
     rs2 as T4 T3 T2 T1 T0
     rd' and rs1'/rd' as d2 d1 d0
     rs1' as s2 s1 s0
     rs2' as t2 t1 t0
 Sign-extended immediates are named as i<x>, with <x> the bit number
 Zero-extended immediates are named as z<x>
 Fixed bits is represented as 0 and 1
 
 Compressed instruction c[15:0]                       | Translated instruction e[31:0]
   111                                                |        
 10543              12  11 10  9  8  7  6  5  4  3  2 | 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7 6543210      
 -----              --  -- -- -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -------
 01011 C.LUI        ih  D4 D3 D2 D1 D0 ig if ie id ic | ih ih ih ih ih ih ih ih ih ih ih ih ih ih ih ig if ie id ic D4 D3 D2 D1 D0 0110111  lui rd,nzimm[17:12].  rd!=0, rd!=2
 01011 C.ADDI16SP   i9   0  0  0  1  0 i4 i6 i8 i7 i5 | i9 i9 i9 i8 i7 i6 i5 i4  0  0  0  0  0  0  0  1  0  0  0  0  0  0  0  1  0 0010011  addi x2,x2,nzimm[9:4]
 10100 C.JR          0  S4 S3 S2 S1 S0  0  0  0  0  0 |  0  0  0  0  0  0  0  0  0  0  0  0 S4 S3 S2 S1 S0  0  0  0  0  0  0  0  0 1100111  jalr x0,0(rs1)  (rs1 != 0)
 10100 C.MV          0  D4 D3 D2 D1 D0 T4 T3 T2 T1 T0 |  0  0  0  0  0  0  0 T4 T3 T2 T1 T0  0  0  0  0  0  0  0  0 D4 D3 D2 D1 D0 0110011  add rd,rd,rs2          
 01100 C.AND         0   1  1 d2 d1 d0  1  1 t2 t1 t0 |  0  0  0  0  0  0  0  0  1 t2 t1 t0  0  1 d2 d1 d0  1  1  1  0  1 d2 d1 d0 0110011  and rd',rd',rs2'
 01100 C.OR          0   1  1 d2 d1 d0  1  0 t2 t1 t0 |  0  0  0  0  0  0  0  0  1 t2 t1 t0  0  1 d2 d1 d0  1  1  0  0  1 d2 d1 d0 0110011  or rd',rd'rs2'
 01100 C.SUB         0   1  1 d2 d1 d0  0  0 t2 t1 t0 |  0  1  0  0  0  0  0  0  1 t2 t1 t0  0  1 d2 d1 d0  0  0  0  0  1 d2 d1 d0 0110011  sub rd',rd',rs2'
 01100 C.XOR         0   1  1 d2 d1 d0  0  1 t2 t1 t0 |  0  0  0  0  0  0  0  0  1 t2 t1 t0  0  1 d2 d1 d0  1  0  0  0  1 d2 d1 d0 0110011  xor rd',rd',rs2'
 10100 C.ADD         l  D4 D3 D2 D1 D0 T4 T3 T2 T1 T0 |  0  0  0  0  0  0  0 T4 T3 T2 T1 T0 D4 D3 D2 D1 D0  0  0  0 D4 D3 D2 D1 D0 0110011  add rd,rd,rs2
 10100 C.EBREAK      l   0  0  0  0  0  0  0  0  0  0 |  0  0  0  0  0  0  0  0  0  0  0  1  0  0  0  0  0  0  0  0  0  0  0  0  0 1110011  ebreak
 10100 C.JALR        l  S4 S3 S2 S1 S0  0  0  0  0  0 |  0  0  0  0  0  0  0  0  0  0  0  0 S4 S3 S2 S1 S0  0  0  0  0  0  0  0  1 1100111  jalr x1,0(rs1)  (rs1 != 0)
 01100 reserved      1   1  1  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x xxxxx11  
 00000 C.ADDI4SPN   z5  z4 z9 z8 z7 z6 z2 z3 d2 d1 d0 |  0  0 z9 z8 z7 z6 z5 z4 z3 z2  0  0  0  0  0  1  0  0  0  0  0  1 d2 d1 d0 0010011  addi rd',x2,mzuimm[9:2]   
 00001 C.FLD         x   x  x  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x xxxxxx0  illegal
 00010 C.LW         z5  z4 z3 s2 s1 s0 z2 z6 d2 d1 d0 |  0  0  0  0  0 z6 z5 z4 z3 z2  0  0  0  1 s2 s1 s0  0  1  0  0  1 d2 d1 d0 0000011  lw rd',offset[6:2](rs1')
 00011 C.FLW         x   x  x  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x xxxxxx0  illegal
 00100 reserved      x   x  x  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x xxxxx11  
 00101 C.FSD         x   x  x  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x xxxxxx0  illegal
 00110 C.SW         z5  z4 z3 s2 s1 s0 z2 z6 t2 t1 t0 |  0  0  0  0  0 z6 z5  0  1 t2 t1 t0  0  1 s2 s1 s0  0  1  0 z4 z3 z2  0  0 0100011  sw rs2',offset[6:2](rs1') 
 00111 C.FSW         x   x  x  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x xxxxxx0  illegal
 01000 C.ADDI/C.NOP i5  D4 D3 D2 D1 D0 i4 i3 i2 i1 i0 | i5 i5 i5 i5 i5 i5 i5 i4 i3 i2 i1 i0 D4 D3 D2 D1 D0  0  0  0 D4 D3 D2 D1 D0 0010011  addi rd,rd,nzimm[5:0] 
 01001 C.JAL        ib  i4 i9 i8 ia i6 i7 i3 i2 i1 i5 | ib ia i9 i8 i7 i6 i5 i4 i3 i2 i1 ib ib ib ib ib ib ib ib ib  0  0  0  0  1 1101111  jal x1, offset[11:1]
 01010 C.LI         i5  D4 D3 D2 D1 D0 i4 i3 i2 i1 i0 | i5 i5 i5 i5 i5 i5 i5 i4 i3 i2 i1 i0  0  0  0  0  0  0  0  0 D4 D3 D2 D1 D0 0010011  addi rd,x0,imm[5:0] 
 01101 C.J          ib  i4 i9 i8 ia i6 i7 i3 i2 i1 i5 | ib ia i9 i8 i7 i6 i5 i4 i3 i2 i1 ib ib ib ib ib ib ib ib ib  0  0  0  0  0 1101111  jal x0, offset[11:1]
 01110 C.BEQZ       i8  i4 i3 s2 s1 s0 i7 i6 i2 i1 i5 | i8 i8 i8 i8 i7 i6 i5  0  0  0  0  0  0  1 s2 s1 s0  0  0  0 i4 i3 i2 i1 i8 1100011  beq rs1',x0,offset[8:1]                  
 01111 C.BNEZ       i8  i4 i3 s2 s1 s0 i7 i6 i2 i1 i5 | i8 i8 i8 i8 i7 i6 i5  0  0  0  0  0  0  1 s2 s1 s0  0  0  1 i4 i3 i2 i1 i8 1100011  bne rs1',x0,offset[8:1]                  
 10000 C.SLLI        x  D4 D3 D2 D1 D0 z4 z3 z2 z1 z0 |  0  0  0  0  0  0  0 z4 z3 z2 z1 z0 D4 D3 D2 D1 D0  0  0  1 D4 D3 D2 D1 D0 0010011  slli rd,rd,shamt[5:0]
 10001 C.FLDSP       x   x  x  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x xxxxxx0  illegal
 10010 C.LWSP       z5  D4 D3 D2 D1 D0 z4 z3 z2 z7 z6 |  0  0  0  0 z7 z6 z5 z4 z3 z2  0  0  0  0  0  1  0  0  1  0 D4 D3 D2 D1 D0 0000011  lw rd,offset[7:2](x2)
 10011 C.FLWSP       x   x  x  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x xxxxxx0  illegal
 10101 C.FSDSP       x   x  x  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x xxxxxx0  illegal
 10110 C.SWSP       z5  z4 z3 z2 z7 z6 T4 T3 T2 T1 T0 |  0  0  0  0 z7 z6 z5 T4 T3 T2 T1 T0  0  0  0  1  0  0  1  0 z4 z3 z2  0  0 0100011  sw rs2,offset[7:2](x2)
 10111 C.FSWSP       x   x  x  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x xxxxxx0  illegal
 01100 C.ANDI       i5   1  0 d2 d1 d0 i4 i3 i2 i1 i0 | i5 i5 i5 i5 i5 i5 i5 i4 i3 i2 i1 i0  0  1 d2 d1 d0  l  l  l  0  1 d2 d1 d0 0010011  andi rd',rd',imm[5:0]
 01100 C.SRAI        x   0  1 d2 d1 d0 z4 z3 z2 z1 z0 |  0  1  0  0  0  0  0 z4 z3 z2 z1 z0  0  1 d2 d1 d0  1  0  1  0  1 d2 d1 d0 0010011  srai rd',rd',shamt[5:0]
 01100 C.SRLI        x   0  0 d2 d1 d0 z4 z3 z2 z1 z0 |  0  1  0  0  0  0  0 z4 z3 z2 z1 z0  0  1 d2 d1 d0  1  0  1  0  1 d2 d1 d0 0010011  srli rd',rd',shamt[5:0]

In following tables, numbers from 2 to 12 is from the compressed instruction, while 0 and 1 mean zero and one.
 
11                                                  Auxiliary mux for SRLI/SRAI/ANDI/SUB/XOR/OR/AND
1065            12  11 10  9  8  7  6  5  4  3  2 | 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0                         
||||            --  -- -- -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --  -  -  -  -  -  -  -                         
00xx   C.SRLI    x   0  0 d2 d1 d0 z4 z3 z2 z1 z0 |  0  1  0  0  0  0  0  6  5  4  3  2  0  1  9  8  7  1  0  1  0  1  9  8  7  0  0  1  0  0  1  1  srli rd',rd',shamt[5:0]                               
01xx   C.SRAI    x   0  1 d2 d1 d0 z4 z3 z2 z1 z0 |  0  1  0  0  0  0  0  6  5  4  3  2  0  1  9  8  7  1  0  1  0  1  9  8  7  0  0  1  0  0  1  1  srai rd',rd',shamt[5:0]
10xx   C.ANDI   i5   1  0 d2 d1 d0 i4 i3 i2 i1 i0 | 12 12 12 12 12 12 12  6  5  4  3  2  0  1  9  8  7  1  1  1  0  1  9  8  7  0  0  1  0  0  1  1  andi rd',rd',imm[5:0]
1100   C.SUB     0   1  1 d2 d1 d0  0  0 t2 t1 t0 |  0  1  0  0  0  0  0  0  1  4  3  2  0  1  9  8  7  0  0  0  0  1  9  8  7  0  1  1  0  0  1  1  sub rd',rd',rs2'
1101   C.XOR     0   1  1 d2 d1 d0  0  1 t2 t1 t0 |  0  0  0  0  0  0  0  0  1  4  3  2  0  1  9  8  7  1  0  0  0  1  9  8  7  0  1  1  0  0  1  1  xor rd',rd',rs2'
1110   C.OR      0   1  1 d2 d1 d0  1  0 t2 t1 t0 |  0  0  0  0  0  0  0  0  1  4  3  2  0  1  9  8  7  1  1  0  0  1  9  8  7  0  1  1  0  0  1  1  or rd',rd'rs2'
1111   C.AND     0   1  1 d2 d1 d0  1  1 t2 t1 t0 |  0  0  0  0  0  0  0  0  1  4  3  2  0  1  9  8  7  1  1  1  0  1  9  8  7  0  1  1  0  0  1  1  and rd',rd',rs2'
11xx   reserved  1   1  1  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  No decode on c[12], folds 
                                                    36 37 36 36 36 36 36 38 39  4  3  2  0  1  9  8  7 40 41 42  0  1  9  8  7  0 43  1  0  0  1  1           into cases above
c[11:7]==5'h2 (rs1eq2)                                                                                                                                                     
|                                                   Auxiliary mux for LUO/ADDI16SP
|               12  11 10  9  8  7  6  5  4  3  2 | 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0                         
|               --  -- -- -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --  -  -  -  -  -  -  -                         
0  C.LUI        ih  D4 D3 D2 D1 D0 ig if ie id ic | 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12  6  5  4  3  2 11 10  9  8  7  0  1  1  0  1  1  1  lui rd,nzimm[17:12].    
1  C.ADDI16SP   i9   0  0  0  1  0 i4 i6 i8 i7 i5 | 12 12 12  4  3  5  2  6  0  0  0  0  0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  1  0  0  1  1  addi x2,x2,nzimm[9:4] 
                                                    12 12 12 20 21 22 23 24 25 25 25 25 25 25 25 26 27 28 29 30 31 32 33 34 35  0 17  1  0 17  1  1
  c[11:7]==5'h0 (rs1eq0)                                                                                                                            
1|c[6:2]==5'h0 (rs2eq0)                             Auxiliary mux for MV/JR/JALR/EBREAK/AND
2||             12  11 10  9  8  7  6  5  4  3  2 | 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0        
|||             --  -- -- -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --  -  -  -  -  -  -  -  
0x0  C.MV        0  D4 D3 D2 D1 D0 T4 T3 T2 T1 T0 |  0  0  0  0  0  0  0  6  5  4  3  2  0  0  0  0  0  0  0  0 11 10  9  8  7  0  1  1  0  0  1  1  add rd,rd,rs2          
0x1  C.JR        0  S4 S3 S2 S1 S0  0  0  0  0  0 |  0  0  0  0  0  0  0  0  0  0  0  0 11 10  9  8  7  0  0  0  0  0  0  0  0  1  1  0  0  1  1  1  jalr x0,0(rs1)                  
101  C.JALR      l  S4 S3 S2 S1 S0  0  0  0  0  0 |  0  0  0  0  0  0  0  0  0  0  0  0 11 10  9  8  7  0  0  0  0  0  0  0  1  1  1  0  0  1  1  1  jalr x1,0(rs1)                  
111  C.EBREAK    l   0  0  0  0  0  0  0  0  0  0 |  0  0  0  0  0  0  0  0  0  0  0  1  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  0  0  1  1  ebreak
1x0  C.ADD       l  D4 D3 D2 D1 D0 T4 T3 T2 T1 T0 |  0  0  0  0  0  0  0  6  5  4  3  2 11 10  9  8  7  0  0  0 11 10  9  8  7  0  1  1  0  0  1  1  add rd,rd,rs2                   
                                                     0  0  0  0  0  0  0 44 45 46 47 48 49 50 51 52 53  0  0  0 54 55 56 57 58 59  1 16  0 19  1  1
12
|rs1eq0                                                                                                                                                        
||rs2eq0
|||                                                  Auxiliary mux for ADDI4SPN/ILLEGAL
1xx C.ADDI4SPN  z5  z4 z9 z8 z7 z6 z2 z3 d2 d1 d0 |  0  0 10  9  8  7 12 11  5  6  0  0  0  0  0  1  0  0  0  0  0  1  4  3  2  0  0  1  0  0  1  1  addi rd',x2,mzuimm[9:2]   
00x C.ADDI4SPN  z5  z4 z9 z8 z7 z6 z2 z3 d2 d1 d0 |  0  0 10  9  8  7 12 11  5  6  0  0  0  0  0  1  0  0  0  0  0  1  4  3  2  0  0  1  0  0  1  1  addi rd',x2,mzuimm[9:2]   
010 C.ADDI4SPN  z5  z4 z9 z8 z7 z6 z2 z3 d2 d1 d0 |  0  0 10  9  8  7 12 11  5  6  0  0  0  0  0  1  0  0  0  0  0  1  4  3  2  0  0  1  0  0  1  1  addi rd',x2,mzuimm[9:2]   
011 ILLEGAL                                       |  0  0 10  9  8  7 12 11  5  6  0  0  0  0  0  1  0  0  0  0  0  1  4  3  2  0  0  1  0  0  1  0  defined illegal 
                                                     0  0 10  9  8  7 12 11  5  6  0  0  0  0  0  1  0  0  0  0  0  1  4  3  2  0  0  1  0  0  1 18  
                                                           
  111                                                     Main translation table
10543                 12  11 10  9  8  7  6  5  4  3  2 | 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0      
-----                 --  -- -- -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --  -  -  -  -  -  -  -
00000  ILLEGAL/ADDI4SPN                                 |  0  0 10  9  8  7 12 11  5  6  0  0  0  0  0  1  0  0  0  0  0  1  4  3  2  0  0  1  0  0  1 18  
00001  C.FLD           x   x  x  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  0  illegal in midgetv
00010  C.LW           z5  z4 z3 s2 s1 s0 z2 z6 d2 d1 d0 |  0  0  0  0  0  5 12 11 10  6  0  0  0  1  9  8  7  0  1  0  0  1  4  3  2  0  0  0  0  0  1  1  lw rd',offset[6:2](rs1')
00011  C.FLW           x   x  x  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  0  illegal in midgetv
00100  reserved        x   x  x  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  don't care in midgetv
00101  C.FSD           x   x  x  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  0  illegal in midgetv
00110  C.SW           z5  z4 z3 s2 s1 s0 z2 z6 t2 t1 t0 |  0  0  0  0  0  5 12  0  1  4  3  2  0  1  9  8  7  0  1  0 11 10  6  0  0  0  1  0  0  0  1  1  sw rs2',offset[6:2](rs1') 
00111  C.FSW           x   x  x  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  0  illegal in midgetv
01000  C.ADDI/C.NOP   i5  D4 D3 D2 D1 D0 i4 i3 i2 i1 i0 | 12 12 12 12 12 12 12  6  5  4  3  2 11 10  9  8  7  0  0  0 11 10  9  8  7  0  0  1  0  0  1  1  addi rd,rd,nzimm[5:0] 
01001  C.JAL          ib  i4 i9 i8 ia i6 i7 i3 i2 i1 i5 | 12  8 10  9  6  7  2 11  5  4  3 12 12 12 12 12 12 12 12 12  0  0  0  0  1  1  1  0  1  1  1  1  jal x1, offset[11:1]       
01010  C.LI           i5  D4 D3 D2 D1 D0 i4 i3 i2 i1 i0 | 12 12 12 12 12 12 12  6  5  4  3  2  0  0  0  0  0  0  0  0 11 10  9  8  7  0  0  1  0  0  1  1  addi rd,x0,imm[5:0] 
01011  LUI/ADDI16SP                                     | 12 12 12 20 21 22 23 24 25 25 25 25 25 25 25 26 27 28 29 30 31 32 33 34 35  0 17  1  0 17  1  1
01100  SRLI/SRAI/ANDI/SUB/XOR/OR/AND                    | 36 37 36 36 36 36 36 38 39  4  3  2  0  1  9  8  7 40 41 42  0  1  9  8  7  0 43  1  0  0  1  1
01101  C.J            ib  i4 i9 i8 ia i6 i7 i3 i2 i1 i5 | 12  8 10  9  6  7  2 11  5  4  3 12 12 12 12 12 12 12 12 12  0  0  0  0  0  1  1  0  1  1  1  1  jal x0, offset[11:1]
01110  C.BEQZ         i8  i4 i3 s2 s1 s0 i7 i6 i2 i1 i5 | 12 12 12 12  6  5  2  0  0  0  0  0  0  1  9  8  7  0  0  0 11 10  4  3 12  1  1  0  0  0  1  1  beq rs1',x0,offset[8:1]                  
01111  C.BNEZ         i8  i4 i3 s2 s1 s0 i7 i6 i2 i1 i5 | 12 12 12 12  6  5  2  0  0  0  0  0  0  1  9  8  7  0  0  1 11 10  4  3 12  1  1  0  0  0  1  1  bne rs1',x0,offset[8:1]                  
10000  C.SLLI          x  D4 D3 D2 D1 D0 z4 z3 z2 z1 z0 |  0  0  0  0  0  0  0  6  5  4  3  2 11 10  9  8  7  0  0  1 11 10  9  8  7  0  0  1  0  0  1  1  slli rd,rd,shamt[5:0] 
10001  C.FLDSP         x   x  x  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  0  illegal in midgetv
10010  C.LWSP         z5  D4 D3 D2 D1 D0 z4 z3 z2 z7 z6 |  0  0  0  0  3  2 12  6  5  4  0  0  0  0  0  1  0  0  1  0 11 10  9  8  7  0  0  0  0  0  1  1  lw rd,offset[7:2](x2) 
10011  C.FLWSP         x   x  x  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  0  illegal in midgetv
10100  MV/JR/JALR/EBREAK/ADD                            |  0  0  0  0  0  0  0 44 45 46 47 48 49 50 51 52 53  0  0  0 54 55 56 57 58 59  1 16  0 19  1  1
10101  C.FSDSP         x   x  x  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  0  illegal
10110  C.SWSP         z5  z4 z3 z2 z7 z6 T4 T3 T2 T1 T0 |  0  0  0  0  8  7 12  6  5  4  3  2  0  0  0  1  0  0  1  0 11 10  9  0  0  0  1  0  0  0  1  1  sw rs2,offset[7:2](x2)
10111  C.FSWSP         x   x  x  x  x  x  x  x  x  x  x |  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  0  illegal

 Synplify    : 238 luts
 Lattice LSE : 258 luts
 
*/

/*
 
 Situations:
 pc1 luh
 0    0    Di[31:0] is word aligned. If Di[1:0] != 3, Dii[31:0] is the instruction expanded from Di[15:0].
           If Di[1:0] == 3, Dii[31:0] is  Di[31:0], the incoming normal 32-bit instruction.
           is_valid_instrhigh = 1, is_valid_instrlow = 1
 1    0    Di[31:0] is not word aligned. If Di[17:16] != 3, Dii[31:0] is the instruction expanded from Di[31:16]
           is_valid_instrhigh = 1, is_valid_instrlow = 1
           If Di[17:16] == 3, Dii[15:0] is Di[31:16], the lower hword of the normal 32-bit instruction. Dii[31:16] 
           is not valid.
           is_valid_instrhigh = 0, is_valid_instrlow = 1
 x    1    Di[31:0] is not word aligned and we are to get the upper hword of the normal 32-bit instruction. 
           Here Dii[15:0] is not valid. Dii[31:16] is Di[15:0], the upper howrd of the normal 32-bit instruction.
           is_valid_instrhigh = 1, is_valid_instrlow = 0
 */
module m_RVC # ( parameter RVC = 1) 
   (
    input [31:0]      Di, //  Possibly compressed instruction
    /* verilator lint_off UNUSED */
    input             pc1, // Bit 1 of pc for alignment
    input             luh, // Load upper halfword
    input             sa12, // Anticipating size optimalisation, we bring in this signal that is an overall "is_valid_instr" signal
    /* verilator lint_on UNUSED */
    output reg [31:0] Dii, //  Expanded result
    output reg        is_valid_instrlow,
    output reg        is_valid_instrhigh
    );
   
   generate
      if ( RVC == 0 ) begin
         always @(/*AS*/Di or sa12) begin
            Dii = Di;
            is_valid_instrlow  = sa12;
            is_valid_instrhigh = sa12;
         end
      end else begin
         /*verilator lint_off UNUSED */
         reg [60:0]  cc;
         /*verilator lint_on UNUSED */
         wire [15:0] c   = (pc1 ? Di[31:16] :  Di[15:0]) | {14'h0000,luh,luh};
         wire [15:0] uhw = (pc1 | luh) ? Di[15:0]  : Di[31:16];
//         wire [15:0] uhw = (luh) ? Di[15:0]  : Di[31:16]; Probably all we need

         always @(/*AS*/Di or luh or pc1 or sa12) begin
            is_valid_instrlow  = sa12 & ~luh;
            is_valid_instrhigh = sa12 & (luh | ~pc1 | (Di[17:16] != 2'b11));
         end
         
         wire [4:0]  inx = {c[1:0],c[15:13]};
         wire        rs1eq2 = c[11:7] == 5'b00010;
         wire        rs1eq0 = c[11:7] == 5'b00000;
         wire        rs2eq0 = c[6:2]  == 5'b00000;
         wire [2:0]  jnx = {c[12],rs1eq0,rs2eq0};
         
         always @(/*AS*/c or jnx or rs1eq0 or rs1eq2 or rs2eq0) begin
            cc[15:0] = c[15:0];
            
            // Helping SRLI/SRAI/ANDI/SUB/XOR/OR/AND
            cc[36] = c[11:10] == 2'b10 ? c[12] : 0;
            cc[37] = c[11:10] == 2'b10 ? c[12] : ((c[11:10] == 2'b01) || ( {c[11:10],c[6:5]} == 4'b1100 )) ? 1 : 0;
            cc[38] = c[11:10] != 2'b11 ? c[6] : 0;
            cc[39] = c[11:10] != 2'b11 ? c[5] : 1;
            cc[40] = c[11:10] != 2'b11 ? 1 : c[6:5] != 2'b00 ? 1 : 0;
            cc[41] = c[11:10] == 2'b10 ? 1 : {c[11:10],c[6]} == 3'b111 ? 1 : 0;   
            cc[42] = c[11:10] != 2'b11 ? 1 : c[6:5] == 2'b11 ? 1 : 0;
            cc[43] = c[11:10] == 2'b11 ? 1 : 0;
            cc[60] = c[12:10] == 3'b111 ? c[6] : 1; 
            
            // Helping LUI/ADDI16SP
            cc[20] = rs1eq2 ? c[4] : c[12];
            cc[21] = rs1eq2 ? c[3] : c[12];
            cc[22] = rs1eq2 ? c[5] : c[12];
            cc[23] = rs1eq2 ? c[2] : c[12];
            cc[24] = rs1eq2 ? c[6] : c[12];
            cc[25] = rs1eq2 ? 0    : c[12];
            cc[26] = rs1eq2 ? 1    : c[6];
            cc[27] = rs1eq2 ? 0    : c[5];
            cc[28] = rs1eq2 ? 0    : c[4];
            cc[29] = rs1eq2 ? 0    : c[3];
            cc[30] = rs1eq2 ? 0    : c[2];
            cc[31] = rs1eq2 ? 0    : c[11];
            cc[32] = rs1eq2 ? 0    : c[10];
            cc[33] = rs1eq2 ? 0    : c[9];
            cc[34] = rs1eq2 ? 1    : c[8];
            cc[35] = rs1eq2 ? 0    : c[7];
            cc[17] = rs1eq2 ? 0    : 1;
            
            // Helping MV/JR/JALR/EBREAK/AND
            cc[44] = (jnx == 0 || jnx == 2 || jnx == 4 || jnx == 6 ) ? c[6] : 0;
            cc[45] = (jnx == 0 || jnx == 2 || jnx == 4 || jnx == 6 ) ? c[5] : 0;
            cc[46] = (jnx == 0 || jnx == 2 || jnx == 4 || jnx == 6 ) ? c[4] : 0;
            cc[47] = (jnx == 0 || jnx == 2 || jnx == 4 || jnx == 6 ) ? c[3] : 0;
            cc[48] = (jnx == 0 || jnx == 2 || jnx == 4 || jnx == 6 ) ? c[2] : (jnx == 7 ) ? 1 : 0;
            cc[49] = (jnx == 1 || jnx == 3 || jnx == 5 || jnx == 4 || jnx == 6 ) ? c[11] : 0;
            cc[50] = (jnx == 1 || jnx == 3 || jnx == 5 || jnx == 4 || jnx == 6 ) ? c[10] : 0;
            cc[51] = (jnx == 1 || jnx == 3 || jnx == 5 || jnx == 4 || jnx == 6 ) ? c[9] : 0;
            cc[52] = (jnx == 1 || jnx == 3 || jnx == 5 || jnx == 4 || jnx == 6 ) ? c[8] : 0;
            cc[53] = (jnx == 1 || jnx == 3 || jnx == 5 || jnx == 4 || jnx == 6 ) ? c[7] : 0;
            cc[54] = jnx[0] == 0 ? c[11] : 0;
            cc[55] = jnx[0] == 0 ? c[10] : 0;
            cc[56] = jnx[0] == 0 ? c[9] : 0;
            cc[57] = jnx[0] == 0 ? c[8] : 0;
            cc[58] = jnx[0] == 0 ? c[7] : jnx == 3'b101 ? 1 : 0;
            cc[59] = jnx[0];
            cc[16] = (jnx[0] == 0 || jnx == 3'b111) ? 1 : 0;
            cc[19] = (jnx == 1 || jnx == 3 || jnx == 5 ) ? 1 : 0;
            
            // Helping ADDI4SPN/ILLEGAL
            cc[18] = c[12] == 0 && rs1eq0 == 1 & rs2eq0 == 1 ? 0 : 1;
         end
         
         
         always @(*) begin //    31     30    29      28   27     26     25     24     23     22     21     20     19     18     17     16     15     14     13     12     11     10      9      8      7      6      5      4      3     2     1     0       
            case (inx) //        --     --    --      --   --     --     --     --     --     --     --     --     --     --     --     --     --     --     --     --     --     --     --     --     --     --     --     --     --    --    --    --       
              5'b00000 : Dii={ 1'b0  ,1'b0  ,cc[10],cc[9] ,cc[8] ,cc[7] ,cc[12],cc[11],cc[5] ,cc[6] ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b1  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b1  ,cc[4] ,cc[3] ,cc[2] ,1'b0  ,1'b0  ,1'b1  ,1'b0,1'b0  ,1'b1, cc[18]};   
              5'b00001 : Dii={ 1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx,1'bx  ,1'bx, 1'b0  };
              5'b00010 : Dii={ 1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,cc[5] ,cc[12],cc[11],cc[10],cc[6] ,1'b0  ,1'b0  ,1'b0  ,1'b1  ,cc[9] ,cc[8] ,cc[7] ,1'b0  ,1'b1  ,1'b0  ,1'b0  ,1'b1  ,cc[4] ,cc[3] ,cc[2] ,1'b0  ,1'b0  ,1'b0  ,1'b0,1'b0  ,1'b1, 1'b1  };
              5'b00011 : Dii={ 1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx,1'bx  ,1'bx, 1'b0  };
              5'b00100 : Dii={ 1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx,1'bx  ,1'bx, 1'bx  };
              5'b00101 : Dii={ 1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx,1'bx  ,1'bx, 1'b0  };
              5'b00110 : Dii={ 1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,cc[5] ,cc[12],1'b0  ,1'b1  ,cc[4] ,cc[3] ,cc[2] ,1'b0  ,1'b1  ,cc[9] ,cc[8] ,cc[7] ,1'b0  ,1'b1  ,1'b0  ,cc[11],cc[10],cc[6] ,1'b0  ,1'b0  ,1'b0  ,1'b1  ,1'b0  ,1'b0,1'b0  ,1'b1, 1'b1  };
              5'b00111 : Dii={ 1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx,1'bx  ,1'bx, 1'b0  };
              5'b01000 : Dii={ cc[12],cc[12],cc[12],cc[12],cc[12],cc[12],cc[12],cc[6] ,cc[5] ,cc[4] ,cc[3] ,cc[2] ,cc[11],cc[10],cc[9] ,cc[8] ,cc[7] ,1'b0  ,1'b0  ,1'b0  ,cc[11],cc[10],cc[9] ,cc[8] ,cc[7] ,1'b0  ,1'b0  ,1'b1  ,1'b0,1'b0  ,1'b1, 1'b1  };
              5'b01001 : Dii={ cc[12],cc[8] ,cc[10],cc[9] ,cc[6] ,cc[7] ,cc[2] ,cc[11],cc[5] ,cc[4] ,cc[3] ,cc[12],cc[12],cc[12],cc[12],cc[12],cc[12],cc[12],cc[12],cc[12],1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b1  ,1'b1  ,1'b1  ,1'b0  ,1'b1,1'b1  ,1'b1, 1'b1  };
              5'b01010 : Dii={ cc[12],cc[12],cc[12],cc[12],cc[12],cc[12],cc[12],cc[6] ,cc[5] ,cc[4] ,cc[3] ,cc[2] ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,cc[11],cc[10],cc[9] ,cc[8] ,cc[7] ,1'b0  ,1'b0  ,1'b1  ,1'b0,1'b0  ,1'b1, 1'b1  };
              5'b01011 : Dii={ cc[12],cc[12],cc[12],cc[20],cc[21],cc[22],cc[23],cc[24],cc[25],cc[25],cc[25],cc[25],cc[25],cc[25],cc[25],cc[26],cc[27],cc[28],cc[29],cc[30],cc[31],cc[32],cc[33],cc[34],cc[35],1'b0  ,cc[17],1'b1  ,1'b0,cc[17],1'b1, 1'b1  };
              5'b01100 : Dii={ cc[36],cc[37],cc[36],cc[36],cc[36],cc[36],cc[36],cc[38],cc[39],cc[4] ,cc[3] ,cc[2] ,1'b0  ,1'b1  ,cc[9] ,cc[8] ,cc[7] ,cc[40],cc[41],cc[42],1'b0  ,1'b1  ,cc[9] ,cc[8] ,cc[7] ,1'b0  ,cc[43],1'b1  ,1'b0,1'b0  ,1'b1, cc[60]};
              5'b01101 : Dii={ cc[12],cc[8] ,cc[10],cc[9] ,cc[6] ,cc[7] ,cc[2] ,cc[11],cc[5] ,cc[4] ,cc[3] ,cc[12],cc[12],cc[12],cc[12],cc[12],cc[12],cc[12],cc[12],cc[12],1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b1  ,1'b1  ,1'b0  ,1'b1,1'b1  ,1'b1, 1'b1  };
              5'b01110 : Dii={ cc[12],cc[12],cc[12],cc[12],cc[6] ,cc[5] ,cc[2] ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b1  ,cc[9] ,cc[8] ,cc[7] ,1'b0  ,1'b0  ,1'b0  ,cc[11],cc[10],cc[4] ,cc[3] ,cc[12],1'b1  ,1'b1  ,1'b0  ,1'b0,1'b0  ,1'b1, 1'b1  };
              5'b01111 : Dii={ cc[12],cc[12],cc[12],cc[12],cc[6] ,cc[5] ,cc[2] ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b1  ,cc[9] ,cc[8] ,cc[7] ,1'b0  ,1'b0  ,1'b1  ,cc[11],cc[10],cc[4] ,cc[3] ,cc[12],1'b1  ,1'b1  ,1'b0  ,1'b0,1'b0  ,1'b1, 1'b1  };
              5'b10000 : Dii={ 1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,cc[6] ,cc[5] ,cc[4] ,cc[3] ,cc[2] ,cc[11],cc[10],cc[9] ,cc[8] ,cc[7] ,1'b0  ,1'b0  ,1'b1  ,cc[11],cc[10],cc[9] ,cc[8] ,cc[7] ,1'b0  ,1'b0  ,1'b1  ,1'b0,1'b0  ,1'b1, 1'b1  };
              5'b10001 : Dii={ 1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx,1'bx  ,1'bx, 1'b0  };
              5'b10010 : Dii={ 1'b0  ,1'b0  ,1'b0  ,1'b0  ,cc[3] ,cc[2] ,cc[12],cc[6] ,cc[5] ,cc[4] ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b1  ,1'b0  ,1'b0  ,1'b1  ,1'b0  ,cc[11],cc[10],cc[9] ,cc[8] ,cc[7] ,1'b0  ,1'b0  ,1'b0  ,1'b0,1'b0  ,1'b1, 1'b1  };
              5'b10011 : Dii={ 1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx,1'bx  ,1'bx, 1'b0  };
              5'b10100 : Dii={ 1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,1'b0  ,cc[44],cc[45],cc[46],cc[47],cc[48],cc[49],cc[50],cc[51],cc[52],cc[53],1'b0  ,1'b0  ,1'b0  ,cc[54],cc[55],cc[56],cc[57],cc[58],cc[59],1'b1  ,cc[16],1'b0,cc[19],1'b1, 1'b1  };
              5'b10101 : Dii={ 1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx,1'bx  ,1'bx, 1'b0  };
              5'b10110 : Dii={ 1'b0  ,1'b0  ,1'b0  ,1'b0  ,cc[8] ,cc[7] ,cc[12],cc[6] ,cc[5] ,cc[4] ,cc[3] ,cc[2] ,1'b0  ,1'b0  ,1'b0  ,1'b1  ,1'b0  ,1'b0  ,1'b1  ,1'b0  ,cc[11],cc[10],cc[9] ,1'b0  ,1'b0  ,1'b0  ,1'b1  ,1'b0  ,1'b0,1'b0  ,1'b1, 1'b1  };
              5'b10111 : Dii={ 1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx  ,1'bx,1'bx  ,1'bx, 1'b0  };
              default: Dii={ uhw, c[15:2], 2'b11}; // Uncompressed
            endcase
         end
      end
   endgenerate
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019-202. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 */
module m_illegalop
  # ( parameter LAZY_DECODE = 0, MULDIV = 0
      )
   (
     input [31:0] INSTR,
     input        corerunning,
     output       illegal,
     output       m_illegalop_killwarning
    );
   /* verilator lint_off UNUSED */
   wire           illegal_funct7_or_illegal_rs1_rd;
   /* verilator lint_on UNUSED */
   assign m_illegalop_killwarning = &INSTR;
   
   generate
      if ( LAZY_DECODE != 0 ) begin
         
         // =======================================================
         // Nearly full instruction decode but skips
         // some minor code spaces.
         // =======================================================
         assign illegal_funct7_or_illegal_rs1_rd = 1'b0;
         
      end else begin
         
         reg also_illegal;
         /* verilator lint_off UNUSED */
         wire [2:0] funct3 = INSTR[14:12];
         wire [6:0] funct7 = INSTR[31:25];
         wire [6:0] opcode = INSTR[6:0];
         wire       checkfunct7;
         wire       also_check_funct7_5;
         wire       mostof_funct7_ne0;
         
         assign checkfunct7 = (opcode[5:4] == 2'b01 && opcode[2] == 0 && funct3[1:0] == 2'b01 ) |
                              (opcode[6:4] == 3'b011 && opcode[2] == 0 );

         if ( MULDIV == 0 ) begin
            // =======================================================
            // Full instruction decode. Without multiplication
            // =======================================================
            /*  
             Instructions and, or, slli, srli, add, sll, slt, sltu, xor and srl
             should only be valid when funct7 == 7'b00000000. 
             srai, sub, and sra should only be valid when funct7 == 7'b0100000. 
             funct7_5 takes part in the decode, and when MULDIV == 0, many
             cases are weeded out.
             
                                                               checkfunct7
                                         INSTR                 | also_check_funct7_5 (check that it is zero)
             funct7  rs2   rs1 funct3 rd 6543210  Instruction  | |
             0000000 shamt rs1 001,   rd x01x0xx  slli         1 1      ucode do not find out correct state of funct7_5 for this case
             0x00000 shamt rs1 101,   rd x01x0xx  srli/srai    1 0
             0x00000 rs2   rs1 000,   rd 011x0xx  add/sub      1 0
             0000000 rs2   rs1 001,   rd 011x0xx  sll          1 1
             0000000 rs2   rs1 010,   rd 011x0xx  slt          1 1
             0000000 rs2   rs1 011,   rd 011x0xx  sltu         1 1
             0000000 rs2   rs1 100,   rd 011x0xx  xor          1 1
             0x00000 rs2   rs1 101,   rd 011x0xx  srl/sra      1 0
             0000000 rs2   rs1 110,   rd 011x0xx  or           1 1
             0000000 rs2   rs1 111,   rd 011x0xx  and          1 1
             instructions which main_illegal says are legal    0 x
             instructions which main_illegal says are illegal  x x
             */
            
            assign mostof_funct7_ne0 = {funct7[6],funct7[4:0]} != 6'h0;
            assign also_check_funct7_5 = (opcode[5] == 0 && funct3[2] == 1'b0) |
                                         (opcode[5] == 1 && ~(funct3 == 3'b000 || funct3 == 3'b101));

            always @(*) 
              also_illegal = 0;
            
         end else begin
            
            /* verilator lint_off UNUSED */
            // =======================================================
            // Full instruction decode. With multiplication and division
            // =======================================================
            /*  
             We must not trigger on MUL/DIV instructions. mostof_funct7_ne0
             is relaxed, it does not check funct7[0] for 
             add/sub/sll/slt/sltu/xor/srl/sra/or/and any more,
             while also_check_funct7_5 is extended (and is now a misnomer).
             
                                                               checkfunct7
                                         INSTR                 | also_check_funct7_5
             funct7  rs2   rs1 funct3 rd 6543210  Instruction  | |
             0000000 shamt rs1 001,   rd x01x0xx  slli         1 1
             0x00000 shamt rs1 101,   rd x01x0xx  srli/srai    1 0
             0x00000 rs2   rs1 000,   rd 011x0xx  add/sub      1 0
             0000000 rs2   rs1 001,   rd 011x0xx  sll          1 1
             0000000 rs2   rs1 010,   rd 011x0xx  slt          1 1
             0000000 rs2   rs1 011,   rd 011x0xx  sltu         1 1
             0000000 rs2   rs1 100,   rd 011x0xx  xor          1 1
             0x00000 rs2   rs1 101,   rd 011x0xx  srl/sra      1 0
             0000000 rs2   rs1 110,   rd 011x0xx  or           1 1
             0000000 rs2   rs1 111,   rd 011x0xx  and          1 1
             0000001 rs2   rs1 000,   rd 011x0xx  mul          1 1
             0000001 rs2   rs1 001,   rd 011x0xx  mulh         1 1
             0000001 rs2   rs1 010,   rd 011x0xx  mulhsu       1 1
             0000001 rs2   rs1 011,   rd 011x0xx  mulhu        1 1
             0000001 rs2   rs1 100,   rd 011x0xx  div          1 1
             0000001 rs2   rs1 101,   rd 011x0xx  divu         1 1
             0000001 rs2   rs1 110,   rd 011x0xx  rem          1 1
             0000001 rs2   rs1 111,   rd 011x0xx  remu         1 1
             instructions which main_illegal says are legal    0 x
             instructions which main_illegal says are illegal  x x
             */
            assign mostof_funct7_ne0 = ({funct7[6],funct7[4:1]} != 5'h0) || (opcode[5] == 0 && funct7[0]);
            assign also_check_funct7_5 = (opcode[5] == 0 && funct3[2] == 1'b0) |
                                         (opcode[5] == 1 && ~(funct3 == 3'b000 || funct3 == 3'b101)) |
                                         (opcode[5] == 1 && funct7[0]);
            
            /*
             When MULDIV == 1, a number of entries in the microcodetable, formerly used to
             detect illegal opcodes, are now used to implement MUL/DIV instructions.              
             These opcodes must now be detected here.
             */

            // I have some trouble with some versions of yosys, hence this:
`define really_dontcare 1'b0
            // Ideally we could loosen up somewhat: really_dontcare 1'b?
            
            always @*
              casez ( {INSTR[6:2],INSTR[14:12]} )
                //       111
                // 65432 432   also_illegal  Comment
                8'b00000_00? : also_illegal = 1'b0;
                8'b00000_010 : also_illegal = 1'b0;
                8'b00000_011 : also_illegal = 1'b1; // close to LB
                8'b00000_10? : also_illegal = 1'b0;
                8'b00000_11? : also_illegal = 1'b1; // close to LB       
                
                8'b00001_??? : also_illegal = `really_dontcare; // 
                
                8'b00010_000 : also_illegal = 1'b0;
                8'b00010_001 : also_illegal = 1'b1;  // close to ij   
                8'b00010_01? : also_illegal = 1'b1;  // close to ij   
                8'b00010_1?? : also_illegal = 1'b1;  // close to ij
                
                8'b00011_00? : also_illegal = 1'b0;
                8'b00011_01? : also_illegal = 1'b1;  // close to FENCE
                8'b00011_1?? : also_illegal = 1'b1;  // close to FENCE
                
                8'b0010?_??? : also_illegal = 1'b0;
                8'b0011?_??? : also_illegal = `really_dontcare;
                
                8'b01000_00? : also_illegal = 1'b0;
                8'b01000_010 : also_illegal = 1'b0;
                8'b01000_011 : also_illegal = 1'b1;  // close to SW   
                8'b01000_1?? : also_illegal = 1'b1;  // close to SW   
                
                8'b01001_??? : also_illegal = `really_dontcare;
                8'b0101?_??? : also_illegal = `really_dontcare;
                8'b0110?_??? : also_illegal = 1'b0;
                8'b0111?_??? : also_illegal = `really_dontcare;
                8'b10???_??? : also_illegal = `really_dontcare;
                
                8'b11000_00? : also_illegal = 1'b0;
                8'b11000_01? : also_illegal = 1'b1;  // close to BEQ
                8'b11000_1?? : also_illegal = 1'b0;

                8'b11001_000 : also_illegal = 1'b0;
                8'b11001_001 : also_illegal = 1'b1;  // close to JALR 
                8'b11001_01? : also_illegal = 1'b1;  // close to JALR 
                8'b11001_1?? : also_illegal = 1'b1;  // close to JALR
                
                8'b11010_??? : also_illegal = `really_dontcare;
                8'b11011_??? : also_illegal = 1'b0;
                
                8'b11100_0?? : also_illegal = 1'b0;
                8'b11100_100 : also_illegal = 1'b1;  // close to CSR
                8'b11100_101 : also_illegal = 1'b0;
                8'b11100_11? : also_illegal = 1'b0;
                
                8'b11101_??? : also_illegal = `really_dontcare;
                8'b1111?_??? : also_illegal = `really_dontcare;
                default : also_illegal = `really_dontcare;
              endcase
            
         end
         
         
         /* 
          Issue 3:
          ecall, ebreak, wfi, and mret put requirements onto the immediate
          field imm12, which is decoded to register Q.
          
          |__imm12______|
          funct7   rs2    rs1    funct3 rd      opcode
          0000000, 00000, 00000, 000,   00000,  1110011, ecall     imm12 checked by ucode
          0000000, 00001, 00000, 000,   00000,  1110011, ebreak    imm12 checked by ucode
          0001000, 00101, 00000, 000,   00000,  1110011, wfi       imm12 checked by ucode
          0011000, 00010, 00000, 000,   00000,  1110011, mret      imm12 checked by ucode
          
          All of these instructions should have field rs1 and rd as 5'b00000.
          
          */
         wire   check_rs1_rd = (opcode[6] == 1'b1 && opcode[4] == 1'b1) && (funct3[1:0] == 2'b00);
         wire   rs1_ne_zero = INSTR[19:15] != 5'h0;
         wire   rd_ne_zero  = INSTR[11:7] != 5'h0;
         wire   illegal_rs1_rd = check_rs1_rd & (rs1_ne_zero | rd_ne_zero);
         
         assign illegal_funct7_or_illegal_rs1_rd
           = (checkfunct7 & mostof_funct7_ne0) |
             (checkfunct7 & also_check_funct7_5 & funct7[5]) |
             illegal_rs1_rd | also_illegal;
                  
      end
      
      /* =============================================================================
       * The illegal signal
       * ============================================================================= */
      if ( LAZY_DECODE == 2 ) begin
         
         assign  illegal = ~INSTR[0] & corerunning;
         
      end else begin
         
         reg              illegal_a, illegal_b;
         always @(*)
           case ( INSTR[5:2] )
             4'b0000 : {illegal_b,illegal_a} = 2'b10; // 10000                                        00000   lb/lh/lbu/lhu/lw                                                                
             4'b0001 : {illegal_b,illegal_a} = 2'b11; // 10001                                        00001                                                                                   
             4'b0010 : {illegal_b,illegal_a} = 2'b10; // 10010                                        00010   ij                                                                                
             4'b0011 : {illegal_b,illegal_a} = 2'b10; // 10011                                        00011   fence.i/fence                                                                   
             4'b0100 : {illegal_b,illegal_a} = 2'b10; // 10100                                        00100   addi/slti/sltiu/xori/ori/andi/slli/srli/srai                                    
             4'b0101 : {illegal_b,illegal_a} = 2'b10; // 10101                                        00101   auipc                                                                           
             4'b0110 : {illegal_b,illegal_a} = 2'b11; // 10110                                        00110                                                                                   
             4'b0111 : {illegal_b,illegal_a} = 2'b11; // 10111                                        00111                                                                                   
             4'b1000 : {illegal_b,illegal_a} = 2'b00; // 11000   beq/bne/blt/bge/bltu/bgeu            01000   sb/sh/sw                                                                        
             4'b1001 : {illegal_b,illegal_a} = 2'b01; // 11001   jalr                                 01001                                                                                   
             4'b1010 : {illegal_b,illegal_a} = 2'b11; // 11010                                        01010                                                                                   
             4'b1011 : {illegal_b,illegal_a} = 2'b01; // 11011   jal                                  01011                                                                                   
             4'b1100 : {illegal_b,illegal_a} = 2'b00; // 11100   csr/ecall/ebreak/uret/sret/wfi/mret  01100  add/sll/slt/sltu/xor/srl/or/and/mul/mulh/mulhsu/mulhu/div/divu/rem/remu/sub/sra/ 
             4'b1101 : {illegal_b,illegal_a} = 2'b10; // 11101                                        01101  lui                                                                              
             4'b1110 : {illegal_b,illegal_a} = 2'b11; // 11110                                        01110                                                                                   
             4'b1111 : {illegal_b,illegal_a} = 2'b11; // 11111                                        01111                                                                                   
           endcase
         wire             main_illegal;
         assign main_illegal = 
                               (~INSTR[6] & illegal_a) | 
                               (INSTR[6] & illegal_b ) | 
                               ~INSTR[1] |
                               ~INSTR[0];
         
         if ( LAZY_DECODE == 1 ) begin
            assign  illegal = main_illegal & corerunning;
         end else begin
            assign illegal = (main_illegal | illegal_funct7_or_illegal_rs1_rd) & corerunning;
         end
      end
   endgenerate
endmodule
/* -----------------------------------------------------------------------------
 * Part of midgetv
 * 2019-2020. Copyright B. Nossum.
 * For licence, see LICENCE
 * -----------------------------------------------------------------------------ehdr
 * Constructs to try to get cleaner code
 */
/* verilator lint_off DECLFILENAME */
module bn_l4
  # ( parameter I = 16'h0 )
   (
    input  i0,i1,i2,i3,
    output o
    );
   SB_LUT4 #(.LUT_INIT(I)) l(.O(o), .I3(i3), .I2(i2), .I1(i1), .I0(i0));
endmodule

module bn_lcy4
  # ( parameter I = 16'h0 )
   (
    input  i0,i1,i2,i3,
    output o,co
    );
   SB_LUT4 #(.LUT_INIT(I)) l(.O(o), .I3(i3), .I2(i2), .I1(i1), .I0(i0));
   SB_CARRY y(.CO(co),              .CI(i3), .I1(i2), .I0(i1));
endmodule

module bn_lcy4_b
  # ( parameter I = 16'h0 )
   (
    input  i0,i1,i2,i3,ci,
    output o,co
    );
   SB_LUT4 #(.LUT_INIT(I)) l(.O(o), .I3(i3), .I2(i2), .I1(i1), .I0(i0));
   SB_CARRY y(.CO(co),              .CI(ci), .I1(i2), .I0(i1));
endmodule

module bn_l4v
  # ( parameter I = 16'h0 )
   (
    input [3:0] i,
    output      o
    );
   SB_LUT4 #(.LUT_INIT(I)) l(.O(o), .I3(i[3]), .I2(i[2]), .I1(i[1]), .I0(i[0]));
endmodule

module bn_lcy4v
  # ( parameter I = 16'h0 )
   (
    input [3:0] i,
    output      o,co
    );
   SB_LUT4 #(.LUT_INIT(I)) l(.O(o), .I3(i[3]), .I2(i[2]), .I1(i[1]), .I0(i[0]));
   SB_CARRY y(.CO(co),              .CI(i[3]), .I1(i[2]), .I0(i[1]));
endmodule

module bn_lcy4v_b
  # ( parameter I = 16'h0 )
   (
    input [3:0] i,
    input       ci,
    output      o,co
    );
   SB_LUT4 #(.LUT_INIT(I)) l(.O(o), .I3(i[3]), .I2(i[2]), .I1(i[1]), .I0(i[0]));
   SB_CARRY y(.CO(co),              .CI(ci),   .I1(i[2]), .I0(i[1]));
endmodule


// Local Variables:
// verilog-library-files:("../generated/m_2ebr.v" )
// verilog-library-directories:("." "sb_sim_rtl" )
// verilog-library-extensions:(".v" )
// End:
