                 buser/dinx                                                                                                             progress  (RAM)      Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ       ACK      S T E t r |mie ft Micro                                                                         
start|| ucode    ||||may            c v u                                                                                    |          ||WE       STB| SEL  epepepepep\\csr|| code                                                                          
  cy||| |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
0000-00 00200000 000000 00 00000000 0 0 0 00000252 0080      00000000 00000000 00000000 00000000 00000000 h 00000000 nearXOR 0 fffffffc 1... ... ... .. 0000 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0001-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000000 ADD     0 00000000 11.. ... ... .. 0000 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0002-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0003-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0004-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0005-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0006-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0007-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0008-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0009-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
000a-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
000b-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
000c-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
000d-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
000e-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
000f-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0010-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0011-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0012-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0013-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0014-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0015-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0016-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0017-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0018-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0019-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
001a-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
001b-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
                 buser/dinx                                                                                                             progress STB(IO)     Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ    |sysack     S T E t r |mie ft Micro                                                                         
start|| ucode    ||||may            c v u                                                                                    |          ||WE     ||ACK  SEL  epepepepep\\csr|| code                                                                          
  cy||| |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
001c-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
001d-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
001e-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
001f-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0020-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0021-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0022-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0023-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0024-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0025-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0026-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0027-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0028-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0029-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
002a-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
002b-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
002c-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
002d-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
002e-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
002f-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0030-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0031-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0032-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0033-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0034-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0035-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0036-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0037-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
                 buser/dinx                                                                                                             progress  (RAM)      Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ       ACK      S T E t r |mie ft Micro                                                                         
start|| ucode    ||||may            c v u                                                                                    |          ||WE       STB| SEL  epepepepep\\csr|| code                                                                          
  cy||| |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
0038-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0039-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
003a-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
003b-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
003c-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
003d-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
003e-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
003f-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0040-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0041-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0042-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0043-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0044-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0045-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0046-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0047-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0048-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0049-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
004a-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
004b-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
004c-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
004d-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
004e-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
004f-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0050-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0051-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0052-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0053-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
                 buser/dinx                                                                                                             progress STB(IO)     Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ    |sysack     S T E t r |mie ft Micro                                                                         
start|| ucode    ||||may            c v u                                                                                    |          ||WE     ||ACK  SEL  epepepepep\\csr|| code                                                                          
  cy||| |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
0054-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0055-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0056-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0057-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0058-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0059-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
005a-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
005b-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
005c-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
005d-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
005e-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
005f-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0060-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0061-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0062-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0063-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0064-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0065-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0066-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0067-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0068-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0069-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
006a-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
006b-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
006c-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
006d-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
006e-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
006f-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
                 buser/dinx                                                                                                             progress  (RAM)      Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ       ACK      S T E t r |mie ft Micro                                                                         
start|| ucode    ||||may            c v u                                                                                    |          ||WE       STB| SEL  epepepepep\\csr|| code                                                                          
  cy||| |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
0070-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0071-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0072-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0073-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0074-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0075-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0076-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0077-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0078-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0079-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
007a-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
007b-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
007c-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
007d-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
007e-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
007f-00 036b2001 000000 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0080 01 036b2001 000100 00 00000000 0 0 0 00000252 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_1           Read until q=mem[rs1+ofs) & ~3u]                
0081 d2 02fb09d2 000100 00 00000000 0 0 0 00000252 00a8      00000000 00000001 00000000 00000000 00000000 u 00000001 passD   0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_2           Repeat shr until shreg == 0 (0,8,16,24 times)   
0082 06 029b0906 000100 00 00000000 0 0 0 00000252 00a8      00000000 00000001 00000000 00000000 00000000 h 00000001 passD   0 00000000 1... ... ... .. 1111 0000000000 000 00 LB_3           q = ~mem[rs1+ofs]                               
0083 07 01bb1007 000100 00 00000000 0 0 0 00000252 0098      00000000 00000001 00000000 00000000 00000000 u 00000001 INVQ    0 ffffffff 11.. ... ... .. 1111 0000000000 000 1f LB_4           q = (uint8_t) mem[rs1+Iimm]                     
0084 09 017b1809 000100 00 00000000 0 0 0 00000252 0094      00000000 00000001 000000ff 000000ff ffffffff u 00000001 nearAND 0 00000000 11.. ... ... .. 1111 0000000000 000 1f LB_5           q = D^0xffffffff^q = D^0x80                     
0085 8b 017b008b 000100 00 00000000 0 0 0 00000252 0094      00000000 00000001 ffffff7f ffffff7f 00000000 u 00000001 nearXOR 0 00000080 11.. ... ... .. 1111 0000000000 000 1f LB_6           WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80        
0086 e6 10ba26e6 000110 00 00000000 0 0 0 00000252 0088 0080 00000000 00000001 ffffff7f ffffff7f 00000080 z 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
0087 de 2b7126de 000110 00 00000000 0 0 0 00000252 0254 0088 00000000 00000001 00000252 00000252 00000000 u 00000001 ADD     0 00000256 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
0088 f4 20fab0f4 000100 00 00000000 1 0 0 00000256 008c 0080 00000000 00000001 4f890000 4f890000 00000256 z 00000001 passQ   0 00000256 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0089 04 6fff20d5 010000 04 00200f93 1 1 0 00000256 0000 008c 00000000 00000001 00000000 00000000 00000000 u 00000001 ADD     0 00000009 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x31,x0,2
008a e6 10ba20e6 000000 04 00200f93 1 1 0 00000256 0088 007c 00000000 00000001 00000000 00000000 00000002 z 00000001 ADD     0 00000002 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
008b de 2b7126de 000010 04 00200f93 1 1 0 00000256 0258 0088 00000000 00000001 00000256 00000256 00000000 u 00000001 ADD     0 00000258 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
                 buser/dinx                                                                                                             progress STB(IO)     Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ    |sysack     S T E t r |mie ft Micro                                                                         
     || ucode    ||||may            c v u                                                                                    |          ||WE     ||ACK  SEL  epepepepep\\csr|| code                                                                          
  cy || |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
008c f4 20fab0f4 000000 04 00200f93 0 1 0 00000258 008c 0080 00000000 00000001 00000f17 00000f17 00000258 z 00000001 passQ   0 00000258 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
008d 05 6fff20d5 010000 05 00000f17 0 0 0 00000258 0000 008c 00000000 00000001 00000009 00000009 00000000 u 00000001 ADD     0 0000000d 11.. ... ... .. 1111 0000000000 000 1f _L0x05  AUIPC  q = imm20+2 or imm20+4  (copy x/2)              auipc    x30,0x0
008e 04 00310004 000000 05 00000f17 0 0 0 00000258 0080      00000000 00000001 00000000 00000000 00000000 h 00000001 nearXOR 0 fffffffc 1... ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         
008f e6 10ba20e6 000000 05 00000f17 0 0 0 00000258 0088 0078 00000000 00000001 00000258 00000258 00000000 z 00000001 ADD     0 00000258 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
0090 de 2b7126de 000010 05 00000f17 0 0 0 00000258 025c 0088 00000000 00000001 00000258 00000258 00000000 u 00000001 ADD     0 0000025c 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
0091 f4 20fab0f4 000000 05 00000f17 0 0 0 0000025c 008c 0080 00000000 00000001 014f0f13 014f0f13 0000025c z 00000001 passQ   0 0000025c 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0092 04 6fff20d5 010000 04 014f0f13 0 0 0 0000025c 0078 008c 00000000 00000001 0000000d 0000000d 00000000 u 00000001 ADD     0 00000012 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x30,x30,20
0093 e6 10ba20e6 000000 04 014f0f13 0 0 0 0000025c 0088 0078 00000000 00000001 00000258 00000258 00000014 z 00000001 ADD     0 0000026c 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
0094 de 2b7126de 000010 04 014f0f13 0 0 0 0000025c 0260 0088 00000000 00000001 0000025c 0000025c 00000000 u 00000001 ADD     0 00000260 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
0095 f4 20fab0f4 000000 04 014f0f13 0 0 0 00000260 008c 0080 00000000 00000001 00000097 00000097 00000260 z 00000001 passQ   0 00000260 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0096 05 6fff20d5 010000 05 00000097 0 0 0 00000260 0000 008c 00000000 00000001 00000012 00000012 00000000 u 00000001 ADD     0 00000016 11.. ... ... .. 1111 0000000000 000 1f _L0x05  AUIPC  q = imm20+2 or imm20+4  (copy x/2)              auipc    x1,0x0
0097 04 00310004 000000 05 00000097 0 0 0 00000260 0080      00000000 00000001 00000000 00000000 00000000 h 00000001 nearXOR 0 fffffffc 1... ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         
0098 e6 10ba20e6 000000 05 00000097 0 0 0 00000260 0088 0004 00000000 00000001 00000260 00000260 00000000 z 00000001 ADD     0 00000260 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
0099 de 2b7126de 000010 05 00000097 0 0 0 00000260 0264 0088 00000000 00000001 00000260 00000260 00000000 u 00000001 ADD     0 00000264 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
009a f4 20fab0f4 000000 05 00000097 0 0 0 00000264 008c 0080 00000000 00000001 fa408093 fa408093 00000264 z 00000001 passQ   0 00000264 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
009b 04 6fff20d5 010000 04 fa408093 0 0 0 00000264 0004 008c 00000000 00000001 00000016 00000016 00000000 u 00000001 ADD     0 0000001b 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x1,x1,-92
009c e6 10ba20e6 000000 04 fa408093 0 0 0 00000264 0088 0004 00000000 00000001 00000260 00000260 ffffffa4 z 00000001 ADD     0 00000204 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
009d de 2b7126de 000010 04 fa408093 0 0 0 00000264 0268 0088 00000000 00000001 00000264 00000264 00000000 u 00000001 ADD     0 00000268 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
009e f4 20fab0f4 000000 04 fa408093 0 0 0 00000268 008c 0080 00000000 00000001 0a102223 0a102223 00000268 z 00000001 passQ   0 00000268 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
009f 48 6fff20d5 010000 48 0a102223 0 0 0 00000268 0000 008c 00000000 00000001 0000001b 0000001b 00000000 u 00000001 ADD     0 0000001f 11.. ... ... .. 1111 0000000000 000 1f _L0x48  SW     Store word. Q=wradr=RS1+Simm                    sw       x1,164(x0)
00a0 66 83bb2066 000010 48 0a102223 0 0 0 00000268 0004      00000000 00000001 00000000 00000000 000000a4 u 00000001 ADD     0 000000a4 11.. ... ... .. 1111 0000000000 000 1f SW_1           Write d to a+k until accepted                   
00a1 f2 0fb908f2 000000 48 0a102223 0 0 0 00000268 0004 00a4 00000000 00000001 00000204 00000204 000000a4 h 00000001 passD   0 00000204 1... ... ... .. 1111 0000000000 000 1f SW_2           Prepare read PC                                 
00a2 e6 00b200e6 000000 48 0a102223 0 0 0 00000268 0088      00000000 00000001 00000204 00000204 000000a4 z 00000001 nearXOR 1 fffffd5c 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00a3 de 2b7126de 000010 48 0a102223 0 0 0 00000268 026c 0088 00000000 00000001 00000268 00000268 00000000 u 00000001 ADD     0 0000026c 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00a4 f4 20fab0f4 000000 48 0a102223 0 0 0 0000026c 008c 0080 00000000 00000001 00000073 00000073 0000026c z 00000001 passQ   0 0000026c 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00a5 1c 6fff20d5 010000 1c 00000073 0 0 0 0000026c 0000 008c 00000000 00000001 0000001f 0000001f 00000000 u 00000001 ADD     0 00000025 11.. ... ... .. 1111 0000000000 000 1f ECAL_BRKECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI    ecall    
00a6 a6 82f930a6 000010 1c 00000073 0 0 0 0000026c 00ac      00000000 00000001 00000000 00000000 00000000 h 00000001 passQ   0 00000000 1... ... ... .. 1111 0000000000 000 1f ECAL_RETECALL/(U/S/M)RET Select ECALL or (U/S/M)RET            
00a7 d0 82f930d0 000010 1c 00000073 0 0 0 0000026c 00ac      00000000 00000001 ffffffff ffffffff 00000000 h 00000001 passQ   0 00000000 1... ... ... .. 1111 0000000000 000 1f ECALL_1 ECALL  Verify Imm==0x000                               
                 buser/dinx                                                                                                             progress  (RAM)      Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ       ACK      S T E t r |mie ft Micro                                                                         
     || ucode    ||||may            c v u                                                                                    |          ||WE       STB| SEL  epepepepep\\csr|| code                                                                          
  cy || |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
00a8 37 003b2637 000000 1c 00000073 0 0 0 0000026c 0080      00000000 00000001 ffffffff ffffffff 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 1f ECALL_2        mepc = pc, prep store 0 to mtval                
00a9 d7 343a48d7 000011 1c 00000073 0 0 0 0000026c 0080 00b4 00000000 00000001 0000026c 0000026c 00000000 z 00000001 passD   0 0000026c 11.. ... ... .. 1111 0000000000 000 1f ECALL_3        mtval = 0, now start the chore of 11 to mcause  
00aa a1 3eba30a1 000000 1c 00000073 0 0 0 0000026c 00a8 00bc 00000000 00000001 0000026c 0000026c 00000000 z 00000001 passQ   0 00000000 11.. ... ... .. 1111 0000000000 000 1f ECALL_4        Q = 4                                           
00ab b6 02b326b6 000010 1c 00000073 0 0 0 0000026c 00a8      00000000 00000001 00000000 00000000 00000000 u 00000001 ADD     0 00000004 11.. ... ... .. 1111 0000000000 000 1f ECALL_5        Q = 8                                           
00ac 9a 02b3269a 000010 1c 00000073 0 0 0 0000026c 00a8      00000000 00000001 00000000 00000000 00000004 u 00000001 ADD     0 00000008 11.. ... ... .. 1111 0000000000 000 1f ECALL_6        mcause = 11                                     
00ad 34 3a702034 000000 1c 00000073 0 0 0 0000026c 00a4 00b8 00000000 00000001 00000000 00000000 00000008 h 00000001 ADD     0 0000000b 1... ... ... .. 1111 0000000000 000 1f JAL_3        Prep fetch next instr.                            
00ae de 2b7908de 000010 1c 00000073 0 0 0 0000026c 0204 0088 00000000 00000001 00000204 00000204 00000008 u 00000001 passD   0 00000204 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00af f4 20fab0f4 000000 1c 00000073 0 0 0 00000204 008c 0080 00000000 00000001 2083412d 2083412d 00000204 z 00000001 passQ   0 00000204 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00b0 04 6fff20d5 010000 04 00b00113 0 1 0 00000204 0000 008c 00000000 00000001 00000025 00000025 00000000 u 00000001 ADD     0 00000030 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x2,x0,11
00b1 e6 10ba20e6 000000 04 00b00113 0 1 0 00000204 0088 0008 00000000 00000001 00000000 00000000 0000000b z 00000001 ADD     0 0000000b 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00b2 de 2b7126de 000010 04 00b00113 0 1 0 00000204 0204 0088 00000000 00000001 00000204 00000204 00000000 u 00000001 ADD     0 00000206 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00b3 f4 20fab0f4 000000 04 00b00113 1 1 0 00000206 008c 0080 00000000 00000001 2083412d 2083412d 00000206 z 00000001 passQ   0 00000206 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00b4 d5 6fff20d5 000000 40 00b02083 1 0 1 00000206 0000 008c 00000000 00000001 00000030 00000030 00000000 u 00000001 ADD     0 00000034 11.. ... ... .. 1111 0000000000 000 1f unalignd Fr00u Unaligned pc, prep read high hword              
00b5 12 00ba3012 000000 40 00b02083 1 0 1 00000206 0088      00000000 00000001 00000000 00000000 0000000b z 00000001 passQ   0 0000000b 11.. ... ... .. 1111 0000000000 000 1f straddle Fr10u IncPC, OpFetch                                  
00b6 76 2b712676 000010 40 00b02083 1 0 1 00000206 0208 0088 00000000 00000001 00000206 00000206 00000000 u 00000001 ADD     0 00000208 11.. ... ... .. 1111 0000000000 000 1f Fetchu   Fr00u Read and latch instruction                      
00b7 f4 00fab0f4 000000 40 00b02083 0 0 1 00000208 008c      00000000 00000001 9a630b80 9a630b80 00000208 z 00000001 passQ   0 00000208 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00b8 40 6fff20d5 010000 40 0b802083 0 1 0 00000208 0000 008c 00000000 00000001 00000034 00000034 00000000 u 00000001 ADD     0 00000038 11.. ... ... .. 1111 0000000000 000 1f LW_0    LW     Load word. Q=yy=rdadr=RS1+Iimm                  lw       x1,184(x0)
00b9 50 837b2050 000010 40 0b802083 0 1 0 00000208 00b8      00000000 00000001 00000000 00000000 000000b8 u 00000001 ADD     0 000000b8 11.. ... ... .. 1111 0000000000 000 1f LW_1           Read until d=mem[(rs1+ofs) & ~3u]               
00ba e6 12fa08e6 000000 40 0b802083 0 1 0 00000208 0088 0004 00000000 00000001 0000000b 0000000b 000000b8 z 00000001 passD   0 0000000b 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00bb de 2b7126de 000010 40 0b802083 0 1 0 00000208 0208 0088 00000000 00000001 00000208 00000208 00000000 u 00000001 ADD     0 0000020a 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00bc f4 20fab0f4 000000 40 0b802083 1 1 0 0000020a 008c 0080 00000000 00000001 9a630b80 9a630b80 0000020a z 00000001 passQ   0 0000020a 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00bd d5 6fff20d5 000000 38 0b809a63 1 0 1 0000020a 0004 008c 00000000 00000001 00000038 00000038 00000000 u 00000001 ADD     0 0000003d 11.. ... ... .. 1111 0000000000 000 1f unalignd Fr00u Unaligned pc, prep read high hword              
00be 12 00ba3012 000000 38 0b809a63 1 0 1 0000020a 0088      00000000 00000001 0000000b 0000000b 000000b4 z 00000001 passQ   0 000000b4 11.. ... ... .. 1111 0000000000 000 1f straddle Fr10u IncPC, OpFetch                                  
00bf 76 2b712676 000010 38 0b809a63 1 0 1 0000020a 020c 0088 00000000 00000001 0000020a 0000020a 00000000 u 00000001 ADD     0 0000020c 11.. ... ... .. 1111 0000000000 000 1f Fetchu   Fr00u Read and latch instruction                      
00c0 f4 00fab0f4 000000 38 0b809a63 0 0 1 0000020c 008c      00000000 00000001 20830220 20830220 0000020c z 00000001 passQ   0 0000020c 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00c1 38 6fff20d5 010000 38 02209a63 0 1 0 0000020c 0004 008c 00000000 00000001 0000003d 0000003d 00000000 u 00000001 ADD     0 00000041 11.. ... ... .. 1111 0000000000 000 1f BNE     BNE    Conditional Branch. Offset to Ryy               bne      x1,x2,240
00c2 13 33ba3013 000000 38 02209a63 0 1 0 0000020c 0008 00b0 00000000 00000001 0000000b 0000000b 00000034 z 00000001 passQ   0 00000034 11.. ... ... .. 1111 0000000000 000 1f condb_2        ~RS2 in Q                                       
00c3 14 03fb0014 000000 38 02209a63 0 1 0 0000020c 0004      00000000 00000001 0000000b 0000000b 00000000 u 00000001 nearXOR 0 fffffff4 11.. ... ... .. 1111 0000000000 000 1f condb_3        Calculate RS1+~RS2+1                            
                 buser/dinx                                                                                                             progress STB(IO)     Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ    |sysack     S T E t r |mie ft Micro                                                                         
     || ucode    ||||may            c v u                                                                                    |          ||WE     ||ACK  SEL  epepepepep\\csr|| code                                                                          
  cy || |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
00c4 15 033b2615 000000 38 02209a63 0 1 0 0000020c 00b0      00000000 00000001 0000000b 0000000b fffffff4 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 1f condb_4        Branch on condition                             
00c5 16 003b4816 000010 38 02209a63 0 1 0 0000020c 0080      00000000 00000001 00000034 00000034 00000000 u 00000001 passD   0 00000034 11.. ... ... .. 1111 0000000000 000 1f condb_5        Branch not taken.                               
00c6 e6 00b200e6 000000 38 02209a63 0 1 0 0000020c 0088      00000000 00000001 0000020a 0000020a 00000034 z 00000001 nearXOR 0 fffffdc2 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00c7 de 2b7126de 000010 38 02209a63 0 1 0 0000020c 020c 0088 00000000 00000001 0000020c 0000020c 00000000 u 00000001 ADD     0 0000020e 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00c8 f4 20fab0f4 000000 38 02209a63 1 1 0 0000020e 008c 0080 00000000 00000001 20830220 20830220 0000020e z 00000001 passQ   0 0000020e 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00c9 d5 6fff20d5 000000 40 02202083 1 0 1 0000020e 0000 008c 00000000 00000001 00000041 00000041 00000000 u 00000001 ADD     0 00000049 11.. ... ... .. 1111 0000000000 000 1f unalignd Fr00u Unaligned pc, prep read high hword              
00ca 12 00ba3012 000000 40 02202083 1 0 1 0000020e 0088      00000000 00000001 00000000 00000000 00000022 z 00000001 passQ   0 00000022 11.. ... ... .. 1111 0000000000 000 1f straddle Fr10u IncPC, OpFetch                                  
00cb 76 2b712676 000010 40 02202083 1 0 1 0000020e 0210 0088 00000000 00000001 0000020e 0000020e 00000000 u 00000001 ADD     0 00000210 11.. ... ... .. 1111 0000000000 000 1f Fetchu   Fr00u Read and latch instruction                      
00cc f4 00fab0f4 000000 40 02202083 0 0 1 00000210 008c      00000000 00000001 01130b40 01130b40 00000210 z 00000001 passQ   0 00000210 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00cd 40 6fff20d5 010000 40 0b402083 0 1 0 00000210 0000 008c 00000000 00000001 00000049 00000049 00000000 u 00000001 ADD     0 0000004d 11.. ... ... .. 1111 0000000000 000 1f LW_0    LW     Load word. Q=yy=rdadr=RS1+Iimm                  lw       x1,180(x0)
00ce 50 837b2050 000010 40 0b402083 0 1 0 00000210 00b4      00000000 00000001 00000000 00000000 000000b4 u 00000001 ADD     0 000000b4 11.. ... ... .. 1111 0000000000 000 1f LW_1           Read until d=mem[(rs1+ofs) & ~3u]               
00cf e6 12fa08e6 000000 40 0b402083 0 1 0 00000210 0088 0004 00000000 00000001 0000026c 0000026c 000000b4 z 00000001 passD   0 0000026c 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00d0 de 2b7126de 000010 40 0b402083 0 1 0 00000210 0210 0088 00000000 00000001 00000210 00000210 00000000 u 00000001 ADD     0 00000212 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00d1 f4 20fab0f4 000000 40 0b402083 1 1 0 00000212 008c 0080 00000000 00000001 01130b40 01130b40 00000212 z 00000001 passQ   0 00000212 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00d2 d5 6fff20d5 000000 04 0b400113 1 0 1 00000212 0000 008c 00000000 00000001 0000004d 0000004d 00000000 u 00000001 ADD     0 00000052 11.. ... ... .. 1111 0000000000 000 1f unalignd Fr00u Unaligned pc, prep read high hword              
00d3 12 00ba3012 000000 04 0b400113 1 0 1 00000212 0088      00000000 00000001 00000000 00000000 000000b4 z 00000001 passQ   0 000000b4 11.. ... ... .. 1111 0000000000 000 1f straddle Fr10u IncPC, OpFetch                                  
00d4 76 2b712676 000010 04 0b400113 1 0 1 00000212 0214 0088 00000000 00000001 00000212 00000212 00000000 u 00000001 ADD     0 00000214 11.. ... ... .. 1111 0000000000 000 1f Fetchu   Fr00u Read and latch instruction                      
00d5 f4 00fab0f4 000000 04 0b400113 0 0 1 00000214 008c      00000000 00000001 9663000f 9663000f 00000214 z 00000001 passQ   0 00000214 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00d6 04 6fff20d5 010000 04 000f0113 0 1 0 00000214 0078 008c 00000000 00000001 00000052 00000052 00000000 u 00000001 ADD     0 00000056 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x2,x30,0
00d7 e6 10ba20e6 000000 04 000f0113 0 1 0 00000214 0088 0008 00000000 00000001 0000026c 0000026c 00000000 z 00000001 ADD     0 0000026c 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00d8 de 2b7126de 000010 04 000f0113 0 1 0 00000214 0214 0088 00000000 00000001 00000214 00000214 00000000 u 00000001 ADD     0 00000216 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00d9 f4 20fab0f4 000000 04 000f0113 1 1 0 00000216 008c 0080 00000000 00000001 9663000f 9663000f 00000216 z 00000001 passQ   0 00000216 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00da d5 6fff20d5 000000 38 000f9663 1 0 1 00000216 007c 008c 00000000 00000001 00000056 00000056 00000000 u 00000001 ADD     0 0000005a 11.. ... ... .. 1111 0000000000 000 1f unalignd Fr00u Unaligned pc, prep read high hword              
00db 12 00ba3012 000000 38 000f9663 1 0 1 00000216 0088      00000000 00000001 00000002 00000002 0000000c z 00000001 passQ   0 0000000c 11.. ... ... .. 1111 0000000000 000 1f straddle Fr10u IncPC, OpFetch                                  
00dc 76 2b712676 000010 38 000f9663 1 0 1 00000216 0218 0088 00000000 00000001 00000216 00000216 00000000 u 00000001 ADD     0 00000218 11.. ... ... .. 1111 0000000000 000 1f Fetchu   Fr00u Read and latch instruction                      
00dd f4 00fab0f4 000000 38 000f9663 0 0 1 00000218 008c      00000000 00000001 20830220 20830220 00000218 z 00000001 passQ   0 00000218 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00de 38 6fff20d5 010000 38 02209663 0 1 0 00000218 0004 008c 00000000 00000001 0000005a 0000005a 00000000 u 00000001 ADD     0 0000005e 11.. ... ... .. 1111 0000000000 000 1f BNE     BNE    Conditional Branch. Offset to Ryy               bne      x1,x2,244
00df 13 33ba3013 000000 38 02209663 0 1 0 00000218 0008 00b0 00000000 00000001 0000026c 0000026c 0000002c z 00000001 passQ   0 0000002c 11.. ... ... .. 1111 0000000000 000 1f condb_2        ~RS2 in Q                                       
                 buser/dinx                                                                                                             progress  (RAM)      Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ       ACK      S T E t r |mie ft Micro                                                                         
     || ucode    ||||may            c v u                                                                                    |          ||WE       STB| SEL  epepepepep\\csr|| code                                                                          
  cy || |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
00e0 14 03fb0014 000000 38 02209663 0 1 0 00000218 0004      00000000 00000001 0000026c 0000026c 00000000 u 00000001 nearXOR 0 fffffd93 11.. ... ... .. 1111 0000000000 000 1f condb_3        Calculate RS1+~RS2+1                            
00e1 15 033b2615 000000 38 02209663 0 1 0 00000218 00b0      00000000 00000001 0000026c 0000026c fffffd93 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 1f condb_4        Branch on condition                             
00e2 16 003b4816 000010 38 02209663 0 1 0 00000218 0080      00000000 00000001 0000002c 0000002c 00000000 u 00000001 passD   0 0000002c 11.. ... ... .. 1111 0000000000 000 1f condb_5        Branch not taken.                               
00e3 e6 00b200e6 000000 38 02209663 0 1 0 00000218 0088      00000000 00000001 00000216 00000216 0000002c z 00000001 nearXOR 0 fffffdc6 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00e4 de 2b7126de 000010 38 02209663 0 1 0 00000218 0218 0088 00000000 00000001 00000218 00000218 00000000 u 00000001 ADD     0 0000021a 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00e5 f4 20fab0f4 000000 38 02209663 1 1 0 0000021a 008c 0080 00000000 00000001 20830220 20830220 0000021a z 00000001 passQ   0 0000021a 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00e6 d5 6fff20d5 000000 40 02202083 1 0 1 0000021a 0000 008c 00000000 00000001 0000005e 0000005e 00000000 u 00000001 ADD     0 00000066 11.. ... ... .. 1111 0000000000 000 1f unalignd Fr00u Unaligned pc, prep read high hword              
00e7 12 00ba3012 000000 40 02202083 1 0 1 0000021a 0088      00000000 00000001 00000000 00000000 00000022 z 00000001 passQ   0 00000022 11.. ... ... .. 1111 0000000000 000 1f straddle Fr10u IncPC, OpFetch                                  
00e8 76 2b712676 000010 40 02202083 1 0 1 0000021a 021c 0088 00000000 00000001 0000021a 0000021a 00000000 u 00000001 ADD     0 0000021c 11.. ... ... .. 1111 0000000000 000 1f Fetchu   Fr00u Read and latch instruction                      
00e9 f4 00fab0f4 000000 40 02202083 0 0 1 0000021c 008c      00000000 00000001 94630bc0 94630bc0 0000021c z 00000001 passQ   0 0000021c 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00ea 40 6fff20d5 010000 40 0bc02083 0 1 0 0000021c 0000 008c 00000000 00000001 00000066 00000066 00000000 u 00000001 ADD     0 0000006a 11.. ... ... .. 1111 0000000000 000 1f LW_0    LW     Load word. Q=yy=rdadr=RS1+Iimm                  lw       x1,188(x0)
00eb 50 837b2050 000010 40 0bc02083 0 1 0 0000021c 00bc      00000000 00000001 00000000 00000000 000000bc u 00000001 ADD     0 000000bc 11.. ... ... .. 1111 0000000000 000 1f LW_1           Read until d=mem[(rs1+ofs) & ~3u]               
00ec e6 12fa08e6 000000 40 0bc02083 0 1 0 0000021c 0088 0004 00000000 00000001 00000000 00000000 000000bc z 00000001 passD   0 00000000 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00ed de 2b7126de 000010 40 0bc02083 0 1 0 0000021c 021c 0088 00000000 00000001 0000021c 0000021c 00000000 u 00000001 ADD     0 0000021e 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00ee f4 20fab0f4 000000 40 0bc02083 1 1 0 0000021e 008c 0080 00000000 00000001 94630bc0 94630bc0 0000021e z 00000001 passQ   0 0000021e 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00ef d5 6fff20d5 000000 38 0bc09463 1 0 1 0000021e 0004 008c 00000000 00000001 0000006a 0000006a 00000000 u 00000001 ADD     0 0000006f 11.. ... ... .. 1111 0000000000 000 1f unalignd Fr00u Unaligned pc, prep read high hword              
00f0 12 00ba3012 000000 38 0bc09463 1 0 1 0000021e 0088      00000000 00000001 00000000 00000000 000000a8 z 00000001 passQ   0 000000a8 11.. ... ... .. 1111 0000000000 000 1f straddle Fr10u IncPC, OpFetch                                  
00f1 76 2b712676 000010 38 0bc09463 1 0 1 0000021e 0220 0088 00000000 00000001 0000021e 0000021e 00000000 u 00000001 ADD     0 00000220 11.. ... ... .. 1111 0000000000 000 1f Fetchu   Fr00u Read and latch instruction                      
00f2 f4 00fab0f4 000000 38 0bc09463 0 0 1 00000220 008c      00000000 00000001 1ffd0200 1ffd0200 00000220 z 00000001 passQ   0 00000220 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00f3 38 6fff20d5 010000 38 02009463 0 1 0 00000220 0004 008c 00000000 00000001 0000006f 0000006f 00000000 u 00000001 ADD     0 00000073 11.. ... ... .. 1111 0000000000 000 1f BNE     BNE    Conditional Branch. Offset to Ryy               bne      x1,x0,248
00f4 13 33ba3013 000000 38 02009463 0 1 0 00000220 0000 00b0 00000000 00000001 00000000 00000000 00000028 z 00000001 passQ   0 00000028 11.. ... ... .. 1111 0000000000 000 1f condb_2        ~RS2 in Q                                       
00f5 14 03fb0014 000000 38 02009463 0 1 0 00000220 0004      00000000 00000001 00000000 00000000 00000000 u 00000001 nearXOR 0 ffffffff 11.. ... ... .. 1111 0000000000 000 1f condb_3        Calculate RS1+~RS2+1                            
00f6 15 033b2615 000000 38 02009463 0 1 0 00000220 00b0      00000000 00000001 00000000 00000000 ffffffff u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 1f condb_4        Branch on condition                             
00f7 16 003b4816 000010 38 02009463 0 1 0 00000220 0080      00000000 00000001 00000028 00000028 00000000 u 00000001 passD   0 00000028 11.. ... ... .. 1111 0000000000 000 1f condb_5        Branch not taken.                               
00f8 e6 00b200e6 000000 38 02009463 0 1 0 00000220 0088      00000000 00000001 0000021e 0000021e 00000028 z 00000001 nearXOR 0 fffffdca 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00f9 de 2b7126de 000010 38 02009463 0 1 0 00000220 0220 0088 00000000 00000001 00000220 00000220 00000000 u 00000001 ADD     0 00000222 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00fa f4 20fab0f4 000000 38 02009463 1 1 0 00000222 008c 0080 00000000 00000001 1ffd0200 1ffd0200 00000222 z 00000001 passQ   0 00000222 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00fb 04 6fff20d5 010000 04 ffff8f93 1 1 0 00000222 007c 008c 00000000 00000001 00000073 00000073 00000000 u 00000001 ADD     0 0000007b 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x31,x31,-1
                 buser/dinx                                                                                                             progress STB(IO)     Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ    |sysack     S T E t r |mie ft Micro                                                                         
     || ucode    ||||may            c v u                                                                                    |          ||WE     ||ACK  SEL  epepepepep\\csr|| code                                                                          
  cy || |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
00fc e6 10ba20e6 000000 04 ffff8f93 1 1 0 00000222 0088 007c 00000000 00000001 00000002 00000002 ffffffff z 00000001 ADD     0 00000001 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00fd de 2b7126de 000010 04 ffff8f93 1 1 0 00000222 0224 0088 00000000 00000001 00000222 00000222 00000000 u 00000001 ADD     0 00000224 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00fe f4 20fab0f4 000000 04 ffff8f93 0 1 0 00000224 008c 0080 00000000 00000001 03f00763 03f00763 00000224 z 00000001 passQ   0 00000224 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00ff 18 6fff20d5 010000 18 03f00763 0 0 0 00000224 0000 008c 00000000 00000001 0000007b 0000007b 00000000 u 00000001 ADD     0 0000007f 11.. ... ... .. 1111 0000000000 000 1f BEQ     BEQ    Conditional Branch. Offset to Ryy               beq      x0,x31,252
0100 13 33ba3013 000000 18 03f00763 0 0 0 00000224 007c 00b0 00000000 00000001 00000000 00000000 0000002e z 00000001 passQ   0 0000002e 11.. ... ... .. 1111 0000000000 000 1f condb_2        ~RS2 in Q                                       
0101 14 03fb0014 000000 18 03f00763 0 0 0 00000224 0000      00000000 00000001 00000001 00000001 00000000 u 00000001 nearXOR 0 fffffffe 11.. ... ... .. 1111 0000000000 000 1f condb_3        Calculate RS1+~RS2+1                            
0102 15 033b2615 000000 18 03f00763 0 0 0 00000224 00b0      00000000 00000001 00000000 00000000 fffffffe u 00000001 ADD     0 ffffffff 11.. ... ... .. 1111 0000000000 000 1f condb_4        Branch on condition                             
0103 16 003b4816 000010 18 03f00763 0 0 0 00000224 0080      00000000 00000001 0000002e 0000002e ffffffff u 00000001 passD   0 0000002e 11.. ... ... .. 1111 0000000000 000 1f condb_5        Branch not taken.                               
0104 e6 00b200e6 000000 18 03f00763 0 0 0 00000224 0088      00000000 00000001 00000224 00000224 0000002e z 00000001 nearXOR 0 fffffdf4 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
0105 de 2b7126de 000010 18 03f00763 0 0 0 00000224 0228 0088 00000000 00000001 00000224 00000224 00000000 u 00000001 ADD     0 00000228 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
0106 f4 20fab0f4 000000 18 03f00763 0 0 0 00000228 008c 0080 00000000 00000001 0b402083 0b402083 00000228 z 00000001 passQ   0 00000228 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0107 40 6fff20d5 010000 40 0b402083 0 0 0 00000228 0000 008c 00000000 00000001 0000007f 0000007f 00000000 u 00000001 ADD     0 00000087 11.. ... ... .. 1111 0000000000 000 1f LW_0    LW     Load word. Q=yy=rdadr=RS1+Iimm                  lw       x1,180(x0)
0108 50 837b2050 000010 40 0b402083 0 0 0 00000228 00b4      00000000 00000001 00000000 00000000 000000b4 u 00000001 ADD     0 000000b4 11.. ... ... .. 1111 0000000000 000 1f LW_1           Read until d=mem[(rs1+ofs) & ~3u]               
0109 e6 12fa08e6 000000 40 0b402083 0 0 0 00000228 0088 0004 00000000 00000001 0000026c 0000026c 000000b4 z 00000001 passD   0 0000026c 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
010a de 2b7126de 000010 40 0b402083 0 0 0 00000228 022c 0088 00000000 00000001 00000228 00000228 00000000 u 00000001 ADD     0 0000022c 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
010b f4 20fab0f4 000000 40 0b402083 0 0 0 0000022c 008c 0080 00000000 00000001 2a230091 2a230091 0000022c z 00000001 passQ   0 0000022c 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
010c 04 6fff20d5 010000 04 00408093 0 1 0 0000022c 0004 008c 00000000 00000001 00000087 00000087 00000000 u 00000001 ADD     0 0000008c 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x1,x1,4
010d e6 10ba20e6 000000 04 00408093 0 1 0 0000022c 0088 0004 00000000 00000001 0000026c 0000026c 00000004 z 00000001 ADD     0 00000270 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
010e de 2b7126de 000010 04 00408093 0 1 0 0000022c 022c 0088 00000000 00000001 0000022c 0000022c 00000000 u 00000001 ADD     0 0000022e 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
010f f4 20fab0f4 000000 04 00408093 1 1 0 0000022e 008c 0080 00000000 00000001 2a230091 2a230091 0000022e z 00000001 passQ   0 0000022e 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0110 d5 6fff20d5 000000 48 00402a23 1 0 1 0000022e 0000 008c 00000000 00000001 0000008c 0000008c 00000000 u 00000001 ADD     0 00000090 11.. ... ... .. 1111 0000000000 000 1f unalignd Fr00u Unaligned pc, prep read high hword              
0111 12 00ba3012 000000 48 00402a23 1 0 1 0000022e 0088      00000000 00000001 00000000 00000000 00000014 z 00000001 passQ   0 00000014 11.. ... ... .. 1111 0000000000 000 1f straddle Fr10u IncPC, OpFetch                                  
0112 76 2b712676 000010 48 00402a23 1 0 1 0000022e 0230 0088 00000000 00000001 0000022e 0000022e 00000000 u 00000001 ADD     0 00000230 11.. ... ... .. 1111 0000000000 000 1f Fetchu   Fr00u Read and latch instruction                      
0113 f4 00fab0f4 000000 48 00402a23 0 0 1 00000230 008c      00000000 00000001 0f170a10 0f170a10 00000230 z 00000001 passQ   0 00000230 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0114 48 6fff20d5 010000 48 0a102a23 0 1 0 00000230 0000 008c 00000000 00000001 00000090 00000090 00000000 u 00000001 ADD     0 00000094 11.. ... ... .. 1111 0000000000 000 1f _L0x48  SW     Store word. Q=wradr=RS1+Simm                    sw       x1,180(x0)
0115 66 83bb2066 000010 48 0a102a23 0 1 0 00000230 0004      00000000 00000001 00000000 00000000 000000b4 u 00000001 ADD     0 000000b4 11.. ... ... .. 1111 0000000000 000 1f SW_1           Write d to a+k until accepted                   
0116 f2 0fb908f2 000000 48 0a102a23 0 1 0 00000230 0004 00b4 00000000 00000001 00000270 00000270 000000b4 h 00000001 passD   0 00000270 1... ... ... .. 1111 0000000000 000 1f SW_2           Prepare read PC                                 
0117 e6 00b200e6 000000 48 0a102a23 0 1 0 00000230 0088      00000000 00000001 00000270 00000270 000000b4 z 00000001 nearXOR 1 fffffd38 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
                 buser/dinx                                                                                                             progress  (RAM)      Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ       ACK      S T E t r |mie ft Micro                                                                         
     || ucode    ||||may            c v u                                                                                    |          ||WE       STB| SEL  epepepepep\\csr|| code                                                                          
  cy || |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
0118 de 2b7126de 000010 48 0a102a23 0 1 0 00000230 0230 0088 00000000 00000001 00000230 00000230 00000000 u 00000001 ADD     0 00000232 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
0119 f4 20fab0f4 000000 48 0a102a23 1 1 0 00000232 008c 0080 00000000 00000001 0f170a10 0f170a10 00000232 z 00000001 passQ   0 00000232 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
011a d5 6fff20d5 000000 05 0a100f17 1 0 1 00000232 0000 008c 00000000 00000001 00000094 00000094 00000000 u 00000001 ADD     0 0000009a 11.. ... ... .. 1111 0000000000 000 1f unalignd Fr00u Unaligned pc, prep read high hword              
011b 12 00ba3012 000000 05 0a100f17 1 0 1 00000232 0088      00000000 00000001 00000000 00000000 0a100000 z 00000001 passQ   0 0a100000 11.. ... ... .. 1111 0000000000 000 1f straddle Fr10u IncPC, OpFetch                                  
011c 76 2b712676 000010 05 0a100f17 1 0 1 00000232 0234 0088 00000000 00000001 00000232 00000232 00000000 u 00000001 ADD     0 00000234 11.. ... ... .. 1111 0000000000 000 1f Fetchu   Fr00u Read and latch instruction                      
011d f4 00fab0f4 000000 05 0a100f17 0 0 1 00000234 008c      00000000 00000001 0f130000 0f130000 00000234 z 00000001 passQ   0 00000234 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
011e 05 6fff20d5 010000 05 00000f17 0 1 0 00000234 0000 008c 00000000 00000001 0000009a 0000009a 00000000 u 00000001 ADD     0 0000009e 11.. ... ... .. 1111 0000000000 000 1f _L0x05  AUIPC  q = imm20+2 or imm20+4  (copy x/2)              auipc    x30,0x0
011f 04 00310004 000000 05 00000f17 0 1 0 00000234 0080      00000000 00000001 00000000 00000000 00000000 h 00000001 nearXOR 0 fffffffc 1... ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         
0120 e6 10ba20e6 000000 05 00000f17 0 1 0 00000234 0088 0078 00000000 00000001 00000232 00000232 00000000 z 00000001 ADD     0 00000232 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
0121 de 2b7126de 000010 05 00000f17 0 1 0 00000234 0234 0088 00000000 00000001 00000234 00000234 00000000 u 00000001 ADD     0 00000236 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
0122 f4 20fab0f4 000000 05 00000f17 1 1 0 00000236 008c 0080 00000000 00000001 0f130000 0f130000 00000236 z 00000001 passQ   0 00000236 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0123 d5 6fff20d5 000000 04 00000f13 1 0 1 00000236 0000 008c 00000000 00000001 0000009e 0000009e 00000000 u 00000001 ADD     0 000000a3 11.. ... ... .. 1111 0000000000 000 1f unalignd Fr00u Unaligned pc, prep read high hword              
0124 12 00ba3012 000000 04 00000f13 1 0 1 00000236 0088      00000000 00000001 00000000 00000000 00000000 z 00000001 passQ   0 00000000 11.. ... ... .. 1111 0000000000 000 1f straddle Fr10u IncPC, OpFetch                                  
0125 76 2b712676 000010 04 00000f13 1 0 1 00000236 0238 0088 00000000 00000001 00000236 00000236 00000000 u 00000001 ADD     0 00000238 11.. ... ... .. 1111 0000000000 000 1f Fetchu   Fr00u Read and latch instruction                      
0126 f4 00fab0f4 000000 04 00000f13 0 0 1 00000238 008c      00000000 00000001 0073040f 0073040f 00000238 z 00000001 passQ   0 00000238 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0127 04 6fff20d5 010000 04 040f0f13 0 1 0 00000238 0078 008c 00000000 00000001 000000a3 000000a3 00000000 u 00000001 ADD     0 000000a7 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x30,x30,64
0128 e6 10ba20e6 000000 04 040f0f13 0 1 0 00000238 0088 0078 00000000 00000001 00000232 00000232 00000040 z 00000001 ADD     0 00000272 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
0129 de 2b7126de 000010 04 040f0f13 0 1 0 00000238 0238 0088 00000000 00000001 00000238 00000238 00000000 u 00000001 ADD     0 0000023a 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
012a f4 20fab0f4 000000 04 040f0f13 1 1 0 0000023a 008c 0080 00000000 00000001 0073040f 0073040f 0000023a z 00000001 passQ   0 0000023a 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
012b d5 6fff20d5 000100 1c 040f0073 1 0 1 0000023a 0078 008c 00000000 00000001 000000a7 000000a7 00000000 u 00000001 ADD     0 000000ab 11.. ... ... .. 1111 0000000000 000 1f unalignd Fr00u Unaligned pc, prep read high hword              
012c 12 00ba3012 000100 1c 040f0073 1 0 1 0000023a 0088      00000000 00000001 00000272 00000272 00000040 z 00000001 passQ   0 00000040 11.. ... ... .. 1111 0000000000 000 1f straddle Fr10u IncPC, OpFetch                                  
012d 76 2b712676 000110 1c 040f0073 1 0 1 0000023a 023c 0088 00000000 00000001 0000023a 0000023a 00000000 u 00000001 ADD     0 0000023c 11.. ... ... .. 1111 0000000000 000 1f Fetchu   Fr00u Read and latch instruction                      
012e f4 00fab0f4 000100 1c 040f0073 0 0 1 0000023c 008c      00000000 00000001 b0333020 b0333020 0000023c z 00000001 passQ   0 0000023c 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
012f 1c 6fff20d5 010000 1c 30200073 0 1 0 0000023c 0000 008c 00000000 00000001 000000ab 000000ab 00000000 u 00000001 ADD     0 000000af 11.. ... ... .. 1111 0000000000 000 1f ECAL_BRKECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI    mret     
0130 a6 82f930a6 000010 1c 30200073 0 1 0 0000023c 00ac      00000000 00000001 00000000 00000000 00000302 h 00000001 passQ   0 00000302 1... ... ... .. 1111 0000000000 000 1f ECAL_RETECALL/(U/S/M)RET Select ECALL or (U/S/M)RET            
0131 d1 82f930d0 000011 1c 30200073 0 1 0 0000023c 00ac      00000000 00000001 ffffffff ffffffff 00000302 h 00000001 passQ   0 00000302 1... ... ... .. 1111 0000000000 000 1f MRET_1  MRET   First save Imm, start build constant for check  
0132 c9 21ba30c9 000000 1c 30200073 0 1 0 0000023c 0098 0080 00000000 00000001 ffffffff ffffffff 00000302 z 00000001 passQ   0 00000302 11.. ... ... .. 1111 0000000000 000 1f MRET_2         0xff+3 = 0x102                                  
0133 a5 01b320a5 000000 1c 30200073 0 1 0 0000023c 0098      00000000 00000001 000000ff 000000ff 00000000 u 00000001 ADD     0 00000102 11.. ... ... .. 1111 0000000000 000 1f MRET_3         0x102 + 0xff + 1 = 0x202                        
                 buser/dinx                                                                                                             progress STB(IO)     Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ    |sysack     S T E t r |mie ft Micro                                                                         
     || ucode    ||||may            c v u                                                                                    |          ||WE     ||ACK  SEL  epepepepep\\csr|| code                                                                          
  cy || |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
0134 af 01bb26af 000000 1c 30200073 0 1 0 0000023c 0098      00000000 00000001 000000ff 000000ff 00000102 u 00000001 ADD     0 00000202 11.. ... ... .. 1111 0000000000 000 1f MRET_4         0x202 + 0xff + 1 = 0x302                        
0135 c5 003b26c5 000000 1c 30200073 0 1 0 0000023c 0080      00000000 00000001 000000ff 000000ff 00000202 u 00000001 ADD     0 00000302 11.. ... ... .. 1111 0000000000 000 1f MRET_5         ~302                                            
0136 6f 003b106f 000000 1c 30200073 0 1 0 0000023c 0080      00000000 00000001 00000302 00000302 00000302 u 00000001 INVQ    0 fffffcfd 11.. ... ... .. 1111 0000000000 000 1f MRET_6         ~302 + origImm + 1 for branch decision          
0137 cf 003b26cf 000000 1c 30200073 0 1 0 0000023c 0080      00000000 00000001 00000302 00000302 fffffcfd u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 1f MRET_7         Prepare emulation entry point 0x104             
0138 4f 01b2404f 000011 1c 30200073 0 1 0 0000023c 0098      00000000 00000001 00000302 00000302 00000000 z 00000001 nearXOR 0 fffffcfe 11.. ... ... .. 1111 0000000000 000 1f MRET_8         Prep +4                                         
0139 e6 02bb26e6 000000 1c 30200073 0 1 0 0000023c 00a8      00000000 00000001 000000ff 000000ff 00000000 u 00000001 ADD     0 00000100 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
013a de 2b7126de 000010 1c 30200073 0 1 0 0000023c 0100 0088 00000000 00000001 00000000 00000000 00000100 u 00000001 ADD     0 00000102 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
013b f4 20fab0f4 000000 1c 30200073 1 1 0 00000102 008c 0080 00000000 00000001 00000000 00000000 00000102 z 00000001 passQ   0 00000102 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
013c fe 6fff20d5 010100 04 00010412 1 1 0 00000102 0008 008c 00000000 00000001 000000af 000000af 00000000 u 00000001 ADD     0 000000bc 11.. ... ... .. 1111 0000000000 000 1f ILLe    Illegal                                                Unsupported 
013d 46 00b00046 000100 04 00010412 1 1 0 00000102 0088      00000000 00000001 0000026c 0000026c 00000000 h 00000001 nearXOR 0 fffffd90 1... ... ... .. 1111 0000000000 000 1f ILL_1          Store PC to mepc                                
013e 47 36b80847 000100 04 00010412 1 1 0 00000102 00a8 00b4 00000000 00000001 00000102 00000102 00000000 h 00000001 passD   0 00000102 1... ... ... .. 1111 0000000000 000 1f ILL_2          Store 0 to mtval                                
013f 8f 3eba088f 000100 04 00010412 1 1 0 00000102 00a8 00bc 00000000 00000001 00000000 00000000 00000000 z 00000001 passD   0 00000000 11.. ... ... .. 1111 0000000000 000 1f ILL_3          Q = 1                                           
0140 a9 02bb26a9 000100 04 00010412 1 1 0 00000102 00a8      00000000 00000001 00000000 00000000 00000000 u 00000001 ADD     0 00000001 11.. ... ... .. 1111 0000000000 000 1f ILL_4          Store 2 to mcause                               
0141 34 3a782634 000100 04 00010412 1 1 0 00000102 00a4 00b8 00000000 00000001 00000000 00000000 00000001 h 00000001 ADD     0 00000002 1... ... ... .. 1111 0000000000 000 1f JAL_3        Prep fetch next instr.                            
0142 de 2b7908de 000110 04 00010412 1 1 0 00000102 0204 0088 00000000 00000001 00000204 00000204 00000001 u 00000001 passD   0 00000204 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
0143 f4 20fab0f4 000100 04 00010412 0 1 0 00000204 008c 0080 00000000 00000001 2083412d 2083412d 00000204 z 00000001 passQ   0 00000204 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0144 04 6fff20d5 010000 04 00b00113 0 1 0 00000204 0000 008c 00000000 00000001 000000bc 000000bc 00000000 u 00000001 ADD     0 000000c4 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x2,x0,11
0145 e6 10ba20e6 000000 04 00b00113 0 1 0 00000204 0088 0008 00000000 00000001 00000000 00000000 0000000b z 00000001 ADD     0 0000000b 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
0146 de 2b7126de 000010 04 00b00113 0 1 0 00000204 0204 0088 00000000 00000001 00000204 00000204 00000000 u 00000001 ADD     0 00000206 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
0147 f4 20fab0f4 000000 04 00b00113 1 1 0 00000206 008c 0080 00000000 00000001 2083412d 2083412d 00000206 z 00000001 passQ   0 00000206 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0148 d5 6fff20d5 000000 40 00b02083 1 0 1 00000206 0000 008c 00000000 00000001 000000c4 000000c4 00000000 u 00000001 ADD     0 000000c8 11.. ... ... .. 1111 0000000000 000 1f unalignd Fr00u Unaligned pc, prep read high hword              
0149 12 00ba3012 000000 40 00b02083 1 0 1 00000206 0088      00000000 00000001 00000000 00000000 0000000b z 00000001 passQ   0 0000000b 11.. ... ... .. 1111 0000000000 000 1f straddle Fr10u IncPC, OpFetch                                  
014a 76 2b712676 000010 40 00b02083 1 0 1 00000206 0208 0088 00000000 00000001 00000206 00000206 00000000 u 00000001 ADD     0 00000208 11.. ... ... .. 1111 0000000000 000 1f Fetchu   Fr00u Read and latch instruction                      
014b f4 00fab0f4 000000 40 00b02083 0 0 1 00000208 008c      00000000 00000001 9a630b80 9a630b80 00000208 z 00000001 passQ   0 00000208 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
014c 40 6fff20d5 010000 40 0b802083 0 1 0 00000208 0000 008c 00000000 00000001 000000c8 000000c8 00000000 u 00000001 ADD     0 000000cc 11.. ... ... .. 1111 0000000000 000 1f LW_0    LW     Load word. Q=yy=rdadr=RS1+Iimm                  lw       x1,184(x0)
014d 50 837b2050 000010 40 0b802083 0 1 0 00000208 00b8      00000000 00000001 00000000 00000000 000000b8 u 00000001 ADD     0 000000b8 11.. ... ... .. 1111 0000000000 000 1f LW_1           Read until d=mem[(rs1+ofs) & ~3u]               
014e e6 12fa08e6 000000 40 0b802083 0 1 0 00000208 0088 0004 00000000 00000001 00000002 00000002 000000b8 z 00000001 passD   0 00000002 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
014f de 2b7126de 000010 40 0b802083 0 1 0 00000208 0208 0088 00000000 00000001 00000208 00000208 00000000 u 00000001 ADD     0 0000020a 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
                 buser/dinx                                                                                                             progress  (RAM)      Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ       ACK      S T E t r |mie ft Micro                                                                         
     || ucode    ||||may            c v u                                                                                    |          ||WE       STB| SEL  epepepepep\\csr|| code                                                                          
  cy || |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
0150 f4 20fab0f4 000000 40 0b802083 1 1 0 0000020a 008c 0080 00000000 00000001 9a630b80 9a630b80 0000020a z 00000001 passQ   0 0000020a 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0151 d5 6fff20d5 000000 38 0b809a63 1 0 1 0000020a 0004 008c 00000000 00000001 000000cc 000000cc 00000000 u 00000001 ADD     0 000000d1 11.. ... ... .. 1111 0000000000 000 1f unalignd Fr00u Unaligned pc, prep read high hword              
0152 12 00ba3012 000000 38 0b809a63 1 0 1 0000020a 0088      00000000 00000001 00000002 00000002 000000b4 z 00000001 passQ   0 000000b4 11.. ... ... .. 1111 0000000000 000 1f straddle Fr10u IncPC, OpFetch                                  
0153 76 2b712676 000010 38 0b809a63 1 0 1 0000020a 020c 0088 00000000 00000001 0000020a 0000020a 00000000 u 00000001 ADD     0 0000020c 11.. ... ... .. 1111 0000000000 000 1f Fetchu   Fr00u Read and latch instruction                      
0154 f4 00fab0f4 000000 38 0b809a63 0 0 1 0000020c 008c      00000000 00000001 20830220 20830220 0000020c z 00000001 passQ   0 0000020c 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0155 38 6fff20d5 010000 38 02209a63 0 1 0 0000020c 0004 008c 00000000 00000001 000000d1 000000d1 00000000 u 00000001 ADD     0 000000d5 11.. ... ... .. 1111 0000000000 000 1f BNE     BNE    Conditional Branch. Offset to Ryy               bne      x1,x2,240
0156 13 33ba3013 000000 38 02209a63 0 1 0 0000020c 0008 00b0 00000000 00000001 00000002 00000002 00000034 z 00000001 passQ   0 00000034 11.. ... ... .. 1111 0000000000 000 1f condb_2        ~RS2 in Q                                       
0157 14 03fb0014 000000 38 02209a63 0 1 0 0000020c 0004      00000000 00000001 0000000b 0000000b 00000000 u 00000001 nearXOR 0 fffffff4 11.. ... ... .. 1111 0000000000 000 1f condb_3        Calculate RS1+~RS2+1                            
0158 15 033b2615 000000 38 02209a63 0 1 0 0000020c 00b0      00000000 00000001 00000002 00000002 fffffff4 u 00000001 ADD     0 fffffff7 11.. ... ... .. 1111 0000000000 000 1f condb_4        Branch on condition                             
0159 17 003b4816 000011 38 02209a63 0 1 0 0000020c 0080      00000000 00000001 00000034 00000034 fffffff7 u 00000001 passD   0 00000034 11.. ... ... .. 1111 0000000000 000 1f condb_5t       Branch taken.                                   
015a de 2b7920de 000010 38 02209a63 0 1 0 0000020c 023c 0088 00000000 00000001 0000020a 0000020a 00000034 u 00000001 ADD     0 0000023e 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
015b f4 20fab0f4 000000 38 02209a63 1 1 0 0000023e 008c 0080 00000000 00000001 b0333020 b0333020 0000023e z 00000001 passQ   0 0000023e 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
015c d5 6fff20d5 000000 6d 0220b033 1 0 1 0000023e 0004 008c 00000000 00000001 000000d5 000000d5 00000000 u 00000001 ADD     0 000000dc 11.. ... ... .. 1111 0000000000 000 1f unalignd Fr00u Unaligned pc, prep read high hword              
015d 12 00ba3012 000000 6d 0220b033 1 0 1 0000023e 0088      00000000 00000001 00000002 00000002 00000022 z 00000001 passQ   0 00000022 11.. ... ... .. 1111 0000000000 000 1f straddle Fr10u IncPC, OpFetch                                  
015e 76 2b712676 000010 6d 0220b033 1 0 1 0000023e 0240 0088 00000000 00000001 0000023e 0000023e 00000000 u 00000001 ADD     0 00000240 11.. ... ... .. 1111 0000000000 000 1f Fetchu   Fr00u Read and latch instruction                      
015f f4 00fab0f4 000000 6d 0220b033 0 0 1 00000240 008c      00000000 00000001 30330000 30330000 00000240 z 00000001 passQ   0 00000240 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
Simulation ended with error code 0x1
           ../../obj_dir/second/t401.bin: Simulation ended with error code 0x1
