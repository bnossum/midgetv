                 buser/dinx                                                                                                             progress  (RAM)      Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ       ACK      S T E t r |mie ft Micro                                                                         
start|| ucode    ||||may            c v u                                                                                    |          ||WE       STB| SEL  epepepepep\\csr|| code                                                                          
  cy||| |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
0000-00 00200000 000000 00 00000000 0 0 0 00000258 0080      00000000 00000000 00000000 00000000 00000000 h 00000000 nearXOR 0 fffffffc 1... ... ... .. 0000 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0001-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000000 ADD     0 00000000 11.. ... ... .. 0000 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0002-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0003-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0004-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0005-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0006-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0007-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0008-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0009-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
000a-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
000b-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
000c-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
000d-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
000e-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
000f-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0010-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0011-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0012-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0013-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0014-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0015-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0016-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0017-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0018-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0019-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
001a-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
001b-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
                 buser/dinx                                                                                                             progress STB(IO)     Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ    |sysack     S T E t r |mie ft Micro                                                                         
start|| ucode    ||||may            c v u                                                                                    |          ||WE     ||ACK  SEL  epepepepep\\csr|| code                                                                          
  cy||| |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
001c-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
001d-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
001e-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
001f-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0020-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0021-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0022-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0023-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0024-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0025-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0026-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0027-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0028-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0029-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
002a-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
002b-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
002c-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
002d-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
002e-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
002f-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0030-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0031-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0032-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0033-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0034-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0035-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0036-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0037-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
                 buser/dinx                                                                                                             progress  (RAM)      Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ       ACK      S T E t r |mie ft Micro                                                                         
start|| ucode    ||||may            c v u                                                                                    |          ||WE       STB| SEL  epepepepep\\csr|| code                                                                          
  cy||| |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
0038-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0039-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
003a-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
003b-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
003c-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
003d-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
003e-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
003f-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0040-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0041-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0042-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0043-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0044-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0045-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0046-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0047-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0048-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0049-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
004a-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
004b-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
004c-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
004d-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
004e-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
004f-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0050-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0051-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0052-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0053-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
                 buser/dinx                                                                                                             progress STB(IO)     Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ    |sysack     S T E t r |mie ft Micro                                                                         
start|| ucode    ||||may            c v u                                                                                    |          ||WE     ||ACK  SEL  epepepepep\\csr|| code                                                                          
  cy||| |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
0054-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0055-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0056-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0057-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0058-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0059-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
005a-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
005b-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
005c-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
005d-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
005e-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
005f-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0060-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0061-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0062-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0063-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0064-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0065-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0066-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0067-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0068-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0069-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
006a-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
006b-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
006c-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
006d-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
006e-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
006f-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
                 buser/dinx                                                                                                             progress  (RAM)      Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ       ACK      S T E t r |mie ft Micro                                                                         
start|| ucode    ||||may            c v u                                                                                    |          ||WE       STB| SEL  epepepepep\\csr|| code                                                                          
  cy||| |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
0070-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0071-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0072-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0073-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0074-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0075-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0076-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0077-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0078-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0079-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
007a-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
007b-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
007c-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
007d-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
007e-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
007f-00 036b2001 000000 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_0    LB     Load byte. q = rdadr=RS1+0fs                    
0080 01 036b2001 000100 00 00000000 0 0 0 00000258 0000      00000000 00000000 00000000 00000000 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_1           Read until q=mem[rs1+ofs) & ~3u]                
0081 d2 02fb09d2 000100 00 00000000 0 0 0 00000258 00a8      00000000 00000001 00000000 00000000 00000000 u 00000001 passD   0 00000000 11.. ... ... .. 1111 0000000000 000 00 LB_2           Repeat shr until shreg == 0 (0,8,16,24 times)   
0082 06 029b0906 000100 00 00000000 0 0 0 00000258 00a8      00000000 00000001 00000000 00000000 00000000 h 00000001 passD   0 00000000 1... ... ... .. 1111 0000000000 000 00 LB_3           q = ~mem[rs1+ofs]                               
0083 07 01bb1007 000100 00 00000000 0 0 0 00000258 0098      00000000 00000001 00000000 00000000 00000000 u 00000001 INVQ    0 ffffffff 11.. ... ... .. 1111 0000000000 000 1f LB_4           q = (uint8_t) mem[rs1+Iimm]                     
0084 09 017b1809 000100 00 00000000 0 0 0 00000258 0094      00000000 00000001 000000ff 000000ff ffffffff u 00000001 nearAND 0 00000000 11.. ... ... .. 1111 0000000000 000 1f LB_5           q = D^0xffffffff^q = D^0x80                     
0085 8b 017b008b 000100 00 00000000 0 0 0 00000258 0094      00000000 00000001 ffffff7f ffffff7f 00000000 u 00000001 nearXOR 0 00000080 11.. ... ... .. 1111 0000000000 000 1f LB_6           WTRG=(D^0x80)+0xFFFFFF7F+1=(D^0x80)-0x80        
0086 e6 10ba26e6 000110 00 00000000 0 0 0 00000258 0088 0080 00000000 00000001 ffffff7f ffffff7f 00000080 z 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
0087 de 2b7126de 000110 00 00000000 0 0 0 00000258 025c 0088 00000000 00000001 00000258 00000258 00000000 u 00000001 ADD     0 0000025c 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
0088 f4 20fab0f4 000100 00 00000000 0 0 0 0000025c 008c 0080 00000000 00000001 00200f93 00200f93 0000025c z 00000001 passQ   0 0000025c 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0089 04 6fff20d5 010000 04 00200f93 0 0 0 0000025c 0000 008c 00000000 00000001 00000000 00000000 00000000 u 00000001 ADD     0 00000009 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x31,x0,2
008a e6 10ba20e6 000000 04 00200f93 0 0 0 0000025c 0088 007c 00000000 00000001 00000000 00000000 00000002 z 00000001 ADD     0 00000002 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
008b de 2b7126de 000010 04 00200f93 0 0 0 0000025c 0260 0088 00000000 00000001 0000025c 0000025c 00000000 u 00000001 ADD     0 00000260 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
                 buser/dinx                                                                                                             progress STB(IO)     Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ    |sysack     S T E t r |mie ft Micro                                                                         
     || ucode    ||||may            c v u                                                                                    |          ||WE     ||ACK  SEL  epepepepep\\csr|| code                                                                          
  cy || |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
008c f4 20fab0f4 000000 04 00200f93 0 0 0 00000260 008c 0080 00000000 00000001 00000f17 00000f17 00000260 z 00000001 passQ   0 00000260 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
008d 05 6fff20d5 010000 05 00000f17 0 0 0 00000260 0000 008c 00000000 00000001 00000009 00000009 00000000 u 00000001 ADD     0 0000000d 11.. ... ... .. 1111 0000000000 000 1f _L0x05  AUIPC  q = imm20+2 or imm20+4  (copy x/2)              auipc    x30,0x0
008e 04 00310004 000000 05 00000f17 0 0 0 00000260 0080      00000000 00000001 00000000 00000000 00000000 h 00000001 nearXOR 0 fffffffc 1... ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         
008f e6 10ba20e6 000000 05 00000f17 0 0 0 00000260 0088 0078 00000000 00000001 00000260 00000260 00000000 z 00000001 ADD     0 00000260 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
0090 de 2b7126de 000010 05 00000f17 0 0 0 00000260 0264 0088 00000000 00000001 00000260 00000260 00000000 u 00000001 ADD     0 00000264 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
0091 f4 20fab0f4 000000 05 00000f17 0 0 0 00000264 008c 0080 00000000 00000001 014f0f13 014f0f13 00000264 z 00000001 passQ   0 00000264 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0092 04 6fff20d5 010000 04 014f0f13 0 0 0 00000264 0078 008c 00000000 00000001 0000000d 0000000d 00000000 u 00000001 ADD     0 00000012 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x30,x30,20
0093 e6 10ba20e6 000000 04 014f0f13 0 0 0 00000264 0088 0078 00000000 00000001 00000260 00000260 00000014 z 00000001 ADD     0 00000274 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
0094 de 2b7126de 000010 04 014f0f13 0 0 0 00000264 0268 0088 00000000 00000001 00000264 00000264 00000000 u 00000001 ADD     0 00000268 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
0095 f4 20fab0f4 000000 04 014f0f13 0 0 0 00000268 008c 0080 00000000 00000001 00000097 00000097 00000268 z 00000001 passQ   0 00000268 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0096 05 6fff20d5 010000 05 00000097 0 0 0 00000268 0000 008c 00000000 00000001 00000012 00000012 00000000 u 00000001 ADD     0 00000016 11.. ... ... .. 1111 0000000000 000 1f _L0x05  AUIPC  q = imm20+2 or imm20+4  (copy x/2)              auipc    x1,0x0
0097 04 00310004 000000 05 00000097 0 0 0 00000268 0080      00000000 00000001 00000000 00000000 00000000 h 00000001 nearXOR 0 fffffffc 1... ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         
0098 e6 10ba20e6 000000 05 00000097 0 0 0 00000268 0088 0004 00000000 00000001 00000268 00000268 00000000 z 00000001 ADD     0 00000268 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
0099 de 2b7126de 000010 05 00000097 0 0 0 00000268 026c 0088 00000000 00000001 00000268 00000268 00000000 u 00000001 ADD     0 0000026c 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
009a f4 20fab0f4 000000 05 00000097 0 0 0 0000026c 008c 0080 00000000 00000001 f9c08093 f9c08093 0000026c z 00000001 passQ   0 0000026c 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
009b 04 6fff20d5 010000 04 f9c08093 0 0 0 0000026c 0004 008c 00000000 00000001 00000016 00000016 00000000 u 00000001 ADD     0 0000001b 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x1,x1,-100
009c e6 10ba20e6 000000 04 f9c08093 0 0 0 0000026c 0088 0004 00000000 00000001 00000268 00000268 ffffff9c z 00000001 ADD     0 00000204 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
009d de 2b7126de 000010 04 f9c08093 0 0 0 0000026c 0270 0088 00000000 00000001 0000026c 0000026c 00000000 u 00000001 ADD     0 00000270 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
009e f4 20fab0f4 000000 04 f9c08093 0 0 0 00000270 008c 0080 00000000 00000001 0a102223 0a102223 00000270 z 00000001 passQ   0 00000270 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
009f 48 6fff20d5 010000 48 0a102223 0 0 0 00000270 0000 008c 00000000 00000001 0000001b 0000001b 00000000 u 00000001 ADD     0 0000001f 11.. ... ... .. 1111 0000000000 000 1f _L0x48  SW     Store word. Q=wradr=RS1+Simm                    sw       x1,164(x0)
00a0 66 83bb2066 000010 48 0a102223 0 0 0 00000270 0004      00000000 00000001 00000000 00000000 000000a4 u 00000001 ADD     0 000000a4 11.. ... ... .. 1111 0000000000 000 1f SW_1           Write d to a+k until accepted                   
00a1 f2 0fb908f2 000000 48 0a102223 0 0 0 00000270 0004 00a4 00000000 00000001 00000204 00000204 000000a4 h 00000001 passD   0 00000204 1... ... ... .. 1111 0000000000 000 1f SW_2           Prepare read PC                                 
00a2 e6 00b200e6 000000 48 0a102223 0 0 0 00000270 0088      00000000 00000001 00000204 00000204 000000a4 z 00000001 nearXOR 1 fffffd5c 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00a3 de 2b7126de 000010 48 0a102223 0 0 0 00000270 0274 0088 00000000 00000001 00000270 00000270 00000000 u 00000001 ADD     0 00000274 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00a4 f4 20fab0f4 000000 48 0a102223 0 0 0 00000274 008c 0080 00000000 00000001 00000073 00000073 00000274 z 00000001 passQ   0 00000274 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00a5 1c 6fff20d5 010000 1c 00000073 0 0 0 00000274 0000 008c 00000000 00000001 0000001f 0000001f 00000000 u 00000001 ADD     0 00000025 11.. ... ... .. 1111 0000000000 000 1f ECAL_BRKECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI    ecall    
00a6 a6 82f930a6 000010 1c 00000073 0 0 0 00000274 00ac      00000000 00000001 00000000 00000000 00000000 h 00000001 passQ   0 00000000 1... ... ... .. 1111 0000000000 000 1f ECAL_RETECALL/(U/S/M)RET Select ECALL or (U/S/M)RET            
00a7 d0 82f930d0 000010 1c 00000073 0 0 0 00000274 00ac      00000000 00000001 ffffffff ffffffff 00000000 h 00000001 passQ   0 00000000 1... ... ... .. 1111 0000000000 000 1f ECALL_1 ECALL  Verify Imm==0x000                               
                 buser/dinx                                                                                                             progress  (RAM)      Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ       ACK      S T E t r |mie ft Micro                                                                         
     || ucode    ||||may            c v u                                                                                    |          ||WE       STB| SEL  epepepepep\\csr|| code                                                                          
  cy || |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
00a8 37 003b2637 000000 1c 00000073 0 0 0 00000274 0080      00000000 00000001 ffffffff ffffffff 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 1f ECALL_2        mepc = pc, prep store 0 to mtval                
00a9 d7 343a48d7 000011 1c 00000073 0 0 0 00000274 0080 00b4 00000000 00000001 00000274 00000274 00000000 z 00000001 passD   0 00000274 11.. ... ... .. 1111 0000000000 000 1f ECALL_3        mtval = 0, now start the chore of 11 to mcause  
00aa a1 3eba30a1 000000 1c 00000073 0 0 0 00000274 00a8 00bc 00000000 00000001 00000274 00000274 00000000 z 00000001 passQ   0 00000000 11.. ... ... .. 1111 0000000000 000 1f ECALL_4        Q = 4                                           
00ab b6 02b326b6 000010 1c 00000073 0 0 0 00000274 00a8      00000000 00000001 00000000 00000000 00000000 u 00000001 ADD     0 00000004 11.. ... ... .. 1111 0000000000 000 1f ECALL_5        Q = 8                                           
00ac 9a 02b3269a 000010 1c 00000073 0 0 0 00000274 00a8      00000000 00000001 00000000 00000000 00000004 u 00000001 ADD     0 00000008 11.. ... ... .. 1111 0000000000 000 1f ECALL_6        mcause = 11                                     
00ad 34 3a702034 000000 1c 00000073 0 0 0 00000274 00a4 00b8 00000000 00000001 00000000 00000000 00000008 h 00000001 ADD     0 0000000b 1... ... ... .. 1111 0000000000 000 1f JAL_3        Prep fetch next instr.                            
00ae de 2b7908de 000010 1c 00000073 0 0 0 00000274 0204 0088 00000000 00000001 00000204 00000204 00000008 u 00000001 passD   0 00000204 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00af f4 20fab0f4 000000 1c 00000073 0 0 0 00000204 008c 0080 00000000 00000001 00b00113 00b00113 00000204 z 00000001 passQ   0 00000204 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00b0 04 6fff20d5 010000 04 00b00113 0 0 0 00000204 0000 008c 00000000 00000001 00000025 00000025 00000000 u 00000001 ADD     0 00000030 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x2,x0,11
00b1 e6 10ba20e6 000000 04 00b00113 0 0 0 00000204 0088 0008 00000000 00000001 00000000 00000000 0000000b z 00000001 ADD     0 0000000b 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00b2 de 2b7126de 000010 04 00b00113 0 0 0 00000204 0208 0088 00000000 00000001 00000204 00000204 00000000 u 00000001 ADD     0 00000208 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00b3 f4 20fab0f4 000000 04 00b00113 0 0 0 00000208 008c 0080 00000000 00000001 0b802083 0b802083 00000208 z 00000001 passQ   0 00000208 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00b4 40 6fff20d5 010000 40 0b802083 0 0 0 00000208 0000 008c 00000000 00000001 00000030 00000030 00000000 u 00000001 ADD     0 00000034 11.. ... ... .. 1111 0000000000 000 1f LW_0    LW     Load word. Q=yy=rdadr=RS1+Iimm                  lw       x1,184(x0)
00b5 50 837b2050 000010 40 0b802083 0 0 0 00000208 00b8      00000000 00000001 00000000 00000000 000000b8 u 00000001 ADD     0 000000b8 11.. ... ... .. 1111 0000000000 000 1f LW_1           Read until d=mem[(rs1+ofs) & ~3u]               
00b6 e6 12fa08e6 000000 40 0b802083 0 0 0 00000208 0088 0004 00000000 00000001 0000000b 0000000b 000000b8 z 00000001 passD   0 0000000b 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00b7 de 2b7126de 000010 40 0b802083 0 0 0 00000208 020c 0088 00000000 00000001 00000208 00000208 00000000 u 00000001 ADD     0 0000020c 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00b8 f4 20fab0f4 000000 40 0b802083 0 0 0 0000020c 008c 0080 00000000 00000001 02209c63 02209c63 0000020c z 00000001 passQ   0 0000020c 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00b9 38 6fff20d5 010000 38 02209c63 0 0 0 0000020c 0004 008c 00000000 00000001 00000034 00000034 00000000 u 00000001 ADD     0 00000039 11.. ... ... .. 1111 0000000000 000 1f BNE     BNE    Conditional Branch. Offset to Ryy               bne      x1,x2,244
00ba 13 33ba3013 000000 38 02209c63 0 0 0 0000020c 0008 00b0 00000000 00000001 0000000b 0000000b 00000038 z 00000001 passQ   0 00000038 11.. ... ... .. 1111 0000000000 000 1f condb_2        ~RS2 in Q                                       
00bb 14 03fb0014 000000 38 02209c63 0 0 0 0000020c 0004      00000000 00000001 0000000b 0000000b 00000000 u 00000001 nearXOR 0 fffffff4 11.. ... ... .. 1111 0000000000 000 1f condb_3        Calculate RS1+~RS2+1                            
00bc 15 033b2615 000000 38 02209c63 0 0 0 0000020c 00b0      00000000 00000001 0000000b 0000000b fffffff4 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 1f condb_4        Branch on condition                             
00bd 16 003b4816 000010 38 02209c63 0 0 0 0000020c 0080      00000000 00000001 00000038 00000038 00000000 u 00000001 passD   0 00000038 11.. ... ... .. 1111 0000000000 000 1f condb_5        Branch not taken.                               
00be e6 00b200e6 000000 38 02209c63 0 0 0 0000020c 0088      00000000 00000001 0000020c 0000020c 00000038 z 00000001 nearXOR 0 fffffdc8 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00bf de 2b7126de 000010 38 02209c63 0 0 0 0000020c 0210 0088 00000000 00000001 0000020c 0000020c 00000000 u 00000001 ADD     0 00000210 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00c0 f4 20fab0f4 000000 38 02209c63 0 0 0 00000210 008c 0080 00000000 00000001 0b402083 0b402083 00000210 z 00000001 passQ   0 00000210 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00c1 40 6fff20d5 010000 40 0b402083 0 0 0 00000210 0000 008c 00000000 00000001 00000039 00000039 00000000 u 00000001 ADD     0 00000041 11.. ... ... .. 1111 0000000000 000 1f LW_0    LW     Load word. Q=yy=rdadr=RS1+Iimm                  lw       x1,180(x0)
00c2 50 837b2050 000010 40 0b402083 0 0 0 00000210 00b4      00000000 00000001 00000000 00000000 000000b4 u 00000001 ADD     0 000000b4 11.. ... ... .. 1111 0000000000 000 1f LW_1           Read until d=mem[(rs1+ofs) & ~3u]               
00c3 e6 12fa08e6 000000 40 0b402083 0 0 0 00000210 0088 0004 00000000 00000001 00000274 00000274 000000b4 z 00000001 passD   0 00000274 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
                 buser/dinx                                                                                                             progress STB(IO)     Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ    |sysack     S T E t r |mie ft Micro                                                                         
     || ucode    ||||may            c v u                                                                                    |          ||WE     ||ACK  SEL  epepepepep\\csr|| code                                                                          
  cy || |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
00c4 de 2b7126de 000010 40 0b402083 0 0 0 00000210 0214 0088 00000000 00000001 00000210 00000210 00000000 u 00000001 ADD     0 00000214 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00c5 f4 20fab0f4 000000 40 0b402083 0 0 0 00000214 008c 0080 00000000 00000001 000f0113 000f0113 00000214 z 00000001 passQ   0 00000214 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00c6 04 6fff20d5 010000 04 000f0113 0 0 0 00000214 0078 008c 00000000 00000001 00000041 00000041 00000000 u 00000001 ADD     0 00000046 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x2,x30,0
00c7 e6 10ba20e6 000000 04 000f0113 0 0 0 00000214 0088 0008 00000000 00000001 00000274 00000274 00000000 z 00000001 ADD     0 00000274 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00c8 de 2b7126de 000010 04 000f0113 0 0 0 00000214 0218 0088 00000000 00000001 00000214 00000214 00000000 u 00000001 ADD     0 00000218 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00c9 f4 20fab0f4 000000 04 000f0113 0 0 0 00000218 008c 0080 00000000 00000001 02209863 02209863 00000218 z 00000001 passQ   0 00000218 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00ca 38 6fff20d5 010000 38 02209863 0 0 0 00000218 0004 008c 00000000 00000001 00000046 00000046 00000000 u 00000001 ADD     0 0000004a 11.. ... ... .. 1111 0000000000 000 1f BNE     BNE    Conditional Branch. Offset to Ryy               bne      x1,x2,248
00cb 13 33ba3013 000000 38 02209863 0 0 0 00000218 0008 00b0 00000000 00000001 00000274 00000274 00000030 z 00000001 passQ   0 00000030 11.. ... ... .. 1111 0000000000 000 1f condb_2        ~RS2 in Q                                       
00cc 14 03fb0014 000000 38 02209863 0 0 0 00000218 0004      00000000 00000001 00000274 00000274 00000000 u 00000001 nearXOR 0 fffffd8b 11.. ... ... .. 1111 0000000000 000 1f condb_3        Calculate RS1+~RS2+1                            
00cd 15 033b2615 000000 38 02209863 0 0 0 00000218 00b0      00000000 00000001 00000274 00000274 fffffd8b u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 1f condb_4        Branch on condition                             
00ce 16 003b4816 000010 38 02209863 0 0 0 00000218 0080      00000000 00000001 00000030 00000030 00000000 u 00000001 passD   0 00000030 11.. ... ... .. 1111 0000000000 000 1f condb_5        Branch not taken.                               
00cf e6 00b200e6 000000 38 02209863 0 0 0 00000218 0088      00000000 00000001 00000218 00000218 00000030 z 00000001 nearXOR 0 fffffdd4 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00d0 de 2b7126de 000010 38 02209863 0 0 0 00000218 021c 0088 00000000 00000001 00000218 00000218 00000000 u 00000001 ADD     0 0000021c 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00d1 f4 20fab0f4 000000 38 02209863 0 0 0 0000021c 008c 0080 00000000 00000001 0bc02083 0bc02083 0000021c z 00000001 passQ   0 0000021c 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00d2 40 6fff20d5 010000 40 0bc02083 0 0 0 0000021c 0000 008c 00000000 00000001 0000004a 0000004a 00000000 u 00000001 ADD     0 00000052 11.. ... ... .. 1111 0000000000 000 1f LW_0    LW     Load word. Q=yy=rdadr=RS1+Iimm                  lw       x1,188(x0)
00d3 50 837b2050 000010 40 0bc02083 0 0 0 0000021c 00bc      00000000 00000001 00000000 00000000 000000bc u 00000001 ADD     0 000000bc 11.. ... ... .. 1111 0000000000 000 1f LW_1           Read until d=mem[(rs1+ofs) & ~3u]               
00d4 e6 12fa08e6 000000 40 0bc02083 0 0 0 0000021c 0088 0004 00000000 00000001 00000000 00000000 000000bc z 00000001 passD   0 00000000 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00d5 de 2b7126de 000010 40 0bc02083 0 0 0 0000021c 0220 0088 00000000 00000001 0000021c 0000021c 00000000 u 00000001 ADD     0 00000220 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00d6 f4 20fab0f4 000000 40 0bc02083 0 0 0 00000220 008c 0080 00000000 00000001 02009663 02009663 00000220 z 00000001 passQ   0 00000220 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00d7 38 6fff20d5 010000 38 02009663 0 0 0 00000220 0004 008c 00000000 00000001 00000052 00000052 00000000 u 00000001 ADD     0 00000057 11.. ... ... .. 1111 0000000000 000 1f BNE     BNE    Conditional Branch. Offset to Ryy               bne      x1,x0,24c
00d8 13 33ba3013 000000 38 02009663 0 0 0 00000220 0000 00b0 00000000 00000001 00000000 00000000 0000002c z 00000001 passQ   0 0000002c 11.. ... ... .. 1111 0000000000 000 1f condb_2        ~RS2 in Q                                       
00d9 14 03fb0014 000000 38 02009663 0 0 0 00000220 0004      00000000 00000001 00000000 00000000 00000000 u 00000001 nearXOR 0 ffffffff 11.. ... ... .. 1111 0000000000 000 1f condb_3        Calculate RS1+~RS2+1                            
00da 15 033b2615 000000 38 02009663 0 0 0 00000220 00b0      00000000 00000001 00000000 00000000 ffffffff u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 1f condb_4        Branch on condition                             
00db 16 003b4816 000010 38 02009663 0 0 0 00000220 0080      00000000 00000001 0000002c 0000002c 00000000 u 00000001 passD   0 0000002c 11.. ... ... .. 1111 0000000000 000 1f condb_5        Branch not taken.                               
00dc e6 00b200e6 000000 38 02009663 0 0 0 00000220 0088      00000000 00000001 00000220 00000220 0000002c z 00000001 nearXOR 0 fffffdf0 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00dd de 2b7126de 000010 38 02009663 0 0 0 00000220 0224 0088 00000000 00000001 00000220 00000220 00000000 u 00000001 ADD     0 00000224 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00de f4 20fab0f4 000000 38 02009663 0 0 0 00000224 008c 0080 00000000 00000001 ffff8f93 ffff8f93 00000224 z 00000001 passQ   0 00000224 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00df 04 6fff20d5 010000 04 ffff8f93 0 0 0 00000224 007c 008c 00000000 00000001 00000057 00000057 00000000 u 00000001 ADD     0 0000005f 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x31,x31,-1
                 buser/dinx                                                                                                             progress  (RAM)      Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ       ACK      S T E t r |mie ft Micro                                                                         
     || ucode    ||||may            c v u                                                                                    |          ||WE       STB| SEL  epepepepep\\csr|| code                                                                          
  cy || |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
00e0 e6 10ba20e6 000000 04 ffff8f93 0 0 0 00000224 0088 007c 00000000 00000001 00000002 00000002 ffffffff z 00000001 ADD     0 00000001 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00e1 de 2b7126de 000010 04 ffff8f93 0 0 0 00000224 0228 0088 00000000 00000001 00000224 00000224 00000000 u 00000001 ADD     0 00000228 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00e2 f4 20fab0f4 000000 04 ffff8f93 0 0 0 00000228 008c 0080 00000000 00000001 03f00863 03f00863 00000228 z 00000001 passQ   0 00000228 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00e3 18 6fff20d5 010000 18 03f00863 0 0 0 00000228 0000 008c 00000000 00000001 0000005f 0000005f 00000000 u 00000001 ADD     0 00000063 11.. ... ... .. 1111 0000000000 000 1f BEQ     BEQ    Conditional Branch. Offset to Ryy               beq      x0,x31,258
00e4 13 33ba3013 000000 18 03f00863 0 0 0 00000228 007c 00b0 00000000 00000001 00000000 00000000 00000030 z 00000001 passQ   0 00000030 11.. ... ... .. 1111 0000000000 000 1f condb_2        ~RS2 in Q                                       
00e5 14 03fb0014 000000 18 03f00863 0 0 0 00000228 0000      00000000 00000001 00000001 00000001 00000000 u 00000001 nearXOR 0 fffffffe 11.. ... ... .. 1111 0000000000 000 1f condb_3        Calculate RS1+~RS2+1                            
00e6 15 033b2615 000000 18 03f00863 0 0 0 00000228 00b0      00000000 00000001 00000000 00000000 fffffffe u 00000001 ADD     0 ffffffff 11.. ... ... .. 1111 0000000000 000 1f condb_4        Branch on condition                             
00e7 16 003b4816 000010 18 03f00863 0 0 0 00000228 0080      00000000 00000001 00000030 00000030 ffffffff u 00000001 passD   0 00000030 11.. ... ... .. 1111 0000000000 000 1f condb_5        Branch not taken.                               
00e8 e6 00b200e6 000000 18 03f00863 0 0 0 00000228 0088      00000000 00000001 00000228 00000228 00000030 z 00000001 nearXOR 0 fffffde4 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00e9 de 2b7126de 000010 18 03f00863 0 0 0 00000228 022c 0088 00000000 00000001 00000228 00000228 00000000 u 00000001 ADD     0 0000022c 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00ea f4 20fab0f4 000000 18 03f00863 0 0 0 0000022c 008c 0080 00000000 00000001 0b402083 0b402083 0000022c z 00000001 passQ   0 0000022c 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00eb 40 6fff20d5 010000 40 0b402083 0 0 0 0000022c 0000 008c 00000000 00000001 00000063 00000063 00000000 u 00000001 ADD     0 0000006b 11.. ... ... .. 1111 0000000000 000 1f LW_0    LW     Load word. Q=yy=rdadr=RS1+Iimm                  lw       x1,180(x0)
00ec 50 837b2050 000010 40 0b402083 0 0 0 0000022c 00b4      00000000 00000001 00000000 00000000 000000b4 u 00000001 ADD     0 000000b4 11.. ... ... .. 1111 0000000000 000 1f LW_1           Read until d=mem[(rs1+ofs) & ~3u]               
00ed e6 12fa08e6 000000 40 0b402083 0 0 0 0000022c 0088 0004 00000000 00000001 00000274 00000274 000000b4 z 00000001 passD   0 00000274 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00ee de 2b7126de 000010 40 0b402083 0 0 0 0000022c 0230 0088 00000000 00000001 0000022c 0000022c 00000000 u 00000001 ADD     0 00000230 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00ef f4 20fab0f4 000000 40 0b402083 0 0 0 00000230 008c 0080 00000000 00000001 00408093 00408093 00000230 z 00000001 passQ   0 00000230 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00f0 04 6fff20d5 010000 04 00408093 0 0 0 00000230 0004 008c 00000000 00000001 0000006b 0000006b 00000000 u 00000001 ADD     0 00000070 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x1,x1,4
00f1 e6 10ba20e6 000000 04 00408093 0 0 0 00000230 0088 0004 00000000 00000001 00000274 00000274 00000004 z 00000001 ADD     0 00000278 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00f2 de 2b7126de 000010 04 00408093 0 0 0 00000230 0234 0088 00000000 00000001 00000230 00000230 00000000 u 00000001 ADD     0 00000234 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00f3 f4 20fab0f4 000000 04 00408093 0 0 0 00000234 008c 0080 00000000 00000001 0a102a23 0a102a23 00000234 z 00000001 passQ   0 00000234 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00f4 48 6fff20d5 010000 48 0a102a23 0 0 0 00000234 0000 008c 00000000 00000001 00000070 00000070 00000000 u 00000001 ADD     0 00000074 11.. ... ... .. 1111 0000000000 000 1f _L0x48  SW     Store word. Q=wradr=RS1+Simm                    sw       x1,180(x0)
00f5 66 83bb2066 000010 48 0a102a23 0 0 0 00000234 0004      00000000 00000001 00000000 00000000 000000b4 u 00000001 ADD     0 000000b4 11.. ... ... .. 1111 0000000000 000 1f SW_1           Write d to a+k until accepted                   
00f6 f2 0fb908f2 000000 48 0a102a23 0 0 0 00000234 0004 00b4 00000000 00000001 00000278 00000278 000000b4 h 00000001 passD   0 00000278 1... ... ... .. 1111 0000000000 000 1f SW_2           Prepare read PC                                 
00f7 e6 00b200e6 000000 48 0a102a23 0 0 0 00000234 0088      00000000 00000001 00000278 00000278 000000b4 z 00000001 nearXOR 1 fffffd30 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00f8 de 2b7126de 000010 48 0a102a23 0 0 0 00000234 0238 0088 00000000 00000001 00000234 00000234 00000000 u 00000001 ADD     0 00000238 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00f9 f4 20fab0f4 000000 48 0a102a23 0 0 0 00000238 008c 0080 00000000 00000001 00000f17 00000f17 00000238 z 00000001 passQ   0 00000238 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00fa 05 6fff20d5 010000 05 00000f17 0 0 0 00000238 0000 008c 00000000 00000001 00000074 00000074 00000000 u 00000001 ADD     0 0000007a 11.. ... ... .. 1111 0000000000 000 1f _L0x05  AUIPC  q = imm20+2 or imm20+4  (copy x/2)              auipc    x30,0x0
00fb 04 00310004 000000 05 00000f17 0 0 0 00000238 0080      00000000 00000001 00000000 00000000 00000000 h 00000001 nearXOR 0 fffffffc 1... ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         
                 buser/dinx                                                                                                             progress STB(IO)     Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ    |sysack     S T E t r |mie ft Micro                                                                         
     || ucode    ||||may            c v u                                                                                    |          ||WE     ||ACK  SEL  epepepepep\\csr|| code                                                                          
  cy || |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
00fc e6 10ba20e6 000000 05 00000f17 0 0 0 00000238 0088 0078 00000000 00000001 00000238 00000238 00000000 z 00000001 ADD     0 00000238 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
00fd de 2b7126de 000010 05 00000f17 0 0 0 00000238 023c 0088 00000000 00000001 00000238 00000238 00000000 u 00000001 ADD     0 0000023c 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
00fe f4 20fab0f4 000000 05 00000f17 0 0 0 0000023c 008c 0080 00000000 00000001 042f0f13 042f0f13 0000023c z 00000001 passQ   0 0000023c 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
00ff 04 6fff20d5 010000 04 042f0f13 0 0 0 0000023c 0078 008c 00000000 00000001 0000007a 0000007a 00000000 u 00000001 ADD     0 0000007f 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x30,x30,66
0100 e6 10ba20e6 000000 04 042f0f13 0 0 0 0000023c 0088 0078 00000000 00000001 00000238 00000238 00000042 z 00000001 ADD     0 0000027a 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
0101 de 2b7126de 000010 04 042f0f13 0 0 0 0000023c 0240 0088 00000000 00000001 0000023c 0000023c 00000000 u 00000001 ADD     0 00000240 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
0102 f4 20fab0f4 000000 04 042f0f13 0 0 0 00000240 008c 0080 00000000 00000001 30200073 30200073 00000240 z 00000001 passQ   0 00000240 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0103 1c 6fff20d5 010000 1c 30200073 0 0 0 00000240 0000 008c 00000000 00000001 0000007f 0000007f 00000000 u 00000001 ADD     0 00000083 11.. ... ... .. 1111 0000000000 000 1f ECAL_BRKECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI    mret     
0104 a6 82f930a6 000010 1c 30200073 0 0 0 00000240 00ac      00000000 00000001 00000000 00000000 00000302 h 00000001 passQ   0 00000302 1... ... ... .. 1111 0000000000 000 1f ECAL_RETECALL/(U/S/M)RET Select ECALL or (U/S/M)RET            
0105 d1 82f930d0 000011 1c 30200073 0 0 0 00000240 00ac      00000000 00000001 ffffffff ffffffff 00000302 h 00000001 passQ   0 00000302 1... ... ... .. 1111 0000000000 000 1f MRET_1  MRET   First save Imm, start build constant for check  
0106 c9 21ba30c9 000000 1c 30200073 0 0 0 00000240 0098 0080 00000000 00000001 ffffffff ffffffff 00000302 z 00000001 passQ   0 00000302 11.. ... ... .. 1111 0000000000 000 1f MRET_2         0xff+3 = 0x102                                  
0107 a5 01b320a5 000000 1c 30200073 0 0 0 00000240 0098      00000000 00000001 000000ff 000000ff 00000000 u 00000001 ADD     0 00000102 11.. ... ... .. 1111 0000000000 000 1f MRET_3         0x102 + 0xff + 1 = 0x202                        
0108 af 01bb26af 000000 1c 30200073 0 0 0 00000240 0098      00000000 00000001 000000ff 000000ff 00000102 u 00000001 ADD     0 00000202 11.. ... ... .. 1111 0000000000 000 1f MRET_4         0x202 + 0xff + 1 = 0x302                        
0109 c5 003b26c5 000000 1c 30200073 0 0 0 00000240 0080      00000000 00000001 000000ff 000000ff 00000202 u 00000001 ADD     0 00000302 11.. ... ... .. 1111 0000000000 000 1f MRET_5         ~302                                            
010a 6f 003b106f 000000 1c 30200073 0 0 0 00000240 0080      00000000 00000001 00000302 00000302 00000302 u 00000001 INVQ    0 fffffcfd 11.. ... ... .. 1111 0000000000 000 1f MRET_6         ~302 + origImm + 1 for branch decision          
010b cf 003b26cf 000000 1c 30200073 0 0 0 00000240 0080      00000000 00000001 00000302 00000302 fffffcfd u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 1f MRET_7         Prepare emulation entry point 0x104             
010c 4f 01b2404f 000011 1c 30200073 0 0 0 00000240 0098      00000000 00000001 00000302 00000302 00000000 z 00000001 nearXOR 0 fffffcfe 11.. ... ... .. 1111 0000000000 000 1f MRET_8         Prep +4                                         
010d e6 02bb26e6 000000 1c 30200073 0 0 0 00000240 00a8      00000000 00000001 000000ff 000000ff 00000000 u 00000001 ADD     0 00000100 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
010e de 2b7126de 000010 1c 30200073 0 0 0 00000240 0104 0088 00000000 00000001 00000000 00000000 00000100 u 00000001 ADD     0 00000104 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
010f f4 20fab0f4 000000 1c 30200073 0 0 0 00000104 008c 0080 00000000 00000001 0b40000b 0b40000b 00000104 z 00000001 passQ   0 00000104 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0110 02 6fff20d5 010000 02 0b40000b 0 0 0 00000104 0000 008c 00000000 00000001 00000083 00000083 00000000 u 00000001 ADD     0 00000090 11.. ... ... .. 1111 0000000000 000 1f IJ_0    IJ     Jump to mem[(rs1+ofs)&~1u]. inCSR=0             Unsupported 
0111 be 837b20be 000010 02 0b40000b 0 0 0 00000104 00b4      00000000 00000001 00000000 00000000 000000b4 u 00000001 ADD     0 000000b4 11.. ... ... .. 1111 0000000000 000 1f IJ_1           Read until q=mem[(rs1+ofs)&~1u]                 
0112 1f 02fb081f 000000 02 0b40000b 0 0 0 00000104 00ac      00000000 00000001 00000278 00000278 000000b4 u 00000001 passD   0 00000278 11.. ... ... .. 1111 0000000000 000 1f IJ_2           Read word is to be masked with lsb = 0          
0113 b7 32ba30b7 000000 02 0b40000b 0 0 0 00000104 00a8 00b0 00000000 00000001 ffffffff ffffffff 00000278 z 00000001 passQ   0 00000278 11.. ... ... .. 1111 0000000000 000 1f IJ_3           Construct Q = 1                                 
0114 bd 033b26bd 000000 02 0b40000b 0 0 0 00000104 00b0      00000000 00000001 00000000 00000000 00000000 u 00000001 ADD     0 00000001 11.. ... ... .. 1111 0000000000 000 1f IJ_4           Mask and use as PC                              
0115 de 2b7918de 000010 02 0b40000b 0 0 0 00000104 0278 0088 00000000 00000001 00000278 00000278 00000001 u 00000001 nearAND 0 00000278 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
0116 f4 20fab0f4 000000 02 0b40000b 0 0 0 00000278 008c 0080 00000000 00000001 00730001 00730001 00000278 z 00000001 passQ   0 00000278 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0117 04 6fff20d5 010000 04 00000013 0 1 0 00000278 0000 008c 00000000 00000001 00000090 00000090 00000000 u 00000001 ADD     0 00000097 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x0,x0,0
                 buser/dinx                                                                                                             progress  (RAM)      Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ       ACK      S T E t r |mie ft Micro                                                                         
     || ucode    ||||may            c v u                                                                                    |          ||WE       STB| SEL  epepepepep\\csr|| code                                                                          
  cy || |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
0118 e6 10ba20e6 000000 04 00000013 0 1 0 00000278 0088 0080 00000000 00000001 00000000 00000000 00000000 z 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
0119 de 2b7126de 000010 04 00000013 0 1 0 00000278 0278 0088 00000000 00000001 00000278 00000278 00000000 u 00000001 ADD     0 0000027a 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
011a f4 20fab0f4 000000 04 00000013 1 1 0 0000027a 008c 0080 00000000 00000001 00730001 00730001 0000027a z 00000001 passQ   0 0000027a 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
011b d5 6fff20d5 000000 1c 00000073 1 0 1 0000027a 0000 008c 00000000 00000001 00000097 00000097 00000000 u 00000001 ADD     0 0000009b 11.. ... ... .. 1111 0000000000 000 1f unalignd Fr00u Unaligned pc, prep read high hword              
011c 12 00ba3012 000000 1c 00000073 1 0 1 0000027a 0088      00000000 00000001 00000000 00000000 00000000 z 00000001 passQ   0 00000000 11.. ... ... .. 1111 0000000000 000 1f straddle Fr10u IncPC, OpFetch                                  
011d 76 2b712676 000010 1c 00000073 1 0 1 0000027a 027c 0088 00000000 00000001 0000027a 0000027a 00000000 u 00000001 ADD     0 0000027c 11.. ... ... .. 1111 0000000000 000 1f Fetchu   Fr00u Read and latch instruction                      
011e f4 00fab0f4 000000 1c 00000073 0 0 1 0000027c 008c      00000000 00000001 b0330000 b0330000 0000027c z 00000001 passQ   0 0000027c 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
011f 1c 6fff20d5 010000 1c 00000073 0 1 0 0000027c 0000 008c 00000000 00000001 0000009b 0000009b 00000000 u 00000001 ADD     0 0000009f 11.. ... ... .. 1111 0000000000 000 1f ECAL_BRKECALL/EBREAK  Select ECALL/(U/S/M)RET or EBREAK/WFI    ecall    
0120 a6 82f930a6 000010 1c 00000073 0 1 0 0000027c 00ac      00000000 00000001 00000000 00000000 00000000 h 00000001 passQ   0 00000000 1... ... ... .. 1111 0000000000 000 1f ECAL_RETECALL/(U/S/M)RET Select ECALL or (U/S/M)RET            
0121 d0 82f930d0 000010 1c 00000073 0 1 0 0000027c 00ac      00000000 00000001 ffffffff ffffffff 00000000 h 00000001 passQ   0 00000000 1... ... ... .. 1111 0000000000 000 1f ECALL_1 ECALL  Verify Imm==0x000                               
0122 37 003b2637 000000 1c 00000073 0 1 0 0000027c 0080      00000000 00000001 ffffffff ffffffff 00000000 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 1f ECALL_2        mepc = pc, prep store 0 to mtval                
0123 d7 343a48d7 000011 1c 00000073 0 1 0 0000027c 0080 00b4 00000000 00000001 0000027a 0000027a 00000000 z 00000001 passD   0 0000027a 11.. ... ... .. 1111 0000000000 000 1f ECALL_3        mtval = 0, now start the chore of 11 to mcause  
0124 a1 3eba30a1 000000 1c 00000073 0 1 0 0000027c 00a8 00bc 00000000 00000001 0000027a 0000027a 00000000 z 00000001 passQ   0 00000000 11.. ... ... .. 1111 0000000000 000 1f ECALL_4        Q = 4                                           
0125 b6 02b326b6 000010 1c 00000073 0 1 0 0000027c 00a8      00000000 00000001 00000000 00000000 00000000 u 00000001 ADD     0 00000004 11.. ... ... .. 1111 0000000000 000 1f ECALL_5        Q = 8                                           
0126 9a 02b3269a 000010 1c 00000073 0 1 0 0000027c 00a8      00000000 00000001 00000000 00000000 00000004 u 00000001 ADD     0 00000008 11.. ... ... .. 1111 0000000000 000 1f ECALL_6        mcause = 11                                     
0127 34 3a702034 000000 1c 00000073 0 1 0 0000027c 00a4 00b8 00000000 00000001 00000000 00000000 00000008 h 00000001 ADD     0 0000000b 1... ... ... .. 1111 0000000000 000 1f JAL_3        Prep fetch next instr.                            
0128 de 2b7908de 000010 1c 00000073 0 1 0 0000027c 0204 0088 00000000 00000001 00000204 00000204 00000008 u 00000001 passD   0 00000204 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
0129 f4 20fab0f4 000000 1c 00000073 0 1 0 00000204 008c 0080 00000000 00000001 00b00113 00b00113 00000204 z 00000001 passQ   0 00000204 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
012a 04 6fff20d5 010000 04 00b00113 0 0 0 00000204 0000 008c 00000000 00000001 0000009f 0000009f 00000000 u 00000001 ADD     0 000000aa 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x2,x0,11
012b e6 10ba20e6 000000 04 00b00113 0 0 0 00000204 0088 0008 00000000 00000001 00000000 00000000 0000000b z 00000001 ADD     0 0000000b 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
012c de 2b7126de 000010 04 00b00113 0 0 0 00000204 0208 0088 00000000 00000001 00000204 00000204 00000000 u 00000001 ADD     0 00000208 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
012d f4 20fab0f4 000000 04 00b00113 0 0 0 00000208 008c 0080 00000000 00000001 0b802083 0b802083 00000208 z 00000001 passQ   0 00000208 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
012e 40 6fff20d5 010000 40 0b802083 0 0 0 00000208 0000 008c 00000000 00000001 000000aa 000000aa 00000000 u 00000001 ADD     0 000000ae 11.. ... ... .. 1111 0000000000 000 1f LW_0    LW     Load word. Q=yy=rdadr=RS1+Iimm                  lw       x1,184(x0)
012f 50 837b2050 000010 40 0b802083 0 0 0 00000208 00b8      00000000 00000001 00000000 00000000 000000b8 u 00000001 ADD     0 000000b8 11.. ... ... .. 1111 0000000000 000 1f LW_1           Read until d=mem[(rs1+ofs) & ~3u]               
0130 e6 12fa08e6 000000 40 0b802083 0 0 0 00000208 0088 0004 00000000 00000001 0000000b 0000000b 000000b8 z 00000001 passD   0 0000000b 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
0131 de 2b7126de 000010 40 0b802083 0 0 0 00000208 020c 0088 00000000 00000001 00000208 00000208 00000000 u 00000001 ADD     0 0000020c 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
0132 f4 20fab0f4 000000 40 0b802083 0 0 0 0000020c 008c 0080 00000000 00000001 02209c63 02209c63 0000020c z 00000001 passQ   0 0000020c 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0133 38 6fff20d5 010000 38 02209c63 0 0 0 0000020c 0004 008c 00000000 00000001 000000ae 000000ae 00000000 u 00000001 ADD     0 000000b3 11.. ... ... .. 1111 0000000000 000 1f BNE     BNE    Conditional Branch. Offset to Ryy               bne      x1,x2,244
                 buser/dinx                                                                                                             progress STB(IO)     Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ    |sysack     S T E t r |mie ft Micro                                                                         
     || ucode    ||||may            c v u                                                                                    |          ||WE     ||ACK  SEL  epepepepep\\csr|| code                                                                          
  cy || |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
0134 13 33ba3013 000000 38 02209c63 0 0 0 0000020c 0008 00b0 00000000 00000001 0000000b 0000000b 00000038 z 00000001 passQ   0 00000038 11.. ... ... .. 1111 0000000000 000 1f condb_2        ~RS2 in Q                                       
0135 14 03fb0014 000000 38 02209c63 0 0 0 0000020c 0004      00000000 00000001 0000000b 0000000b 00000000 u 00000001 nearXOR 0 fffffff4 11.. ... ... .. 1111 0000000000 000 1f condb_3        Calculate RS1+~RS2+1                            
0136 15 033b2615 000000 38 02209c63 0 0 0 0000020c 00b0      00000000 00000001 0000000b 0000000b fffffff4 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 1f condb_4        Branch on condition                             
0137 16 003b4816 000010 38 02209c63 0 0 0 0000020c 0080      00000000 00000001 00000038 00000038 00000000 u 00000001 passD   0 00000038 11.. ... ... .. 1111 0000000000 000 1f condb_5        Branch not taken.                               
0138 e6 00b200e6 000000 38 02209c63 0 0 0 0000020c 0088      00000000 00000001 0000020c 0000020c 00000038 z 00000001 nearXOR 0 fffffdc8 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
0139 de 2b7126de 000010 38 02209c63 0 0 0 0000020c 0210 0088 00000000 00000001 0000020c 0000020c 00000000 u 00000001 ADD     0 00000210 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
013a f4 20fab0f4 000000 38 02209c63 0 0 0 00000210 008c 0080 00000000 00000001 0b402083 0b402083 00000210 z 00000001 passQ   0 00000210 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
013b 40 6fff20d5 010000 40 0b402083 0 0 0 00000210 0000 008c 00000000 00000001 000000b3 000000b3 00000000 u 00000001 ADD     0 000000bb 11.. ... ... .. 1111 0000000000 000 1f LW_0    LW     Load word. Q=yy=rdadr=RS1+Iimm                  lw       x1,180(x0)
013c 50 837b2050 000010 40 0b402083 0 0 0 00000210 00b4      00000000 00000001 00000000 00000000 000000b4 u 00000001 ADD     0 000000b4 11.. ... ... .. 1111 0000000000 000 1f LW_1           Read until d=mem[(rs1+ofs) & ~3u]               
013d e6 12fa08e6 000000 40 0b402083 0 0 0 00000210 0088 0004 00000000 00000001 0000027a 0000027a 000000b4 z 00000001 passD   0 0000027a 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
013e de 2b7126de 000010 40 0b402083 0 0 0 00000210 0214 0088 00000000 00000001 00000210 00000210 00000000 u 00000001 ADD     0 00000214 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
013f f4 20fab0f4 000000 40 0b402083 0 0 0 00000214 008c 0080 00000000 00000001 000f0113 000f0113 00000214 z 00000001 passQ   0 00000214 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0140 04 6fff20d5 010000 04 000f0113 0 0 0 00000214 0078 008c 00000000 00000001 000000bb 000000bb 00000000 u 00000001 ADD     0 000000c0 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x2,x30,0
0141 e6 10ba20e6 000000 04 000f0113 0 0 0 00000214 0088 0008 00000000 00000001 0000027a 0000027a 00000000 z 00000001 ADD     0 0000027a 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
0142 de 2b7126de 000010 04 000f0113 0 0 0 00000214 0218 0088 00000000 00000001 00000214 00000214 00000000 u 00000001 ADD     0 00000218 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
0143 f4 20fab0f4 000000 04 000f0113 0 0 0 00000218 008c 0080 00000000 00000001 02209863 02209863 00000218 z 00000001 passQ   0 00000218 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0144 38 6fff20d5 010000 38 02209863 0 0 0 00000218 0004 008c 00000000 00000001 000000c0 000000c0 00000000 u 00000001 ADD     0 000000c4 11.. ... ... .. 1111 0000000000 000 1f BNE     BNE    Conditional Branch. Offset to Ryy               bne      x1,x2,248
0145 13 33ba3013 000000 38 02209863 0 0 0 00000218 0008 00b0 00000000 00000001 0000027a 0000027a 00000030 z 00000001 passQ   0 00000030 11.. ... ... .. 1111 0000000000 000 1f condb_2        ~RS2 in Q                                       
0146 14 03fb0014 000000 38 02209863 0 0 0 00000218 0004      00000000 00000001 0000027a 0000027a 00000000 u 00000001 nearXOR 0 fffffd85 11.. ... ... .. 1111 0000000000 000 1f condb_3        Calculate RS1+~RS2+1                            
0147 15 033b2615 000000 38 02209863 0 0 0 00000218 00b0      00000000 00000001 0000027a 0000027a fffffd85 u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 1f condb_4        Branch on condition                             
0148 16 003b4816 000010 38 02209863 0 0 0 00000218 0080      00000000 00000001 00000030 00000030 00000000 u 00000001 passD   0 00000030 11.. ... ... .. 1111 0000000000 000 1f condb_5        Branch not taken.                               
0149 e6 00b200e6 000000 38 02209863 0 0 0 00000218 0088      00000000 00000001 00000218 00000218 00000030 z 00000001 nearXOR 0 fffffdd4 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
014a de 2b7126de 000010 38 02209863 0 0 0 00000218 021c 0088 00000000 00000001 00000218 00000218 00000000 u 00000001 ADD     0 0000021c 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
014b f4 20fab0f4 000000 38 02209863 0 0 0 0000021c 008c 0080 00000000 00000001 0bc02083 0bc02083 0000021c z 00000001 passQ   0 0000021c 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
014c 40 6fff20d5 010000 40 0bc02083 0 0 0 0000021c 0000 008c 00000000 00000001 000000c4 000000c4 00000000 u 00000001 ADD     0 000000cc 11.. ... ... .. 1111 0000000000 000 1f LW_0    LW     Load word. Q=yy=rdadr=RS1+Iimm                  lw       x1,188(x0)
014d 50 837b2050 000010 40 0bc02083 0 0 0 0000021c 00bc      00000000 00000001 00000000 00000000 000000bc u 00000001 ADD     0 000000bc 11.. ... ... .. 1111 0000000000 000 1f LW_1           Read until d=mem[(rs1+ofs) & ~3u]               
014e e6 12fa08e6 000000 40 0bc02083 0 0 0 0000021c 0088 0004 00000000 00000001 00000000 00000000 000000bc z 00000001 passD   0 00000000 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
014f de 2b7126de 000010 40 0bc02083 0 0 0 0000021c 0220 0088 00000000 00000001 0000021c 0000021c 00000000 u 00000001 ADD     0 00000220 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
                 buser/dinx                                                                                                             progress  (RAM)      Int_info_ mpie shi                                                                              
     minx        ||qint/ill         p r l                                                                                    Cy         |enaQ       ACK      S T E t r |mie ft Micro                                                                         
     || ucode    ||||may            c v u                                                                                    |          ||WE       STB| SEL  epepepepep\\csr|| code                                                                          
  cy || |||||||| |||||take I[31:0]  1 c h pc[31:0] rai  wai  in[31:0] rDee____ DAT_O___ Di[31:0] ADR_O___   M[31:0]_ ALUOP__ | B[31:0]_ |||      ||| || 3210 |||||||||| ||| || label__ Microcode_instruction_text____________________________ Assembler_instr
0150 f4 20fab0f4 000000 40 0bc02083 0 0 0 00000220 008c 0080 00000000 00000001 02009663 02009663 00000220 z 00000001 passQ   0 00000220 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0151 38 6fff20d5 010000 38 02009663 0 0 0 00000220 0004 008c 00000000 00000001 000000cc 000000cc 00000000 u 00000001 ADD     0 000000d1 11.. ... ... .. 1111 0000000000 000 1f BNE     BNE    Conditional Branch. Offset to Ryy               bne      x1,x0,24c
0152 13 33ba3013 000000 38 02009663 0 0 0 00000220 0000 00b0 00000000 00000001 00000000 00000000 0000002c z 00000001 passQ   0 0000002c 11.. ... ... .. 1111 0000000000 000 1f condb_2        ~RS2 in Q                                       
0153 14 03fb0014 000000 38 02009663 0 0 0 00000220 0004      00000000 00000001 00000000 00000000 00000000 u 00000001 nearXOR 0 ffffffff 11.. ... ... .. 1111 0000000000 000 1f condb_3        Calculate RS1+~RS2+1                            
0154 15 033b2615 000000 38 02009663 0 0 0 00000220 00b0      00000000 00000001 00000000 00000000 ffffffff u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 1f condb_4        Branch on condition                             
0155 16 003b4816 000010 38 02009663 0 0 0 00000220 0080      00000000 00000001 0000002c 0000002c 00000000 u 00000001 passD   0 0000002c 11.. ... ... .. 1111 0000000000 000 1f condb_5        Branch not taken.                               
0156 e6 00b200e6 000000 38 02009663 0 0 0 00000220 0088      00000000 00000001 00000220 00000220 0000002c z 00000001 nearXOR 0 fffffdf0 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
0157 de 2b7126de 000010 38 02009663 0 0 0 00000220 0224 0088 00000000 00000001 00000220 00000220 00000000 u 00000001 ADD     0 00000224 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
0158 f4 20fab0f4 000000 38 02009663 0 0 0 00000224 008c 0080 00000000 00000001 ffff8f93 ffff8f93 00000224 z 00000001 passQ   0 00000224 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
0159 04 6fff20d5 010000 04 ffff8f93 0 0 0 00000224 007c 008c 00000000 00000001 000000d1 000000d1 00000000 u 00000001 ADD     0 000000d9 11.. ... ... .. 1111 0000000000 000 1f ADDI_0  ADDI   Add immediate. rd =RS1+Iimm (or joined)         addi     x31,x31,-1
015a e6 10ba20e6 000000 04 ffff8f93 0 0 0 00000224 0088 007c 00000000 00000001 00000001 00000001 ffffffff z 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 1f StdIncPc Fr00  IncPC, OpFetch                                  
015b de 2b7126de 000010 04 ffff8f93 0 0 0 00000224 0228 0088 00000000 00000001 00000224 00000224 00000000 u 00000001 ADD     0 00000228 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
015c f4 20fab0f4 000000 04 ffff8f93 0 0 0 00000228 008c 0080 00000000 00000001 03f00863 03f00863 00000228 z 00000001 passQ   0 00000228 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
015d 18 6fff20d5 010000 18 03f00863 0 0 0 00000228 0000 008c 00000000 00000001 000000d9 000000d9 00000000 u 00000001 ADD     0 000000dd 11.. ... ... .. 1111 0000000000 000 1f BEQ     BEQ    Conditional Branch. Offset to Ryy               beq      x0,x31,258
015e 13 33ba3013 000000 18 03f00863 0 0 0 00000228 007c 00b0 00000000 00000001 00000000 00000000 00000030 z 00000001 passQ   0 00000030 11.. ... ... .. 1111 0000000000 000 1f condb_2        ~RS2 in Q                                       
015f 14 03fb0014 000000 18 03f00863 0 0 0 00000228 0000      00000000 00000001 00000000 00000000 00000000 u 00000001 nearXOR 0 ffffffff 11.. ... ... .. 1111 0000000000 000 1f condb_3        Calculate RS1+~RS2+1                            
0160 15 033b2615 000000 18 03f00863 0 0 0 00000228 00b0      00000000 00000001 00000000 00000000 ffffffff u 00000001 ADD     0 00000000 11.. ... ... .. 1111 0000000000 000 1f condb_4        Branch on condition                             
0161 17 003b4816 000011 18 03f00863 0 0 0 00000228 0080      00000000 00000001 00000030 00000030 00000000 u 00000001 passD   0 00000030 11.. ... ... .. 1111 0000000000 000 1f condb_5t       Branch taken.                                   
0162 de 2b7920de 000010 18 03f00863 0 0 0 00000228 0258 0088 00000000 00000001 00000228 00000228 00000030 u 00000001 ADD     0 00000258 11.. ... ... .. 1111 0000000000 000 1f Fetch    Fr00  Read and latch instruction                      
0163 f4 20fab0f4 000000 18 03f00863 0 0 0 00000258 008c 0080 00000000 00000001 00003033 00003033 00000258 z 00000001 passQ   0 00000258 11.. ... ... .. 1111 0000000000 000 1f Fetch2   Fr00  Upd ttime, I. Q=imm Use dinx unless unaligned   
../../obj_dir/second/t400.bin            success    38 instructions in    356 cycles, cpi =  7.68
